[{"authors":null,"categories":null,"content":"","date":1524672000,"expirydate":-62135596800,"kind":"section","lang":"zh","lastmod":1543733643,"objectID":"433d5129a667ddc5fb439ec172a8745c","permalink":"https://mooncaker816.github.io/example/","publishdate":"2018-04-26T00:00:00+08:00","relpermalink":"/example/","section":"example","summary":"","tags":null,"title":"Example","type":"docs"},{"authors":null,"categories":["C","GO","APUE"],"content":" 整体目录：  CH1 - UNIX System Overview  ","date":1543630065,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1543733643,"objectID":"9e5b161bb401a02dfd1b7652f22f1a90","permalink":"https://mooncaker816.github.io/2018/12/01/apue_with_go_0/","publishdate":"2018-12-01T10:07:45+08:00","relpermalink":"/2018/12/01/apue_with_go_0/","section":"post","summary":"整体目录： CH1 - UNIX System Overview","tags":["APUE"],"title":"APUE_With_GO_0","type":"post"},{"authors":null,"categories":["C","GO","APUE"],"content":" UNIX System Overview： 目录  UNIX System Overview：  简介 登录    简介 操作系统可以简单地理解为一套用来控制计算机硬件资源并为应用程序提供运行环境的软件，通常我们称这套软件为内核(kernel)。\n如下图所示，内核处于整个环境的中心，通过外部包裹的系统调用层(system calls)进行交互。\n库函数是建立在系统调用层之上的，用户既可以选择调用封装好的库函数，也可以选择直接调用 system calls。\nshell，如其字面意思“壳”，不难理解为一个为用户提供交互界面从而来运行其他特定应用的“壳应用”。\n更宽泛地说，操作系统是一个内核加上其他一系列为用户提供支持的软件的整体。如人们通常所说的 GNU/Linux，就是以 Linux 为内核的系统。而 Linux 就是由 Unix 演化而来的，有兴趣的同学可以自行google Unix 和 Linux 的历史，也是很有趣的一段过程。\n各大厂商在一定的基础上，又根据自身的需求，添加各种相应的软件包，形成了发行版的Linux系统。\n登录 ","date":1543630065,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1543733643,"objectID":"c4f9347e77321306021ccdd9b5a2e6e9","permalink":"https://mooncaker816.github.io/2018/12/01/apue_with_go_1/","publishdate":"2018-12-01T10:07:45+08:00","relpermalink":"/2018/12/01/apue_with_go_1/","section":"post","summary":"UNIX System Overview： 目录 UNIX System Overview： 简介 登录 简介 操作系统可以简单地理解为一套用来控制计算机硬件资源并为应用程序提供运行环境的软件","tags":["APUE"],"title":"APUE_With_GO_1","type":"post"},{"authors":null,"categories":[],"content":"1. GCM 认证加密 　GCM 可以看成是 CTR 模式的升级版，在完成数据加密的前提下，同时完成数据的完整性验证。GCM 固定分组大小为 128bits，用于数据完整性验证的 MAC 称之为 GMAC。加密和 GMAC 计算使用同一秘钥。\n2. GF","date":1535282276,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1543733643,"objectID":"314b5ae4034fcdd3b1185ee971dd01cf","permalink":"https://mooncaker816.github.io/2018/08/26/gcm/","publishdate":"2018-08-26T19:17:56+08:00","relpermalink":"/2018/08/26/gcm/","section":"post","summary":"1. GCM 认证加密 GCM 可以看成是 CTR 模式的升级版，在完成数据加密的前提下，同时完成数据的完整性验证。GCM 固定分组大小为 128bits，用于数据完整性","tags":[],"title":"GCM","type":"post"},{"authors":null,"categories":["Golang","Web","密码学"],"content":"书接上回，客户端在完成 clientHelloMsg 和 serverHelloMsg 后，开启缓存写入模式，也分为重用 session 和非重用 session 两种情况。服务端在发送完第一批次消息后，等待客户端的回应。\n1. 客户端 1.1 重用 session 1.1.2 调用 establishKeys()，由主密钥衍生出各种实际秘钥，等待切换  通过主密钥生成一系列计算 hmac，加解密需要使用到的 key，和初始化向量，客户端服务端各不相同\n 根据密码套件，将这些 key，iv 组合成客户端，服务端各自用于加密和计算 hmac 的 cipher，hmac\n 更新到对应的 halfConn 中的预备字段中，等待正式切换\n  // [Min] 根据主密钥建立加密通讯需要的 cipher，hash，更新到客户端和服务端各自对应的 halfConn 的预备字段中，等待切换 func (hs *clientHandshakeState) establishKeys() error { c := hs.c // [Min] 通过主密钥生成一系列计算 mac，加解密需要使用到的 key，和初始化向量 clientMAC, serverMAC, clientKey, serverKey, clientIV, serverIV := keysFromMasterSecret(c.vers, hs.suite, hs.masterSecret, hs.hello.random, hs.serverHello.random, hs.suite.macLen, hs.suite.keyLen, hs.suite.ivLen) var clientCipher, serverCipher interface{} var clientHash, serverHash macFunction if hs.suite.cipher != nil { clientCipher = hs.suite.cipher(clientKey, clientIV, false /* not for reading */) clientHash = hs.suite.mac(c.vers, clientMAC) serverCipher = hs.suite.cipher(serverKey, serverIV, true /* for reading */) serverHash = hs.suite.mac(c.vers, serverMAC) } else { clientCipher = hs.suite.aead(clientKey, clientIV) serverCipher = hs.suite.aead(serverKey, serverIV) } // [Min] 将 server 的 cipher，hash 算法更新到 in 的预备字段中，等待正式切换 // [Min] 将 client 的 cipher，hash 算法更新到 out 的预备字段中，等待正式切换 c.in.prepareCipherSpec(c.vers, serverCipher, serverHash) c.out.prepareCipherSpec(c.vers, clientCipher, clientHash) return nil }  1.1.3 调用 readSessionTicket()，读取 ticket 并保存其中 session 的状态 　注意，在重用 session 模式下，hs.serverHello.ticketSupported 只有在 ticket 需要重新加密的情况下才会设置为真，也就是说，如果该值为真，就说明服务端会发送 newSessionTicketMsg。\n// [Min] 重用 session 的 handshake，返回 helloMsg，告知 session 重用，验证客户端证书并恢复主密钥 func (hs *serverHandshakeState) doResumeHandshake() error { c := hs.c hs.hello.cipherSuite = hs.suite.id // We echo the client's session ID in the ServerHello to let it know // that we're doing a resumption. // [Min] 重用 session 的情况下，sessionId 和客户端发过来的保持一致， // [Min] 这样客户端就可以通过 sessionId 没有变化来判断 session 的重用 hs.hello.sessionId = hs.clientHello.sessionId // [Min] 表明客户端提供的 ticket 是否可以恢复成 sessionState 使用 // [Min] 同时也记录 sessionTicket 是否需要以最新的 key 重制生成 ticket 来刷新（实际内容不变） hs.hello.ticketSupported = hs.sessionState.usedOldKey  　读取并完成newSessionTicketMsg，保存 ticket 以及 session 状态\n// [Min] 读取 newSessionTicketMsg，保存 ticket 中 session 的状态 func (hs *clientHandshakeState) readSessionTicket() error { // [Min] 注意此处 ticketSupported 是指服务端有没有发送 ticket 过来 // [Min] 如果是 fullhandshake，那么只要双方都支持，服务端就会发送 // [Min] 如果是重用 session，那么只有在 ticket 需要重制的情况下（加密 ticket 的 key 不是最新的），才会发送 if !hs.serverHello.ticketSupported { return nil } c := hs.c // [Min] 读取 newSessionTicketMsg msg, err := c.readHandshake() if err != nil { return err } sessionTicketMsg, ok := msg.(*newSessionTicketMsg) if !ok { c.sendAlert(alertUnexpectedMessage) return unexpectedMessageError(sessionTicketMsg, msg) } hs.finishedHash.Write(sessionTicketMsg.marshal()) // [Min] 保存 ticket 中 session 对应的状态 hs.session = \u0026amp;ClientSessionState{ sessionTicket: sessionTicketMsg.ticket, vers: c.vers, cipherSuite: hs.suite.id, masterSecret: hs.masterSecret, serverCertificates: c.peerCertificates, verifiedChains: c.verifiedChains, } return nil }  1.1.4 调用 hs.readFinished 　注意，如果是重用 session，是由服务端先发起 finshedMsg 的，设置clientFinishedIsFirst为假。\n 首先读取切换信号，将客户端 c.in 切换为加密模式 再读取服务端 finishedMsg 通过相同的主密钥，相同的算法，以及截止目前双方理应相同的所有握手信息的 hash 值，计算本地的服务端 verify，再与服务端发送过来的 verifyData 比较，应该保持一致，否则报警 finishedHash 中完成此 finishedMsg 将服务端 verifyData 保存到 c.serverFinished  // [Min] 切换输入通道为加密模式，读取服务端 finishedMsg，并验证 verfiyData func (hs *clientHandshakeState) readFinished(out []byte) error { c := hs.c // [Min] 首先读取切换信号，将 c.in 切换为加密模式 c.readRecord(recordTypeChangeCipherSpec) if c.in.err != nil { return c.in.err } // [Min] 再读取 finishedMsg msg, err := c.readHandshake() if err != nil { return err } serverFinished, ok := msg.(*finishedMsg) if !ok { c.sendAlert(alertUnexpectedMessage) return unexpectedMessageError(serverFinished, msg) } // [Min] 通过相同的主密钥，相同的算法，截止目前双方理应相同的所有握手信息的 hash 值， // [Min] 计算本地的 verify，再与服务端发送过来的 verifyData 比较， // [Min] 如果不相同，报警 verify := hs.finishedHash.serverSum(hs.masterSecret) if len(verify) != len(serverFinished.verifyData) || subtle.ConstantTimeCompare(verify, serverFinished.verifyData) != 1 { c.sendAlert(alertHandshakeFailure) return errors.New(\u0026quot;tls: server's Finished message was incorrect\u0026quot;) } // [Min] 完成该 finishedMsg，并存储 verifyData 到 out 中 hs.finishedHash.Write(serverFinished.marshal()) copy(out, verify) return nil }  1.1.5 调用客户端 sendFinished  通知服务端切换其输入通道为加密模式 如果是 NPN 模式，协商协议，构造并完成nextProtoMsg，然后发送至 sendBuf，等待正式推送 构造客户端 finishedMsg，完成并发送至 sendBuf，等待正式推送 保存客户端 verifyData  // [Min] 客户端通知服务端切换加密模式，完成 NPN 协议协商，发送 finishedMsg func (hs *clientHandshakeState) sendFinished(out []byte) error { c := hs.c // [Min] 通知服务端切换其输入通道为加密模式 if _, err := c.writeRecord(recordTypeChangeCipherSpec, []byte{1}); err != nil { return err } // [Min] 如果是 NPN 模式，协商协议，构造并完成nextProtoMsg，然后发送至 sendBuf，等待正式推送 if hs.serverHello.nextProtoNeg { nextProto := new(nextProtoMsg) proto, fallback := mutualProtocol(c.config.NextProtos, hs.serverHello.nextProtos) nextProto.proto = proto c.clientProtocol = proto c.clientProtocolFallback = fallback hs.finishedHash.Write(nextProto.marshal()) if _, err := c.writeRecord(recordTypeHandshake, nextProto.marshal()); err != nil { return err } } // [Min] 构造客户端 finishedMsg，完成并发送至 sendBuf，等待正式推送 finished := new(finishedMsg) finished.verifyData = hs.finishedHash.clientSum(hs.masterSecret) hs.finishedHash.Write(finished.marshal()) if _, err := c.writeRecord(recordTypeHandshake, finished.marshal()); err != nil { return err } // [Min] 保存客户端 verifyData 到 c.clientFinished copy(out, finished.verifyData) return nil }  1.1.6 推送累积的消息到服务端 　nextProtoMsg（可选），切换信号，finishedMsg\n1.2 非重用 session 　完成 serverHelloMsg 的处理后，在 fullhandshake 模式下，需要对服务端依次发送的 certificateMsg，certificateStatusMsg（可选），serverKeyExchangeMsg（非 RSA 秘钥交换），certificateRequestMsg（可选），serverHelloDoneMsg 进行处理。\n1.2.1 doFullHandshake  读取服务端证书信息certificateMsg，并完成 如果是首次握手，则解析证书，验证证书，保存有效证书到c.peerCertificates；如果不是首次握手，检查消息中的证书与之前存储在c.peerCertificates的证书是否相同 按需读取certificateStatusMsg（可选），并完成，存储证书状态到c.ocspResponse 读取serverKeyExchangeMsg（非 RSA 秘钥交换），完成消息，调用 processServerKeyExchange，从中获取服务端秘钥交换的公钥点，椭圆曲线，以及服务端用其证书私钥对椭圆曲线公钥信息的签名。客户端用服务端证书公钥对此签名进行认证。 读取 certificateRequestMsg（可选），按需获取客户端证书，完成该消息。 读取并完成 serverHelloDoneMsg 如果需要发送客户端证书信息，构造并完成 certificateMsg ，写入 sendBuf，等待推送 调用 generateClientKeyExchange，\n如果是 RSA 秘钥交换，生成46字节随机数，加上头两个字节的TLS版本值，就是预备主密钥，用服务端证书公钥对此预备主密钥加密，构造clientKeyExchangeMsg。\n如果是 ECDHE 秘钥交换，随机生成客户端秘钥交换私钥，和客户端秘钥交换公钥，构造clientKeyExchangeMsg，生成客户端秘钥交换公钥信息。再根据之前获得的服务端秘钥交换公钥，生成客户端预备主密钥。\n完成clientKeyExchangeMsg，写入 sendBuf，等待推送 如果之前发送了客户端的证书，也要发送签名消息 certificateVerifyMsg，签名的对象是 finishedHash 中所有的握手消息（finishedHash.buffer）的 hash 值。完成该消息，写入 sendBuf，等待推送。从这里也就说明了为什么 buffer 只有在需要客户端证书的情况下才不为 nil。 根据预备主密钥，客户端随机数，服务端随机数，计算主密钥 清空 finishedHash 中的 buffer  　目前缓存待推送的消息：certificateMsg（可选），clientKeyExchangeMsg，certificateVerifyMsg（可选）\n// [Min] 客户端 fullhandshake func (hs *clientHandshakeState) doFullHandshake() error { c := hs.c // [Min] ServerHelloMsg之后，期待收到服务端的证书信息，证书必须存在且不为空 msg, err := c.readHandshake() if err != nil { return err } certMsg, ok := msg.(*certificateMsg) if !ok || len(certMsg.certificates) == 0 { c.sendAlert(alertUnexpectedMessage) return unexpectedMessageError(certMsg, msg) } // [Min] fihishedHash 中完成certificateMsg hs.finishedHash.Write(certMsg.marshal()) if c.handshakes == 0 { // [Min] 如果是初次握手，解析证书 // If this is the first handshake on a connection, process and // (optionally) verify the server's certificates. certs := make([]*x509.Certificate, len(certMsg.certificates)) for i, asn1Data := range certMsg.certificates { cert, err := x509.ParseCertificate(asn1Data) if err != nil { c.sendAlert(alertBadCertificate) return errors.New(\u0026quot;tls: failed to parse certificate from server: \u0026quot; + err.Error()) } certs[i] = cert } // [Min] 如果不是跳过验证，对证书进行验证，并更新 c.verifiedChains，c.peerCertificates if !c.config.InsecureSkipVerify { opts := x509.VerifyOptions{ Roots: c.config.RootCAs, CurrentTime: c.config.time(), DNSName: c.config.ServerName, Intermediates: x509.NewCertPool(), } for i, cert := range certs { if i == 0 { continue } opts.Intermediates.AddCert(cert) } c.verifiedChains, err = certs[0].Verify(opts) if err != nil { c.sendAlert(alertBadCertificate) return err } } // [Min] 自定义的验证 if c.config.VerifyPeerCertificate != nil { if err := c.config.VerifyPeerCertificate(certMsg.certificates, c.verifiedChains); err != nil { c.sendAlert(alertBadCertificate) return err } } // [Min] 只支持 RSA，ECDSA 的公钥 switch certs[0].PublicKey.(type) { case *rsa.PublicKey, *ecdsa.PublicKey: break default: c.sendAlert(alertUnsupportedCertificate) return fmt.Errorf(\u0026quot;tls: server's certificate contains an unsupported type of public key: %T\u0026quot;, certs[0].PublicKey) } // [Min] 保存解析后的证书 c.peerCertificates = certs } else { // [Min] 不是首次握手，需确保之前存储的服务端的证书没有改变 // This is a renegotiation handshake. We require that the // server's identity (i.e. leaf certificate) is unchanged and // thus any previous trust decision is still valid. // // See https://mitls.org/pages/attacks/3SHAKE for the // motivation behind this requirement. if !bytes.Equal(c.peerCertificates[0].Raw, certMsg.certificates[0]) { c.sendAlert(alertBadCertificate) return errors.New(\u0026quot;tls: server's identity changed during renegotiation\u0026quot;) } } // [Min] 再次读取 handshake 的 msg，此时有可能是客户端主动要求服务端发送的 certificateStatusMsg msg, err = c.readHandshake() if err != nil { return err } cs, ok := msg.(*certificateStatusMsg) if ok { // RFC4366 on Certificate Status Request: // The server MAY return a \u0026quot;certificate_status\u0026quot; message. // [Min] 如果服务端ocspStapling标记为假，但收到了certificateStatusMsg，报警 if !hs.serverHello.ocspStapling { // If a server returns a \u0026quot;CertificateStatus\u0026quot; message, then the // server MUST have included an extension of type \u0026quot;status_request\u0026quot; // with empty \u0026quot;extension_data\u0026quot; in the extended server hello. c.sendAlert(alertUnexpectedMessage) return errors.New(\u0026quot;tls: received unexpected CertificateStatus message\u0026quot;) } // [Min] 累计计算 hash，并置 c.ocspResponse = cs.response hs.finishedHash.Write(cs.marshal()) if cs.statusType == statusTypeOCSP { c.ocspResponse = cs.response } // [Min] 读取下一条 handshake 消息 msg, err = c.readHandshake() if err != nil { return err } } // [Min] 根据套件获取对应的 keyAgreement keyAgreement := hs.suite.ka(c.vers) // [Min] 可能是 serverKeyExchangeMsg，如果采用的是 RSA 交换秘钥的模式，没有 serverKeyExchangeMsg skx, ok := msg.(*serverKeyExchangeMsg) if ok { // [Min] 如果是 serverKeyExchangeMsg，完成该消息并处理 hs.finishedHash.Write(skx.marshal()) // [Min] 从 serverKeyExchangeMsg 获取服务端公钥，并验证签名 err = keyAgreement.processServerKeyExchange(c.config, hs.hello, hs.serverHello, c.peerCertificates[0], skx) if err != nil { c.sendAlert(alertUnexpectedMessage) return err } // [Min] 读取下一条消息 msg, err = c.readHandshake() if err != nil { return err } } var chainToSend *Certificate var certRequested bool certReq, ok := msg.(*certificateRequestMsg) // [Min] 此时可能是服务端要求客户端发送证书的请求消息 if ok { certRequested = true // [Min] 完成该消息 hs.finishedHash.Write(certReq.marshal()) // [Min] 根据要求获取客户端的证书 if chainToSend, err = hs.getCertificate(certReq); err != nil { c.sendAlert(alertInternalError) return err } // [Min] 读取下一条消息 msg, err = c.readHandshake() if err != nil { return err } } // [Min] 应该是 HelloDone 消息 shd, ok := msg.(*serverHelloDoneMsg) if !ok { c.sendAlert(alertUnexpectedMessage) return unexpectedMessageError(shd, msg) } // [Min] 完成消息 hs.finishedHash.Write(shd.marshal()) // If the server requested a certificate then we have to send a // Certificate message, even if it's empty because we don't have a // certificate to send. // [Min] 发送客户端证书信息 if certRequested { certMsg = new(certificateMsg) certMsg.certificates = chainToSend.Certificate hs.finishedHash.Write(certMsg.marshal()) if _, err := c.writeRecord(recordTypeHandshake, certMsg.marshal()); err != nil { return err } } // [Min] 构造客户端秘钥交换消息，由于已经收到服务端的公钥信息，所以同时可以生成预备主密钥了 preMasterSecret, ckx, err := keyAgreement.generateClientKeyExchange(c.config, hs.hello, c.peerCertificates[0]) if err != nil { c.sendAlert(alertInternalError) return err } // [Min] 完成消息，并将 clientKeyExchangeMsg 写入 sendBuf，等待推送 if ckx != nil { hs.finishedHash.Write(ckx.marshal()) if _, err := c.writeRecord(recordTypeHandshake, ckx.marshal()); err != nil { return err } } // [Min] 如果发送了证书给服务端，那么也要发送签名让服务端验证 if chainToSend != nil \u0026amp;\u0026amp; len(chainToSend.Certificate) \u0026gt; 0 { certVerify := \u0026amp;certificateVerifyMsg{ hasSignatureAndHash: c.vers \u0026gt;= VersionTLS12, } // [Min] 证书支持签名 key, ok := chainToSend.PrivateKey.(crypto.Signer) if !ok { c.sendAlert(alertInternalError) return fmt.Errorf(\u0026quot;tls: client certificate private key of type %T does not implement crypto.Signer\u0026quot;, chainToSend.PrivateKey) } // [Min] 证书的签名类型，RSA 或 ECDSA var signatureType uint8 switch key.Public().(type) { case *ecdsa.PublicKey: signatureType = signatureECDSA case *rsa.PublicKey: signatureType = signatureRSA default: c.sendAlert(alertInternalError) return fmt.Errorf(\u0026quot;tls: failed to sign handshake with client certificate: unknown client certificate key type: %T\u0026quot;, key) } // SignatureAndHashAlgorithm was introduced in TLS 1.2. if certVerify.hasSignatureAndHash { // [Min] 以证书的签名类型为基准，获取一种符合服务端要求的签名算法 certVerify.signatureAlgorithm, err = hs.finishedHash.selectClientCertSignatureAlgorithm(certReq.supportedSignatureAlgorithms, signatureType) if err != nil { c.sendAlert(alertInternalError) return err } } // [Min] 计算finishedHash.buffer 的 hash值，作为待签名对象 digest, hashFunc, err := hs.finishedHash.hashForClientCertificate(signatureType, certVerify.signatureAlgorithm, hs.masterSecret) if err != nil { c.sendAlert(alertInternalError) return err } // [Min] 对上述 hash 值以私钥采用同样的 hash 函数进行签名 certVerify.signature, err = key.Sign(c.config.rand(), digest, hashFunc) if err != nil { c.sendAlert(alertInternalError) return err } // [Min] 累计计算 hash，将 certificateVerifyMsg 写入 conn 缓存 hs.finishedHash.Write(certVerify.marshal()) if _, err := c.writeRecord(recordTypeHandshake, certVerify.marshal()); err != nil { return err } } // [Min] 根据预备主密钥，客户端随机数，服务端随机数，计算主密钥 hs.masterSecret = masterFromPreMasterSecret(c.vers, hs.suite, preMasterSecret, hs.hello.random, hs.serverHello.random) // [Min] 一般测试用 if err := c.config.writeKeyLog(hs.hello.random, hs.masterSecret); err != nil { c.sendAlert(alertInternalError) return errors.New(\u0026quot;tls: failed to write to key log: \u0026quot; + err.Error()) } // [Min] 清空 finishedHash 中的 buffer hs.finishedHash.discardHandshakeBuffer() return nil }  1.2.2 调用 establishKeys()，通过主密钥建立各种秘钥，等待切换 　和重用 session 类似\n1.2.3 客户端发送 nextProtoMsg（可选），finishedMsg 　非重用 session，客户端先于服务端发送 finishedMsg，发送内容与重用 session 一致\n1.2.4 推送消息 　certificateMsg（可选），clientKeyExchangeMsg，certificateVerifyMsg（可选），nextProtoMsg（可选），finishedMsg\n1.2.5 readSessionTicket() 　读取并完成newSessionTicketMsg，保持 ticket 以及 session 状态，与重用 session 类似\n1.2.6 readFinished 　与重用 session 类似，只不过服务端，客户端的 finishedMsg 先后顺序不同\n1.3 客户端 handshake 完成  标注是否为重用 session，c.didResume = isResume 设置 c.handshakeComplete = true 将 session 缓存到 LRU 缓存结构中（sessionCache）  // [Min] 完成客户端 handshake c.didResume = isResume c.handshakeComplete = true  // [Min] 调用 clientHandshakeState.handshake，真正开始 handshake if err = hs.handshake(); err != nil { return err } // If we had a successful handshake and hs.session is different from // the one already cached - cache a new one // [Min] 如果 handshake 成功后，返回的 hs.session 与之前的不同，将新的 hs.session 存入缓存中，cacheKey 不变 if sessionCache != nil \u0026amp;\u0026amp; hs.session != nil \u0026amp;\u0026amp; session != hs.session { sessionCache.Put(cacheKey, hs.session) }  2. 服务端 2.1 重用 session 　如果是重用 session，服务端已经在第一批次的最后一条消息发送了 finishedMsg，现在只需要等待客户发送的切换信号和客户端的 finishedMsg，调用 hs.readFinished 即可。\n 读取切换信号，切换 in 为加密模式 如果是 NPN 模式，此时客户端应该已经发送了nextProtoMsg，读取并完成该消息，更新协议 读取 finishedMsg，并验证客户端发来的 verifyData，完成 finishedMsg 并保存 verifyData  // [Min] 读取客户端 finishedMsg func (hs *serverHandshakeState) readFinished(out []byte) error { c := hs.c // [Min] 首先客户端也应该先返回一个 recordTypeChangeCipherSpec 的消息 // [Min] 此时会将 c.in 的 cipher，mac 切换为之前协商后的结果 c.readRecord(recordTypeChangeCipherSpec) if c.in.err != nil { return c.in.err } // [Min] 如果是 NPN 模式，此时应该收到客户端的对此的回复 if hs.hello.nextProtoNeg { msg, err := c.readHandshake() if err != nil { return err } nextProto, ok := msg.(*nextProtoMsg) if !ok { c.sendAlert(alertUnexpectedMessage) return unexpectedMessageError(nextProto, msg) } hs.finishedHash.Write(nextProto.marshal()) c.clientProtocol = nextProto.proto } // [Min] 接下来应该收到客户端的 finishedMsg msg, err := c.readHandshake() if err != nil { return err } clientFinished, ok := msg.(*finishedMsg) if !ok { c.sendAlert(alertUnexpectedMessage) return unexpectedMessageError(clientFinished, msg) } // [Min] 计算 clientSum，并验证 clientFinished.verifyData 是否一致 verify := hs.finishedHash.clientSum(hs.masterSecret) if len(verify) != len(clientFinished.verifyData) || subtle.ConstantTimeCompare(verify, clientFinished.verifyData) != 1 { c.sendAlert(alertHandshakeFailure) return errors.New(\u0026quot;tls: client's Finished message is incorrect\u0026quot;) } // [Min] 再次计算客户端发送的 finishedMsg 的 hash 并将 verify 拷贝至 out hs.finishedHash.Write(clientFinished.marshal()) copy(out, verify) return nil }  2.2 非重用 session 　非重用 session，服务端此时已经完成了 serverHelloDoneMsg。\n2.2.1 如果之前向客户端提出了证书的请求，此时应该收到 certificateMsg  完成certificateMsg 提取客户端证书公钥 读取下一条消息  // [Min] 读取 handshake 返回消息 msg, err := c.readHandshake() if err != nil { return err } var ok bool // If we requested a client certificate, then the client must send a // certificate message, even if it's empty. if c.config.ClientAuth \u0026gt;= RequestClientCert { // [Min] 如果之前要求了客户端提供证书，此时应该先收到证书消息 if certMsg, ok = msg.(*certificateMsg); !ok { c.sendAlert(alertUnexpectedMessage) return unexpectedMessageError(certMsg, msg) } // [Min] 累计计算 hash hs.finishedHash.Write(certMsg.marshal()) // [Min] 如果证书消息中并没有实际包含证书，但服务端又要求有证书，报警 if len(certMsg.certificates) == 0 { // The client didn't actually send a certificate switch c.config.ClientAuth { case RequireAnyClientCert, RequireAndVerifyClientCert: c.sendAlert(alertBadCertificate) return errors.New(\u0026quot;tls: client didn't provide a certificate\u0026quot;) } } // [Min] 处理客户端的证书，返回公钥 pub, err = hs.processCertsFromClient(certMsg.certificates) if err != nil { return err } // [Min] 读取下一条消息 msg, err = c.readHandshake() if err != nil { return err } }  2.2.2 客户端秘钥交换消息 clientKeyExchangeMsg  完成 clientKeyExchangeMsg 调用processClientKeyExchange，根据客户端发来的交换秘钥的公钥计算预备主密钥\n如果是 RSA 秘钥交换算法，直接用服务端证书的私钥解密，即可得到明文预备主密钥\n如果是 ECDHE 秘钥交换算法，用之前生成的秘钥交换算法私钥和客户端传来的公钥点相乘，即可得到共享秘钥点，该点的 x 坐标值即为预备主密钥\n 再由预备主密钥，客户端随机数，服务端随机数计算主密钥  // Get client key exchange // [Min] 接下来应该收到客户端交换 key 的消息 ckx, ok := msg.(*clientKeyExchangeMsg) if !ok { c.sendAlert(alertUnexpectedMessage) return unexpectedMessageError(ckx, msg) } // [Min] 完成消息 hs.finishedHash.Write(ckx.marshal()) // [Min] 此时有了客户端交换秘钥的公钥，就可以生成预备主密钥了 preMasterSecret, err := keyAgreement.processClientKeyExchange(c.config, hs.cert, ckx, c.vers) if err != nil { c.sendAlert(alertHandshakeFailure) return err } // [Min] 计算主密钥 hs.masterSecret = masterFromPreMasterSecret(c.vers, hs.suite, preMasterSecret, hs.clientHello.random, hs.hello.random) if err := c.config.writeKeyLog(hs.clientHello.random, hs.masterSecret); err != nil { c.sendAlert(alertInternalError) return err }  2.2.3 如果之前客户端发来了证书，验证签名 certificateVerifyMsg  获取 certificateVerifyMsg 明确 certificateVerifyMsg 中的签名算法 检查客户端证书公钥与签名算法是否匹配 用客户端证书公钥验证签名 完成 certificateVerifyMsg 清空 finishedHash 中的 buffer  // If we received a client cert in response to our certificate request message, // the client will send us a certificateVerifyMsg immediately after the // clientKeyExchangeMsg. This message is a digest of all preceding // handshake-layer messages that is signed using the private key corresponding // to the client's certificate. This allows us to verify that the client is in // possession of the private key of the certificate. // [Min] 验证客户端的签名 if len(c.peerCertificates) \u0026gt; 0 { // [Min] 读取一条消息，理应是 certificateVerifyMsg msg, err = c.readHandshake() if err != nil { return err } certVerify, ok := msg.(*certificateVerifyMsg) if !ok { c.sendAlert(alertUnexpectedMessage) return unexpectedMessageError(certVerify, msg) } // Determine the signature type. // [Min] 获取签名算法 var signatureAlgorithm SignatureScheme var sigType uint8 if certVerify.hasSignatureAndHash { signatureAlgorithm = certVerify.signatureAlgorithm if !isSupportedSignatureAlgorithm(signatureAlgorithm, supportedSignatureAlgorithms) { return errors.New(\u0026quot;tls: unsupported hash function for client certificate\u0026quot;) } sigType = signatureFromSignatureScheme(signatureAlgorithm) } else { // Before TLS 1.2 the signature algorithm was implicit // from the key type, and only one hash per signature // algorithm was possible. Leave signatureAlgorithm // unset. switch pub.(type) { case *ecdsa.PublicKey: sigType = signatureECDSA case *rsa.PublicKey: sigType = signatureRSA } } // [Min] 验证签名 switch key := pub.(type) { case *ecdsa.PublicKey: if sigType != signatureECDSA { err = errors.New(\u0026quot;tls: bad signature type for client's ECDSA certificate\u0026quot;) break } ecdsaSig := new(ecdsaSignature) if _, err = asn1.Unmarshal(certVerify.signature, ecdsaSig); err != nil { break } if ecdsaSig.R.Sign() \u0026lt;= 0 || ecdsaSig.S.Sign() \u0026lt;= 0 { err = errors.New(\u0026quot;tls: ECDSA signature contained zero or negative values\u0026quot;) break } var digest []byte if digest, _, err = hs.finishedHash.hashForClientCertificate(sigType, signatureAlgorithm, hs.masterSecret); err != nil { break } if !ecdsa.Verify(key, digest, ecdsaSig.R, ecdsaSig.S) { err = errors.New(\u0026quot;tls: ECDSA verification failure\u0026quot;) } case *rsa.PublicKey: if sigType != signatureRSA { err = errors.New(\u0026quot;tls: bad signature type for client's RSA certificate\u0026quot;) break } var digest []byte var hashFunc crypto.Hash if digest, hashFunc, err = hs.finishedHash.hashForClientCertificate(sigType, signatureAlgorithm, hs.masterSecret); err != nil { break } err = rsa.VerifyPKCS1v15(key, hashFunc, digest, certVerify.signature) } if err != nil { c.sendAlert(alertBadCertificate) return errors.New(\u0026quot;tls: could not validate signature of connection nonces: \u0026quot; + err.Error()) } hs.finishedHash.Write(certVerify.marshal()) } // [Min] 客户端证书验证完毕，清空 finishedHash 的 buffer hs.finishedHash.discardHandshakeBuffer()  2.2.4 调用 hs.establishKeys()，根据主密钥生成各种加密秘钥，等待切换 // [Min] 根据主密钥建立加密通讯需要的 cipher，hash，更新到客户端和服务端各自对应的 halfConn 的预备字段中，等待切换 func (hs *serverHandshakeState) establishKeys() error { c := hs.c // [Min] 通过主密钥生成一系列计算 mac，加解密需要使用到的 key，和初始化向量 clientMAC, serverMAC, clientKey, serverKey, clientIV, serverIV := keysFromMasterSecret(c.vers, hs.suite, hs.masterSecret, hs.clientHello.random, hs.hello.random, hs.suite.macLen, hs.suite.keyLen, hs.suite.ivLen) var clientCipher, serverCipher interface{} var clientHash, serverHash macFunction if hs.suite.aead == nil { clientCipher = hs.suite.cipher(clientKey, clientIV, true /* for reading */) clientHash = hs.suite.mac(c.vers, clientMAC) serverCipher = hs.suite.cipher(serverKey, serverIV, false /* not for reading */) serverHash = hs.suite.mac(c.vers, serverMAC) } else { clientCipher = hs.suite.aead(clientKey, clientIV) serverCipher = hs.suite.aead(serverKey, serverIV) } // [Min] 将 client 的 cipher，hash 算法更新到 in 的预备字段中，等待正式切换 // [Min] 将 server 的 cipher，hash 算法更新到 out 的预备字段中，等待正式切换 c.in.prepareCipherSpec(c.vers, clientCipher, clientHash) c.out.prepareCipherSpec(c.vers, serverCipher, serverHash) return nil }  2.2.5 调用 hs.readFinished 　和重用 session 类似，客户端，服务端先后顺序不同而已\n2.2.6 调用 sendSessionTicket  根据 session 状态加密 ticket 由 ticket 构造 newSessionTicketMsg，完成并写入 sendBuf，等待推送  // [Min] 将 sessionState 转为 sessionTicket func (c *Conn) encryptTicket(state *sessionState) ([]byte, error) { // [Min] 首先序列化 sessionState serialized := state.marshal() // [Min] ticket 结构：ticketKeyName + iv + 加密后的序列化流 + mac encrypted := make([]byte, ticketKeyNameLen+aes.BlockSize+len(serialized)+sha256.Size) keyName := encrypted[:ticketKeyNameLen] iv := encrypted[ticketKeyNameLen : ticketKeyNameLen+aes.BlockSize] macBytes := encrypted[len(encrypted)-sha256.Size:] // [Min] iv 为16字节的随机数 if _, err := io.ReadFull(c.config.rand(), iv); err != nil { return nil, err } // [Min] 从 config 中获取 sessionTicketKeys ，用来将 sessionState 加密为 ticket // [Min] 注意，加密的时候总是使用第一个 sessionTicketKey，后续的都认为是老的 key key := c.config.ticketKeys()[0] // [Min] 从 key 中获取 keyName，并以 key.aseKey 为秘钥，iv 为初始向量，CTR 模式对序列化流加密 copy(keyName, key.keyName[:]) block, err := aes.NewCipher(key.aesKey[:]) if err != nil { return nil, errors.New(\u0026quot;tls: failed to create cipher while encrypting ticket: \u0026quot; + err.Error()) } cipher.NewCTR(block, iv).XORKeyStream(encrypted[ticketKeyNameLen+aes.BlockSize:], serialized) // [Min] 对 keyName + iv + 加密的序列化流 以 key.hmacKey 为秘钥计算 HMAC mac := hmac.New(sha256.New, key.hmacKey[:]) mac.Write(encrypted[:len(encrypted)-sha256.Size]) mac.Sum(macBytes[:0]) return encrypted, nil }  // [Min] 根据当前协商好的信息，制作 sessionTicket，并返回给客户端 func (hs *serverHandshakeState) sendSessionTicket() error { if !hs.hello.ticketSupported { return nil } c := hs.c m := new(newSessionTicketMsg) var err error // [Min] sessionState 的内容 state := sessionState{ vers: c.vers, cipherSuite: hs.suite.id, masterSecret: hs.masterSecret, certificates: hs.certsFromClient, } m.ticket, err = c.encryptTicket(\u0026amp;state) if err != nil { return err } hs.finishedHash.Write(m.marshal()) if _, err := c.writeRecord(recordTypeHandshake, m.marshal()); err != nil { return err } return nil }  2.2.7 调用服务端 hs.sendFinished  发送切换信号，并将 out 转为加密模式 构造 finishedMsg，写入 verifyData，完成并写入 sendBuf，等待推送 更新 config 中套件，并保存 verfiyData  // [Min] 发送 finshedMsg func (hs *serverHandshakeState) sendFinished(out []byte) error { c := hs.c // [Min] 发送切换信号，此时会将 c.out 中的 cipher 和 mac 切换，转为加密模式 if _, err := c.writeRecord(recordTypeChangeCipherSpec, []byte{1}); err != nil { return err } // [Min] 构造 finishedMsg，并序列化，然后完成该消息并写入 c.sendBuf 中等待正式发送 finished := new(finishedMsg) finished.verifyData = hs.finishedHash.serverSum(hs.masterSecret) hs.finishedHash.Write(finished.marshal()) if _, err := c.writeRecord(recordTypeHandshake, finished.marshal()); err != nil { return err } // [Min] 同步 config 中 cipherSuite c.cipherSuite = hs.suite.id // [Min] 将 verifyData 拷贝至 out copy(out, finished.verifyData) return nil }  2.2.8 推送消息 　newSessionTicketMsg，切换信号，finishedMsg\n2.3 服务端完成 handshake 3. 整个握手过程中的消息流 正常情况下非重用 session 消息发送序列：\n   批次-序号 客户端 服务端     1-1 clientHelloMsg serverHelloMsg   1-2  certificateMsg   1-3  certificateStatusMsg（可选）   1-4  serverKeyExchangeMsg（非 RSA 秘钥交换）   1-5  certificateRequestMsg（可选）   1-6  serverHelloDoneMsg   2-1 certificateMsg（可选） newSessionTicketMsg   2-2 clientKeyExchangeMsg 切换信号   2-3 certificateVerifyMsg（可选） finishedMsg   2-4 切换信号    2-5 nextProtoMsg（可选）    2-6 finishedMsg     正常情况下重用 session 消息发送序列：\n   批次-序号 客户端 服务端     1-1 clientHelloMsg serverHelloMsg   1-2  newSessionTicketMsg（可选）   1-3  切换信号   1-4  finishedMsg   2-1 切换信号    2-2 nextProtoMsg（可选）    2-2 finishedMsg     4. 实际处理 Timeline 非重用 session：\n   序号 步骤     1 客户端准备 clientHelloMsg，包含了协商的版本，套件，重用 sessionId，客户端随机数等信息   2 客户端发送 clientHelloMsg（客户端第一次推送）   3 服务端读取 clientHelloMsg，获得客户端随机数   4 服务端协商各种参数，生成服务端随机数   5 服务端按照客户端的要求获取服务端证书   6 服务端判断是否重用 session（否）   7 服务端协商套件   8 服务端完成 serverHelloMsg，写入 sendBuf，等待推送   9 服务端完成 certificateMsg，写入 sendBuf，等待推送   10 服务端完成 certificateStatusMsg（按需可选），写入 sendBuf，等待推送   11 服务端完成 serverKeyExchangeMsg（非 RSA 秘钥交换），写入 sendBuf，等待推送   12 服务端完成 certificateRequestMsg（按需可选），写入 sendBuf，等待推送   13 服务端完成 serverHelloDoneMsg，写入 sendBuf，等待推送   14 服务端第一次推送   15 客户端读取 serverHelloMsg，根据协商结果，完成相关参数的设置，同时获得服务端随机数   16 客户端读取 certificateMsg，完成对服务端证书的解析，基本验证   17 客户端读取 certificateStatusMsg（按需可选），完成服务端证书状态的设置   18 客户端读取 serverKeyExchangeMsg（非 RSA 秘钥交换），获取服务端秘钥交换公钥，并以服务端证书公钥验证签名   19 客户端读取 certificateRequestMsg（按需可选），准备好客户端证书   20 客户端读取 serverHelloDoneMsg，准备开始回应服务端   21 客户端完成 certificateMsg（按需可选），回应服务端要求的证书信息，写入 sendBuf，等待推送   22 客户端完成 clientKeyExchangeMsg，发送客户端秘钥交换信息，写入 sendBuf，等待推送，同时生成预备主密钥   23 客户端完成 certificateVerifyMsg（按需可选），发送客户端证书签名，让服务端验证，写入 sendBuf，等待推送   24 客户端生成主密钥，再由主密钥衍生出各种秘钥   25 客户端发送切换信号，写入 sendBuf，等待推送，将输出通道转为加密模式   26 客户端完成 nextProtoMsg（按需可选），写入 sendBuf，等待推送   27 客户端完成 finishedMsg，写入 sendBuf，等待推送   28 客户端第二次推送   29 服务端读取 certificateMsg（按需可选），获得客户端证书，解析，基本验证，并提取证书公钥   30 服务端读取 clientKeyExchangeMsg，获得客户端秘钥交换信息，生成预备主密钥   31 服务端生成主密钥   32 服务端读取 certificateVerifyMsg（按需可选），并以客户端证书公钥进行签名验证   33 服务端由主密钥衍生出各种秘钥   34 服务端读取切换信号，将输入通道转为加密模式   35 服务端读取 nextProtoMsg（按需可选），更新协议   36 服务端读取 finishedMsg，并对 finishedMsg 中的 verifyData 进行验证   37 服务端根据当前使用的 session 制作 sessionTicket，完成 newSessionTicketMsg，写入 sendBuf，等待推送   38 服务端发送切换信号，写入 sendBuf，等待推送，将输出通道转为加密模式   39 服务端完成 finishedMsg，写入 sendBuf，等待推送   40 服务端第二次推送   41 服务端完成握手   42 客户端读取 newSessionTicketMsg，保存 ticket 和 session 状态   43 客户端读取切换信号，将输入通道转为加密模式   44 客户端读取 finishedMsg，并对 finishedMsg 中的 verifyData 进行验证   45 客户端缓存 session 到本地 sessionCache   46 客户端完成握手    重用 session：\n   序号 步骤     1 客户端准备 clientHelloMsg，包含了协商的版本，套件，重用 sessionId，客户端随机数等信息   2 客户端发送 clientHelloMsg（客户端第一次推送）   3 服务端读取 clientHelloMsg，获得客户端随机数   4 服务端协商各种参数，生成服务端随机数   5 服务端按照客户端的要求获取服务端证书   6 服务端判断是否重用 session（是）   7 服务端完成 serverHelloMsg，写入 sendBuf，等待推送   8 服务端对重用 session 中包含的客户端证书进行解析，基本验证，并提取证书公钥（如果重用 session 中有的话）   9 服务端从重用 session 中恢复主密钥，并根据主密钥衍生出各种秘钥   10 服务端重制 sessionTicket（如果加密 ticket 的 key 不是最新的 ticketKey），完成 newSessionTicketMsg，写入 sendBuf，等待推送   11 服务端发送切换信号，将输出通道转为加密模式   12 服务端完成 finishedMsg，写入 sendBuf，等待推送   13 服务端第一次推送   14 客户端读取 serverHelloMsg，根据协商结果，完成相关参数的设置，同时获得服务端随机数   15 客户端根据 sessionId 得知可以重用 session   16 客户端从重用 session 中恢复主密钥，并由主密钥衍生出各种秘钥   17 客户端根据 severHelloMsg.ticketSupported 得知 ticket 是否被服务端重制，按需读取 newSessionTicketMsg，更新 session 对应的 ticket   18 客户端读取切换信号，将输入通道转为加密模式   19 客户端读取 finishedMsg，并对 finishedMsg 中的 verifyData 进行验证   20 客户端发送切换信号，将输出通道转为加密模式   21 客户端完成 nextProtoMsg（按需可选），通知服务端选择的协议，写入 sendBuf，等待推送   22 客户端完成 finishedMsg，写入 sendBuf，等待推送   23 客户端第二次推送   24 客户端将重制了的 ticket 的 session 缓存到本地 sessionCache   25 客户端完成握手   26 服务端读取切换信号，将输入通道转为加密模式   27 服务端读取 nextProtoMsg（按需可选），设置协议   28 服务端读取 finishedMsg，并对 finishedMsg 中的 verifyData 进行验证   29 服务端完成握手   ","date":1533295838,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1543733643,"objectID":"342d20777f2156c2adea5d0c05b330bc","permalink":"https://mooncaker816.github.io/2018/08/03/tls%E4%BA%8C/","publishdate":"2018-08-03T19:30:38+08:00","relpermalink":"/2018/08/03/tls%E4%BA%8C/","section":"post","summary":"书接上回，客户端在完成 clientHelloMsg 和 serverHelloMsg 后，开启缓存写入模式，也分为重用 session 和非重用 session 两种情况。服务端在发送完第一批次消息后，等待客户端的回应。 1. 客户端 1.1","tags":["TLS"],"title":"TLS（二）","type":"post"},{"authors":null,"categories":["Golang","Web","密码学"],"content":"1. TLS 基本概念  传输层安全性协议（英语：Transport Layer Security，缩写作 TLS），及其前身安全套接层（Secure Sockets Layer，缩写作 SSL）是一种安全协议，目的是为互联网通信，提供安全及数据完整性保障。网景公司（Netscape）在1994年推出首版网页浏览器，网景导航者时，推出HTTPS协议，以SSL进行加密，这是SSL的起源。IETF将SSL进行标准化，1999年公布第一版TLS标准文件。随后又公布RFC 5246 （2008年8月）与 RFC 6176 （2011年3月）。在浏览器、电子邮件、即时通信、VoIP、网络传真等应用程序中，广泛支持这个协议。主要的网站，如Google、Facebook等也以这个协议来创建安全连线，发送数据。目前已成为互联网上保密通信的工业标准。\nSSL包含记录层（Record Layer）和传输层，记录层协议确定传输层数据的封装格式。传输层安全协议使用X.509认证，之后利用非对称加密演算来对通信方做身份认证，之后交换对称密钥作为会谈密钥（Session key）。这个会谈密钥是用来将通信两方交换的数据做加密，保证两个应用间通信的保密性和可靠性，使客户与服务器应用之间的通信不被攻击者窃听。\n 　以上是 Wiki 对 TLS 的描述，通俗点说，TLS 就是用来在通信双方之间建立一条安全的加密的而又可靠的通道，确保双方完成数据交换。\n　本文主要是结合 Go 的 TLS(\u0026lt;= 1.2) 实现来分析如何一步一步搭建起这条“通道”的。在此之前，需要理解秘钥交换算法，签名算法，密码算法，密码模式，摘要算法，它们的组合称为密码套件(CipherSuite)。例如 TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384\n 秘钥交换算法：ECDHE，椭圆曲线秘钥交换，用于交换公钥生成预备主密钥 签名算法：ECDSA，椭圆曲线数字签名算法，用于身份认证 密码算法：AES 256，秘钥为 256-bits 的 AES 加密算法，用于对数据的加密 密码模式：GCM，伽罗瓦计数器模式，数据块加密的模式 摘要算法：SHA384，加密算法中使用的摘要算法  　对于上述各种算法，此处就不展开细说了，Go 的标准库crypto以及x/crypto都有详细的实现，以下是 Go 实现的秘钥套件。\n   套件名 可用版本 伪随机数算法 伪随机算法中的 hash     TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305 1.2 prf12 SHA256   TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305 1.2 prf12 SHA256   TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 1.2 prf12 SHA256   TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 1.2 prf12 SHA256   TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 1.2 prf12 SHA384   TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 1.2 prf12 SHA384   TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA \u0026lt; 1.2 prf10/prf30 MD5,SHA1   TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA \u0026lt; 1.2 prf10/prf30 MD5,SHA1   TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA \u0026lt; 1.2 prf10/prf30 MD5,SHA1   TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA \u0026lt; 1.2 prf10/prf30 MD5,SHA1   TLS_RSA_WITH_AES_128_GCM_SHA256 1.2 prf12 SHA256   TLS_RSA_WITH_AES_256_GCM_SHA384 1.2 prf12 SHA384   TLS_RSA_WITH_AES_128_CBC_SHA \u0026lt; 1.2 prf10/prf30 MD5,SHA1   TLS_RSA_WITH_AES_256_CBC_SHA \u0026lt; 1.2 prf10/prf30 MD5,SHA1   TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA \u0026lt; 1.2 prf10/prf30 MD5,SHA1   TLS_RSA_WITH_3DES_EDE_CBC_SHA \u0026lt; 1.2 prf10/prf30 MD5,SHA1    2. TLS 握手的流程图 　以下是以RSA秘钥交换算法为基础的双向证书握手流程图，有时可以忽略客户端证书需求。 大致可以分为以下几步：\n 客户端生成客户端随机数，协商版本，秘钥套件等信息，发起握手（clientHelloMsg） 服务端收到 clientHelloMsg，同时生成服务端随机数，再同协商结果一同返回客户端（serverHelloMsg） 客户端收到 serverHelloMsg 服务端发送证书给客户端 申请客户端发送证书 客户端验证证书 客户端发送证书 服务端验证证书 客户端对之前所有的信息计算 hash，再以证书私钥对 hash 值进行签名，发送签名给服务端 服务端同样方式计算 hash ，并以客户端证书公钥对签名进行验证 客户端生成随机数作为预备主密钥，用服务端公钥加密，发送给服务端 服务端解密预备主密钥 客户端，服务端拥有了相同的预备主密钥，客户端随机数，服务端随机数，在此基础上，使用相同的秘钥导出算法 prf 计算得到主密钥 客户端以此主密钥作为后续会话的加密秘钥，转为加密模式，通知服务端切换 客户端结束握手 服务端收到切换通知，也转为加密模式 服务端结束握手  　实际运用中，主密钥只是用来生成一系列秘钥的起点，两端的加密秘钥不一定相同，但是由于主密钥的存在，使得双方都知道对方使用的是哪一个秘钥，这样也提高了安全性。\n3. Go 的 TLS 详细实现 　首先我们假设服务端已经开启了 TLS，客户端通过拨号的方式连接服务端，在此基础上我们来分析整个 TLS 的握手流程。\n3.1 ClientHello \u0026amp; ServerHello 阶段 3.1.1 客户端从正式发送 ClientHelloMsg 到接收 ServerHelloMsg  客户端设置超时，并通过 Dial 的方式获得可用的 TCPConn，同时初始化tls.Config，主要是config.ServerName\ntimeout := dialer.Timeout if !dialer.Deadline.IsZero() { deadlineTimeout := time.Until(dialer.Deadline) if timeout == 0 || deadlineTimeout \u0026lt; timeout { timeout = deadlineTimeout } } var errChannel chan error // [Min] 如果有超时，在超时的时候，向 errChannel 发送一个超时信号 // [Min] 注意，errChannel 为2个缓存的非阻塞通道，这样就不会阻塞较慢的那个 goroutine 造成泄露 if timeout != 0 { errChannel = make(chan error, 2) time.AfterFunc(timeout, func() { errChannel \u0026lt;- timeoutError{} }) } // [Min] 正常调用 Dial，获取底层 conn，一般为 TCPConn rawConn, err := dialer.Dial(network, addr) if err != nil { return nil, err } // [Min] 获取 hostname colonPos := strings.LastIndex(addr, \u0026quot;:\u0026quot;) if colonPos == -1 { colonPos = len(addr) } hostname := addr[:colonPos] // [Min] 初始化 config if config == nil { config = defaultConfig() } // If no ServerName is set, infer the ServerName // from the hostname we're connecting to. // [Min] 设置 ServerName，这个很重要，因为服务端需要以此来获取证书发送给客户端 if config.ServerName == \u0026quot;\u0026quot; { // Make a copy to avoid polluting argument or default. c := config.Clone() c.ServerName = hostname config = c }  客户端封装 TCPConn 为 tls.Conn，并发起握手\n// [Min] 构造客户端的 tls.Conn conn := Client(rawConn, config) // [Min] 没有超时，直接调用 Handshake，等到 Handshake 结束 if timeout == 0 { err = conn.Handshake() } else { // [Min] 有超时，发起一个 goroutine 调用 Handshake go func() { errChannel \u0026lt;- conn.Handshake() }() // [Min] 可能是超时返回，也可能是 Handshake 结束的返回 err = \u0026lt;-errChannel }  func Client(conn net.Conn, config *Config) *Conn { return \u0026amp;Conn{conn: conn, config: config, isClient: true} }  客户端调用c.clientHandshake()\nif c.isClient { c.handshakeErr = c.clientHandshake() } else { c.handshakeErr = c.serverHandshake() }  客户端调用 makeClientHello 构造 clientHelloMsg\nclientHelloMsg 包含以下信息:\n  默认采用最新的版本 TLS 1.2\n 非压缩方法\n 要求服务端提供证书状态\n 要求服务端提供 hs.cert.SignedCertificateTimestamps\n serverName 为 hostnameInSNI(config.ServerName)，目前只支持 DNS hostname，如果是IP 地址，serverName会设置为空\n 客户端支持的椭圆曲线 supportedCurves\n 客户端支持的点 supportedPoints，目前只支持非压缩的点\n NPN 模式，由 len(config.NextProtos) \u0026gt; 0 确定，让服务端发送NextProtos，客户端进行选择\n 支持安全重协商\n ALPN 模式，将客户端config.NextProtos发给服务端，让服务端选择\n 客户端可以使用的密码套件\n 客户端随机数\n \u0026gt;= TLS 1.2, 客户端支持的签名算法\n   // [Min] 根据config构造clientHelloMsg hello, err := makeClientHello(c.config) if err != nil { return err }  检查有没有可以复用的候选 session\n  首先要支持 sessionTicket，且c.config.ClientSessionCache不能为空\n 根据服务端 serverName 或者 IP，从c.config.ClientSessionCache中获取有相应键值的 ClientSessionState，其中包含可以恢复 session 的 ticket\n 如果有，检查是否符合客户端的密码套件要求，是否符合 TLS 版本要求\n 如果3都 ok，将 ClientSessionState 中的 ticket 赋值给hello.sessionTicket，并随机分配一个16字节的hello.sessionId   // [Min] 开始检查复用 Session 的可能 var session *ClientSessionState var cacheKey string // [Min] 首先获取 config 中的 ClientSessionCache，如果不支持重用，seesionCache 设置为 nil sessionCache := c.config.ClientSessionCache if c.config.SessionTicketsDisabled { sessionCache = nil } // [Min] 如果此时 sessionCache 不为 nil，说明可以支持重用 session，设置 hello.ticketSupported 为真 if sessionCache != nil { hello.ticketSupported = true } // Session resumption is not allowed if renegotiating because // renegotiation is primarily used to allow a client to send a client // certificate, which would be skipped if session resumption occurred. // [Min] 只有首次握手才能重用 if sessionCache != nil \u0026amp;\u0026amp; c.handshakes == 0 { // Try to resume a previously negotiated TLS session, if // available. // [Min] 根据ServerName 或服务器地址获取 sessioncachekey cacheKey = clientSessionCacheKey(c.conn.RemoteAddr(), c.config) // [Min] 从 sessionCache 中获取该 session candidateSession, ok := sessionCache.Get(cacheKey) if ok { // Check that the ciphersuite/version used for the // previous session are still valid. // [Min] 如果找到了，再次检查该 session 使用的密码套件是否在客户端的支持列表中 cipherSuiteOk := false for _, id := range hello.cipherSuites { if id == candidateSession.cipherSuite { cipherSuiteOk = true break } } // [Min] 检查该 session 使用的版本是否有效 versOk := candidateSession.vers \u0026gt;= c.config.minVersion() \u0026amp;\u0026amp; candidateSession.vers \u0026lt;= c.config.maxVersion() if versOk \u0026amp;\u0026amp; cipherSuiteOk { session = candidateSession } } } // [Min] 如果 session 可用，将 session.sessionTicket 赋值给 hello.sessionTicket if session != nil { hello.sessionTicket = session.sessionTicket // A random session ID is used to detect when the // server accepted the ticket and is resuming a session // (see RFC 5077). // [Min] 同时新建一个16字节的随机数作为该重用 session 的 id hello.sessionId = make([]byte, 16) if _, err := io.ReadFull(c.config.rand(), hello.sessionId); err != nil { return errors.New(\u0026quot;tls: short read from Rand: \u0026quot; + err.Error()) } }  构造clientHandshakeState，并调用其handshake()\nclientHandshakeState 中包含了:\n  该tls.Conn\n 之前构造的clientHelloMsg\n 候选复用 ClientSessionState\n   // [Min] 构造 clientHandshakeState hs := \u0026amp;clientHandshakeState{ c: c, // [Min] TLS Conn hello: hello, // [Min] clientHelloMsg session: session, // [Min] 重用 session }  直接发送 clientHelloMsg 到客户端（不走sendBuf），并等待读取服务端的回应 serverHelloMsg\n// send ClientHello // [Min] 明文写入 clientHelloMsg，直接推送到服务端，没有走c.sendBuf if _, err := c.writeRecord(recordTypeHandshake, hs.hello.marshal()); err != nil { return err } // [Min] 读取 handshake 的返回消息，并构建对应类型的消息体实例 msg msg, err := c.readHandshake() if err != nil { return err } var ok bool // [Min] 期待返回的是 serverHelloMsg if hs.serverHello, ok = msg.(*serverHelloMsg); !ok { c.sendAlert(alertUnexpectedMessage) return unexpectedMessageError(hs.serverHello, msg) }  读取到 serverHelloMsg 后，根据协商结果调用 hs.pickTLSVersion()，hs.pickCipherSuite() 设置版本，密码套件等\n// [Min] 选择 TLS 版本，设置 hs.c.vers，hs.c.haveVers if err = hs.pickTLSVersion(); err != nil { return err } // [Min] 选择加密套件，设置 hs.c.cipherSuite if err = hs.pickCipherSuite(); err != nil { return err }  // [Min] 匹配对应的 TLS 版本，更新到 hs.c.vers，hs.c.haveVers func (hs *clientHandshakeState) pickTLSVersion() error { vers, ok := hs.c.config.mutualVersion(hs.serverHello.vers) if !ok || vers \u0026lt; VersionTLS10 { // TLS 1.0 is the minimum version supported as a client. hs.c.sendAlert(alertProtocolVersion) return fmt.Errorf(\u0026quot;tls: server selected unsupported protocol version %x\u0026quot;, hs.serverHello.vers) } hs.c.vers = vers hs.c.haveVers = true return nil }  // [Min] 匹配加密套件，更新 hs.c.cipherSuite func (hs *clientHandshakeState) pickCipherSuite() error { if hs.suite = mutualCipherSuite(hs.hello.cipherSuites, hs.serverHello.cipherSuite); hs.suite == nil { hs.c.sendAlert(alertHandshakeFailure) return errors.New(\u0026quot;tls: server chose an unconfigured cipher suite\u0026quot;) } hs.c.cipherSuite = hs.suite.id return nil }  调用 hs.processServerHello() 对 serverHelloMsg 的其他处理与检查，得知是否重用 session\n  压缩方法检查 安全重协商检查 NPN，ALPN 模式的检查 scts 的处理 重用 session 的判断，此处我们只要判断serverHelloMsg中的 sessionId 是否与我们之前在 clientHelloMsg 中发送的 sessionId 相同，相同就表示可以重用之前发送的 ticket 如果决定重用 session 后，对重用 session 的检查   客户端完成 clientHelloMsg \u0026amp; serverHelloMsg\n　新建客户端的 finishedHash，当我们处理完一条消息后（包括发送完毕），用来记录所有握手阶段的消息的 hash 值，如果不是重用 session，且服务端对客户端证书有要求，我们也会将所有消息记录在 finishedHash 的 buffer 中。\n完成 clientHelloMsg 和 serverHelloMsg，此后再开启缓存写入模式。\nhs.finishedHash = newFinishedHash(c.vers, hs.suite) // No signatures of the handshake are needed in a resumption. // Otherwise, in a full handshake, if we don't have any certificates // configured then we will never send a CertificateVerify message and // thus no signatures are needed in that case either. if isResume || (len(c.config.Certificates) == 0 \u0026amp;\u0026amp; c.config.GetClientCertificate == nil) { hs.finishedHash.discardHandshakeBuffer() } hs.finishedHash.Write(hs.hello.marshal()) hs.finishedHash.Write(hs.serverHello.marshal()) c.buffering = true   3.1.2 服务端从接收 ClientHelloMsg 到正式发送 ServerHelloMsg  与客户端类似，服务端也是在获得一个可用 TCPConn 之后，对其进行封装，得到tls.Conn，此时 config 已经初始化且包含了服务端的证书\nfunc (l *listener) Accept() (net.Conn, error) { c, err := l.Listener.Accept() if err != nil { return nil, err } return Server(c, l.config), nil }  func Server(conn net.Conn, config *Config) *Conn { return \u0026amp;Conn{conn: conn, config: config} }  服务端发起握手\n　在服务端为该 tls.Conn 发起的 goroutine 中，我们会判断是否为 tls.Conn，如果是，那么我们就会发起握手。\nif tlsConn, ok := c.rwc.(*tls.Conn); ok { if d := c.server.ReadTimeout; d != 0 { c.rwc.SetReadDeadline(time.Now().Add(d)) } if d := c.server.WriteTimeout; d != 0 { c.rwc.SetWriteDeadline(time.Now().Add(d)) } if err := tlsConn.Handshake(); err != nil { c.server.logf(\u0026quot;http: TLS handshake error from %s: %v\u0026quot;, c.rwc.RemoteAddr(), err) return } c.tlsState = new(tls.ConnectionState) *c.tlsState = tlsConn.ConnectionState() if proto := c.tlsState.NegotiatedProtocol; validNPN(proto) { if fn := c.server.TLSNextProto[proto]; fn != nil { h := initNPNRequest{tlsConn, serverHandler{c.server}} fn(c.server, tlsConn, h) } return } }  与客户端类似，服务端会调起 c.serverHandshake()，正式发起握手程序\n 3.1 首先会调起 c.config.serverInit(nil)，来检查并更新用于生成 SessionTicket 的 c.sessionTicketKeys\n // serverInit is run under c.serverInitOnce to do initialization of c. If c was // returned by a GetConfigForClient callback then the argument should be the // Config that was passed to Server, otherwise it should be nil. // [Min] 主要是初始化c.sessionTicketKeys // [Min] 如果不支持SessionTickets，或者已经有sessionTicketKeys，直接返回 func (c *Config) serverInit(originalConfig *Config) { if c.SessionTicketsDisabled || len(c.ticketKeys()) != 0 { return } alreadySet := false for _, b := range c.SessionTicketKey { if b != 0 { alreadySet = true break } } // [Min] 如果 SessionTicketKey 为0，需要先设置SessionTicketKey // [Min] 如果 originalConfig 不是nil，拷贝 originalConfig 的SessionTicketKey // [Min] 如果是nil，则随机生成32字节的SessionTicketKey if !alreadySet { if originalConfig != nil { copy(c.SessionTicketKey[:], originalConfig.SessionTicketKey[:]) } else if _, err := io.ReadFull(c.rand(), c.SessionTicketKey[:]); err != nil { c.SessionTicketsDisabled = true return } } // [Min] 接下来设置sessionTicketKeys，如果originalConfig不为nil，直接拷贝 sessionTicketKeys // [Min] 否则调用 ticketKeyFromBytes 将刚才随机生成的 SessionTicketKey 转为 ticketKey 存入sessionTicketKeys if originalConfig != nil { originalConfig.mutex.RLock() c.sessionTicketKeys = originalConfig.sessionTicketKeys originalConfig.mutex.RUnlock() } else { // [Min] 对c.SessionTicketKey求SHA512，然后再按固定长度分割为 keyName，aesKey，hmacKey c.sessionTicketKeys = []ticketKey{ticketKeyFromBytes(c.SessionTicketKey)} } }   3.2 其次构造serverHandshakeState，调用hs.readClientHello()\n hs := serverHandshakeState{ c: c, } // [Min] 读取客户端 helloMsg，更新相关信息，同时决定是否重用 session，如果重用， // [Min] 那么 session 的信息就已经从 hs.clientHello.sessionTicket 中恢复到了 hs.sessionState isResume, err := hs.readClientHello() if err != nil { return err }  读取客户端发来的 clientHelloMsg, 作以下处理：\n 4.1 如果服务端配置中自定义了c.config.GetConfigForClient，那么就先执行该函数，修改配置 config\n if c.config.GetConfigForClient != nil { // [Min] 根据客户端的 helloMsg 生成一个新的 config if newConfig, err := c.config.GetConfigForClient(hs.clientHelloInfo()); err != nil { c.sendAlert(alertInternalError) return false, err } else if newConfig != nil { // [Min] 新的 config 中 // [Min] sessionTicketKeys 从 c.config 中拷贝 // [Min] SessionTicketKey 如果已经设置就不变，没有设置（0），则也从 c.config 中拷贝 newConfig.serverInitOnce.Do(func() { newConfig.serverInit(c.config) }) c.config = newConfig } }   4.2 协商 TLS 版本，检查客户端支持的椭圆曲线，点的格式，压缩方法在服务端是否支持，同时构造 ServerHelloMsg 消息实例\n // [Min] 根据客户端中的版本号，协商双方都可用的版本号 c.vers, ok = c.config.mutualVersion(hs.clientHello.vers) if !ok { c.sendAlert(alertProtocolVersion) return false, fmt.Errorf(\u0026quot;tls: client offered an unsupported, maximum protocol version of %x\u0026quot;, hs.clientHello.vers) } c.haveVers = true // [Min] 构建服务端 HelloMsg hs.hello = new(serverHelloMsg) supportedCurve := false preferredCurves := c.config.curvePreferences() // [Min] 判断客户端支持的Curve服务端是否也支持 Curves: for _, curve := range hs.clientHello.supportedCurves { for _, supported := range preferredCurves { if supported == curve { supportedCurve = true break Curves } } } // [Min] 判断客户端支持的PointFormat是否包含pointFormatUncompressed // [Min] Go标准库目前只支持pointFormatUncompressed supportedPointFormat := false for _, pointFormat := range hs.clientHello.supportedPoints { if pointFormat == pointFormatUncompressed { supportedPointFormat = true break } } // [Min] 椭圆曲线算法可用 hs.ellipticOk = supportedCurve \u0026amp;\u0026amp; supportedPointFormat foundCompression := false // We only support null compression, so check that the client offered it. // [Min] Go 标准库只支持非压缩，所以客户端提供的压缩方法中必须含有非压缩的方法 // [Min] 注：Go 实现的客户端hellomsg只设置了非压缩的方法 for _, compression := range hs.clientHello.compressionMethods { if compression == compressionNone { foundCompression = true break } } // [Min] 如果压缩方法不一致，报警 if !foundCompression { c.sendAlert(alertHandshakeFailure) return false, errors.New(\u0026quot;tls: client does not support uncompressed connections\u0026quot;) }   4.3 serverHelloMsg 中设置协商版本，生成服务端随机数\n // [Min] 设置服务端版本号，随机数 hs.hello.vers = c.vers hs.hello.random = make([]byte, 32) _, err = io.ReadFull(c.config.rand(), hs.hello.random) if err != nil { c.sendAlert(alertInternalError) return false, err }   4.4 检查安全重协商，NPN，ALPN 等相关信息，并作出回应\n // [Min] 初次handshake 客户端 hello msg 中 secureRenegotiation必须为空 if len(hs.clientHello.secureRenegotiation) != 0 { c.sendAlert(alertHandshakeFailure) return false, errors.New(\u0026quot;tls: initial handshake had non-empty renegotiation extension\u0026quot;) } // [Min] 服务端的安全重协商支持标志与客户端保持一致 hs.hello.secureRenegotiationSupported = hs.clientHello.secureRenegotiationSupported hs.hello.compressionMethod = compressionNone // [Min] 将 config 中的 serverName 设置为客户端 helloMsg 中 serverName if len(hs.clientHello.serverName) \u0026gt; 0 { c.serverName = hs.clientHello.serverName } // [Min] 优先ALPN模式，服务器从客户端提供的protos中选择自己支持的返回， // [Min] fallback表示是否因为没有匹配成功而选择了客户端提供的第一个proto if len(hs.clientHello.alpnProtocols) \u0026gt; 0 { if selectedProto, fallback := mutualProtocol(hs.clientHello.alpnProtocols, c.config.NextProtos); !fallback { hs.hello.alpnProtocol = selectedProto c.clientProtocol = selectedProto } } else { // [Min] NPN 模式，服务端返回自己支持的protos，让客户端自己去选择 // Although sending an empty NPN extension is reasonable, Firefox has // had a bug around this. Best to send nothing at all if // c.config.NextProtos is empty. See // https://golang.org/issue/5445. if hs.clientHello.nextProtoNeg \u0026amp;\u0026amp; len(c.config.NextProtos) \u0026gt; 0 { hs.hello.nextProtoNeg = true hs.hello.nextProtos = c.config.NextProtos } }   4.5 从服务端 config 中获取符合客户端要求的证书，并按需返回scts，同时判断证书的签名算法以及解密算法\n // [Min] 获取最适合 clientHelloMsg 的证书 hs.cert, err = c.config.getCertificate(hs.clientHelloInfo()) if err != nil { c.sendAlert(alertInternalError) return false, err } // [Min] 如果客户端提出需要 scts，则返回 hs.cert.SignedCertificateTimestamps if hs.clientHello.scts { hs.hello.scts = hs.cert.SignedCertificateTimestamps } // [Min] 根据选择的证书，判断公钥支持的签名算法 if priv, ok := hs.cert.PrivateKey.(crypto.Signer); ok { switch priv.Public().(type) { case *ecdsa.PublicKey: hs.ecdsaOk = true case *rsa.PublicKey: hs.rsaSignOk = true default: c.sendAlert(alertInternalError) return false, fmt.Errorf(\u0026quot;tls: unsupported signing key type (%T)\u0026quot;, priv.Public()) } } // [Min] 根据选择的证书，判断公钥支持的解密算法 if priv, ok := hs.cert.PrivateKey.(crypto.Decrypter); ok { switch priv.Public().(type) { case *rsa.PublicKey: hs.rsaDecryptOk = true default: c.sendAlert(alertInternalError) return false, fmt.Errorf(\u0026quot;tls: unsupported decryption key type (%T)\u0026quot;, priv.Public()) } }   4.6 判断 clientHelloMsg 中的 sessionTicket 是否可以重用，若重用，结束 readClientHello\na) 调用 decryptTicket 对 sessionTicket 进行解密获得 hs.sessionState，sessionTicket 格式为：keyName + iv + 加密的序列化流 + HMAC(SHA256)\na.1) 解密的时候首先根据 keyName 从 config 的 sessionTicketKeys 中找到用于生成此 ticket 的 key\na.2) 然后扣去 HMAC，用 key.hmacKey 计算 HMAC，验证完整性\na.3) 再利用iv,key.aesKey采取 CTR 模式对加密部分解密得到明文的序列化流\na.4) 再反序列化明文即得到 sessionState\nb) 检查 sessionState 中的版本，密码套件，证书是否符合双方要求\n // checkForResumption reports whether we should perform resumption on this connection. // [Min] 根据客户端提供的 sessionTicket，检查是否重用 session func (hs *serverHandshakeState) checkForResumption() bool { c := hs.c // [Min] 首先 SessionTicketsDisabled 不能为禁用 if c.config.SessionTicketsDisabled { return false } var ok bool // [Min] 拷贝客户端 helloMsg 中的 sessionTicket var sessionTicket = append([]uint8{}, hs.clientHello.sessionTicket...) // [Min] 对 ticket 解密，还原为 sessionState，如果无法还原，不重用 if hs.sessionState, ok = c.decryptTicket(sessionTicket); !ok { return false } // Never resume a session for a different TLS version. // [Min] 如果 TLS 版本不同，不重用 if c.vers != hs.sessionState.vers { return false } cipherSuiteOk := false // Check that the client is still offering the ciphersuite in the session. // [Min] 检查客户端对该重用 session 的加密套件仍然支持 for _, id := range hs.clientHello.cipherSuites { if id == hs.sessionState.cipherSuite { cipherSuiteOk = true break } } if !cipherSuiteOk { return false } // Check that we also support the ciphersuite from the session. // [Min] 检查服务端仍然支持该套件，并设置套件 if !hs.setCipherSuite(hs.sessionState.cipherSuite, c.config.cipherSuites(), hs.sessionState.vers) { return false } sessionHasClientCerts := len(hs.sessionState.certificates) != 0 needClientCerts := c.config.ClientAuth == RequireAnyClientCert || c.config.ClientAuth == RequireAndVerifyClientCert // [Min] 如果服务端需要客户端提供证书（验证），但重用 session 中没有任何证书，则不能重用 if needClientCerts \u0026amp;\u0026amp; !sessionHasClientCerts { return false } // [Min] 如果 session 有证书，但服务端不要求客户端提供证书，也不能重用 if sessionHasClientCerts \u0026amp;\u0026amp; c.config.ClientAuth == NoClientCert { return false } return true }   4.7 如果非重用 session，则继续协商密码套件\n根据 config 配置，如果是服务器密码套件优先，则以服务器支持的密码套件为基准，去匹配客户端支持的套件，匹配成功，就设置密码套件，都不成功，则报警。反之亦然\n // [Min] 以下为非重用 session 的情况，我们仍需继续协商套件 var preferenceList, supportedList []uint16 // [Min] 如果优先服务器加密套件，则将服务器加密套件作为优先选择的列表，客户端发送的列表作为支持的列表 // [Min] 否则，相反 if c.config.PreferServerCipherSuites { preferenceList = c.config.cipherSuites() supportedList = hs.clientHello.cipherSuites } else { preferenceList = hs.clientHello.cipherSuites supportedList = c.config.cipherSuites() } // [Min] 从优先选择列表中依次判断套件是否在支持列表中，且双方实现该套件的参数都可用， // [Min] 是就协商成功，设置hs.suite，否就继续协商，直到preferenceList完结 for _, id := range preferenceList { if hs.setCipherSuite(id, supportedList, c.vers) { break } } // [Min] 如果没有协商出双方都可以的套件，报警 if hs.suite == nil { c.sendAlert(alertHandshakeFailure) return false, errors.New(\u0026quot;tls: no cipher suite supported by both client and server\u0026quot;) } // See https://tools.ietf.org/html/rfc7507. for _, id := range hs.clientHello.cipherSuites { if id == TLS_FALLBACK_SCSV { // The client is doing a fallback connection. if hs.clientHello.vers \u0026lt; c.config.maxVersion() { c.sendAlert(alertInappropriateFallback) return false, errors.New(\u0026quot;tls: client using inappropriate protocol fallback\u0026quot;) } break } } return false, nil  接下来分为两种情况，一种是非重用 session 的完整握手，一种是重用 session，此时均已经开启了缓存写入的模式\n 5.1 完整握手\n5.1.1 调用 hs.doFullHandshake()\n5.1.1.1 设置协商好的密码套件等信息\n5.1.1.2 与客户端类似，新建服务端 finishedHash\n5.1.1.3 完成 clientHelloMsg 和 serverHelloMsg\n5.1.1.4 将 serverHelloMsg 写入 c.sendBuf 中等待正式发送\n5.1.1.5 构造服务端证书消息 certificateMsg，完成该消息并写入 c.sendBuf 中等待正式发送\n5.1.1.6 按需构造服务端证书状态消息 certificateStatusMsg，完成该消息并写入 c.sendBuf 中等待正式发送\n5.1.1.7 根据密码套件获取 keyAgreement，调用 generateServerKeyExchange 生成服务端秘钥交换消息 serverKeyExchangeMsg（非 RSA 秘钥交换），完成该消息并写入 c.sendBuf 中等待正式发送\n5.1.1.8 根据自身需求，向客户端发送验证客户端证书的请求，构造请求消息 certificateRequestMsg，完成该消息并写入 c.sendBuf 中等待正式发送\n5.1.1.9 至此，serverHello 完成，完成 serverHelloDoneMsg 消息，并写入 c.sendBuf 中等待正式发送\n5.1.1.10 正式推送 c.sendBuf 中累积的消息给客户端，依次包括 serverHelloMsg，certificateMsg，certificateStatusMsg（可选），serverKeyExchangeMsg（非 RSA 秘钥交换），certificateRequestMsg（可选），serverHelloDoneMsg\n // [Min] 完整的 handshake func (hs *serverHandshakeState) doFullHandshake() error { c := hs.c // [Min] 如果客户端要求 ocspStapling，且证书状态不为空，设置 hs.hello.ocspStapling 为真 if hs.clientHello.ocspStapling \u0026amp;\u0026amp; len(hs.cert.OCSPStaple) \u0026gt; 0 { hs.hello.ocspStapling = true } // [Min] 设置是否支持 ticket，套件 id hs.hello.ticketSupported = hs.clientHello.ticketSupported \u0026amp;\u0026amp; !c.config.SessionTicketsDisabled hs.hello.cipherSuite = hs.suite.id // [Min] 根据版本和套件新建 finishedHash hs.finishedHash = newFinishedHash(hs.c.vers, hs.suite) // [Min] 如果不需要客户端证书，直接将 finishedHash.buffer 置为 nil if c.config.ClientAuth == NoClientCert { // No need to keep a full record of the handshake if client // certificates won't be used. hs.finishedHash.discardHandshakeBuffer() } // [Min] 计算 clientHelloMsg 和 serverHelloMsg 的 hash hs.finishedHash.Write(hs.clientHello.marshal()) hs.finishedHash.Write(hs.hello.marshal()) // [Min] 将 serverHelloMsg 写入 tls.Conn 的缓存 sendBuf 中 if _, err := c.writeRecord(recordTypeHandshake, hs.hello.marshal()); err != nil { return err } // [Min] 构造certificateMsg，将服务端证书写入缓存 c.sendBuf 中，并完成该消息 certMsg := new(certificateMsg) certMsg.certificates = hs.cert.Certificate hs.finishedHash.Write(certMsg.marshal()) if _, err := c.writeRecord(recordTypeHandshake, certMsg.marshal()); err != nil { return err } // [Min] 如果需要 ocspStapling，构造 certificateStatusMsg，写入缓存 c.sendBuf 中，并完成该消息 if hs.hello.ocspStapling { certStatus := new(certificateStatusMsg) certStatus.statusType = statusTypeOCSP certStatus.response = hs.cert.OCSPStaple hs.finishedHash.Write(certStatus.marshal()) if _, err := c.writeRecord(recordTypeHandshake, certStatus.marshal()); err != nil { return err } } // [Min] 获得该套件的 keyAgreement 实例 keyAgreement := hs.suite.ka(c.vers) // [Min] 生成交换的公钥和签名，组成 serverKeyExchangeMsg // [Min] 也可能不需要交换公钥，如 RSA 秘钥交换 skx, err := keyAgreement.generateServerKeyExchange(c.config, hs.cert, hs.clientHello, hs.hello) if err != nil { c.sendAlert(alertHandshakeFailure) return err } // [Min] 如果 skx 不为 nil，说明不是 RSA，RSA 秘钥交换不会发送 serverKeyExchangeMsg // [Min] 再把 serverKeyExchangeMsg 写入缓存 c.sendBuf 中，并完成该消息 if skx != nil { hs.finishedHash.Write(skx.marshal()) if _, err := c.writeRecord(recordTypeHandshake, skx.marshal()); err != nil { return err } } // [Min] 如果服务端需要验证客户端的证书，则要发送验证请求 if c.config.ClientAuth \u0026gt;= RequestClientCert { // Request a client certificate certReq := new(certificateRequestMsg) // [Min] 要求证书为 RSASign 或 ECDSASign certReq.certificateTypes = []byte{ byte(certTypeRSASign), byte(certTypeECDSASign), } // [Min] \u0026gt;= TLS 1.2，提供服务端支持的签名算法 if c.vers \u0026gt;= VersionTLS12 { certReq.hasSignatureAndHash = true certReq.supportedSignatureAlgorithms = supportedSignatureAlgorithms } // An empty list of certificateAuthorities signals to // the client that it may send any certificate in response // to our request. When we know the CAs we trust, then // we can send them down, so that the client can choose // an appropriate certificate to give to us. // [Min] 限定证书的授权组织 if c.config.ClientCAs != nil { certReq.certificateAuthorities = c.config.ClientCAs.Subjects() } // [Min] 累计计算 hash 并写入 conn 的缓存 hs.finishedHash.Write(certReq.marshal()) if _, err := c.writeRecord(recordTypeHandshake, certReq.marshal()); err != nil { return err } } // [Min] 至此，hello 阶段完成，发送 helloDone 消息 helloDone := new(serverHelloDoneMsg) hs.finishedHash.Write(helloDone.marshal()) if _, err := c.writeRecord(recordTypeHandshake, helloDone.marshal()); err != nil { return err } // [Min] 从缓存中将累积的消息推送到客户端，依次包括： // [Min] serverHelloMsg，certificateMsg，certificateStatusMsg（可选）， // [Min] serverKeyExchangeMsg（非 RSA 秘钥交换），certificateRequestMsg（可选），serverHelloDoneMsg if _, err := c.flush(); err != nil { return err }   5.2 重用 Session\n5.2.1 调用 hs.doResumeHandshake()\n5.2.1.1 设置协商好的密码套件，重用 sessionId 等信息，客户端需根据 sessionId 来判断是否可以重用\n5.2.1.2 与客户端类似，新建服务端 finishedHash，由于是重用，将 finishedHash 中的 buffer 置为 nil\n5.2.1.3 完成 clientHelloMsg 和 serverHelloMsg\n5.2.1.4 将 serverHelloMsg 写入 c.sendBuf 中等待正式发送\n5.2.1.5 如果重用 sessionState 中有客户端的证书信息，则对证书进行验证并更新相关字段，同时提取出客户端证书的公钥 5.2.1.6 将重用 sessionState 中的主密钥恢复到 hs.masterSecret\n5.2.2 调用 hs.establishKeys()\n5.2.2.1 通过主密钥生成一系列计算 hmac，加解密需要使用到的 key，和初始化向量，客户端服务端各不相同\n5.2.2.2 根据密码套件，将这些 key，iv 组合成客户端，服务端各自用于加密和计算 hmac 的 cipher，hmac\n5.2.2.3 更新到对应的 halfConn 中的预备字段中，等待正式切换\n5.2.3 如果 ticket 需要重制（加密 ticket 的 key 不是最新的，sessionState实际内容不变），调用 hs.sendSessionTicket() 重制 ticket 并发送给客户端让其刷新\n5.2.3.1 sessionState 内容保持不变，调用 encryptTicket，生成 ticket（encrytTicket 始终会使用最新的 sessionTicketKey 来加密）\n5.2.3.2 构造 newSessionTicketMsg，完成该消息并写入 c.sendBuf 中等待正式发送\n5.2.4 调用hs.sendFinished 发送finishedMsg\n5.2.4.1 发送切换信号，通知客户端此信号之后的消息都为加密消息，服务端将 c.out 切换为加密模式。注意，此信号不写入 finishedHash。\n5.2.4.2 构造 finishedMsg，finishedMsg.verifyData 是通过密码套件决定的伪随机数算法计算的伪随机数（func(result, secret, label, seed []byte)），其中secret为主密钥，label是固定的字符串，seed是到目前为止，双方所有的发送以及接收到的消息按先后顺序累积计算的 hash 值。然后完成该消息并写入 c.sendBuf 中等待正式发送，最后将 verifyData 写入c.serverFinished。\n5.2.4.3 正式推送 c.sendBuf 中累积的消息给客户端，依次包括 serverHelloMsg，newSessionTicketMsg（可选），切换信号，finishedMsg。\n if isResume { // The client has included a session ticket and so we do an abbreviated handshake. // [Min] 告知重用 session，验证客户端证书，恢复主密钥 hs.masterSecret = hs.sessionState.masterSecret if err := hs.doResumeHandshake(); err != nil { return err } // [Min] 根据主密钥建立加密通讯需要的 cipher，hash，更新到客户端和服务端各自对应的 halfConn 的预备字段中，等待切换 if err := hs.establishKeys(); err != nil { return err } // ticketSupported is set in a resumption handshake if the // ticket from the client was encrypted with an old session // ticket key and thus a refreshed ticket should be sent. // [Min] 如果重用的 sessionState 是使用老的 ticketKey 解密而得， // [Min] 需要用最新的 key 重新加密生成新的 ticket，并返回给客户端让其同步刷新 if hs.hello.ticketSupported { if err := hs.sendSessionTicket(); err != nil { return err } } // [Min] 发送finishedMsg，并将 fishishedMsg 中的 verifyData 写入 c.serverFinished[:] // [Min] 切换 c.out 为加密模式 if err := hs.sendFinished(c.serverFinished[:]); err != nil { return err } // [Min] 推送 c.sendBuf 中累积的消息到客户端，依次包括：serverHelloMsg，newSessionTicketMsg（可选），finishedMsg。 if _, err := c.flush(); err != nil { return err }  // [Min] 重用 session 的 handshake，返回 helloMsg，告知 session 重用，验证客户端证书并恢复主密钥 func (hs *serverHandshakeState) doResumeHandshake() error { c := hs.c hs.hello.cipherSuite = hs.suite.id // We echo the client's session ID in the ServerHello to let it know // that we're doing a resumption. // [Min] 重用 session 的情况下，sessionId 和客户端发过来的保持一致， // [Min] 这样客户端就可以通过 sessionId 没有变化来判断 session 的重用 hs.hello.sessionId = hs.clientHello.sessionId // [Min] 表明客户端提供的 ticket 是否可以恢复成 sessionState 使用 // [Min] 同时也记录 sessionTicket 是否需要以最新的 key 重制生成 ticket 来刷新（实际内容不变） hs.hello.ticketSupported = hs.sessionState.usedOldKey hs.finishedHash = newFinishedHash(c.vers, hs.suite) hs.finishedHash.discardHandshakeBuffer() hs.finishedHash.Write(hs.clientHello.marshal()) hs.finishedHash.Write(hs.hello.marshal()) // [Min] 将服务端 helloMsg 写入缓存 if _, err := c.writeRecord(recordTypeHandshake, hs.hello.marshal()); err != nil { return err } // [Min] 验证客户端的证书链 if len(hs.sessionState.certificates) \u0026gt; 0 { if _, err := hs.processCertsFromClient(hs.sessionState.certificates); err != nil { return err } } // [Min] 客户端证书没问题，再从 sessionState 中恢复主密钥 hs.masterSecret = hs.sessionState.masterSecret return nil }  // [Min] 根据主密钥建立加密通讯需要的 cipher，hash，更新到客户端和服务端各自对应的 halfConn 的预备字段中，等待切换 func (hs *serverHandshakeState) establishKeys() error { c := hs.c // [Min] 通过主密钥生成一系列计算 mac，加解密需要使用到的 key，和初始化向量 clientMAC, serverMAC, clientKey, serverKey, clientIV, serverIV := keysFromMasterSecret(c.vers, hs.suite, hs.masterSecret, hs.clientHello.random, hs.hello.random, hs.suite.macLen, hs.suite.keyLen, hs.suite.ivLen) var clientCipher, serverCipher interface{} var clientHash, serverHash macFunction if hs.suite.aead == nil { clientCipher = hs.suite.cipher(clientKey, clientIV, true /* for reading */) clientHash = hs.suite.mac(c.vers, clientMAC) serverCipher = hs.suite.cipher(serverKey, serverIV, false /* not for reading */) serverHash = hs.suite.mac(c.vers, serverMAC) } else { clientCipher = hs.suite.aead(clientKey, clientIV) serverCipher = hs.suite.aead(serverKey, serverIV) } // [Min] 将 client 的 cipher，hash 算法更新到 in 的预备字段中，等待正式切换 // [Min] 将 server 的 cipher，hash 算法更新到 out 的预备字段中，等待正式切换 c.in.prepareCipherSpec(c.vers, clientCipher, clientHash) c.out.prepareCipherSpec(c.vers, serverCipher, serverHash) return nil }  // [Min] 根据当前协商好的信息，制作 sessionTicket，并返回给客户端 func (hs *serverHandshakeState) sendSessionTicket() error { if !hs.hello.ticketSupported { return nil } c := hs.c m := new(newSessionTicketMsg) var err error // [Min] sessionState 的内容 state := sessionState{ vers: c.vers, cipherSuite: hs.suite.id, masterSecret: hs.masterSecret, certificates: hs.certsFromClient, } m.ticket, err = c.encryptTicket(\u0026amp;state) if err != nil { return err } hs.finishedHash.Write(m.marshal()) if _, err := c.writeRecord(recordTypeHandshake, m.marshal()); err != nil { return err } return nil }  // [Min] 发送 finshedMsg func (hs *serverHandshakeState) sendFinished(out []byte) error { c := hs.c // [Min] 发送切换信号，此时会将 c.out 中的 cipher 和 mac 切换，转为加密模式 if _, err := c.writeRecord(recordTypeChangeCipherSpec, []byte{1}); err != nil { return err } // [Min] 构造 finishedMsg，并序列化，然后完成该消息并写入 c.sendBuf 中等待正式发送 finished := new(finishedMsg) finished.verifyData = hs.finishedHash.serverSum(hs.masterSecret) hs.finishedHash.Write(finished.marshal()) if _, err := c.writeRecord(recordTypeHandshake, finished.marshal()); err != nil { return err } // [Min] 同步 config 中 cipherSuite c.cipherSuite = hs.suite.id // [Min] 将 verifyData 拷贝至 out copy(out, finished.verifyData) return nil }   4. 阶段小结 　至此，我们完成了：\n1. 客户端从正式发送 clinetHelloMsg 到正式接收 serverHelloMsg（第一次正式发送，第一次正式接收）\n2. 服务端从正式收到 clinetHelloMsg 到正式发送 serverHelloMsg（第一次正式接收，第一次正式发送）\n正常情况下非重用 session 消息发送序列：\n   批次-序号 客户端 服务端     1-1 clientHelloMsg serverHelloMsg   1-2  certificateMsg   1-3  certificateStatusMsg（可选）   1-4  serverKeyExchangeMsg（非 RSA 秘钥交换）   1-5  certificateRequestMsg（可选）   1-6  serverHelloDoneMsg    正常情况下重用 session 消息发送序列：\n   批次-序号 客户端 服务端     1-1 clientHelloMsg serverHelloMsg   1-2  newSessionTicketMsg（可选）   1-3  切换信号   1-4  finishedMsg    未完待续\n","date":1533252255,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1543733643,"objectID":"60e1d1d22493d9e36d69265f47ebcf5c","permalink":"https://mooncaker816.github.io/2018/08/03/tls%E4%B8%80/","publishdate":"2018-08-03T07:24:15+08:00","relpermalink":"/2018/08/03/tls%E4%B8%80/","section":"post","summary":"1. TLS 基本概念 传输层安全性协议（英语：Transport Layer Security，缩写作 TLS），及其前身安全套接层（Secure Sockets Layer，缩写","tags":["TLS"],"title":"TLS（一）","type":"post"},{"authors":null,"categories":[],"content":"1 概念 　分组密码的模式主要是指对每一个分组明文（密文）进行迭代加（解）密的过程。主要的分组模式有以下几种：\n ECB 电子密码本（Electronic CodeBook mode） CBC 密码块链接（Cipher Block Chaining mode） CFB 密文反馈（Cipher FeedBack mode） OFB 输出反馈（Output FeedBack mode） CTR 计数器模式（CounTeR mode）  2 ECB 　ECB模式中，明文分组加密后的结果直接记为密文分组，依次按顺序连接这些密文分组就是最终的密文。\nECB 加密过程: ECB 解密过程: 　ECB是所有模式中最简单的一种模式，明文分组和密文分组是一一对应的关系，因此如果明文中存在多个相同的分组，那么他们就会被加密成相同的密文分组。在密文中通过观察这一重复性特点，就能知道明文中存在重复的组合，从而增大了被破译的风险。\n再有，由于各个明文分组是独立加密的，所以如果我们将加密后的密文分组的顺序打乱，组成一个新的密文，解密者同样可以根据秘钥来解密每一个分组，但是呈现在解密者面前的信息却已经被改变。也就是说，在已知分组大小的前提下，攻击者可以不用破译密码，而通过操纵密文分组（颠倒顺序，覆盖分组等），来达到攻击的效果。\n所以，ECB并不是一个安全的分组模式。\n3 CBC 3.1 CBC的流程 　在CBC加密流程中，首先将当前明文分组与上一密文分组（初始向量）异或，再对该值进行加密得到当前组的密文。 　在CBC解密流程中，首先对当前密文执行解密函数，然后与上一密文分组（初始向量）异或，得到当前明文分组。 　与ECB模式相比，在进行加密之前，CBC多了一步与上一密文分组（初始向量）异或的操作。\n3.2 CBC的特点  由于加密之前会与上一密文分组（初始向量）进行异或，即便两个明文分组相同，得到的密文分组也不同。 分组的加密必须按顺序依次执行，无法并行 如果某一密文分组损坏（密文分组长度不变），在解密时，只会影响到当前和下一密文分组的解密，其他分组不受影响 如果某一密文分组长度被破坏，则该分组以及之后的所有分组都无法解密 需要填充  3.3 CBC Go的实现 // Copyright 2009 The Go Authors. All rights reserved. // Use of this source code is governed by a BSD-style // license that can be found in the LICENSE file. // Cipher block chaining (CBC) mode. // CBC provides confidentiality by xoring (chaining) each plaintext block // with the previous ciphertext block before applying the block cipher. // See NIST SP 800-38A, pp 10-11 package cipher // [Min] 分组密码之CBC模式，模式用来明确各个分组的迭代方式 // [Min] 更像是在Block外部套一层迭代方式，以及用于驱动这个迭代方式的初始向量 type cbc struct { b Block // [Min] 承载了具体的对单一分组的加解密函数，以及秘钥 blockSize int // [Min] 分组大小 iv []byte // [Min] 初始向量 tmp []byte // [Min] 临时存储空间，长度为blockSize } // [Min] 根据初始向量和确定的算法实例，新建cbc实例 func newCBC(b Block, iv []byte) *cbc { return \u0026amp;cbc{ b: b, blockSize: b.BlockSize(), iv: dup(iv), // [Min] 初始化向量的副本 tmp: make([]byte, b.BlockSize()), // [Min] 与分组大小相同 } } // [Min] 分组密码加密 type cbcEncrypter cbc // cbcEncAble is an interface implemented by ciphers that have a specific // optimized implementation of CBC encryption, like crypto/aes. // NewCBCEncrypter will check for this interface and return the specific // BlockMode if found. type cbcEncAble interface { NewCBCEncrypter(iv []byte) BlockMode } // NewCBCEncrypter returns a BlockMode which encrypts in cipher block chaining // mode, using the given Block. The length of iv must be the same as the // Block's block size. // [Min] 构造一个CBC分组加密模式， // [Min] 如果 block 本身实现了NewCBCEncrypter接口，直接调用即可，否则调用newCBC func NewCBCEncrypter(b Block, iv []byte) BlockMode { if len(iv) != b.BlockSize() { panic(\u0026quot;cipher.NewCBCEncrypter: IV length must equal block size\u0026quot;) } if cbc, ok := b.(cbcEncAble); ok { return cbc.NewCBCEncrypter(iv) } return (*cbcEncrypter)(newCBC(b, iv)) } func (x *cbcEncrypter) BlockSize() int { return x.blockSize } // [Min] 迭代分组，此处明文数据已经经过填充，大小恰好为分组大小的整数倍 func (x *cbcEncrypter) CryptBlocks(dst, src []byte) { // [Min] 明文数据的大小必须是分组大小的整数倍 if len(src)%x.blockSize != 0 { panic(\u0026quot;crypto/cipher: input not full blocks\u0026quot;) } // [Min] 输出容量必须比明文长 if len(dst) \u0026lt; len(src) { panic(\u0026quot;crypto/cipher: output smaller than input\u0026quot;) } iv := x.iv // [Min] 循环处理每一组明文 for len(src) \u0026gt; 0 { // Write the xor to dst, then encrypt in place. // [Min] 首先异或前一组密文（初始向量）和分组明文 xorBytes(dst[:x.blockSize], src[:x.blockSize], iv) // [Min] 调用Block的Encrypt方法对该组明文进行加密 x.b.Encrypt(dst[:x.blockSize], dst[:x.blockSize]) // Move to the next block with this block as the next iv. // [Min] 将该组密文作为下一组明文的异或对象 iv = dst[:x.blockSize] // [Min] 调整下一组明文，密文位置 src = src[x.blockSize:] dst = dst[x.blockSize:] } // Save the iv for the next CryptBlocks call. // [Min] 保存当前最后一组密文作为下一次调用的初始向量 copy(x.iv, iv) } // [Min] 设置初始向量 func (x *cbcEncrypter) SetIV(iv []byte) { if len(iv) != len(x.iv) { panic(\u0026quot;cipher: incorrect length IV\u0026quot;) } copy(x.iv, iv) } // [Min] 分组密码解密 type cbcDecrypter cbc // cbcDecAble is an interface implemented by ciphers that have a specific // optimized implementation of CBC decryption, like crypto/aes. // NewCBCDecrypter will check for this interface and return the specific // BlockMode if found. type cbcDecAble interface { NewCBCDecrypter(iv []byte) BlockMode } // NewCBCDecrypter returns a BlockMode which decrypts in cipher block chaining // mode, using the given Block. The length of iv must be the same as the // Block's block size and must match the iv used to encrypt the data. func NewCBCDecrypter(b Block, iv []byte) BlockMode { if len(iv) != b.BlockSize() { panic(\u0026quot;cipher.NewCBCDecrypter: IV length must equal block size\u0026quot;) } if cbc, ok := b.(cbcDecAble); ok { return cbc.NewCBCDecrypter(iv) } return (*cbcDecrypter)(newCBC(b, iv)) } func (x *cbcDecrypter) BlockSize() int { return x.blockSize } func (x *cbcDecrypter) CryptBlocks(dst, src []byte) { if len(src)%x.blockSize != 0 { panic(\u0026quot;crypto/cipher: input not full blocks\u0026quot;) } if len(dst) \u0026lt; len(src) { panic(\u0026quot;crypto/cipher: output smaller than input\u0026quot;) } if len(src) == 0 { return } // [Min] 从最后一个分组开始处理，先解密，再异或前一组密文，得到该组的明文 // For each block, we need to xor the decrypted data with the previous block's ciphertext (the iv). // To avoid making a copy each time, we loop over the blocks BACKWARDS. end := len(src) start := end - x.blockSize prev := start - x.blockSize // Copy the last block of ciphertext in preparation as the new iv. // [Min] 保持最后一组密文作为最后返回时的初始向量 copy(x.tmp, src[start:end]) // Loop over all but the first block. // [Min] 从后往前循环处理每一个分组 for start \u0026gt; 0 { // [Min] 先解密当前分组的密文 x.b.Decrypt(dst[start:end], src[start:end]) // [Min] 再与前一分组的密文异或得到明文 xorBytes(dst[start:end], dst[start:end], src[prev:start]) // [Min] 调整前一个分组的位置 end = start start = prev prev -= x.blockSize } // The first block is special because it uses the saved iv. // [Min] 解密第一分组 x.b.Decrypt(dst[start:end], src[start:end]) // [Min] 对于第一个分组，没有了前一个分组的密文，其异或的向量为初始向量 xorBytes(dst[start:end], dst[start:end], x.iv) // Set the new iv to the first block we copied earlier. // [Min] 设置初始向量为最后一个分组的密文 x.iv, x.tmp = x.tmp, x.iv } // [Min] 设置初始向量 func (x *cbcDecrypter) SetIV(iv []byte) { if len(iv) != len(x.iv) { panic(\u0026quot;cipher: incorrect length IV\u0026quot;) } copy(x.iv, iv) }  4 CFB 4.1 CFB的流程 　在CFB模式中，前一个密文分组（初始向量）会被送到密码算法的输入端，这就是密文反馈这个名字的由来。\nCFB加密流程： CFB解密流程： 　需要注意的是，对于CFB来说，最终的密文分组是由明文分组直接和密码算法输出X异或得到的，由异或的特性可知，只需要对该密文分组再次异或相同的X即可得到对应的明文分组。换句话说，对于解密来说，我们使用的函数和加密时使用的函数是同一个函数，没有加解密之分。这一点和CBC不同。\n4.2 CFB的特点  在ECB，CBC中，明文分组都是通过密码算法进行加密的，而CFB中，明文分组并没有直接用密码算法进行加密，密码算法只是用来对上一密文分组（初始向量）进行加密，获得一个mask，用来对该组的明密文进行加解密。 明文和密文之间没有加密步骤，只有异或步骤 CFB中由密码算法输出的比特流称为密钥流，它直接影响到该分组的加解密 在CFB解密过程中，所有密文分组是已知的，所以每一个分组对应的密钥流就可以通过密码算法预先确定。换句话说，解密过程可以并行处理，而加密只能按分组顺序执行。 CFB不能抵御重放攻击。如果从某一密文分组开始，被另一组相同数量的密文分组所替代，那么只有被替换的头一个分组无法解密，后续分组不受影响。这一特性，使得重放攻击成为可能。 不需要填充  4.3 CFB Go的实现 // Copyright 2010 The Go Authors. All rights reserved. // Use of this source code is governed by a BSD-style // license that can be found in the LICENSE file. // CFB (Cipher Feedback) Mode. package cipher /* [Min] 1. 对CFB来说，我们要做的核心工作是为每个分组生成密钥流，再使用这个密钥流来加解密该分组 2. 对于加，解密，生成密钥流的方法都是一样的，可以看成是对某一数据的加密， 而这个某一数据就是前一分组的密文（初始向量） 3. 加密时，先利用加密算法对前一分组的密文进行加密，得到秘钥流，再和该分组明文异或得到该组的密文 4. 解密时，先利用加密算法对前一分组的密文进行加密，得到秘钥流，再和该分组密文异或得到该组的明文 */ // [Min] 分组密码之CFB模式 type cfb struct { b Block // [Min] 用来对密文（初始向量）加密生成下一分组的秘钥流 next []byte // [Min] 存储当前分组的密文（初始向量） out []byte // [Min] 存储对当前分组密文加密后的密钥流 outUsed int decrypt bool } // [Min] 循环处理每一个分组，加解密都是从第一个分组开始 func (x *cfb) XORKeyStream(dst, src []byte) { for len(src) \u0026gt; 0 { // [Min] 处理第一个分组的时候，next中为初始向量， // [Min] 后续分组 next 中为前一分组的密文，用于生成密钥流到out中 // [Min] x.outUsed == len(x.out)，说明上轮循环成功加密或解密了一个分组的数据， // [Min] 需要为后续分组创建密钥流 if x.outUsed == len(x.out) { // [Min] 加解密调用的都是Encrypt，用来生成密钥流 x.b.Encrypt(x.out, x.next) x.outUsed = 0 } // [Min] 如果是解密，则从src中取出该分组密文存入next中 // [Min] 理论上，如果是解密的话，可以像OFB模式一样一次计算出多个密钥流， // [Min] 但是这里并没有实现，next的长度还是blockSize if x.decrypt { // We can precompute a larger segment of the // keystream on decryption. This will allow // larger batches for xor, and we should be // able to match CTR/OFB performance. copy(x.next[x.outUsed:], src) } // [Min] 将当前分组和密钥流异或，得到当前分组的密文 n := xorBytes(dst, src, x.out[x.outUsed:]) // [Min] 如果是加密，则从dst中将该分组密文存入next中 if !x.decrypt { copy(x.next[x.outUsed:], dst) } // [Min] 设置下一分组位置 dst = dst[n:] src = src[n:] x.outUsed += n } } // NewCFBEncrypter returns a Stream which encrypts with cipher feedback mode, // using the given Block. The iv must be the same length as the Block's block // size. func NewCFBEncrypter(block Block, iv []byte) Stream { return newCFB(block, iv, false) } // NewCFBDecrypter returns a Stream which decrypts with cipher feedback mode, // using the given Block. The iv must be the same length as the Block's block // size. func NewCFBDecrypter(block Block, iv []byte) Stream { return newCFB(block, iv, true) } // [Min] 新建CFB秘钥流模式 func newCFB(block Block, iv []byte, decrypt bool) Stream { blockSize := block.BlockSize() if len(iv) != blockSize { // stack trace will indicate whether it was de or encryption panic(\u0026quot;cipher.newCFB: IV length must equal block size\u0026quot;) } x := \u0026amp;cfb{ b: block, out: make([]byte, blockSize), next: make([]byte, blockSize), outUsed: blockSize, decrypt: decrypt, } copy(x.next, iv) return x }  5 OFB 5.1 OFB的流程 　OFB模式中，密码算法的输出（某一分组的密钥流）会反馈到密码算法的输入中。和CFB一样，密码算法不直接对明密文进行计算，只是用来生成分组的密钥流。\nOFB加密流程： OFB解密流程： 　OFB模式和CFB模式极其相似，分组的加解密都是依赖于该分组的密钥流。只是生成密钥流的输入来源不同，OFB是上一组的密钥流，CFB是上一密文分组。\n5.2 OFB的特点  与CFB类似，OFB模式的关键是分组对应的密钥流 OFB分组秘钥流与初始化向量和分组的序号有关，各个分组的密钥流可以提前生成，这也就意味着OFB模式的分组加解密可以并行，CFB只有解密可以并行 如果对于某一个密钥流加密后还是该密钥流，那么该分组后续所有分组的秘钥流都相同，这可能是OFB的一个弱点 不需要填充  5.3 OFB Go的实现 // Copyright 2011 The Go Authors. All rights reserved. // Use of this source code is governed by a BSD-style // license that can be found in the LICENSE file. // OFB (Output Feedback) Mode. package cipher /* [Min] 1. 对OFB来说，与CFB类似，我们要做的核心工作是为每个分组生成密钥流，再使用这个密钥流来加解密该分组 2. 对于加，解密，生成密钥流的方法都是一样的，可以看成是对某一数据的加密， 而这个某一数据就是前一分组的密钥流（初始向量）， 即对初始向量不断加密，如果加密函数为f的话，那么第i组的密钥流就是f...(f(f(iv))),i=1,2,3... 3. 与CFB略有不同的是，密钥流可以提前计算好，因为每一组对应的秘钥流只与组的索引有关， 所以我们可以提前按顺序计算好若干个组的密钥流，然后一次性对这若干个组进行加解密，提高效率 4. 如果在完成这若干个秘钥流的加解密后，还有数据，继续3中的操作，直到完成所有数据的加解密 */ // [Min] 分组密码之OFB模式 type ofb struct { b Block // [Min] 用来对本组密钥流（初始向量）加密生成下一分组的秘钥流 cipher []byte // [Min] 前一组密钥流(初始向量) out []byte // [Min] 一系列按顺序通过refill计算好的密钥流 outUsed int // [Min] out中已经使用过的密钥流的总长度 } // NewOFB returns a Stream that encrypts or decrypts using the block cipher b // in output feedback mode. The initialization vector iv's length must be equal // to b's block size. // [Min] 新建OFB密钥流模式 func NewOFB(b Block, iv []byte) Stream { blockSize := b.BlockSize() if len(iv) != blockSize { panic(\u0026quot;cipher.NewOFB: IV length must equal block size\u0026quot;) } // [Min] out的容量最低取512字节，如果blockSize超过512，按blockSize计算 bufSize := streamBufferSize if bufSize \u0026lt; blockSize { bufSize = blockSize } x := \u0026amp;ofb{ b: b, cipher: make([]byte, blockSize), out: make([]byte, 0, bufSize), outUsed: 0, } copy(x.cipher, iv) return x } // [Min] 根据outUsed，移去out中已使用过的密钥流，并计算后续密钥流 func (x *ofb) refill() { bs := x.b.BlockSize() remain := len(x.out) - x.outUsed // [Min] 如果剩余的大于已使用的，说明剩余的至少还有一个完整的密钥流未使用，直接返回 if remain \u0026gt; x.outUsed { return } // [Min] 从out中移去已使用的密钥流 copy(x.out, x.out[x.outUsed:]) // [Min] 保留remain的部分，并初始化后续数据 x.out = x.out[:cap(x.out)] // [Min] 累计计算密钥流，并添加到remain中，直到无法再次添加一个完整的密钥流为止 for remain \u0026lt; len(x.out)-bs { x.b.Encrypt(x.cipher, x.cipher) copy(x.out[remain:], x.cipher) remain += bs } // [Min] 保留当前所有未使用的秘钥流，置outUsed为0 x.out = x.out[:remain] x.outUsed = 0 } // [Min] 通过out中的密钥流，对明文，密文加解密 func (x *ofb) XORKeyStream(dst, src []byte) { for len(src) \u0026gt; 0 { // [Min] 如果out中剩余未使用的部分不够一个密钥流的长度， // [Min] 则需要从out中移去已使用过的密钥流，并且计算后续的密钥流 if x.outUsed \u0026gt;= len(x.out)-x.b.BlockSize() { x.refill() } // [Min] 一次性从src中加解密与out中未使用的秘钥流对应的相同数量的明文或密文 n := xorBytes(dst, src, x.out[x.outUsed:]) // [Min] 设置下一次加解密的起点位置 dst = dst[n:] src = src[n:] x.outUsed += n } }  6 CTR 6.1 CTR的流程 　与OFB相似，CTR模式是一种通过将逐次累加的计数器进行加密来生成密钥流的流密码。每一个分组对应一个逐次累加的计数，该计数用于生成该分组的秘钥流。\nCTR加密流程： CTR解密流程： 　计数器一般由一个随机数nonce确定，nonce + 一定位数的计数空间构成了该计数器。\n6.2 CTR的特点  和OFB类似，CTR也是利用秘钥流进行加解密 生成CTR秘钥流的来源是该分组的计数 CTR加解密可以并行 由于密码算法的输入是各组对应的不同的计数，分组的秘钥流就不同，因此CTR没有OFB中提到的弱点 不需要填充  6.3 CTR Go的实现 // Copyright 2009 The Go Authors. All rights reserved. // Use of this source code is governed by a BSD-style // license that can be found in the LICENSE file. // Counter (CTR) mode. // CTR converts a block cipher into a stream cipher by // repeatedly encrypting an incrementing counter and // xoring the resulting stream of data with the input. // See NIST SP 800-38A, pp 13-15 package cipher /* [Min] 1. 对CTR来说，与OFB极其类似，我们要做的核心工作也是为每个分组生成密钥流，再使用这个密钥流来加解密该分组 2. 对于加，解密，生成密钥流的方法都是一样的，可以看成是对某一数据的加密， 而这个某一数据就是当前分组的计数值， 如果加密函数为f的话，初始计数为A，那么第i组的密钥流就是f(A+i-1),i=1,2,3... 3. 同样，密钥流也可以提前计算好，因为每一组对应的秘钥流只与组的索引有关，（初始计数已确定） 所以我们可以提前按顺序计算好若干个组的密钥流，然后一次性对这若干个组进行加解密，提高效率 4. 如果在完成这若干个秘钥流的加解密后，还有数据，继续3中的操作，直到完成所有数据的加解密 */ // [Min] 分组密码之CTR模式 type ctr struct { b Block // [Min] 用来对本组计数加密生成下一分组的秘钥流 ctr []byte // [Min] 分组计数器，长度与blockSize相同，可以把byte切片看成一个连起来的大数 out []byte // [Min] 一系列密钥流 outUsed int // [Min] out中已使用的密钥流 } const streamBufferSize = 512 // ctrAble is an interface implemented by ciphers that have a specific optimized // implementation of CTR, like crypto/aes. NewCTR will check for this interface // and return the specific Stream if found. type ctrAble interface { NewCTR(iv []byte) Stream } // NewCTR returns a Stream which encrypts/decrypts using the given Block in // counter mode. The length of iv must be the same as the Block's block size. func NewCTR(block Block, iv []byte) Stream { if ctr, ok := block.(ctrAble); ok { return ctr.NewCTR(iv) } if len(iv) != block.BlockSize() { panic(\u0026quot;cipher.NewCTR: IV length must equal block size\u0026quot;) } bufSize := streamBufferSize if bufSize \u0026lt; block.BlockSize() { bufSize = block.BlockSize() } return \u0026amp;ctr{ b: block, ctr: dup(iv), out: make([]byte, 0, bufSize), outUsed: 0, } } // [Min] 尽可能多地在out中计算密钥流 func (x *ctr) refill() { remain := len(x.out) - x.outUsed copy(x.out, x.out[x.outUsed:]) x.out = x.out[:cap(x.out)] bs := x.b.BlockSize() for remain \u0026lt;= len(x.out)-bs { x.b.Encrypt(x.out[remain:], x.ctr) remain += bs // Increment counter // [Min] 从最后一个字节开始尝试加1，如果没有溢出，跳出循环 // [Min] 否则高一个字节进一位 for i := len(x.ctr) - 1; i \u0026gt;= 0; i-- { x.ctr[i]++ if x.ctr[i] != 0 { break } } } x.out = x.out[:remain] x.outUsed = 0 } // [Min] 与OFB类似 func (x *ctr) XORKeyStream(dst, src []byte) { for len(src) \u0026gt; 0 { if x.outUsed \u0026gt;= len(x.out)-x.b.BlockSize() { x.refill() } n := xorBytes(dst, src, x.out[x.outUsed:]) dst = dst[n:] src = src[n:] x.outUsed += n } } ","date":1532393399,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1543733643,"objectID":"8f316ffd8007180679b50da5ea24d474","permalink":"https://mooncaker816.github.io/2018/07/24/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E6%A8%A1%E5%BC%8F/","publishdate":"2018-07-24T08:49:59+08:00","relpermalink":"/2018/07/24/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E6%A8%A1%E5%BC%8F/","section":"post","summary":"1 概念 分组密码的模式主要是指对每一个分组明文（密文）进行迭代加（解）密的过程。主要的分组模式有以下几种： ECB 电子密码本（Electronic CodeBook","tags":[],"title":"分组密码模式","type":"post"},{"authors":null,"categories":["Golang","密码学"],"content":"1 什么是SHA-3 　SHA-3是一种作为新标准发布的单向散列函数算法，用来替代在理论上已被找出攻击方法的SHA-1算法。全世界的企业和密码学家提交了很多SHA-3的候选方案，经过长达5年的选拔，最终于2012年正式确定将Kececak算法作为SHA-3标准。\nKeccak的以下几大特点，是其成为SHA-3标准的重要原因：\n 采用了与SHA-2完全不同的结构 结构清晰，易于分析 能够适用于各种设备，也适用于嵌入式应用 在硬件上的实现显示出了很高的性能 比其他最终候选算法安全性边际更大  　Keccak可以生成任意长度的散列值，但为了配合SHA-2的散列值长度，SHA-3标准中共规定了SHA3-224，SHA3-256，SHA3-384，SHA3-512这4种版本。在输入数据的长度上限方面，SHA-1为2^64 - 1，SHA-2为2^128 - 1，而SHA-3则没有长度限制。\n此外，SHA3还有两个可以输出任意长度散列值的函数：SHAKE128,SHAKE256，在 Go 的SHA3文档中，推荐使用SHAKE256。\n // Guidance\n//\n// If you aren\u0026rsquo;t sure what function you need, use SHAKE256 with at least 64\n// bytes of output. The SHAKE instances are faster than the SHA3 instances;\n// the latter have to allocate memory to conform to the hash.Hash interface.\n//\n// If you need a secret-key MAC (message authentication code), prepend the\n// secret key to the input, hash with SHAKE256 and read at least 32 bytes of\n// output.\n 2 Keccak 2.1 Keccak的结构 　Keccak采用了与SHA-1，SHA-2完全不同的海绵结构。顾名思义，海绵最大的特点就是其吸水性，用在此处想必也是有此寓意。在Keccak的海绵结构中，输入数据在进行分组以及相应的填充之后，要经过吸收阶段和挤出阶段，最终生成输出的散列值。\n吸收阶段中，源数据按一定大小分组，最后一组会进行填充补足。依次将每一分组的数据与Keccak中内部状态作XOR操作，从而将分组数据吸收入Keccak结构中，再将XOR之后的数据按一定算法进行搅拌，此时内部状态中的数据为该分组数据搅拌后的数据，再在此状态下用相同的方法吸入下一组数据并再次搅拌，循环往复，直至最后一组数据搅拌成功，完成吸收阶段。\n挤出阶段中，在完成对最后一组数据的搅拌后，直接按分组大小将内部状态中的数据输出到最终输出中，如果达不到输出的长度要求，则再次执行同样的搅拌，每次从内部状态中挤出最多分组大小的数据，循环往复，直至达到输出长度的要求。\n2.2 Keccak的内部状态 　Keccak的内部状态可以看成是一个5*5*w的三维立方体，每一个单位元素代表一个比特位。根据设计规格，Keccak的内部状态大小可以为25，50，100，200，400，800，1600共7种，分别对应的w为1，2，4，8，16，32，64。SHA3 采用了最大的规格，用以提升安全等级，所以SHA3的内部状态实际是一个5*5*64大小的比特流。将这个比特流映射到具体的数据结构上，可以表述为一个由25个无符号64位整数组成的数组。\n更具体的内部状态信息，可以参考以下官方文档中的3.1小节。 https://csrc.nist.gov/csrc/media/publications/fips/202/final/documents/fips_202_draft.pdf\n2.3 搅拌方法 　Keccak最重要的就是他的“搅拌函数”，用来在原数据的基础上对其进行一系列复杂的运算，最后生成摘要信息。搅拌的过程一共可以分为5个步骤，θ，ρ，π，χ，ι，共计24轮计算。每一个步骤都是对这个5*5*64的状态矩阵进行相应的计算，移位，旋转等操作。 具体步骤可以参考上文链接中的3.2小节，此处不再赘述。\n2.4 搅拌方法的实现 　在Keccak官网上，给出了许多有趣的实现方法，以下是参考链接： https://keccak.team/files/Keccak-implementation-3.2.pdf\n而 Go 的 x/crypto/sha3 包采用的是其中的 Efficient in-place implementations。\n// Copyright 2014 The Go Authors. All rights reserved. // Use of this source code is governed by a BSD-style // license that can be found in the LICENSE file. // +build !amd64 appengine gccgo package sha3 // rc stores the round constants for use in the ι step. var rc = [24]uint64{ 0x0000000000000001, 0x0000000000008082, 0x800000000000808A, 0x8000000080008000, 0x000000000000808B, 0x0000000080000001, 0x8000000080008081, 0x8000000000008009, 0x000000000000008A, 0x0000000000000088, 0x0000000080008009, 0x000000008000000A, 0x000000008000808B, 0x800000000000008B, 0x8000000000008089, 0x8000000000008003, 0x8000000000008002, 0x8000000000000080, 0x000000000000800A, 0x800000008000000A, 0x8000000080008081, 0x8000000000008080, 0x0000000080000001, 0x8000000080008008, } // keccakF1600 applies the Keccak permutation to a 1600b-wide // state represented as a slice of 25 uint64s. // [Min] 对已经吸收到 a 中的一个分组的数据进行处理 func keccakF1600(a *[25]uint64) { // Implementation translated from Keccak-inplace.c // in the keccak reference code. var t, bc0, bc1, bc2, bc3, bc4, d0, d1, d2, d3, d4 uint64 /* [Min] 共计24轮计算，每四轮一循环，所有涉及A,B,C,D索引的计算都是mod 5，对a的索引计算都是 mod 25 已知\tN = 1 0 1 2 N^i的值每4轮一循环（元素值 mod5 相同） A[x,y] = a[5y+x], 此处小a就是函数的输入 r[x,y] 值如下表，代表循环左移的位数 x=3 x=4 x=0 x=1 x=2 y=2 25\t39 3 10 43 y=1 55 20 36 44 6 y=0 28 27 0 1 62 y=4 56 14 18 2 61 y=3 21 8 41 45 15 对第i轮进行计算： 1. C[x] = A[N^i(x,0)T]⊕A[N^i(x,1)T]⊕A[N^i(x,2)T]⊕A[N^i(x,3)T]⊕A[N^i(x,4)T], x = 0...4 2. D[x] = C[x−1]⊕ROT(C[x+1],1), x = 0...4 for y=0...4 3. B[x+2y] = ROT((A[N^(i+1)(x,y)T]⊕D[x]),r[N(x,y)T]), x=0...4 4. A[N^(i+1)(x,y)T]=B[x]⊕((NOT B[x+1]) AND B[x+2]), x=0...4 end 5. A[0,0] = A[0,0] ⊕ RC[i] */ for i := 0; i \u0026lt; 24; i += 4 { // Combines the 5 steps in each round into 2 steps. // Unrolls 4 rounds per loop and spreads some steps across rounds. // Round 1 /* [Min] i = 0, N^0 = 单位矩阵 C[0] = A[0,0]⊕A[0,1]⊕A[0,2]⊕A[0,3]⊕A[0,4] = a[0] ^ a[5] ^ a[10] ^ a[15] ^ a[20] C[1] = A[1,0]⊕A[1,1]⊕A[1,2]⊕A[1,3]⊕A[1,4] = a[1] ^ a[6] ^ a[11] ^ a[16] ^ a[21] ... */ // [Min] C[x] = A[N^i(x,0)T]⊕A[N^i(x,1)T]⊕A[N^i(x,2)T]⊕A[N^i(x,3)T]⊕A[N^i(x,4)T] bc0 = a[0] ^ a[5] ^ a[10] ^ a[15] ^ a[20] bc1 = a[1] ^ a[6] ^ a[11] ^ a[16] ^ a[21] bc2 = a[2] ^ a[7] ^ a[12] ^ a[17] ^ a[22] bc3 = a[3] ^ a[8] ^ a[13] ^ a[18] ^ a[23] bc4 = a[4] ^ a[9] ^ a[14] ^ a[19] ^ a[24] // [Min] D[x] = C[x−1]⊕ROT(C[x+1],1), x = 0...4 d0 = bc4 ^ (bc1\u0026lt;\u0026lt;1 | bc1\u0026gt;\u0026gt;63) d1 = bc0 ^ (bc2\u0026lt;\u0026lt;1 | bc2\u0026gt;\u0026gt;63) d2 = bc1 ^ (bc3\u0026lt;\u0026lt;1 | bc3\u0026gt;\u0026gt;63) d3 = bc2 ^ (bc4\u0026lt;\u0026lt;1 | bc4\u0026gt;\u0026gt;63) d4 = bc3 ^ (bc0\u0026lt;\u0026lt;1 | bc0\u0026gt;\u0026gt;63) // [Min] y = 0 // [Min] B[x+2y] = ROT((A[N^(i+1)(x,y)T]⊕D[x]),r[N(x,y)T]), x=0...4 // [Min] A[N^(i+1)(x,y)T]=B[x]⊕((NOT B[x+1]) AND B[x+2]), x=0...4 // [Min] A[0,0] = A[0,0] ⊕ RC[i] bc0 = a[0] ^ d0 t = a[6] ^ d1 bc1 = t\u0026lt;\u0026lt;44 | t\u0026gt;\u0026gt;(64-44) t = a[12] ^ d2 bc2 = t\u0026lt;\u0026lt;43 | t\u0026gt;\u0026gt;(64-43) t = a[18] ^ d3 bc3 = t\u0026lt;\u0026lt;21 | t\u0026gt;\u0026gt;(64-21) t = a[24] ^ d4 bc4 = t\u0026lt;\u0026lt;14 | t\u0026gt;\u0026gt;(64-14) a[0] = bc0 ^ (bc2 \u0026amp;^ bc1) ^ rc[i] a[6] = bc1 ^ (bc3 \u0026amp;^ bc2) a[12] = bc2 ^ (bc4 \u0026amp;^ bc3) a[18] = bc3 ^ (bc0 \u0026amp;^ bc4) a[24] = bc4 ^ (bc1 \u0026amp;^ bc0) // [Min] y = 1 // [Min] B[x+2y] = ROT((A[N^(i+1)(x,y)T]⊕D[x]),r[N(x,y)T]), x=0...4 // [Min] A[N^(i+1)(x,y)T]=B[x]⊕((NOT B[x+1]) AND B[x+2]), x=0...4 t = a[10] ^ d0 bc2 = t\u0026lt;\u0026lt;3 | t\u0026gt;\u0026gt;(64-3) t = a[16] ^ d1 bc3 = t\u0026lt;\u0026lt;45 | t\u0026gt;\u0026gt;(64-45) t = a[22] ^ d2 bc4 = t\u0026lt;\u0026lt;61 | t\u0026gt;\u0026gt;(64-61) t = a[3] ^ d3 bc0 = t\u0026lt;\u0026lt;28 | t\u0026gt;\u0026gt;(64-28) t = a[9] ^ d4 bc1 = t\u0026lt;\u0026lt;20 | t\u0026gt;\u0026gt;(64-20) a[10] = bc0 ^ (bc2 \u0026amp;^ bc1) a[16] = bc1 ^ (bc3 \u0026amp;^ bc2) a[22] = bc2 ^ (bc4 \u0026amp;^ bc3) a[3] = bc3 ^ (bc0 \u0026amp;^ bc4) a[9] = bc4 ^ (bc1 \u0026amp;^ bc0) // [Min] y = 2 // [Min] B[x+2y] = ROT((A[N^(i+1)(x,y)T]⊕D[x]),r[N(x,y)T]), x=0...4 // [Min] A[N^(i+1)(x,y)T]=B[x]⊕((NOT B[x+1]) AND B[x+2]), x=0...4 t = a[20] ^ d0 bc4 = t\u0026lt;\u0026lt;18 | t\u0026gt;\u0026gt;(64-18) t = a[1] ^ d1 bc0 = t\u0026lt;\u0026lt;1 | t\u0026gt;\u0026gt;(64-1) t = a[7] ^ d2 bc1 = t\u0026lt;\u0026lt;6 | t\u0026gt;\u0026gt;(64-6) t = a[13] ^ d3 bc2 = t\u0026lt;\u0026lt;25 | t\u0026gt;\u0026gt;(64-25) t = a[19] ^ d4 bc3 = t\u0026lt;\u0026lt;8 | t\u0026gt;\u0026gt;(64-8) a[20] = bc0 ^ (bc2 \u0026amp;^ bc1) a[1] = bc1 ^ (bc3 \u0026amp;^ bc2) a[7] = bc2 ^ (bc4 \u0026amp;^ bc3) a[13] = bc3 ^ (bc0 \u0026amp;^ bc4) a[19] = bc4 ^ (bc1 \u0026amp;^ bc0) // [Min] y = 3 // [Min] B[x+2y] = ROT((A[N^(i+1)(x,y)T]⊕D[x]),r[N(x,y)T]), x=0...4 // [Min] A[N^(i+1)(x,y)T]=B[x]⊕((NOT B[x+1]) AND B[x+2]), x=0...4 t = a[5] ^ d0 bc1 = t\u0026lt;\u0026lt;36 | t\u0026gt;\u0026gt;(64-36) t = a[11] ^ d1 bc2 = t\u0026lt;\u0026lt;10 | t\u0026gt;\u0026gt;(64-10) t = a[17] ^ d2 bc3 = t\u0026lt;\u0026lt;15 | t\u0026gt;\u0026gt;(64-15) t = a[23] ^ d3 bc4 = t\u0026lt;\u0026lt;56 | t\u0026gt;\u0026gt;(64-56) t = a[4] ^ d4 bc0 = t\u0026lt;\u0026lt;27 | t\u0026gt;\u0026gt;(64-27) a[5] = bc0 ^ (bc2 \u0026amp;^ bc1) a[11] = bc1 ^ (bc3 \u0026amp;^ bc2) a[17] = bc2 ^ (bc4 \u0026amp;^ bc3) a[23] = bc3 ^ (bc0 \u0026amp;^ bc4) a[4] = bc4 ^ (bc1 \u0026amp;^ bc0) // [Min] y = 4 // [Min] B[x+2y] = ROT((A[N^(i+1)(x,y)T]⊕D[x]),r[N(x,y)T]), x=0...4 // [Min] A[N^(i+1)(x,y)T]=B[x]⊕((NOT B[x+1]) AND B[x+2]), x=0...4 t = a[15] ^ d0 bc3 = t\u0026lt;\u0026lt;41 | t\u0026gt;\u0026gt;(64-41) t = a[21] ^ d1 bc4 = t\u0026lt;\u0026lt;2 | t\u0026gt;\u0026gt;(64-2) t = a[2] ^ d2 bc0 = t\u0026lt;\u0026lt;62 | t\u0026gt;\u0026gt;(64-62) t = a[8] ^ d3 bc1 = t\u0026lt;\u0026lt;55 | t\u0026gt;\u0026gt;(64-55) t = a[14] ^ d4 bc2 = t\u0026lt;\u0026lt;39 | t\u0026gt;\u0026gt;(64-39) a[15] = bc0 ^ (bc2 \u0026amp;^ bc1) a[21] = bc1 ^ (bc3 \u0026amp;^ bc2) a[2] = bc2 ^ (bc4 \u0026amp;^ bc3) a[8] = bc3 ^ (bc0 \u0026amp;^ bc4) a[14] = bc4 ^ (bc1 \u0026amp;^ bc0) // Round 2 /* [Min] i = 1, N^i将 (x,y) 映射成 (x,x+2y) C[0] = A[0,0]⊕A[0,2]⊕A[0,4]⊕A[0,1]⊕A[0,3] = a[0] ^ a[10] ^ a[20] ^ a[5] ^ a[15] C[1] = A[1,1]⊕A[1,3]⊕A[1,0]⊕A[1,2]⊕A[1,4] = a[6] ^ a[16] ^ a[1] ^ a[11] ^ a[21] ... */ // [Min] C[x] = A[N^i(x,0)T]⊕A[N^i(x,1)T]⊕A[N^i(x,2)T]⊕A[N^i(x,3)T]⊕A[N^i(x,4)T] bc0 = a[0] ^ a[5] ^ a[10] ^ a[15] ^ a[20] bc1 = a[1] ^ a[6] ^ a[11] ^ a[16] ^ a[21] bc2 = a[2] ^ a[7] ^ a[12] ^ a[17] ^ a[22] bc3 = a[3] ^ a[8] ^ a[13] ^ a[18] ^ a[23] bc4 = a[4] ^ a[9] ^ a[14] ^ a[19] ^ a[24] // [Min] D[x] = C[x−1]⊕ROT(C[x+1],1), x = 0...4 d0 = bc4 ^ (bc1\u0026lt;\u0026lt;1 | bc1\u0026gt;\u0026gt;63) d1 = bc0 ^ (bc2\u0026lt;\u0026lt;1 | bc2\u0026gt;\u0026gt;63) d2 = bc1 ^ (bc3\u0026lt;\u0026lt;1 | bc3\u0026gt;\u0026gt;63) d3 = bc2 ^ (bc4\u0026lt;\u0026lt;1 | bc4\u0026gt;\u0026gt;63) d4 = bc3 ^ (bc0\u0026lt;\u0026lt;1 | bc0\u0026gt;\u0026gt;63) // [Min] y = 0 // [Min] B[x+2y] = ROT((A[N^(i+1)(x,y)T]⊕D[x]),r[N(x,y)T]), x=0...4 // [Min] A[N^(i+1)(x,y)T]=B[x]⊕((NOT B[x+1]) AND B[x+2]), x=0...4 // [Min] A[0,0] = A[0,0] ⊕ RC[i] bc0 = a[0] ^ d0 t = a[16] ^ d1 bc1 = t\u0026lt;\u0026lt;44 | t\u0026gt;\u0026gt;(64-44) t = a[7] ^ d2 bc2 = t\u0026lt;\u0026lt;43 | t\u0026gt;\u0026gt;(64-43) t = a[23] ^ d3 bc3 = t\u0026lt;\u0026lt;21 | t\u0026gt;\u0026gt;(64-21) t = a[14] ^ d4 bc4 = t\u0026lt;\u0026lt;14 | t\u0026gt;\u0026gt;(64-14) a[0] = bc0 ^ (bc2 \u0026amp;^ bc1) ^ rc[i+1] a[16] = bc1 ^ (bc3 \u0026amp;^ bc2) a[7] = bc2 ^ (bc4 \u0026amp;^ bc3) a[23] = bc3 ^ (bc0 \u0026amp;^ bc4) a[14] = bc4 ^ (bc1 \u0026amp;^ bc0) // [Min] y = 1 // [Min] B[x+2y] = ROT((A[N^(i+1)(x,y)T]⊕D[x]),r[N(x,y)T]), x=0...4 // [Min] A[N^(i+1)(x,y)T]=B[x]⊕((NOT B[x+1]) AND B[x+2]), x=0...4 t = a[20] ^ d0 bc2 = t\u0026lt;\u0026lt;3 | t\u0026gt;\u0026gt;(64-3) t = a[11] ^ d1 bc3 = t\u0026lt;\u0026lt;45 | t\u0026gt;\u0026gt;(64-45) t = a[2] ^ d2 bc4 = t\u0026lt;\u0026lt;61 | t\u0026gt;\u0026gt;(64-61) t = a[18] ^ d3 bc0 = t\u0026lt;\u0026lt;28 | t\u0026gt;\u0026gt;(64-28) t = a[9] ^ d4 bc1 = t\u0026lt;\u0026lt;20 | t\u0026gt;\u0026gt;(64-20) a[20] = bc0 ^ (bc2 \u0026amp;^ bc1) a[11] = bc1 ^ (bc3 \u0026amp;^ bc2) a[2] = bc2 ^ (bc4 \u0026amp;^ bc3) a[18] = bc3 ^ (bc0 \u0026amp;^ bc4) a[9] = bc4 ^ (bc1 \u0026amp;^ bc0) // [Min] y = 2 // [Min] B[x+2y] = ROT((A[N^(i+1)(x,y)T]⊕D[x]),r[N(x,y)T]), x=0...4 // [Min] A[N^(i+1)(x,y)T]=B[x]⊕((NOT B[x+1]) AND B[x+2]), x=0...4 t = a[15] ^ d0 bc4 = t\u0026lt;\u0026lt;18 | t\u0026gt;\u0026gt;(64-18) t = a[6] ^ d1 bc0 = t\u0026lt;\u0026lt;1 | t\u0026gt;\u0026gt;(64-1) t = a[22] ^ d2 bc1 = t\u0026lt;\u0026lt;6 | t\u0026gt;\u0026gt;(64-6) t = a[13] ^ d3 bc2 = t\u0026lt;\u0026lt;25 | t\u0026gt;\u0026gt;(64-25) t = a[4] ^ d4 bc3 = t\u0026lt;\u0026lt;8 | t\u0026gt;\u0026gt;(64-8) a[15] = bc0 ^ (bc2 \u0026amp;^ bc1) a[6] = bc1 ^ (bc3 \u0026amp;^ bc2) a[22] = bc2 ^ (bc4 \u0026amp;^ bc3) a[13] = bc3 ^ (bc0 \u0026amp;^ bc4) a[4] = bc4 ^ (bc1 \u0026amp;^ bc0) // [Min] y = 3 // [Min] B[x+2y] = ROT((A[N^(i+1)(x,y)T]⊕D[x]),r[N(x,y)T]), x=0...4 // [Min] A[N^(i+1)(x,y)T]=B[x]⊕((NOT B[x+1]) AND B[x+2]), x=0...4 t = a[10] ^ d0 bc1 = t\u0026lt;\u0026lt;36 | t\u0026gt;\u0026gt;(64-36) t = a[1] ^ d1 bc2 = t\u0026lt;\u0026lt;10 | t\u0026gt;\u0026gt;(64-10) t = a[17] ^ d2 bc3 = t\u0026lt;\u0026lt;15 | t\u0026gt;\u0026gt;(64-15) t = a[8] ^ d3 bc4 = t\u0026lt;\u0026lt;56 | t\u0026gt;\u0026gt;(64-56) t = a[24] ^ d4 bc0 = t\u0026lt;\u0026lt;27 | t\u0026gt;\u0026gt;(64-27) a[10] = bc0 ^ (bc2 \u0026amp;^ bc1) a[1] = bc1 ^ (bc3 \u0026amp;^ bc2) a[17] = bc2 ^ (bc4 \u0026amp;^ bc3) a[8] = bc3 ^ (bc0 \u0026amp;^ bc4) a[24] = bc4 ^ (bc1 \u0026amp;^ bc0) // [Min] y = 4 // [Min] B[x+2y] = ROT((A[N^(i+1)(x,y)T]⊕D[x]),r[N(x,y)T]), x=0...4 // [Min] A[N^(i+1)(x,y)T]=B[x]⊕((NOT B[x+1]) AND B[x+2]), x=0...4 t = a[5] ^ d0 bc3 = t\u0026lt;\u0026lt;41 | t\u0026gt;\u0026gt;(64-41) t = a[21] ^ d1 bc4 = t\u0026lt;\u0026lt;2 | t\u0026gt;\u0026gt;(64-2) t = a[12] ^ d2 bc0 = t\u0026lt;\u0026lt;62 | t\u0026gt;\u0026gt;(64-62) t = a[3] ^ d3 bc1 = t\u0026lt;\u0026lt;55 | t\u0026gt;\u0026gt;(64-55) t = a[19] ^ d4 bc2 = t\u0026lt;\u0026lt;39 | t\u0026gt;\u0026gt;(64-39) a[5] = bc0 ^ (bc2 \u0026amp;^ bc1) a[21] = bc1 ^ (bc3 \u0026amp;^ bc2) a[12] = bc2 ^ (bc4 \u0026amp;^ bc3) a[3] = bc3 ^ (bc0 \u0026amp;^ bc4) a[19] = bc4 ^ (bc1 \u0026amp;^ bc0) // Round 3 /* [Min] i = 2, N^i将 (x,y) 映射成 (x,3x+4y) C[0] = A[0,0]⊕A[0,4]⊕A[0,3]⊕A[0,2]⊕A[0,1] = a[0] ^ a[20] ^ a[15] ^ a[10] ^ a[5] C[1] = A[1,3]⊕A[1,2]⊕A[1,1]⊕A[1,0]⊕A[1,4] = a[16] ^ a[11] ^ a[6] ^ a[1] ^ a[21] ... */ // [Min] C[x] = A[N^i(x,0)T]⊕A[N^i(x,1)T]⊕A[N^i(x,2)T]⊕A[N^i(x,3)T]⊕A[N^i(x,4)T] bc0 = a[0] ^ a[5] ^ a[10] ^ a[15] ^ a[20] bc1 = a[1] ^ a[6] ^ a[11] ^ a[16] ^ a[21] bc2 = a[2] ^ a[7] ^ a[12] ^ a[17] ^ a[22] bc3 = a[3] ^ a[8] ^ a[13] ^ a[18] ^ a[23] bc4 = a[4] ^ a[9] ^ a[14] ^ a[19] ^ a[24] // [Min] D[x] = C[x−1]⊕ROT(C[x+1],1), x = 0...4 d0 = bc4 ^ (bc1\u0026lt;\u0026lt;1 | bc1\u0026gt;\u0026gt;63) d1 = bc0 ^ (bc2\u0026lt;\u0026lt;1 | bc2\u0026gt;\u0026gt;63) d2 = bc1 ^ (bc3\u0026lt;\u0026lt;1 | bc3\u0026gt;\u0026gt;63) d3 = bc2 ^ (bc4\u0026lt;\u0026lt;1 | bc4\u0026gt;\u0026gt;63) d4 = bc3 ^ (bc0\u0026lt;\u0026lt;1 | bc0\u0026gt;\u0026gt;63) // [Min] y = 0 // [Min] B[x+2y] = ROT((A[N^(i+1)(x,y)T]⊕D[x]),r[N(x,y)T]), x=0...4 // [Min] A[N^(i+1)(x,y)T]=B[x]⊕((NOT B[x+1]) AND B[x+2]), x=0...4 // [Min] A[0,0] = A[0,0] ⊕ RC[i] bc0 = a[0] ^ d0 t = a[11] ^ d1 bc1 = t\u0026lt;\u0026lt;44 | t\u0026gt;\u0026gt;(64-44) t = a[22] ^ d2 bc2 = t\u0026lt;\u0026lt;43 | t\u0026gt;\u0026gt;(64-43) t = a[8] ^ d3 bc3 = t\u0026lt;\u0026lt;21 | t\u0026gt;\u0026gt;(64-21) t = a[19] ^ d4 bc4 = t\u0026lt;\u0026lt;14 | t\u0026gt;\u0026gt;(64-14) a[0] = bc0 ^ (bc2 \u0026amp;^ bc1) ^ rc[i+2] a[11] = bc1 ^ (bc3 \u0026amp;^ bc2) a[22] = bc2 ^ (bc4 \u0026amp;^ bc3) a[8] = bc3 ^ (bc0 \u0026amp;^ bc4) a[19] = bc4 ^ (bc1 \u0026amp;^ bc0) // [Min] y = 1 // [Min] B[x+2y] = ROT((A[N^(i+1)(x,y)T]⊕D[x]),r[N(x,y)T]), x=0...4 // [Min] A[N^(i+1)(x,y)T]=B[x]⊕((NOT B[x+1]) AND B[x+2]), x=0...4 t = a[15] ^ d0 bc2 = t\u0026lt;\u0026lt;3 | t\u0026gt;\u0026gt;(64-3) t = a[1] ^ d1 bc3 = t\u0026lt;\u0026lt;45 | t\u0026gt;\u0026gt;(64-45) t = a[12] ^ d2 bc4 = t\u0026lt;\u0026lt;61 | t\u0026gt;\u0026gt;(64-61) t = a[23] ^ d3 bc0 = t\u0026lt;\u0026lt;28 | t\u0026gt;\u0026gt;(64-28) t = a[9] ^ d4 bc1 = t\u0026lt;\u0026lt;20 | t\u0026gt;\u0026gt;(64-20) a[15] = bc0 ^ (bc2 \u0026amp;^ bc1) a[1] = bc1 ^ (bc3 \u0026amp;^ bc2) a[12] = bc2 ^ (bc4 \u0026amp;^ bc3) a[23] = bc3 ^ (bc0 \u0026amp;^ bc4) a[9] = bc4 ^ (bc1 \u0026amp;^ bc0) // [Min] y = 2 // [Min] B[x+2y] = ROT((A[N^(i+1)(x,y)T]⊕D[x]),r[N(x,y)T]), x=0...4 // [Min] A[N^(i+1)(x,y)T]=B[x]⊕((NOT B[x+1]) AND B[x+2]), x=0...4 t = a[5] ^ d0 bc4 = t\u0026lt;\u0026lt;18 | t\u0026gt;\u0026gt;(64-18) t = a[16] ^ d1 bc0 = t\u0026lt;\u0026lt;1 | t\u0026gt;\u0026gt;(64-1) t = a[2] ^ d2 bc1 = t\u0026lt;\u0026lt;6 | t\u0026gt;\u0026gt;(64-6) t = a[13] ^ d3 bc2 = t\u0026lt;\u0026lt;25 | t\u0026gt;\u0026gt;(64-25) t = a[24] ^ d4 bc3 = t\u0026lt;\u0026lt;8 | t\u0026gt;\u0026gt;(64-8) a[5] = bc0 ^ (bc2 \u0026amp;^ bc1) a[16] = bc1 ^ (bc3 \u0026amp;^ bc2) a[2] = bc2 ^ (bc4 \u0026amp;^ bc3) a[13] = bc3 ^ (bc0 \u0026amp;^ bc4) a[24] = bc4 ^ (bc1 \u0026amp;^ bc0) // [Min] y = 3 // [Min] B[x+2y] = ROT((A[N^(i+1)(x,y)T]⊕D[x]),r[N(x,y)T]), x=0...4 // [Min] A[N^(i+1)(x,y)T]=B[x]⊕((NOT B[x+1]) AND B[x+2]), x=0...4 t = a[20] ^ d0 bc1 = t\u0026lt;\u0026lt;36 | t\u0026gt;\u0026gt;(64-36) t = a[6] ^ d1 bc2 = t\u0026lt;\u0026lt;10 | t\u0026gt;\u0026gt;(64-10) t = a[17] ^ d2 bc3 = t\u0026lt;\u0026lt;15 | t\u0026gt;\u0026gt;(64-15) t = a[3] ^ d3 bc4 = t\u0026lt;\u0026lt;56 | t\u0026gt;\u0026gt;(64-56) t = a[14] ^ d4 bc0 = t\u0026lt;\u0026lt;27 | t\u0026gt;\u0026gt;(64-27) a[20] = bc0 ^ (bc2 \u0026amp;^ bc1) a[6] = bc1 ^ (bc3 \u0026amp;^ bc2) a[17] = bc2 ^ (bc4 \u0026amp;^ bc3) a[3] = bc3 ^ (bc0 \u0026amp;^ bc4) a[14] = bc4 ^ (bc1 \u0026amp;^ bc0) // [Min] y = 4 // [Min] B[x+2y] = ROT((A[N^(i+1)(x,y)T]⊕D[x]),r[N(x,y)T]), x=0...4 // [Min] A[N^(i+1)(x,y)T]=B[x]⊕((NOT B[x+1]) AND B[x+2]), x=0...4 t = a[10] ^ d0 bc3 = t\u0026lt;\u0026lt;41 | t\u0026gt;\u0026gt;(64-41) t = a[21] ^ d1 bc4 = t\u0026lt;\u0026lt;2 | t\u0026gt;\u0026gt;(64-2) t = a[7] ^ d2 bc0 = t\u0026lt;\u0026lt;62 | t\u0026gt;\u0026gt;(64-62) t = a[18] ^ d3 bc1 = t\u0026lt;\u0026lt;55 | t\u0026gt;\u0026gt;(64-55) t = a[4] ^ d4 bc2 = t\u0026lt;\u0026lt;39 | t\u0026gt;\u0026gt;(64-39) a[10] = bc0 ^ (bc2 \u0026amp;^ bc1) a[21] = bc1 ^ (bc3 \u0026amp;^ bc2) a[7] = bc2 ^ (bc4 \u0026amp;^ bc3) a[18] = bc3 ^ (bc0 \u0026amp;^ bc4) a[4] = bc4 ^ (bc1 \u0026amp;^ bc0) // Round 4 /* [Min] i = 3, N^i将 (x,y) 映射成 (x,7x+8y) C[0] = A[0,0]⊕A[0,3]⊕A[0,1]⊕A[0,4]⊕A[0,2] = a[0] ^ a[15] ^ a[5] ^ a[20] ^ a[10] C[1] = A[1,2]⊕A[1,0]⊕A[1,3]⊕A[1,1]⊕A[1,4] = a[11] ^ a[1] ^ a[16] ^ a[6] ^ a[21] ... */ // [Min] C[x] = A[N^i(x,0)T]⊕A[N^i(x,1)T]⊕A[N^i(x,2)T]⊕A[N^i(x,3)T]⊕A[N^i(x,4)T] bc0 = a[0] ^ a[5] ^ a[10] ^ a[15] ^ a[20] bc1 = a[1] ^ a[6] ^ a[11] ^ a[16] ^ a[21] bc2 = a[2] ^ a[7] ^ a[12] ^ a[17] ^ a[22] bc3 = a[3] ^ a[8] ^ a[13] ^ a[18] ^ a[23] bc4 = a[4] ^ a[9] ^ a[14] ^ a[19] ^ a[24] // [Min] D[x] = C[x−1]⊕ROT(C[x+1],1), x = 0...4 d0 = bc4 ^ (bc1\u0026lt;\u0026lt;1 | bc1\u0026gt;\u0026gt;63) d1 = bc0 ^ (bc2\u0026lt;\u0026lt;1 | bc2\u0026gt;\u0026gt;63) d2 = bc1 ^ (bc3\u0026lt;\u0026lt;1 | bc3\u0026gt;\u0026gt;63) d3 = bc2 ^ (bc4\u0026lt;\u0026lt;1 | bc4\u0026gt;\u0026gt;63) d4 = bc3 ^ (bc0\u0026lt;\u0026lt;1 | bc0\u0026gt;\u0026gt;63) // [Min] y = 0 // [Min] B[x+2y] = ROT((A[N^(i+1)(x,y)T]⊕D[x]),r[N(x,y)T]), x=0...4 // [Min] A[N^(i+1)(x,y)T]=B[x]⊕((NOT B[x+1]) AND B[x+2]), x=0...4 // [Min] A[0,0] = A[0,0] ⊕ RC[i] bc0 = a[0] ^ d0 t = a[1] ^ d1 bc1 = t\u0026lt;\u0026lt;44 | t\u0026gt;\u0026gt;(64-44) t = a[2] ^ d2 bc2 = t\u0026lt;\u0026lt;43 | t\u0026gt;\u0026gt;(64-43) t = a[3] ^ d3 bc3 = t\u0026lt;\u0026lt;21 | t\u0026gt;\u0026gt;(64-21) t = a[4] ^ d4 bc4 = t\u0026lt;\u0026lt;14 | t\u0026gt;\u0026gt;(64-14) a[0] = bc0 ^ (bc2 \u0026amp;^ bc1) ^ rc[i+3] a[1] = bc1 ^ (bc3 \u0026amp;^ bc2) a[2] = bc2 ^ (bc4 \u0026amp;^ bc3) a[3] = bc3 ^ (bc0 \u0026amp;^ bc4) a[4] = bc4 ^ (bc1 \u0026amp;^ bc0) // [Min] y = 1 // [Min] B[x+2y] = ROT((A[N^(i+1)(x,y)T]⊕D[x]),r[N(x,y)T]), x=0...4 // [Min] A[N^(i+1)(x,y)T]=B[x]⊕((NOT B[x+1]) AND B[x+2]), x=0...4 t = a[5] ^ d0 bc2 = t\u0026lt;\u0026lt;3 | t\u0026gt;\u0026gt;(64-3) t = a[6] ^ d1 bc3 = t\u0026lt;\u0026lt;45 | t\u0026gt;\u0026gt;(64-45) t = a[7] ^ d2 bc4 = t\u0026lt;\u0026lt;61 | t\u0026gt;\u0026gt;(64-61) t = a[8] ^ d3 bc0 = t\u0026lt;\u0026lt;28 | t\u0026gt;\u0026gt;(64-28) t = a[9] ^ d4 bc1 = t\u0026lt;\u0026lt;20 | t\u0026gt;\u0026gt;(64-20) a[5] = bc0 ^ (bc2 \u0026amp;^ bc1) a[6] = bc1 ^ (bc3 \u0026amp;^ bc2) a[7] = bc2 ^ (bc4 \u0026amp;^ bc3) a[8] = bc3 ^ (bc0 \u0026amp;^ bc4) a[9] = bc4 ^ (bc1 \u0026amp;^ bc0) // [Min] y = 2 // [Min] B[x+2y] = ROT((A[N^(i+1)(x,y)T]⊕D[x]),r[N(x,y)T]), x=0...4 // [Min] A[N^(i+1)(x,y)T]=B[x]⊕((NOT B[x+1]) AND B[x+2]), x=0...4 t = a[10] ^ d0 bc4 = t\u0026lt;\u0026lt;18 | t\u0026gt;\u0026gt;(64-18) t = a[11] ^ d1 bc0 = t\u0026lt;\u0026lt;1 | t\u0026gt;\u0026gt;(64-1) t = a[12] ^ d2 bc1 = t\u0026lt;\u0026lt;6 | t\u0026gt;\u0026gt;(64-6) t = a[13] ^ d3 bc2 = t\u0026lt;\u0026lt;25 | t\u0026gt;\u0026gt;(64-25) t = a[14] ^ d4 bc3 = t\u0026lt;\u0026lt;8 | t\u0026gt;\u0026gt;(64-8) a[10] = bc0 ^ (bc2 \u0026amp;^ bc1) a[11] = bc1 ^ (bc3 \u0026amp;^ bc2) a[12] = bc2 ^ (bc4 \u0026amp;^ bc3) a[13] = bc3 ^ (bc0 \u0026amp;^ bc4) a[14] = bc4 ^ (bc1 \u0026amp;^ bc0) // [Min] y = 3 // [Min] B[x+2y] = ROT((A[N^(i+1)(x,y)T]⊕D[x]),r[N(x,y)T]), x=0...4 // [Min] A[N^(i+1)(x,y)T]=B[x]⊕((NOT B[x+1]) AND B[x+2]), x=0...4 t = a[15] ^ d0 bc1 = t\u0026lt;\u0026lt;36 | t\u0026gt;\u0026gt;(64-36) t = a[16] ^ d1 bc2 = t\u0026lt;\u0026lt;10 | t\u0026gt;\u0026gt;(64-10) t = a[17] ^ d2 bc3 = t\u0026lt;\u0026lt;15 | t\u0026gt;\u0026gt;(64-15) t = a[18] ^ d3 bc4 = t\u0026lt;\u0026lt;56 | t\u0026gt;\u0026gt;(64-56) t = a[19] ^ d4 bc0 = t\u0026lt;\u0026lt;27 | t\u0026gt;\u0026gt;(64-27) a[15] = bc0 ^ (bc2 \u0026amp;^ bc1) a[16] = bc1 ^ (bc3 \u0026amp;^ bc2) a[17] = bc2 ^ (bc4 \u0026amp;^ bc3) a[18] = bc3 ^ (bc0 \u0026amp;^ bc4) a[19] = bc4 ^ (bc1 \u0026amp;^ bc0) // [Min] y = 4 // [Min] B[x+2y] = ROT((A[N^(i+1)(x,y)T]⊕D[x]),r[N(x,y)T]), x=0...4 // [Min] A[N^(i+1)(x,y)T]=B[x]⊕((NOT B[x+1]) AND B[x+2]), x=0...4 t = a[20] ^ d0 bc3 = t\u0026lt;\u0026lt;41 | t\u0026gt;\u0026gt;(64-41) t = a[21] ^ d1 bc4 = t\u0026lt;\u0026lt;2 | t\u0026gt;\u0026gt;(64-2) t = a[22] ^ d2 bc0 = t\u0026lt;\u0026lt;62 | t\u0026gt;\u0026gt;(64-62) t = a[23] ^ d3 bc1 = t\u0026lt;\u0026lt;55 | t\u0026gt;\u0026gt;(64-55) t = a[24] ^ d4 bc2 = t\u0026lt;\u0026lt;39 | t\u0026gt;\u0026gt;(64-39) a[20] = bc0 ^ (bc2 \u0026amp;^ bc1) a[21] = bc1 ^ (bc3 \u0026amp;^ bc2) a[22] = bc2 ^ (bc4 \u0026amp;^ bc3) a[23] = bc3 ^ (bc0 \u0026amp;^ bc4) a[24] = bc4 ^ (bc1 \u0026amp;^ bc0) } }  3 Go 具体运用 package main import ( \u0026quot;fmt\u0026quot; \u0026quot;golang.org/x/crypto/sha3\u0026quot; ) func main() { h := sha3.New512() // [Min] 连续写入并即时计算当前SHA3 h.Write([]byte{'a'}) ha := h.Sum(nil) h.Write([]byte{'b'}) hab := h.Sum(nil) h.Write([]byte{'c'}) habc := h.Sum(nil) // [Min] 阶段性SHA3和直接计算对应数据的SHA3完全相同 fmt.Printf(\u0026quot;%x\\n\u0026quot;, ha) fmt.Printf(\u0026quot;%x\\n\u0026quot;, sha3.Sum512([]byte{'a'})) fmt.Printf(\u0026quot;%x\\n\u0026quot;, hab) fmt.Printf(\u0026quot;%x\\n\u0026quot;, sha3.Sum512([]byte{'a', 'b'})) fmt.Printf(\u0026quot;%x\\n\u0026quot;, habc) fmt.Printf(\u0026quot;%x\\n\u0026quot;, sha3.Sum512([]byte{'a', 'b', 'c'})) // [Min] Sum256和ShakeSum256在相同输出长度情况下，摘要是不同的，因为他们的填充首字节不同 s256 := sha3.Sum256([]byte{'a'}) shake256 := make([]byte, 32) sha3.ShakeSum256(shake256, []byte{'a'}) fmt.Printf(\u0026quot;%x\\n\u0026quot;, s256) fmt.Printf(\u0026quot;%x\\n\u0026quot;, shake256) }  结果：\n$ go run main.go 697f2d856172cb8309d6b8b97dac4de344b549d4dee61edfb4962d8698b7fa803f4f93ff24393586e28b5b957ac3d1d369420ce53332712f997bd336d09ab02a 697f2d856172cb8309d6b8b97dac4de344b549d4dee61edfb4962d8698b7fa803f4f93ff24393586e28b5b957ac3d1d369420ce53332712f997bd336d09ab02a 01c87b5e8f094d8725ed47be35430de40f6ab6bd7c6641a4ecf0d046c55cb468453796bb61724306a5fb3d90fbe3726a970e5630ae6a9cf9f30d2aa062a0175e 01c87b5e8f094d8725ed47be35430de40f6ab6bd7c6641a4ecf0d046c55cb468453796bb61724306a5fb3d90fbe3726a970e5630ae6a9cf9f30d2aa062a0175e b751850b1a57168a5693cd924b6b096e08f621827444f70d884f5d0240d2712e10e116e9192af3c91a7ec57647e3934057340b4cf408d5a56592f8274eec53f0 b751850b1a57168a5693cd924b6b096e08f621827444f70d884f5d0240d2712e10e116e9192af3c91a7ec57647e3934057340b4cf408d5a56592f8274eec53f0 80084bf2fba02475726feb2cab2d8215eab14bc6bdd8bfb2c8151257032ecd8b 867e2cb04f5a04dcbd592501a5e8fe9ceaafca50255626ca736c138042530ba4 ","date":1532134347,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1543733643,"objectID":"e1e4da5b5ac24120531468f477b3e1a6","permalink":"https://mooncaker816.github.io/2018/07/21/sha3/","publishdate":"2018-07-21T08:52:27+08:00","relpermalink":"/2018/07/21/sha3/","section":"post","summary":"1 什么是SHA-3 SHA-3是一种作为新标准发布的单向散列函数算法，用来替代在理论上已被找出攻击方法的SHA-1算法。全世界的企业和密码学家","tags":["SHA3"],"title":"SHA3","type":"post"},{"authors":null,"categories":["Golang","密码学"],"content":"1 概念 　单向散列函数，又称单向Hash函数、杂凑函数，就是把任意长的输入消息串变化成固定长的输出串且由输出串难以得到输入串的一种函数。这个输出串称为该消息的散列值。一般用于产生消息摘要，密钥加密，常见的如 MD5，SHAx，HMAC 等。\n具体来说，单向散列函数有一个输入，一个输出，其中输入称为消息，输出称为散列值。这里的消息可以是任何类型的数据，对于散列函数来说，它们只不过是一大串比特流。\n散列值的长度与消息的长度无关，其值由选择的散列函数决定。下表是常见散列函数对应的散列值长度。\n   散列类型 最大消息长度 散列值长度 分块大小 块内分组 单值字节序     MD5 无限制 16 bytes(128 bits) 64 bytes(512 bits) 16 * uint32 littleEndian   SHA1 2^64-1 20 bytes(160 bits) 64 bytes(512 bits) 16 * uint32 bigEndian   SHA-224 2^64-1 28 bytes(224 bits) 64 bytes(512 bits) (16 + 48) * uint32 bigEndian   SHA-256 2^64-1 32 bytes(256 bits) 64 bytes(512 bits) (16 + 48) * uint32 bigEndian   SHA-384 2^128-1 48 bytes(384 bits) 128 bytes(1024 bits) (16 + 64) * uint64 bigEndian   SHA-512 2^128-1 64 bytes(512 bits) 128 bytes(1024 bits) (16 + 64) * uint64 bigEndian   SHA-512\u0026frasl;224 2^128-1 28 bytes(224 bits) 128 bytes(1024 bits) (16 + 64) * uint64 bigEndian   SHA-512\u0026frasl;256 2^128-1 32 bytes(256 bits) 128 bytes(1024 bits) (16 + 64) * uint64 bigEndian   SHA3-224 无限制 28 bytes(224 bits) 144 bytes(1152 bits)     SHA3-256 无限制 32 bytes(256 bits) 136 bytes(1088 bits)     SHA3-384 无限制 48 bytes(384 bits) 104 bytes(832 bits)     SHA3-512 无限制 64 bytes(512 bits) 72 bytes(576 bits)     SHAKE128 无限制 变长 168 bytes(1344 bits)     SHAKE256 无限制 变长 136 bytes(1088 bits)      注：对于 MD5 来说，如果根据最后一个分块末尾用来记录源数据字节长度的空间大小（8个字节）来看，其最大输入长度应该为2^64 - 1，但是在 MD5 的算法中，指明了此处的值是对 2^64 取余,所以 MD5 的输入没有限制。（但是 Go 中并没有取余）\n The remaining bits are filled up with 64 bits representing the length of the original message, modulo 264.\n 2 MD5 2.1 预备函数 \\begin{align} F(B,C,D) \u0026amp;= (B \\land C) | (\\lnot B \\land D) \\\\[2ex] G(B,C,D) \u0026amp;= (B \\land D) | (C \\land \\lnot D) \\\\[2ex] H(B,C,D) \u0026amp;= B \\oplus C \\oplus D \\\\[2ex] I(B,C,D) \u0026amp;= C \\oplus (B \\lor \\lnot D) \\end{align}\nF,G 更高效的表达： \\begin{align} F(B,C,D) \u0026amp;= D \\oplus (B \\land (C \\oplus D)) \\\\[2ex] G(B,C,D) \u0026amp;= C \\oplus (D \\land (B \\oplus C)) \\end{align}\n\\begin{align} FF(a,b,c,d,Mj,s,ti) 表示\u0026amp;a=b+((a+F(b,c,d)+Mj+ti)\\lll s) \\\\[2ex] GG(a,b,c,d,Mj,s,ti) 表示\u0026amp;a=b+((a+G(b,c,d)+Mj+ti)\\lll s) \\\\[2ex] HH(a,b,c,d,Mj,s,ti) 表示\u0026amp;a=b+((a+H(b,c,d)+Mj+ti)\\lll s) \\\\[2ex] II(a,b,c,d,Mj,s,ti) 表示\u0026amp;a=b+((a+I(b,c,d)+Mj+ti)\\lll s) \\end{align}\n2.2 具体实现 　假设我们有一串消息 data，长度位 n 个字节，以下是获取其 MD5 信息摘要的步骤：\n 以64字节为单位，对 n 个字节进行分块，$$n = k*64 + r, k = 0,1,2\u0026hellip;,r \\in [0,64) $$ 对这 k 个分块中的数据依次调用 MD5 HASH 函数，计算出这 k 个分块对应的散列值 对剩下的 r 个字节进行填充，\n如果 r \u0026gt;= 56，先填充至64个字节，第一位填充1，后续填充0，即填满一个分块\n如果 r \u0026lt; 56，先填充至56个字节，第一位填充1，后续填充0，再将原始数据对应的字节长度信息以 uint64 为类型，按小字节序填入该分块的最末尾8个字节 处理填充分块，可能只有一个填充分块，也可能有两个 块内按小字节序将64字节数据分为16组uint32，对这16组数据进行共计4轮64次循环计算 整合最终散列值  2.3 Go 源码分析 // Copyright 2009 The Go Authors. All rights reserved. // Use of this source code is governed by a BSD-style // license that can be found in the LICENSE file. //go:generate go run gen.go -full -output md5block.go // Package md5 implements the MD5 hash algorithm as defined in RFC 1321. // // MD5 is cryptographically broken and should not be used for secure // applications. package md5 import ( \u0026quot;crypto\u0026quot; \u0026quot;errors\u0026quot; \u0026quot;hash\u0026quot; ) func init() { crypto.RegisterHash(crypto.MD5, New) } // The size of an MD5 checksum in bytes. // [Min] MD5 消息摘要的字节数，16 字节，128 bits const Size = 16 // The blocksize of MD5 in bytes. // [Min] 分块的大小 64 字节 const BlockSize = 64 const ( chunk = 64 // [Min] 一个分块的字节长度，64 字节，512 位 init0 = 0x67452301 // [Min] 初始摘要中0-3字节的值 init1 = 0xEFCDAB89 // [Min] 初始摘要中4-7字节的值 init2 = 0x98BADCFE // [Min] 初始摘要中8-11字节的值 init3 = 0x10325476 // [Min] 初始摘要中12-15字节的值 ) /* [Min] 1. 先将源数据以64字节为单位分块，留出不够一个分块的部分 B ，其余部分 A 为64字节的整数倍 2. 将 A 中的数据依次按分块处理 3. 对 B 进行以下填充，使得 B % 64 = 56， 单位为字节 如果 B 不满 56 字节（448位），第一位填充1，后续填充 0 至448位即可，等待最终长度的填充 如果 B \u0026gt;= 56 字节，则需填充 (64 - B)*8 + 448 位，第一位为1，后续为0， 并且此时会形成一个满的分块，对此分块处理，剩余 448 位等待最终长度填充后达到512位后一起处理 4. 最后将源数据和所有填充数据的长度以 uint64 的类型填充到上述 448 位后，形成最后一个分块 对此分块进行处理 */ // digest represents the partial evaluation of a checksum. // [Min] 消息摘要 type digest struct { s [4]uint32 // [Min] 存储摘要的实际载体 x [chunk]byte // [Min] 填充分块 nx int // [Min] 当前填充分块中未处理数据的字节长度 len uint64 // [Min] 源消息的长度 } // [Min] 重置摘要，将载体中的值按初始值初始化 func (d *digest) Reset() { d.s[0] = init0 d.s[1] = init1 d.s[2] = init2 d.s[3] = init3 d.nx = 0 d.len = 0 } const ( magic = \u0026quot;md5\\x01\u0026quot; // [Min] MarshalBinary 返回的字节长度 ： // [Min] magic 头长度 + 16 字节消息摘要长度 + 64 字节最后一个分块长度 + 8 字节源消息大小的长度 marshaledSize = len(magic) + 4*4 + chunk + 8 ) // [Min] 调用 Write 方法后，将当前 d 中数据格式化，用于反应 hash 过程中的状态 func (d *digest) MarshalBinary() ([]byte, error) { b := make([]byte, 0, marshaledSize) // [Min] 头 b = append(b, magic...) // [Min] 当前已处理分块的消息摘要 b = appendUint32(b, d.s[0]) b = appendUint32(b, d.s[1]) b = appendUint32(b, d.s[2]) b = appendUint32(b, d.s[3]) // [Min] 将填充分块中的还在等待填充的数据写入 b b = append(b, d.x[:d.nx]...) // [Min] 撑满一个分块的大小 b = b[:len(b)+len(d.x)-int(d.nx)] // already zero // [Min] 当前已处理的数据的长度（可能包括填充数据）写入 b b = appendUint64(b, d.len) return b, nil } // [Min] 根据 digest 的状态（marshal 后的字节流），还原 digest func (d *digest) UnmarshalBinary(b []byte) error { // [Min] 必须有 magic 头 if len(b) \u0026lt; len(magic) || string(b[:len(magic)]) != magic { return errors.New(\u0026quot;crypto/md5: invalid hash state identifier\u0026quot;) } // [Min] b 的长度是固定的 marshaledSize if len(b) != marshaledSize { return errors.New(\u0026quot;crypto/md5: invalid hash state size\u0026quot;) } b = b[len(magic):] // [Min] 还原当前的消息摘要 b, d.s[0] = consumeUint32(b) b, d.s[1] = consumeUint32(b) b, d.s[2] = consumeUint32(b) b, d.s[3] = consumeUint32(b) // [Min] 还原填充分块数据 b = b[copy(d.x[:], b):] // [Min] 还原已处理数据（可能包括填充数据）长度 b, d.len = consumeUint64(b) // [Min] 还原填充分块中待填充的数据的长度 d.nx = int(d.len) % chunk return nil } // [Min] 将 x 对应的8个字节由高到低依次存入 b 中 func appendUint64(b []byte, x uint64) []byte { a := [8]byte{ byte(x \u0026gt;\u0026gt; 56), byte(x \u0026gt;\u0026gt; 48), byte(x \u0026gt;\u0026gt; 40), byte(x \u0026gt;\u0026gt; 32), byte(x \u0026gt;\u0026gt; 24), byte(x \u0026gt;\u0026gt; 16), byte(x \u0026gt;\u0026gt; 8), byte(x), } return append(b, a[:]...) } // [Min] 将 x 对应的4个字节由高到低依次存入 b 中 func appendUint32(b []byte, x uint32) []byte { a := [4]byte{ byte(x \u0026gt;\u0026gt; 24), byte(x \u0026gt;\u0026gt; 16), byte(x \u0026gt;\u0026gt; 8), byte(x), } return append(b, a[:]...) } // [Min] 将 b 中前8个字节当成一个 uint64 数值，返回剩余部分和该数值 func consumeUint64(b []byte) ([]byte, uint64) { _ = b[7] x := uint64(b[7]) | uint64(b[6])\u0026lt;\u0026lt;8 | uint64(b[5])\u0026lt;\u0026lt;16 | uint64(b[4])\u0026lt;\u0026lt;24 | uint64(b[3])\u0026lt;\u0026lt;32 | uint64(b[2])\u0026lt;\u0026lt;40 | uint64(b[1])\u0026lt;\u0026lt;48 | uint64(b[0])\u0026lt;\u0026lt;56 return b[8:], x } // [Min] 将 b 中前4个字节当成一个 uint32 数值，返回剩余部分和该数值 func consumeUint32(b []byte) ([]byte, uint32) { _ = b[3] x := uint32(b[3]) | uint32(b[2])\u0026lt;\u0026lt;8 | uint32(b[1])\u0026lt;\u0026lt;16 | uint32(b[0])\u0026lt;\u0026lt;24 return b[4:], x } // New returns a new hash.Hash computing the MD5 checksum. The Hash also // implements encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to // marshal and unmarshal the internal state of the hash. // [Min] 构造一个 MD5 类型的 hash 载体 func New() hash.Hash { d := new(digest) d.Reset() return d } // [Min] 返回 MD5 摘要的字节长度16 func (d *digest) Size() int { return Size } // [Min] 返回 MD5 的 BlockSize 64 func (d *digest) BlockSize() int { return BlockSize } func (d *digest) Write(p []byte) (nn int, err error) { nn = len(p) d.len += uint64(nn) // [Min] 如果 d.nx \u0026gt;0, 说明 d.x 中含有遗留的未处理的尾部源数据（不够一个分块的部分） // [Min] 此时 p 中的数据为填充数据， // [Min] 如果填满了一个分块，就进行处理 // [Min] 如果没满，说明还在等待最后的长度填充（届时一定能恰好填满一个分块） if d.nx \u0026gt; 0 { n := copy(d.x[d.nx:], p) d.nx += n if d.nx == chunk { block(d, d.x[:]) d.nx = 0 } p = p[n:] } // [Min] 源数据超过一个分块的大小，此处的 p 为源数据 if len(p) \u0026gt;= chunk { // [Min] 计算出 p 中最大整数倍分块大小的字节长度 n， // [Min] 对这 n 个字节先处理，剩余部分比分块大小小，存入 p 中 n := len(p) \u0026amp;^ (chunk - 1) block(d, p[:n]) p = p[n:] } // [Min] p 中数据不够一个分块，存入 d.x 中，待后续调用 Write 时再处理 if len(p) \u0026gt; 0 { d.nx = copy(d.x[:], p) } return } func (d0 *digest) Sum(in []byte) []byte { // Make a copy of d0 so that caller can keep writing and summing. d := *d0 hash := d.checkSum() return append(in, hash[:]...) } func (d *digest) checkSum() [Size]byte { // Padding. Add a 1 bit and 0 bits until 56 bytes mod 64. // [Min] 获得填充前的源消息字节长度 len := d.len var tmp [64]byte // [Min] 填充信息，最高位为1，后续全为0 tmp[0] = 0x80 // [Min] 如果不满56字节（448位），填充至56字节即可 // [Min] 如果超过或等于56字节，需填满一个分块64字节，再填56字节 if len%64 \u0026lt; 56 { d.Write(tmp[0 : 56-len%64]) } else { d.Write(tmp[0 : 64+56-len%64]) } // Length in bits. // [Min] 将字节长度转为 bit 位长，再将其存入8个字节中，代表一个 uint64 值 // [Min] 再将这8个字节填入剩余部分，构成最后一个分块（小字节序） len \u0026lt;\u0026lt;= 3 for i := uint(0); i \u0026lt; 8; i++ { tmp[i] = byte(len \u0026gt;\u0026gt; (8 * i)) } d.Write(tmp[0:8]) // [Min] 此时 d.nx 必须为0， 代表 d.x 中的分块已处理 if d.nx != 0 { panic(\u0026quot;d.nx != 0\u0026quot;) } // [Min] 所有分块都处理完后，将最终128位摘要信息按小字节序写入对应的16个字节的变量返回 var digest [Size]byte for i, s := range d.s { digest[i*4] = byte(s) digest[i*4+1] = byte(s \u0026gt;\u0026gt; 8) digest[i*4+2] = byte(s \u0026gt;\u0026gt; 16) digest[i*4+3] = byte(s \u0026gt;\u0026gt; 24) } return digest } // Sum returns the MD5 checksum of the data. // [Min] 计算 data 的 MD5 摘要信息 func Sum(data []byte) [Size]byte { var d digest d.Reset() // [Min] 先把能构成分块的数据处理，留下剩余不够分块的数据待处理 d.Write(data) // [Min] 填充分块，处理数据，最后返回消息摘要 return d.checkSum() }  // Copyright 2013 The Go Authors. All rights reserved. // Use of this source code is governed by a BSD-style // license that can be found in the LICENSE file. // DO NOT EDIT. // Generate with: go run gen.go -full -output md5block.go package md5 import ( \u0026quot;runtime\u0026quot; \u0026quot;unsafe\u0026quot; ) const x86 = runtime.GOARCH == \u0026quot;amd64\u0026quot; || runtime.GOARCH == \u0026quot;386\u0026quot; var littleEndian bool // [Min] 判断当前系统的字节序 func init() { x := uint32(0x04030201) y := [4]byte{0x1, 0x2, 0x3, 0x4} littleEndian = *(*[4]byte)(unsafe.Pointer(\u0026amp;x)) == y } // [Min] 消息摘要处理函数 func blockGeneric(dig *digest, p []byte) { a := dig.s[0] b := dig.s[1] c := dig.s[2] d := dig.s[3] var X *[16]uint32 var xbuf [16]uint32 // [Min] 这里 p 一定是分块大小的整数倍 for len(p) \u0026gt;= chunk { // [Min] 备份未处理当前分块前的值 aa, bb, cc, dd := a, b, c, d // [Min] 首先根据系统，都按小字节序从 p 中获取一个分块的数据（64字节512位）存入 X // [Min] 分成16个小组，每个小组32位 // This is a constant condition - it is not evaluated on each iteration. if x86 { // MD5 was designed so that x86 processors can just iterate // over the block data directly as uint32s, and we generate // less code and run 1.3x faster if we take advantage of that. // My apologies. X = (*[16]uint32)(unsafe.Pointer(\u0026amp;p[0])) } else if littleEndian \u0026amp;\u0026amp; uintptr(unsafe.Pointer(\u0026amp;p[0]))\u0026amp;(unsafe.Alignof(uint32(0))-1) == 0 { X = (*[16]uint32)(unsafe.Pointer(\u0026amp;p[0])) } else { X = \u0026amp;xbuf j := 0 for i := 0; i \u0026lt; 16; i++ { X[i\u0026amp;15] = uint32(p[j]) | uint32(p[j+1])\u0026lt;\u0026lt;8 | uint32(p[j+2])\u0026lt;\u0026lt;16 | uint32(p[j+3])\u0026lt;\u0026lt;24 j += 4 } } // [Min] F(X,Y,Z)=(X\u0026amp;Y)|((~X)\u0026amp;Z) \u0026lt;=\u0026gt; Z xor (X and (Y xor Z)) 后者更高效 // [Min] G(X,Y,Z)=(X\u0026amp;Z)|(Y\u0026amp;(~Z)) \u0026lt;=\u0026gt; Y xor (Z and (X xor Y)) 后者更高效 // [Min] H(X,Y,Z)=X^Y^Z // [Min] I(X,Y,Z)=Y^(X|(~Z)) // [Min] 设Mj表示消息的第j个子分组（从0到15），\u0026lt;\u0026lt;\u0026lt;s表示循环左移s位，则四种操作为： // [Min] FF(a,b,c,d,Mj,s,ti)表示a=b+((a+F(b,c,d)+Mj+ti)\u0026lt;\u0026lt;\u0026lt;s) // [Min] GG(a,b,c,d,Mj,s,ti)表示a=b+((a+G(b,c,d)+Mj+ti)\u0026lt;\u0026lt;\u0026lt;s) // [Min] HH(a,b,c,d,Mj,s,ti)表示a=b+((a+H(b,c,d)+Mj+ti)\u0026lt;\u0026lt;\u0026lt;s) // [Min] II(a,b,c,d,Mj,s,ti)表示a=b+((a+I(b,c,d)+Mj+ti)\u0026lt;\u0026lt;\u0026lt;s) // [Min] 对每一个分块进行以下4轮计算，每一轮中会对每一小组进行处理 // Round 1. // [Min] FF(a ,b ,c ,d,M0 ,7 ,0xd76aa478 ) a += (((c ^ d) \u0026amp; b) ^ d) + X[0] + 3614090360 a = a\u0026lt;\u0026lt;7 | a\u0026gt;\u0026gt;(32-7) + b // [Min] FF(d ,a ,b ,c,M1 ,12 ,0xe8c7b756 ) d += (((b ^ c) \u0026amp; a) ^ c) + X[1] + 3905402710 d = d\u0026lt;\u0026lt;12 | d\u0026gt;\u0026gt;(32-12) + a // [Min] FF(c ,d ,a ,b,M2 ,17 ,0x242070db ) c += (((a ^ b) \u0026amp; d) ^ b) + X[2] + 606105819 c = c\u0026lt;\u0026lt;17 | c\u0026gt;\u0026gt;(32-17) + d // [Min] FF(b ,c ,d ,a,M3 ,22 ,0xc1bdceee ) b += (((d ^ a) \u0026amp; c) ^ a) + X[3] + 3250441966 b = b\u0026lt;\u0026lt;22 | b\u0026gt;\u0026gt;(32-22) + c // [Min] FF(a ,b ,c ,d,M4 ,7 ,0xf57c0faf ) a += (((c ^ d) \u0026amp; b) ^ d) + X[4] + 4118548399 a = a\u0026lt;\u0026lt;7 | a\u0026gt;\u0026gt;(32-7) + b // [Min] b=FF(d,a,b,c,M5,12,0x4787c62a) d += (((b ^ c) \u0026amp; a) ^ c) + X[5] + 1200080426 d = d\u0026lt;\u0026lt;12 | d\u0026gt;\u0026gt;(32-12) + a // [Min] c=FF(c,d,a,b,M6,17,0xa8304613) c += (((a ^ b) \u0026amp; d) ^ b) + X[6] + 2821735955 c = c\u0026lt;\u0026lt;17 | c\u0026gt;\u0026gt;(32-17) + d // [Min] d=FF(b,c,d,a,M7,22,0xfd469501) b += (((d ^ a) \u0026amp; c) ^ a) + X[7] + 4249261313 b = b\u0026lt;\u0026lt;22 | b\u0026gt;\u0026gt;(32-22) + c // [Min] a=FF(a,b,c,d,M8,7,0x698098d8) a += (((c ^ d) \u0026amp; b) ^ d) + X[8] + 1770035416 a = a\u0026lt;\u0026lt;7 | a\u0026gt;\u0026gt;(32-7) + b // [Min] b=FF(d,a,b,c,M9,12,0x8b44f7af) d += (((b ^ c) \u0026amp; a) ^ c) + X[9] + 2336552879 d = d\u0026lt;\u0026lt;12 | d\u0026gt;\u0026gt;(32-12) + a // [Min] c=FF(c,d,a,b,M10,17,0xffff5bb1) c += (((a ^ b) \u0026amp; d) ^ b) + X[10] + 4294925233 c = c\u0026lt;\u0026lt;17 | c\u0026gt;\u0026gt;(32-17) + d // [Min] d=FF(b,c,d,a,M11,22,0x895cd7be) b += (((d ^ a) \u0026amp; c) ^ a) + X[11] + 2304563134 b = b\u0026lt;\u0026lt;22 | b\u0026gt;\u0026gt;(32-22) + c // [Min] a=FF(a,b,c,d,M12,7,0x6b901122) a += (((c ^ d) \u0026amp; b) ^ d) + X[12] + 1804603682 a = a\u0026lt;\u0026lt;7 | a\u0026gt;\u0026gt;(32-7) + b // [Min] b=FF(d,a,b,c,M13,12,0xfd987193) d += (((b ^ c) \u0026amp; a) ^ c) + X[13] + 4254626195 d = d\u0026lt;\u0026lt;12 | d\u0026gt;\u0026gt;(32-12) + a // [Min] c=FF(c,d,a,b,M14,17,0xa679438e) c += (((a ^ b) \u0026amp; d) ^ b) + X[14] + 2792965006 c = c\u0026lt;\u0026lt;17 | c\u0026gt;\u0026gt;(32-17) + d // [Min] d=FF(b,c,d,a,M15,22,0x49b40821) b += (((d ^ a) \u0026amp; c) ^ a) + X[15] + 1236535329 b = b\u0026lt;\u0026lt;22 | b\u0026gt;\u0026gt;(32-22) + c // Round 2. // [Min] a=GG(a,b,c,d,M1,5,0xf61e2562) a += (((b ^ c) \u0026amp; d) ^ c) + X[(1+5*0)\u0026amp;15] + 4129170786 a = a\u0026lt;\u0026lt;5 | a\u0026gt;\u0026gt;(32-5) + b // [Min] b=GG(d,a,b,c,M6,9,0xc040b340) d += (((a ^ b) \u0026amp; c) ^ b) + X[(1+5*1)\u0026amp;15] + 3225465664 d = d\u0026lt;\u0026lt;9 | d\u0026gt;\u0026gt;(32-9) + a // [Min] c=GG(c,d,a,b,M11,14,0x265e5a51) c += (((d ^ a) \u0026amp; b) ^ a) + X[(1+5*2)\u0026amp;15] + 643717713 c = c\u0026lt;\u0026lt;14 | c\u0026gt;\u0026gt;(32-14) + d // [Min] d=GG(b,c,d,a,M0,20,0xe9b6c7aa) b += (((c ^ d) \u0026amp; a) ^ d) + X[(1+5*3)\u0026amp;15] + 3921069994 b = b\u0026lt;\u0026lt;20 | b\u0026gt;\u0026gt;(32-20) + c // [Min] a=GG(a,b,c,d,M5,5,0xd62f105d) a += (((b ^ c) \u0026amp; d) ^ c) + X[(1+5*4)\u0026amp;15] + 3593408605 a = a\u0026lt;\u0026lt;5 | a\u0026gt;\u0026gt;(32-5) + b // [Min] b=GG(d,a,b,c,M10,9,0x02441453) d += (((a ^ b) \u0026amp; c) ^ b) + X[(1+5*5)\u0026amp;15] + 38016083 d = d\u0026lt;\u0026lt;9 | d\u0026gt;\u0026gt;(32-9) + a // [Min] c=GG(c,d,a,b,M15,14,0xd8a1e681) c += (((d ^ a) \u0026amp; b) ^ a) + X[(1+5*6)\u0026amp;15] + 3634488961 c = c\u0026lt;\u0026lt;14 | c\u0026gt;\u0026gt;(32-14) + d // [Min] d=GG(b,c,d,a,M4,20,0xe7d3fbc8) b += (((c ^ d) \u0026amp; a) ^ d) + X[(1+5*7)\u0026amp;15] + 3889429448 b = b\u0026lt;\u0026lt;20 | b\u0026gt;\u0026gt;(32-20) + c // [Min] a=GG(a,b,c,d,M9,5,0x21e1cde6) a += (((b ^ c) \u0026amp; d) ^ c) + X[(1+5*8)\u0026amp;15] + 568446438 a = a\u0026lt;\u0026lt;5 | a\u0026gt;\u0026gt;(32-5) + b // [Min] b=GG(d,a,b,c,M14,9,0xc33707d6) d += (((a ^ b) \u0026amp; c) ^ b) + X[(1+5*9)\u0026amp;15] + 3275163606 d = d\u0026lt;\u0026lt;9 | d\u0026gt;\u0026gt;(32-9) + a // [Min] c=GG(c,d,a,b,M3,14,0xf4d50d87) c += (((d ^ a) \u0026amp; b) ^ a) + X[(1+5*10)\u0026amp;15] + 4107603335 c = c\u0026lt;\u0026lt;14 | c\u0026gt;\u0026gt;(32-14) + d // [Min] d=GG(b,c,d,a,M8,20,0x455a14ed) b += (((c ^ d) \u0026amp; a) ^ d) + X[(1+5*11)\u0026amp;15] + 1163531501 b = b\u0026lt;\u0026lt;20 | b\u0026gt;\u0026gt;(32-20) + c // [Min] a=GG(a,b,c,d,M13,5,0xa9e3e905) a += (((b ^ c) \u0026amp; d) ^ c) + X[(1+5*12)\u0026amp;15] + 2850285829 a = a\u0026lt;\u0026lt;5 | a\u0026gt;\u0026gt;(32-5) + b // [Min] b=GG(d,a,b,c,M2,9,0xfcefa3f8) d += (((a ^ b) \u0026amp; c) ^ b) + X[(1+5*13)\u0026amp;15] + 4243563512 d = d\u0026lt;\u0026lt;9 | d\u0026gt;\u0026gt;(32-9) + a // [Min] c=GG(c,d,a,b,M7,14,0x676f02d9) c += (((d ^ a) \u0026amp; b) ^ a) + X[(1+5*14)\u0026amp;15] + 1735328473 c = c\u0026lt;\u0026lt;14 | c\u0026gt;\u0026gt;(32-14) + d // [Min] d=GG(b,c,d,a,M12,20,0x8d2a4c8a) b += (((c ^ d) \u0026amp; a) ^ d) + X[(1+5*15)\u0026amp;15] + 2368359562 b = b\u0026lt;\u0026lt;20 | b\u0026gt;\u0026gt;(32-20) + c // Round 3. // [Min] a=HH(a,b,c,d,M5,4,0xfffa3942) a += (b ^ c ^ d) + X[(5+3*0)\u0026amp;15] + 4294588738 a = a\u0026lt;\u0026lt;4 | a\u0026gt;\u0026gt;(32-4) + b // [Min] b=HH(d,a,b,c,M8,11,0x8771f681) d += (a ^ b ^ c) + X[(5+3*1)\u0026amp;15] + 2272392833 d = d\u0026lt;\u0026lt;11 | d\u0026gt;\u0026gt;(32-11) + a // [Min] c=HH(c,d,a,b,M11,16,0x6d9d6122) c += (d ^ a ^ b) + X[(5+3*2)\u0026amp;15] + 1839030562 c = c\u0026lt;\u0026lt;16 | c\u0026gt;\u0026gt;(32-16) + d // [Min] d=HH(b,c,d,a,M14,23,0xfde5380c) b += (c ^ d ^ a) + X[(5+3*3)\u0026amp;15] + 4259657740 b = b\u0026lt;\u0026lt;23 | b\u0026gt;\u0026gt;(32-23) + c // [Min] a=HH(a,b,c,d,M1,4,0xa4beea44) a += (b ^ c ^ d) + X[(5+3*4)\u0026amp;15] + 2763975236 a = a\u0026lt;\u0026lt;4 | a\u0026gt;\u0026gt;(32-4) + b // [Min] b=HH(d,a,b,c,M4,11,0x4bdecfa9) d += (a ^ b ^ c) + X[(5+3*5)\u0026amp;15] + 1272893353 d = d\u0026lt;\u0026lt;11 | d\u0026gt;\u0026gt;(32-11) + a // [Min] c=HH(c,d,a,b,M7,16,0xf6bb4b60) c += (d ^ a ^ b) + X[(5+3*6)\u0026amp;15] + 4139469664 c = c\u0026lt;\u0026lt;16 | c\u0026gt;\u0026gt;(32-16) + d // [Min] d=HH(b,c,d,a,M10,23,0xbebfbc70) b += (c ^ d ^ a) + X[(5+3*7)\u0026amp;15] + 3200236656 b = b\u0026lt;\u0026lt;23 | b\u0026gt;\u0026gt;(32-23) + c // [Min] a=HH(a,b,c,d,M13,4,0x289b7ec6) a += (b ^ c ^ d) + X[(5+3*8)\u0026amp;15] + 681279174 a = a\u0026lt;\u0026lt;4 | a\u0026gt;\u0026gt;(32-4) + b // [Min] b=HH(d,a,b,c,M0,11,0xeaa127fa) d += (a ^ b ^ c) + X[(5+3*9)\u0026amp;15] + 3936430074 d = d\u0026lt;\u0026lt;11 | d\u0026gt;\u0026gt;(32-11) + a // [Min] c=HH(c,d,a,b,M3,16,0xd4ef3085) c += (d ^ a ^ b) + X[(5+3*10)\u0026amp;15] + 3572445317 c = c\u0026lt;\u0026lt;16 | c\u0026gt;\u0026gt;(32-16) + d // [Min] d=HH(b,c,d,a,M6,23,0x04881d05) b += (c ^ d ^ a) + X[(5+3*11)\u0026amp;15] + 76029189 b = b\u0026lt;\u0026lt;23 | b\u0026gt;\u0026gt;(32-23) + c // [Min] a=HH(a,b,c,d,M9,4,0xd9d4d039) a += (b ^ c ^ d) + X[(5+3*12)\u0026amp;15] + 3654602809 a = a\u0026lt;\u0026lt;4 | a\u0026gt;\u0026gt;(32-4) + b // [Min] b=HH(d,a,b,c,M12,11,0xe6db99e5) d += (a ^ b ^ c) + X[(5+3*13)\u0026amp;15] + 3873151461 d = d\u0026lt;\u0026lt;11 | d\u0026gt;\u0026gt;(32-11) + a // [Min] c=HH(c,d,a,b,M15,16,0x1fa27cf8) c += (d ^ a ^ b) + X[(5+3*14)\u0026amp;15] + 530742520 c = c\u0026lt;\u0026lt;16 | c\u0026gt;\u0026gt;(32-16) + d // [Min] d=HH(b,c,d,a,M2,23,0xc4ac5665) b += (c ^ d ^ a) + X[(5+3*15)\u0026amp;15] + 3299628645 b = b\u0026lt;\u0026lt;23 | b\u0026gt;\u0026gt;(32-23) + c // Round 4. // [Min] a=II(a,b,c,d,M0,6,0xf4292244) a += (c ^ (b | ^d)) + X[(7*0)\u0026amp;15] + 4096336452 a = a\u0026lt;\u0026lt;6 | a\u0026gt;\u0026gt;(32-6) + b // [Min] b=II(d,a,b,c,M7,10,0x432aff97) d += (b ^ (a | ^c)) + X[(7*1)\u0026amp;15] + 1126891415 d = d\u0026lt;\u0026lt;10 | d\u0026gt;\u0026gt;(32-10) + a // [Min] c=II(c,d,a,b,M14,15,0xab9423a7) c += (a ^ (d | ^b)) + X[(7*2)\u0026amp;15] + 2878612391 c = c\u0026lt;\u0026lt;15 | c\u0026gt;\u0026gt;(32-15) + d // [Min] d=II(b,c,d,a,M5,21,0xfc93a039) b += (d ^ (c | ^a)) + X[(7*3)\u0026amp;15] + 4237533241 b = b\u0026lt;\u0026lt;21 | b\u0026gt;\u0026gt;(32-21) + c // [Min] a=II(a,b,c,d,M12,6,0x655b59c3) a += (c ^ (b | ^d)) + X[(7*4)\u0026amp;15] + 1700485571 a = a\u0026lt;\u0026lt;6 | a\u0026gt;\u0026gt;(32-6) + b // [Min] b=II(d,a,b,c,M3,10,0x8f0ccc92) d += (b ^ (a | ^c)) + X[(7*5)\u0026amp;15] + 2399980690 d = d\u0026lt;\u0026lt;10 | d\u0026gt;\u0026gt;(32-10) + a // [Min] c=II(c,d,a,b,M10,15,0xffeff47d) c += (a ^ (d | ^b)) + X[(7*6)\u0026amp;15] + 4293915773 c = c\u0026lt;\u0026lt;15 | c\u0026gt;\u0026gt;(32-15) + d // [Min] d=II(b,c,d,a,M1,21,0x85845dd1) b += (d ^ (c | ^a)) + X[(7*7)\u0026amp;15] + 2240044497 b = b\u0026lt;\u0026lt;21 | b\u0026gt;\u0026gt;(32-21) + c // [Min] a=II(a,b,c,d,M8,6,0x6fa87e4f) a += (c ^ (b | ^d)) + X[(7*8)\u0026amp;15] + 1873313359 a = a\u0026lt;\u0026lt;6 | a\u0026gt;\u0026gt;(32-6) + b // [Min] b=II(d,a,b,c,M15,10,0xfe2ce6e0) d += (b ^ (a | ^c)) + X[(7*9)\u0026amp;15] + 4264355552 d = d\u0026lt;\u0026lt;10 | d\u0026gt;\u0026gt;(32-10) + a // [Min] c=II(c,d,a,b,M6,15,0xa3014314) c += (a ^ (d | ^b)) + X[(7*10)\u0026amp;15] + 2734768916 c = c\u0026lt;\u0026lt;15 | c\u0026gt;\u0026gt;(32-15) + d // [Min] d=II(b,c,d,a,M13,21,0x4e0811a1) b += (d ^ (c | ^a)) + X[(7*11)\u0026amp;15] + 1309151649 b = b\u0026lt;\u0026lt;21 | b\u0026gt;\u0026gt;(32-21) + c // [Min] a=II(a,b,c,d,M4,6,0xf7537e82) a += (c ^ (b | ^d)) + X[(7*12)\u0026amp;15] + 4149444226 a = a\u0026lt;\u0026lt;6 | a\u0026gt;\u0026gt;(32-6) + b // [Min] b=II(d,a,b,c,M11,10,0xbd3af235) d += (b ^ (a | ^c)) + X[(7*13)\u0026amp;15] + 3174756917 d = d\u0026lt;\u0026lt;10 | d\u0026gt;\u0026gt;(32-10) + a // [Min] c=II(c,d,a,b,M2,15,0x2ad7d2bb) c += (a ^ (d | ^b)) + X[(7*14)\u0026amp;15] + 718787259 c = c\u0026lt;\u0026lt;15 | c\u0026gt;\u0026gt;(32-15) + d // [Min] d=II(b,c,d,a,M9,21,0xeb86d391) b += (d ^ (c | ^a)) + X[(7*15)\u0026amp;15] + 3951481745 b = b\u0026lt;\u0026lt;21 | b\u0026gt;\u0026gt;(32-21) + c // [Min] 在原来的基础上加上经过4轮计算后的值 a += aa b += bb c += cc d += dd // [Min] 处理下一分块 p = p[chunk:] } // [Min] 设置最终摘要 dig.s[0] = a dig.s[1] = b dig.s[2] = c dig.s[3] = d }  3. SHA1 3.1 与 MD5 的比较  SHA1 摘要长度为20字节160位长 SHA1 与 MD5 相反，采用大字节序存储数值 SHA1 采用与 MD5 完全一致的分块方式 SHA1 块内按大字节序分为16组 uint32，再进行共计80次循环计算  3.2 SHA1 分块处理算法 https://en.wikipedia.org/wiki/SHA-1\n3.3 Go源码分析         sha1.go   sha1block.go    4. SHA2 　1. SHA2 是 SHA256，SHA224，SHA512，SHA384，SHA512-256，SHA512-224 的统称\n　2. SHA224 可以看成是以不同初始摘要计算的 SHA256 的截取\n　3. 同样，SHA384，SHA512-256，SHA512-224 可以看成是以不同初始摘要计算的 SHA512 的截取　4.1 SHA256，SHA224 4.1.1 与 MD5 的比较  SHA256 摘要长度为32字节256位长 SHA256 与 MD5 相反，采用大字节序存储数值 SHA256 采用与 MD5 完全一致的分块方式 SHA256 块内按大字节序分为16组 uint32，再以这16组数据为基础，按一定算法扩充至64组，最后再进行共计64次循环计算  4.1.2 SHA256 分块处理算法 https://en.wikipedia.org/wiki/SHA-2\n4.1.3 Go源码分析         sha256.go   sha256block.go    4.2 SHA512，SHA384，SHA512-256，SHA512-224 4.2.1 与 MD5 的比较  SHA512 摘要长度为64字节512位长 SHA512 与 MD5 相反，采用大字节序存储数值 SHA512 采用与 MD5 基本一致的分块方式，分块大小略有调整 分块大小由64字节512位变为128字节1024位， 最后一个分块末尾用来记录源数据字节长度的部分由8字节改为16字节 因为分块的长度改成了128字节，所以填充临界点位128-16=112字节 SHA512 块内按大字节序分为16组 uint64，再以这16组数据为基础，按一定算法扩充至80组，最后再进行共计80次循环计算  4.2.2 SHA512 分块处理算法 https://en.wikipedia.org/wiki/SHA-2\n4.2.3 Go源码分析         sha512.go   sha512block.go   ","date":1531999772,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1543733643,"objectID":"0f4cce3fd2bf8c96a22f74fdc3dce60d","permalink":"https://mooncaker816.github.io/2018/07/19/%E5%8D%95%E5%90%91%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0/","publishdate":"2018-07-19T19:29:32+08:00","relpermalink":"/2018/07/19/%E5%8D%95%E5%90%91%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0/","section":"post","summary":"1 概念 单向散列函数，又称单向Hash函数、杂凑函数，就是把任意长的输入消息串变化成固定长的输出串且由输出串难以得到输入串的一种函数。这个输出","tags":["单向散列函数"],"title":"单向散列函数","type":"post"},{"authors":null,"categories":["Golang"],"content":"1. Filepath包概要 1.1 概述  Package filepath implements utility routines for manipulating filename paths in a way compatible with the target operating system-defined file paths.\n 　filepath包实现了对不同操作系统的文件路径的统一操作\n The filepath package uses either forward slashes or backslashes, depending on the operating system. To process paths such as URLs that always use forward slashes regardless of the operating system, see the path package.\n 　根据不同的操作系统，该包既可以处理以正斜杠/为分隔的路径，也可以处理以反斜杠\\为分隔的路径。对于 URL 的处理，总是使用正斜杠/，无关操作系统。\n 1.2 包结构 ├── example_test.go ├── example_unix_test.go ├── export_test.go ├── export_windows_test.go ├── match.go ├── match_test.go ├── path.go ├── path_plan9.go ├── path_test.go ├── path_unix.go ├── path_windows.go ├── path_windows_test.go ├── symlink.go ├── symlink_unix.go └── symlink_windows.go  2. 深入filepath包 2.1 path.go \u0026amp; path_test.go 2.1.1 Clean 签名：func Clean(path string) string\n用途：对路径进行格式化，与path.Clean基本一致，windows 系统的根目录为C:\\\n示例：https://play.golang.org/p/UZqq84JBFet\n// Already clean {\u0026quot;abc\u0026quot; =\u0026gt; \u0026quot;abc\u0026quot;}, {\u0026quot;abc/def\u0026quot; =\u0026gt; \u0026quot;abc/def\u0026quot;}, {\u0026quot;a/b/c\u0026quot; =\u0026gt; \u0026quot;a/b/c\u0026quot;}, {\u0026quot;.\u0026quot; =\u0026gt; \u0026quot;.\u0026quot;}, {\u0026quot;..\u0026quot; =\u0026gt; \u0026quot;..\u0026quot;}, {\u0026quot;../..\u0026quot; =\u0026gt; \u0026quot;../..\u0026quot;}, {\u0026quot;../../abc\u0026quot; =\u0026gt; \u0026quot;../../abc\u0026quot;}, {\u0026quot;/abc\u0026quot; =\u0026gt; \u0026quot;/abc\u0026quot;}, {\u0026quot;/\u0026quot; =\u0026gt; \u0026quot;/\u0026quot;}, // Empty is current dir {\u0026quot;\u0026quot; =\u0026gt; \u0026quot;.\u0026quot;}, // Remove trailing slash {\u0026quot;abc/\u0026quot; =\u0026gt; \u0026quot;abc\u0026quot;}, {\u0026quot;abc/def/\u0026quot; =\u0026gt; \u0026quot;abc/def\u0026quot;}, {\u0026quot;a/b/c/\u0026quot; =\u0026gt; \u0026quot;a/b/c\u0026quot;}, {\u0026quot;./\u0026quot; =\u0026gt; \u0026quot;.\u0026quot;}, {\u0026quot;../\u0026quot; =\u0026gt; \u0026quot;..\u0026quot;}, {\u0026quot;../../\u0026quot; =\u0026gt; \u0026quot;../..\u0026quot;}, {\u0026quot;/abc/\u0026quot; =\u0026gt; \u0026quot;/abc\u0026quot;}, // Remove doubled slash {\u0026quot;abc//def//ghi\u0026quot; =\u0026gt; \u0026quot;abc/def/ghi\u0026quot;}, {\u0026quot;//abc\u0026quot; =\u0026gt; \u0026quot;/abc\u0026quot;}, {\u0026quot;///abc\u0026quot; =\u0026gt; \u0026quot;/abc\u0026quot;}, {\u0026quot;//abc//\u0026quot; =\u0026gt; \u0026quot;/abc\u0026quot;}, {\u0026quot;abc//\u0026quot; =\u0026gt; \u0026quot;abc\u0026quot;}, // Remove . elements {\u0026quot;abc/./def\u0026quot; =\u0026gt; \u0026quot;abc/def\u0026quot;}, {\u0026quot;/./abc/def\u0026quot; =\u0026gt; \u0026quot;/abc/def\u0026quot;}, {\u0026quot;abc/.\u0026quot; =\u0026gt; \u0026quot;abc\u0026quot;}, // Remove .. elements {\u0026quot;abc/def/ghi/../jkl\u0026quot; =\u0026gt; \u0026quot;abc/def/jkl\u0026quot;}, {\u0026quot;abc/def/../ghi/../jkl\u0026quot; =\u0026gt; \u0026quot;abc/jkl\u0026quot;}, {\u0026quot;abc/def/..\u0026quot; =\u0026gt; \u0026quot;abc\u0026quot;}, {\u0026quot;abc/def/../..\u0026quot; =\u0026gt; \u0026quot;.\u0026quot;}, {\u0026quot;/abc/def/../..\u0026quot; =\u0026gt; \u0026quot;/\u0026quot;}, {\u0026quot;abc/def/../../..\u0026quot; =\u0026gt; \u0026quot;..\u0026quot;}, {\u0026quot;/abc/def/../../..\u0026quot; =\u0026gt; \u0026quot;/\u0026quot;}, {\u0026quot;abc/def/../../../ghi/jkl/../../../mno\u0026quot; =\u0026gt; \u0026quot;../../mno\u0026quot;}, {\u0026quot;/../abc\u0026quot; =\u0026gt; \u0026quot;/abc\u0026quot;}, // Combinations {\u0026quot;abc/./../def\u0026quot; =\u0026gt; \u0026quot;def\u0026quot;}, {\u0026quot;abc//./../def\u0026quot; =\u0026gt; \u0026quot;def\u0026quot;}, {\u0026quot;abc/../../././../def\u0026quot; =\u0026gt; \u0026quot;../../def\u0026quot;}, {`c:` =\u0026gt; `c:.`}, {`c:\\` =\u0026gt; `c:\\`}, {`c:\\abc` =\u0026gt; `c:\\abc`}, {`c:abc\\..\\..\\.\\.\\..\\def` =\u0026gt; `c:..\\..\\def`}, {`c:\\abc\\def\\..\\..` =\u0026gt; `c:\\`}, {`c:\\..\\abc` =\u0026gt; `c:\\abc`}, {`c:..\\abc` =\u0026gt; `c:..\\abc`}, {`\\` =\u0026gt; `\\`}, {`/` =\u0026gt; `\\`}, {`\\\\i\\..\\c$` =\u0026gt; `\\c$`}, {`\\\\i\\..\\i\\c$` =\u0026gt; `\\i\\c$`}, {`\\\\i\\..\\I\\c$` =\u0026gt; `\\I\\c$`}, {`\\\\host\\share\\foo\\..\\bar` =\u0026gt; `\\\\host\\share\\bar`}, {`//host/share/foo/../baz` =\u0026gt; `\\\\host\\share\\baz`}, {`\\\\a\\b\\..\\c` =\u0026gt; `\\\\a\\b\\c`}, {`\\\\a\\b` =\u0026gt; `\\\\a\\b`},  2.1.2 ToSlash \u0026amp; FromSlash 签名：func ToSlash(path string) string \u0026amp; func FromSlash(path string) string\n用途：将路径中的分隔符替换为/ \u0026amp; 将路径中的/分隔符替换为系统对应的分隔符\n示例：https://play.golang.org/p/FB-HZSqbuSd\n{\u0026quot;\u0026quot;, \u0026quot;\u0026quot;}, {\u0026quot;/\u0026quot;, string(sep)}, {\u0026quot;/a/b\u0026quot;, string([]byte{sep, 'a', sep, 'b'})}, {\u0026quot;a//b\u0026quot;, string([]byte{'a', sep, sep, 'b'})},  2.1.3 SplitList 签名：func SplitList(path string) []string\n用途：根据系统的 List分隔符（如环境变量PATH中包含的多个路径之间的: ;）,将List路径拆分成单个路径组成的 slice，若List路径为空，则返回空 slice\n示例：https://play.golang.org/p/bQOhCR4kvFq\n{\u0026quot;\u0026quot;, []string{}}, {string([]byte{'a', lsep, 'b'}), []string{\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;}}, {string([]byte{lsep, 'a', lsep, 'b'}), []string{\u0026quot;\u0026quot;, \u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;}}, // quoted {`\u0026quot;a\u0026quot;`, []string{`a`}}, // semicolon {`\u0026quot;;\u0026quot;`, []string{`;`}}, {`\u0026quot;a;b\u0026quot;`, []string{`a;b`}}, {`\u0026quot;;\u0026quot;;`, []string{`;`, ``}}, {`;\u0026quot;;\u0026quot;`, []string{``, `;`}}, // partially quoted {`a\u0026quot;;\u0026quot;b`, []string{`a;b`}}, {`a; \u0026quot;\u0026quot;b`, []string{`a`, ` b`}}, {`\u0026quot;a;b`, []string{`a;b`}}, {`\u0026quot;\u0026quot;a;b`, []string{`a`, `b`}}, {`\u0026quot;\u0026quot;\u0026quot;a;b`, []string{`a;b`}}, {`\u0026quot;\u0026quot;\u0026quot;\u0026quot;a;b`, []string{`a`, `b`}}, {`a\u0026quot;;b`, []string{`a;b`}}, {`a;b\u0026quot;;c`, []string{`a`, `b;c`}}, {`\u0026quot;a\u0026quot;;b\u0026quot;;c`, []string{`a`, `b;c`}},  2.1.4 Split 签名：func Split(path string) (dir, file string)\n用途：拆分路径为目录+文件名\n示例：https://play.golang.org/p/ABl-Ph464rW\n{\u0026quot;a/b\u0026quot;, \u0026quot;a/\u0026quot;, \u0026quot;b\u0026quot;}, {\u0026quot;a/b/\u0026quot;, \u0026quot;a/b/\u0026quot;, \u0026quot;\u0026quot;}, {\u0026quot;a/\u0026quot;, \u0026quot;a/\u0026quot;, \u0026quot;\u0026quot;}, {\u0026quot;a\u0026quot;, \u0026quot;\u0026quot;, \u0026quot;a\u0026quot;}, {\u0026quot;/\u0026quot;, \u0026quot;/\u0026quot;, \u0026quot;\u0026quot;}, {`c:`, `c:`, ``}, {`c:/`, `c:/`, ``}, {`c:/foo`, `c:/`, `foo`}, {`c:/foo/bar`, `c:/foo/`, `bar`}, {`//host/share`, `//host/share`, ``}, {`//host/share/`, `//host/share/`, ``}, {`//host/share/foo`, `//host/share/`, `foo`}, {`\\\\host\\share`, `\\\\host\\share`, ``}, {`\\\\host\\share\\`, `\\\\host\\share\\`, ``}, {`\\\\host\\share\\foo`, `\\\\host\\share\\`, `foo`},  2.1.5 Join 签名：func Join(elem ...string) string\n用途：拼接路径\n示例：https://play.golang.org/p/RRhT3gH_SCJ\n// zero parameters {[]string{}, \u0026quot;\u0026quot;}, // one parameter {[]string{\u0026quot;\u0026quot;}, \u0026quot;\u0026quot;}, {[]string{\u0026quot;/\u0026quot;}, \u0026quot;/\u0026quot;}, {[]string{\u0026quot;a\u0026quot;}, \u0026quot;a\u0026quot;}, // two parameters {[]string{\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;}, \u0026quot;a/b\u0026quot;}, {[]string{\u0026quot;a\u0026quot;, \u0026quot;\u0026quot;}, \u0026quot;a\u0026quot;}, {[]string{\u0026quot;\u0026quot;, \u0026quot;b\u0026quot;}, \u0026quot;b\u0026quot;}, {[]string{\u0026quot;/\u0026quot;, \u0026quot;a\u0026quot;}, \u0026quot;/a\u0026quot;}, {[]string{\u0026quot;/\u0026quot;, \u0026quot;a/b\u0026quot;}, \u0026quot;/a/b\u0026quot;}, {[]string{\u0026quot;/\u0026quot;, \u0026quot;\u0026quot;}, \u0026quot;/\u0026quot;}, {[]string{\u0026quot;//\u0026quot;, \u0026quot;a\u0026quot;}, \u0026quot;/a\u0026quot;}, {[]string{\u0026quot;/a\u0026quot;, \u0026quot;b\u0026quot;}, \u0026quot;/a/b\u0026quot;}, {[]string{\u0026quot;a/\u0026quot;, \u0026quot;b\u0026quot;}, \u0026quot;a/b\u0026quot;}, {[]string{\u0026quot;a/\u0026quot;, \u0026quot;\u0026quot;}, \u0026quot;a\u0026quot;}, {[]string{\u0026quot;\u0026quot;, \u0026quot;\u0026quot;}, \u0026quot;\u0026quot;}, // three parameters {[]string{\u0026quot;/\u0026quot;, \u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;}, \u0026quot;/a/b\u0026quot;}, {[]string{`directory`, `file`}, `directory\\file`}, {[]string{`C:\\Windows\\`, `System32`}, `C:\\Windows\\System32`}, {[]string{`C:\\Windows\\`, ``}, `C:\\Windows`}, {[]string{`C:\\`, `Windows`}, `C:\\Windows`}, {[]string{`C:`, `a`}, `C:a`}, {[]string{`C:`, `a\\b`}, `C:a\\b`}, {[]string{`C:`, `a`, `b`}, `C:a\\b`}, {[]string{`C:.`, `a`}, `C:a`}, {[]string{`C:a`, `b`}, `C:a\\b`}, {[]string{`C:a`, `b`, `d`}, `C:a\\b\\d`}, {[]string{`\\\\host\\share`, `foo`}, `\\\\host\\share\\foo`}, {[]string{`\\\\host\\share\\foo`}, `\\\\host\\share\\foo`}, {[]string{`//host/share`, `foo/bar`}, `\\\\host\\share\\foo\\bar`}, {[]string{`\\`}, `\\`}, {[]string{`\\`, ``}, `\\`}, {[]string{`\\`, `a`}, `\\a`}, {[]string{`\\\\`, `a`}, `\\a`}, {[]string{`\\`, `a`, `b`}, `\\a\\b`}, {[]string{`\\\\`, `a`, `b`}, `\\a\\b`}, {[]string{`\\`, `\\\\a\\b`, `c`}, `\\a\\b\\c`}, {[]string{`\\\\a`, `b`, `c`}, `\\a\\b\\c`}, {[]string{`\\\\a\\`, `b`, `c`}, `\\a\\b\\c`},  2.1.6 Ext 签名：func Ext(path string) string\n用途：根据最后一个元素中的最后一个.，返回路径中文件的扩展名，若没有.，返回空\n示例：https://play.golang.org/p/K5TZl6W-ByS\n{\u0026quot;path.go\u0026quot;, \u0026quot;.go\u0026quot;}, {\u0026quot;path.pb.go\u0026quot;, \u0026quot;.go\u0026quot;}, {\u0026quot;a.dir/b\u0026quot;, \u0026quot;\u0026quot;}, {\u0026quot;a.dir/b.go\u0026quot;, \u0026quot;.go\u0026quot;}, {\u0026quot;a.dir/\u0026quot;, \u0026quot;\u0026quot;},  2.1.7 EvalSymlinks 签名：func EvalSymlinks(path string) (string, error)\n用途：对symlink文件解引用，并对结果路径格式化\n示例：https://play.golang.org/p/3RwUZ9tfHos (run local)\n2.1.8 Abs 签名：func Abs(path string) (string, error)\n用途：返回绝对路径并格式化，如果给定的路径不是绝对路径，则会加上当前目录形成绝对路径\n示例：https://play.golang.org/p/UMr9_z4AsWR\n2.1.9 Rel 签名：func Rel(basepath, targpath string) (string, error)\n用途：根据 basepath 将 targpath 以相对路径的方式返回，并格式化\n示例：https://play.golang.org/p/KFoNtsbW68D\n{\u0026quot;a/b\u0026quot;, \u0026quot;a/b\u0026quot;, \u0026quot;.\u0026quot;}, {\u0026quot;a/b/.\u0026quot;, \u0026quot;a/b\u0026quot;, \u0026quot;.\u0026quot;}, {\u0026quot;a/b\u0026quot;, \u0026quot;a/b/.\u0026quot;, \u0026quot;.\u0026quot;}, {\u0026quot;./a/b\u0026quot;, \u0026quot;a/b\u0026quot;, \u0026quot;.\u0026quot;}, {\u0026quot;a/b\u0026quot;, \u0026quot;./a/b\u0026quot;, \u0026quot;.\u0026quot;}, {\u0026quot;ab/cd\u0026quot;, \u0026quot;ab/cde\u0026quot;, \u0026quot;../cde\u0026quot;}, {\u0026quot;ab/cd\u0026quot;, \u0026quot;ab/c\u0026quot;, \u0026quot;../c\u0026quot;}, {\u0026quot;a/b\u0026quot;, \u0026quot;a/b/c/d\u0026quot;, \u0026quot;c/d\u0026quot;}, {\u0026quot;a/b\u0026quot;, \u0026quot;a/b/../c\u0026quot;, \u0026quot;../c\u0026quot;}, {\u0026quot;a/b/../c\u0026quot;, \u0026quot;a/b\u0026quot;, \u0026quot;../b\u0026quot;}, {\u0026quot;a/b/c\u0026quot;, \u0026quot;a/c/d\u0026quot;, \u0026quot;../../c/d\u0026quot;}, {\u0026quot;a/b\u0026quot;, \u0026quot;c/d\u0026quot;, \u0026quot;../../c/d\u0026quot;}, {\u0026quot;a/b/c/d\u0026quot;, \u0026quot;a/b\u0026quot;, \u0026quot;../..\u0026quot;}, {\u0026quot;a/b/c/d\u0026quot;, \u0026quot;a/b/\u0026quot;, \u0026quot;../..\u0026quot;}, {\u0026quot;a/b/c/d/\u0026quot;, \u0026quot;a/b\u0026quot;, \u0026quot;../..\u0026quot;}, {\u0026quot;a/b/c/d/\u0026quot;, \u0026quot;a/b/\u0026quot;, \u0026quot;../..\u0026quot;}, {\u0026quot;../../a/b\u0026quot;, \u0026quot;../../a/b/c/d\u0026quot;, \u0026quot;c/d\u0026quot;}, {\u0026quot;/a/b\u0026quot;, \u0026quot;/a/b\u0026quot;, \u0026quot;.\u0026quot;}, {\u0026quot;/a/b/.\u0026quot;, \u0026quot;/a/b\u0026quot;, \u0026quot;.\u0026quot;}, {\u0026quot;/a/b\u0026quot;, \u0026quot;/a/b/.\u0026quot;, \u0026quot;.\u0026quot;}, {\u0026quot;/ab/cd\u0026quot;, \u0026quot;/ab/cde\u0026quot;, \u0026quot;../cde\u0026quot;}, {\u0026quot;/ab/cd\u0026quot;, \u0026quot;/ab/c\u0026quot;, \u0026quot;../c\u0026quot;}, {\u0026quot;/a/b\u0026quot;, \u0026quot;/a/b/c/d\u0026quot;, \u0026quot;c/d\u0026quot;}, {\u0026quot;/a/b\u0026quot;, \u0026quot;/a/b/../c\u0026quot;, \u0026quot;../c\u0026quot;}, {\u0026quot;/a/b/../c\u0026quot;, \u0026quot;/a/b\u0026quot;, \u0026quot;../b\u0026quot;}, {\u0026quot;/a/b/c\u0026quot;, \u0026quot;/a/c/d\u0026quot;, \u0026quot;../../c/d\u0026quot;}, {\u0026quot;/a/b\u0026quot;, \u0026quot;/c/d\u0026quot;, \u0026quot;../../c/d\u0026quot;}, {\u0026quot;/a/b/c/d\u0026quot;, \u0026quot;/a/b\u0026quot;, \u0026quot;../..\u0026quot;}, {\u0026quot;/a/b/c/d\u0026quot;, \u0026quot;/a/b/\u0026quot;, \u0026quot;../..\u0026quot;}, {\u0026quot;/a/b/c/d/\u0026quot;, \u0026quot;/a/b\u0026quot;, \u0026quot;../..\u0026quot;}, {\u0026quot;/a/b/c/d/\u0026quot;, \u0026quot;/a/b/\u0026quot;, \u0026quot;../..\u0026quot;}, {\u0026quot;/../../a/b\u0026quot;, \u0026quot;/../../a/b/c/d\u0026quot;, \u0026quot;c/d\u0026quot;}, {\u0026quot;.\u0026quot;, \u0026quot;a/b\u0026quot;, \u0026quot;a/b\u0026quot;}, {\u0026quot;.\u0026quot;, \u0026quot;..\u0026quot;, \u0026quot;..\u0026quot;}, // can't do purely lexically {\u0026quot;..\u0026quot;, \u0026quot;.\u0026quot;, \u0026quot;err\u0026quot;}, {\u0026quot;..\u0026quot;, \u0026quot;a\u0026quot;, \u0026quot;err\u0026quot;}, {\u0026quot;../..\u0026quot;, \u0026quot;..\u0026quot;, \u0026quot;err\u0026quot;}, {\u0026quot;a\u0026quot;, \u0026quot;/a\u0026quot;, \u0026quot;err\u0026quot;}, {\u0026quot;/a\u0026quot;, \u0026quot;a\u0026quot;, \u0026quot;err\u0026quot;}, {`C:a\\b\\c`, `C:a/b/d`, `..\\d`}, {`C:\\`, `D:\\`, `err`}, {`C:`, `D:`, `err`}, {`C:\\Projects`, `c:\\projects\\src`, `src`}, {`C:\\Projects`, `c:\\projects`, `.`}, {`C:\\Projects\\a\\..`, `c:\\projects`, `.`},  2.1.10 Walk 签名：func Walk(root string, walkFn WalkFunc) error\n用途：用于遍历目录树\n示例：https://play.golang.org/p/1fYRtezNBX-\ntype WalkFunc func(path string, info os.FileInfo, err error) error WalkFunc 函数一般是一个闭包，用于处理目录树中的每个文件/目录，如：\nerrors := make([]error, 0, 10) clear := true markFn := func(path string, info os.FileInfo, err error) error { return mark(info, err, \u0026amp;errors, clear) } // Expect no errors. err := filepath.Walk(tree.name, markFn)  2.1.11 Base 签名：func Base(path string) string\n用途：返回最后一个元素，如果路径为空，则返回.，如果路径全是分隔符，则返回单个分隔符\n示例：https://play.golang.org/p/0F6PSQjwOTX\n{\u0026quot;\u0026quot;, \u0026quot;.\u0026quot;}, {\u0026quot;.\u0026quot;, \u0026quot;.\u0026quot;}, {\u0026quot;/.\u0026quot;, \u0026quot;.\u0026quot;}, {\u0026quot;/\u0026quot;, \u0026quot;/\u0026quot;}, {\u0026quot;////\u0026quot;, \u0026quot;/\u0026quot;}, {\u0026quot;x/\u0026quot;, \u0026quot;x\u0026quot;}, {\u0026quot;abc\u0026quot;, \u0026quot;abc\u0026quot;}, {\u0026quot;abc/def\u0026quot;, \u0026quot;def\u0026quot;}, {\u0026quot;a/b/.x\u0026quot;, \u0026quot;.x\u0026quot;}, {\u0026quot;a/b/c.\u0026quot;, \u0026quot;c.\u0026quot;}, {\u0026quot;a/b/c.x\u0026quot;, \u0026quot;c.x\u0026quot;}, {`c:\\`, `\\`}, {`c:.`, `.`}, {`c:\\a\\b`, `b`}, {`c:a\\b`, `b`}, {`c:a\\b\\c`, `c`}, {`\\\\host\\share\\`, `\\`}, {`\\\\host\\share\\a`, `a`}, {`\\\\host\\share\\a\\b`, `b`},  2.1.12 Dir 签名：func Dir(path string) string\n用途：返回除去最后一个元素的路径，并格式化。如果路径为空，返回.，如果路径全是分隔符，返回单个分隔符，返回的路径不以分隔符结尾，除非该路径为根目录\n示例：https://play.golang.org/p/-6CrUtV9_CO\n{\u0026quot;\u0026quot;, \u0026quot;.\u0026quot;}, {\u0026quot;.\u0026quot;, \u0026quot;.\u0026quot;}, {\u0026quot;/.\u0026quot;, \u0026quot;/\u0026quot;}, {\u0026quot;/\u0026quot;, \u0026quot;/\u0026quot;}, {\u0026quot;////\u0026quot;, \u0026quot;/\u0026quot;}, {\u0026quot;/foo\u0026quot;, \u0026quot;/\u0026quot;}, {\u0026quot;x/\u0026quot;, \u0026quot;x\u0026quot;}, {\u0026quot;abc\u0026quot;, \u0026quot;.\u0026quot;}, {\u0026quot;abc/def\u0026quot;, \u0026quot;abc\u0026quot;}, {\u0026quot;a/b/.x\u0026quot;, \u0026quot;a/b\u0026quot;}, {\u0026quot;a/b/c.\u0026quot;, \u0026quot;a/b\u0026quot;}, {\u0026quot;a/b/c.x\u0026quot;, \u0026quot;a/b\u0026quot;}, {`c:\\`, `c:\\`}, {`c:.`, `c:.`}, {`c:\\a\\b`, `c:\\a`}, {`c:a\\b`, `c:a`}, {`c:a\\b\\c`, `c:a\\b`}, {`\\\\host\\share`, `\\\\host\\share`}, {`\\\\host\\share\\`, `\\\\host\\share\\`}, {`\\\\host\\share\\a`, `\\\\host\\share\\`}, {`\\\\host\\share\\a\\b`, `\\\\host\\share\\a`},  2.1.13 VolumeName 签名：func VolumeName(path string) string\n用途：Windows系统返回卷名，其他系统返回空\n示例：https://play.golang.org/p/uxvpRgAy9Lg\n{`c:/foo/bar`, `c:`}, {`c:`, `c:`}, {`2:`, ``}, {``, ``}, {`\\\\\\host`, ``}, {`\\\\\\host\\`, ``}, {`\\\\\\host\\share`, ``}, {`\\\\\\host\\\\share`, ``}, {`\\\\host`, ``}, {`//host`, ``}, {`\\\\host\\`, ``}, {`//host/`, ``}, {`\\\\host\\share`, `\\\\host\\share`}, {`//host/share`, `//host/share`}, {`\\\\host\\share\\`, `\\\\host\\share`}, {`//host/share/`, `//host/share`}, {`\\\\host\\share\\foo`, `\\\\host\\share`}, {`//host/share/foo`, `//host/share`}, {`\\\\host\\share\\\\foo\\\\\\bar\\\\\\\\baz`, `\\\\host\\share`}, {`//host/share//foo///bar////baz`, `//host/share`}, {`\\\\host\\share\\foo\\..\\bar`, `\\\\host\\share`}, {`//host/share/foo/../bar`, `//host/share`},  2.1.14 IsAbs 签名：func IsAbs(path string) bool\n用途：判断是否为绝对路径，在 Unix 中，以/开始；在 Windows 中以某个盘符开始\n示例：https://play.golang.org/p/JV2dVvYUaYP\n{\u0026quot;\u0026quot;, false}, {\u0026quot;/\u0026quot;, true}, {\u0026quot;/usr/bin/gcc\u0026quot;, true}, {\u0026quot;..\u0026quot;, false}, {\u0026quot;/a/../bb\u0026quot;, true}, {\u0026quot;.\u0026quot;, false}, {\u0026quot;./\u0026quot;, false}, {\u0026quot;lala\u0026quot;, false},  2.2 match.go \u0026amp; match_test.go 2.2.1 Match 签名：func Match(pattern, name string) (matched bool, err error)\n用途：同path.Match\n示例：https://play.golang.org/p/N5knl-o3yWM\n{\u0026quot;abc\u0026quot;, \u0026quot;abc\u0026quot;, true, nil}, {\u0026quot;*\u0026quot;, \u0026quot;abc\u0026quot;, true, nil}, {\u0026quot;*c\u0026quot;, \u0026quot;abc\u0026quot;, true, nil}, {\u0026quot;a*\u0026quot;, \u0026quot;a\u0026quot;, true, nil}, {\u0026quot;a*\u0026quot;, \u0026quot;abc\u0026quot;, true, nil}, {\u0026quot;a*\u0026quot;, \u0026quot;ab/c\u0026quot;, false, nil}, {\u0026quot;a*/b\u0026quot;, \u0026quot;abc/b\u0026quot;, true, nil}, {\u0026quot;a*/b\u0026quot;, \u0026quot;a/c/b\u0026quot;, false, nil}, {\u0026quot;a*b*c*d*e*/f\u0026quot;, \u0026quot;axbxcxdxe/f\u0026quot;, true, nil}, {\u0026quot;a*b*c*d*e*/f\u0026quot;, \u0026quot;axbxcxdxexxx/f\u0026quot;, true, nil}, {\u0026quot;a*b*c*d*e*/f\u0026quot;, \u0026quot;axbxcxdxe/xxx/f\u0026quot;, false, nil}, {\u0026quot;a*b*c*d*e*/f\u0026quot;, \u0026quot;axbxcxdxexxx/fff\u0026quot;, false, nil}, {\u0026quot;a*b?c*x\u0026quot;, \u0026quot;abxbbxdbxebxczzx\u0026quot;, true, nil}, {\u0026quot;a*b?c*x\u0026quot;, \u0026quot;abxbbxdbxebxczzy\u0026quot;, false, nil}, {\u0026quot;ab[c]\u0026quot;, \u0026quot;abc\u0026quot;, true, nil}, {\u0026quot;ab[b-d]\u0026quot;, \u0026quot;abc\u0026quot;, true, nil}, {\u0026quot;ab[e-g]\u0026quot;, \u0026quot;abc\u0026quot;, false, nil}, {\u0026quot;ab[^c]\u0026quot;, \u0026quot;abc\u0026quot;, false, nil}, {\u0026quot;ab[^b-d]\u0026quot;, \u0026quot;abc\u0026quot;, false, nil}, {\u0026quot;ab[^e-g]\u0026quot;, \u0026quot;abc\u0026quot;, true, nil}, {\u0026quot;a\\\\*b\u0026quot;, \u0026quot;a*b\u0026quot;, true, nil}, {\u0026quot;a\\\\*b\u0026quot;, \u0026quot;ab\u0026quot;, false, nil}, {\u0026quot;a?b\u0026quot;, \u0026quot;a☺b\u0026quot;, true, nil}, {\u0026quot;a[^a]b\u0026quot;, \u0026quot;a☺b\u0026quot;, true, nil}, {\u0026quot;a???b\u0026quot;, \u0026quot;a☺b\u0026quot;, false, nil}, {\u0026quot;a[^a][^a][^a]b\u0026quot;, \u0026quot;a☺b\u0026quot;, false, nil}, {\u0026quot;[a-ζ]*\u0026quot;, \u0026quot;α\u0026quot;, true, nil}, {\u0026quot;*[a-ζ]\u0026quot;, \u0026quot;A\u0026quot;, false, nil}, {\u0026quot;a?b\u0026quot;, \u0026quot;a/b\u0026quot;, false, nil}, {\u0026quot;a*b\u0026quot;, \u0026quot;a/b\u0026quot;, false, nil}, {\u0026quot;[\\\\]a]\u0026quot;, \u0026quot;]\u0026quot;, true, nil}, {\u0026quot;[\\\\-]\u0026quot;, \u0026quot;-\u0026quot;, true, nil}, {\u0026quot;[x\\\\-]\u0026quot;, \u0026quot;x\u0026quot;, true, nil}, {\u0026quot;[x\\\\-]\u0026quot;, \u0026quot;-\u0026quot;, true, nil}, {\u0026quot;[x\\\\-]\u0026quot;, \u0026quot;z\u0026quot;, false, nil}, {\u0026quot;[\\\\-x]\u0026quot;, \u0026quot;x\u0026quot;, true, nil}, {\u0026quot;[\\\\-x]\u0026quot;, \u0026quot;-\u0026quot;, true, nil}, {\u0026quot;[\\\\-x]\u0026quot;, \u0026quot;a\u0026quot;, false, nil}, {\u0026quot;[]a]\u0026quot;, \u0026quot;]\u0026quot;, false, ErrBadPattern}, {\u0026quot;[-]\u0026quot;, \u0026quot;-\u0026quot;, false, ErrBadPattern}, {\u0026quot;[x-]\u0026quot;, \u0026quot;x\u0026quot;, false, ErrBadPattern}, {\u0026quot;[x-]\u0026quot;, \u0026quot;-\u0026quot;, false, ErrBadPattern}, {\u0026quot;[x-]\u0026quot;, \u0026quot;z\u0026quot;, false, ErrBadPattern}, {\u0026quot;[-x]\u0026quot;, \u0026quot;x\u0026quot;, false, ErrBadPattern}, {\u0026quot;[-x]\u0026quot;, \u0026quot;-\u0026quot;, false, ErrBadPattern}, {\u0026quot;[-x]\u0026quot;, \u0026quot;a\u0026quot;, false, ErrBadPattern}, {\u0026quot;\\\\\u0026quot;, \u0026quot;a\u0026quot;, false, ErrBadPattern}, {\u0026quot;[a-b-c]\u0026quot;, \u0026quot;a\u0026quot;, false, ErrBadPattern}, {\u0026quot;[\u0026quot;, \u0026quot;a\u0026quot;, false, ErrBadPattern}, {\u0026quot;[^\u0026quot;, \u0026quot;a\u0026quot;, false, ErrBadPattern}, {\u0026quot;[^bc\u0026quot;, \u0026quot;a\u0026quot;, false, ErrBadPattern}, {\u0026quot;a[\u0026quot;, \u0026quot;a\u0026quot;, false, nil}, {\u0026quot;a[\u0026quot;, \u0026quot;ab\u0026quot;, false, ErrBadPattern}, {\u0026quot;*x\u0026quot;, \u0026quot;xxx\u0026quot;, true, nil},  2.2.2 Glob 签名：func Glob(pattern string) (matches []string, err error)\n用途：列出与指定的模式 pattern 完全匹配的文件或目录（匹配原则同Match）\n示例：https://play.golang.org/p/GxqJkYQp_xm (run local)\n","date":1529998758,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1543733643,"objectID":"7c678951136e8bc80a254ac081b0fae5","permalink":"https://mooncaker816.github.io/2018/06/26/filepath/","publishdate":"2018-06-26T15:39:18+08:00","relpermalink":"/2018/06/26/filepath/","section":"post","summary":"1. Filepath包概要 1.1 概述","tags":["Filepath"],"title":"Filepath","type":"post"},{"authors":null,"categories":["Golang"],"content":"1. Path包概要 1.1 概述  Package path implements utility routines for manipulating slash-separated paths.\n 　path 包实现了对以/为分隔的路径的操作\n The path package should only be used for paths separated by forward slashes, such as the paths in URLs. This package does not deal with Windows paths with drive letters or backslashes; to manipulate operating system paths, use the path/filepath package.\n 　该包只能用于对以正斜杠/为分隔的路径的处理，比如 URL，而不能处理带有windows中的盘符或者反斜杠\\的路径，对于这类路径的处理需要使用 path/filepath 包\n1.2 包结构 ├── example_test.go ├── match.go ├── match_test.go ├── path.go └── path_test.go  2. 深入path包 2.1 path.go \u0026amp; path_test.go 2.1.1 Clean 签名：func Clean(path string) string\n用途：Clean函数主要是对给定路径进行以下格式化：\n 替换多个斜杠//为单个斜杠/ 消除. 消除\u0008..当且仅当前一个元素\u0008不是.. 替换绝对路径开头的/..为/ 格式化后的路径不以/结尾，除非该路径\u0008就是根路径/ \u0008若格式化后路径为空，则返回.  示例：https://play.golang.org/p/Ya85iuk0uMU\n// Already clean \u0026quot;\u0026quot; =\u0026gt; \u0026quot;.\u0026quot; \u0026quot;abc\u0026quot; =\u0026gt; \u0026quot;abc\u0026quot; \u0026quot;abc/def\u0026quot; =\u0026gt; \u0026quot;abc/def\u0026quot; \u0026quot;a/b/c\u0026quot; =\u0026gt; \u0026quot;a/b/c\u0026quot; \u0026quot;.\u0026quot; =\u0026gt; \u0026quot;.\u0026quot; \u0026quot;..\u0026quot; =\u0026gt; \u0026quot;..\u0026quot; \u0026quot;../..\u0026quot; =\u0026gt; \u0026quot;../..\u0026quot; \u0026quot;../../abc\u0026quot; =\u0026gt; \u0026quot;../../abc\u0026quot; \u0026quot;/abc\u0026quot; =\u0026gt; \u0026quot;/abc\u0026quot; \u0026quot;/\u0026quot; =\u0026gt; \u0026quot;/\u0026quot; // Remove trailing slash \u0026quot;abc/\u0026quot; =\u0026gt; \u0026quot;abc\u0026quot; \u0026quot;abc/def/\u0026quot; =\u0026gt; \u0026quot;abc/def\u0026quot; \u0026quot;a/b/c/\u0026quot; =\u0026gt; \u0026quot;a/b/c\u0026quot; \u0026quot;./\u0026quot; =\u0026gt; \u0026quot;.\u0026quot; \u0026quot;../\u0026quot; =\u0026gt; \u0026quot;..\u0026quot; \u0026quot;../../\u0026quot; =\u0026gt; \u0026quot;../..\u0026quot; \u0026quot;/abc/\u0026quot; =\u0026gt; \u0026quot;/abc\u0026quot; // Remove doubled slash \u0026quot;abc//def//ghi\u0026quot; =\u0026gt; \u0026quot;abc/def/ghi\u0026quot; \u0026quot;//abc\u0026quot; =\u0026gt; \u0026quot;/abc\u0026quot; \u0026quot;///abc\u0026quot; =\u0026gt; \u0026quot;/abc\u0026quot; \u0026quot;//abc//\u0026quot; =\u0026gt; \u0026quot;/abc\u0026quot; \u0026quot;abc//\u0026quot; =\u0026gt; \u0026quot;abc\u0026quot; \u0026quot;abc/./def\u0026quot; =\u0026gt; \u0026quot;abc/def\u0026quot; \u0026quot;/./abc/def\u0026quot; =\u0026gt; \u0026quot;/abc/def\u0026quot; \u0026quot;abc/.\u0026quot; =\u0026gt; \u0026quot;abc\u0026quot; // Remove .. elements \u0026quot;abc/def/ghi/../jkl\u0026quot; =\u0026gt; \u0026quot;abc/def/jkl\u0026quot; \u0026quot;abc/def/../ghi/../jkl\u0026quot; =\u0026gt; \u0026quot;abc/jkl\u0026quot; \u0026quot;abc/def/..\u0026quot; =\u0026gt; \u0026quot;abc\u0026quot; \u0026quot;abc/def/../..\u0026quot; =\u0026gt; \u0026quot;.\u0026quot; \u0026quot;/abc/def/../..\u0026quot; =\u0026gt; \u0026quot;/\u0026quot; \u0026quot;abc/def/../../..\u0026quot; =\u0026gt; \u0026quot;..\u0026quot; \u0026quot;/abc/def/../../..\u0026quot; =\u0026gt; \u0026quot;/\u0026quot; \u0026quot;abc/def/../../../ghi/jkl/../../../mno\u0026quot; =\u0026gt; \u0026quot;../../mno\u0026quot; // Combinations \u0026quot;abc/./../def\u0026quot; =\u0026gt; \u0026quot;def\u0026quot; \u0026quot;abc//./../def\u0026quot; =\u0026gt; \u0026quot;def\u0026quot; \u0026quot;abc/../../././../def\u0026quot; =\u0026gt; \u0026quot;../../def\u0026quot;  2.1.2 Split 签名：func Split(path string) (dir, file string)\n用途：拆分路径为目录+文件，目录保留/，若路径中没有/，则目录为空\n示例：https://play.golang.org/p/DG8QjjWdkuq\n\u0026quot;a/b\u0026quot; =\u0026gt; \u0026quot;a/\u0026quot; + \u0026quot;b\u0026quot; \u0026quot;a/b/\u0026quot; =\u0026gt; \u0026quot;a/b/\u0026quot; + \u0026quot;\u0026quot; \u0026quot;a/\u0026quot; =\u0026gt; \u0026quot;a/\u0026quot; + \u0026quot;\u0026quot; \u0026quot;a\u0026quot; =\u0026gt; \u0026quot;\u0026quot; + \u0026quot;a\u0026quot; \u0026quot;/\u0026quot; =\u0026gt; \u0026quot;/\u0026quot; + \u0026quot;\u0026quot;  2.1.3 Join 签名：Join(elem ...string) string\n用途：把所有元素按顺序拼接为路径，并对路径格式化\n示例：https://play.golang.org/p/jxcwt_fgUpt\n// zero parameters {[]string{} =\u0026gt; \u0026quot;\u0026quot;}, // one parameter {[]string{\u0026quot;\u0026quot;} =\u0026gt; \u0026quot;\u0026quot;}, {[]string{\u0026quot;a\u0026quot;} =\u0026gt; \u0026quot;a\u0026quot;}, // two parameters {[]string{\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;} =\u0026gt; \u0026quot;a/b\u0026quot;}, {[]string{\u0026quot;a\u0026quot;, \u0026quot;\u0026quot;} =\u0026gt; \u0026quot;a\u0026quot;}, {[]string{\u0026quot;\u0026quot;, \u0026quot;b\u0026quot;} =\u0026gt; \u0026quot;b\u0026quot;}, {[]string{\u0026quot;/\u0026quot;, \u0026quot;a\u0026quot;} =\u0026gt; \u0026quot;/a\u0026quot;}, {[]string{\u0026quot;/\u0026quot;, \u0026quot;\u0026quot;} =\u0026gt; \u0026quot;/\u0026quot;}, {[]string{\u0026quot;a/\u0026quot;, \u0026quot;b\u0026quot;} =\u0026gt; \u0026quot;a/b\u0026quot;}, {[]string{\u0026quot;a/\u0026quot;, \u0026quot;\u0026quot;} =\u0026gt; \u0026quot;a\u0026quot;}, {[]string{\u0026quot;\u0026quot;, \u0026quot;\u0026quot;} =\u0026gt; \u0026quot;\u0026quot;},  2.1.4 Ext 签名：Ext(path string) string\n用途：根据.返回路径中文件的扩展名，若没有.则返回空\n示例：https://play.golang.org/p/VxIO_oewphL\n{\u0026quot;path.go\u0026quot; =\u0026gt; \u0026quot;.go\u0026quot;}, {\u0026quot;path.pb.go\u0026quot; =\u0026gt; \u0026quot;.go\u0026quot;}, {\u0026quot;a.dir/b\u0026quot; =\u0026gt; \u0026quot;\u0026quot;}, {\u0026quot;a.dir/b.go\u0026quot; =\u0026gt; \u0026quot;.go\u0026quot;}, {\u0026quot;a.dir/\u0026quot; =\u0026gt; \u0026quot;\u0026quot;},  2.1.5 Base 签名：Base(path string) string\n用途：先清除路径末尾的/（如果有的话），再根据最后一个/，返回该元素，若没有/，则返回.\n示例：https://play.golang.org/p/bW-KYszq1fE\n{\u0026quot;\u0026quot; =\u0026gt; \u0026quot;.\u0026quot;}, {\u0026quot;.\u0026quot; =\u0026gt; \u0026quot;.\u0026quot;}, {\u0026quot;/.\u0026quot; =\u0026gt; \u0026quot;.\u0026quot;}, {\u0026quot;/\u0026quot; =\u0026gt; \u0026quot;/\u0026quot;}, {\u0026quot;////\u0026quot; =\u0026gt; \u0026quot;/\u0026quot;}, {\u0026quot;x/\u0026quot; =\u0026gt; \u0026quot;x\u0026quot;}, {\u0026quot;abc\u0026quot; =\u0026gt; \u0026quot;abc\u0026quot;}, {\u0026quot;abc/def\u0026quot; =\u0026gt; \u0026quot;def\u0026quot;}, {\u0026quot;a/b/.x\u0026quot; =\u0026gt; \u0026quot;.x\u0026quot;}, {\u0026quot;a/b/c.\u0026quot; =\u0026gt; \u0026quot;c.\u0026quot;}, {\u0026quot;a/b/c.x\u0026quot; =\u0026gt; \u0026quot;c.x\u0026quot;},  2.1.6 IsAbs 签名：IsAbs(path string) bool\n用途：判断路径是否为绝对路径，即以/开头\n示例：https://play.golang.org/p/MWv0m9Q8I-J\n{\u0026quot;\u0026quot; =\u0026gt; false}, {\u0026quot;/\u0026quot; =\u0026gt; true}, {\u0026quot;/usr/bin/gcc\u0026quot; =\u0026gt; true}, {\u0026quot;..\u0026quot; =\u0026gt; false}, {\u0026quot;/a/../bb\u0026quot; =\u0026gt; true}, {\u0026quot;.\u0026quot; =\u0026gt; false}, {\u0026quot;./\u0026quot; =\u0026gt; false}, {\u0026quot;lala\u0026quot; =\u0026gt; false},  2.1.7 Dir 签名：Dir(path string) string\n用途：返回去除最后一项后的目录路径,并格式化\n示例：https://play.golang.org/p/DBULKf343C6\n{\u0026quot;\u0026quot; =\u0026gt; \u0026quot;.\u0026quot;}, {\u0026quot;.\u0026quot; =\u0026gt; \u0026quot;.\u0026quot;}, {\u0026quot;/.\u0026quot; =\u0026gt; \u0026quot;/\u0026quot;}, {\u0026quot;/\u0026quot; =\u0026gt; \u0026quot;/\u0026quot;}, {\u0026quot;////\u0026quot; =\u0026gt; \u0026quot;/\u0026quot;}, {\u0026quot;/foo\u0026quot; =\u0026gt; \u0026quot;/\u0026quot;}, {\u0026quot;x/\u0026quot; =\u0026gt; \u0026quot;x\u0026quot;}, {\u0026quot;abc\u0026quot; =\u0026gt; \u0026quot;.\u0026quot;}, {\u0026quot;abc/def\u0026quot; =\u0026gt; \u0026quot;abc\u0026quot;}, {\u0026quot;abc////def\u0026quot; =\u0026gt; \u0026quot;abc\u0026quot;}, {\u0026quot;a/b/.x\u0026quot; =\u0026gt; \u0026quot;a/b\u0026quot;}, {\u0026quot;a/b/c.\u0026quot; =\u0026gt; \u0026quot;a/b\u0026quot;}, {\u0026quot;a/b/c.x\u0026quot; =\u0026gt; \u0026quot;a/b\u0026quot;},  2.2 match.go \u0026amp; match_test.go 2.2.1 Match 签名：func Match(pattern, name string) (matched bool, err error)\n用途：根据给定的模式对路径进行匹配，模式如下：\npattern: { term } term: '*' matches any sequence of non-/ characters 匹配任意数量的所有非/字符 '?' matches any single non-/ character 匹配所有单个非/字符 '[' [ '^' ] { character-range } ']' 区间匹配，^表示除了该区间，匹配不能为空，至少需要一个 character class (must be non-empty) c matches character c (c != '*', '?', '\\\\', '[') 匹配单个确定字符，除'*', '?', '\\\\', '[' '\\\\' c matches character c 可以看作转义匹配'*', '?', '\\\\', '[' character-range: c matches character c (c != '\\\\', '-', ']') 在区间匹配中匹配单个确定字符，除'\\\\', '-', ']' '\\\\' c matches character c 可以看作在区间匹配中转义匹配'\\\\', '-', ']' lo '-' hi matches character c for lo \u0026lt;= c \u0026lt;= hi 区间范围  示例：https://play.golang.org/p/yhfME8jBmn1\n{\u0026quot;abc\u0026quot;, \u0026quot;abc\u0026quot;, true, nil}, {\u0026quot;*\u0026quot;, \u0026quot;abc\u0026quot;, true, nil}, {\u0026quot;*c\u0026quot;, \u0026quot;abc\u0026quot;, true, nil}, {\u0026quot;a*\u0026quot;, \u0026quot;a\u0026quot;, true, nil}, {\u0026quot;a*\u0026quot;, \u0026quot;abc\u0026quot;, true, nil}, {\u0026quot;a*\u0026quot;, \u0026quot;ab/c\u0026quot;, false, nil}, {\u0026quot;a*/b\u0026quot;, \u0026quot;abc/b\u0026quot;, true, nil}, {\u0026quot;a*/b\u0026quot;, \u0026quot;a/c/b\u0026quot;, false, nil}, {\u0026quot;a*b*c*d*e*/f\u0026quot;, \u0026quot;axbxcxdxe/f\u0026quot;, true, nil}, {\u0026quot;a*b*c*d*e*/f\u0026quot;, \u0026quot;axbxcxdxexxx/f\u0026quot;, true, nil}, {\u0026quot;a*b*c*d*e*/f\u0026quot;, \u0026quot;axbxcxdxe/xxx/f\u0026quot;, false, nil}, {\u0026quot;a*b*c*d*e*/f\u0026quot;, \u0026quot;axbxcxdxexxx/fff\u0026quot;, false, nil}, {\u0026quot;a*b?c*x\u0026quot;, \u0026quot;abxbbxdbxebxczzx\u0026quot;, true, nil}, {\u0026quot;a*b?c*x\u0026quot;, \u0026quot;abxbbxdbxebxczzy\u0026quot;, false, nil}, {\u0026quot;ab[c]\u0026quot;, \u0026quot;abc\u0026quot;, true, nil}, {\u0026quot;ab[b-d]\u0026quot;, \u0026quot;abc\u0026quot;, true, nil}, {\u0026quot;ab[e-g]\u0026quot;, \u0026quot;abc\u0026quot;, false, nil}, {\u0026quot;ab[^c]\u0026quot;, \u0026quot;abc\u0026quot;, false, nil}, {\u0026quot;ab[^b-d]\u0026quot;, \u0026quot;abc\u0026quot;, false, nil}, {\u0026quot;ab[^e-g]\u0026quot;, \u0026quot;abc\u0026quot;, true, nil}, {\u0026quot;a\\\\*b\u0026quot;, \u0026quot;a*b\u0026quot;, true, nil}, {\u0026quot;a\\\\*b\u0026quot;, \u0026quot;ab\u0026quot;, false, nil}, {\u0026quot;a?b\u0026quot;, \u0026quot;a☺b\u0026quot;, true, nil}, {\u0026quot;a[^a]b\u0026quot;, \u0026quot;a☺b\u0026quot;, true, nil}, {\u0026quot;a???b\u0026quot;, \u0026quot;a☺b\u0026quot;, false, nil}, {\u0026quot;a[^a][^a][^a]b\u0026quot;, \u0026quot;a☺b\u0026quot;, false, nil}, {\u0026quot;[a-ζ]*\u0026quot;, \u0026quot;α\u0026quot;, true, nil}, {\u0026quot;*[a-ζ]\u0026quot;, \u0026quot;A\u0026quot;, false, nil}, {\u0026quot;a?b\u0026quot;, \u0026quot;a/b\u0026quot;, false, nil}, {\u0026quot;a*b\u0026quot;, \u0026quot;a/b\u0026quot;, false, nil}, {\u0026quot;[\\\\]a]\u0026quot;, \u0026quot;]\u0026quot;, true, nil}, {\u0026quot;[\\\\-]\u0026quot;, \u0026quot;-\u0026quot;, true, nil}, {\u0026quot;[x\\\\-]\u0026quot;, \u0026quot;x\u0026quot;, true, nil}, {\u0026quot;[x\\\\-]\u0026quot;, \u0026quot;-\u0026quot;, true, nil}, {\u0026quot;[x\\\\-]\u0026quot;, \u0026quot;z\u0026quot;, false, nil}, {\u0026quot;[\\\\-x]\u0026quot;, \u0026quot;x\u0026quot;, true, nil}, {\u0026quot;[\\\\-x]\u0026quot;, \u0026quot;-\u0026quot;, true, nil}, {\u0026quot;[\\\\-x]\u0026quot;, \u0026quot;a\u0026quot;, false, nil}, {\u0026quot;[]a]\u0026quot;, \u0026quot;]\u0026quot;, false, ErrBadPattern}, {\u0026quot;[-]\u0026quot;, \u0026quot;-\u0026quot;, false, ErrBadPattern}, {\u0026quot;[x-]\u0026quot;, \u0026quot;x\u0026quot;, false, ErrBadPattern}, {\u0026quot;[x-]\u0026quot;, \u0026quot;-\u0026quot;, false, ErrBadPattern}, {\u0026quot;[x-]\u0026quot;, \u0026quot;z\u0026quot;, false, ErrBadPattern}, {\u0026quot;[-x]\u0026quot;, \u0026quot;x\u0026quot;, false, ErrBadPattern}, {\u0026quot;[-x]\u0026quot;, \u0026quot;-\u0026quot;, false, ErrBadPattern}, {\u0026quot;[-x]\u0026quot;, \u0026quot;a\u0026quot;, false, ErrBadPattern}, {\u0026quot;\\\\\u0026quot;, \u0026quot;a\u0026quot;, false, ErrBadPattern}, {\u0026quot;[a-b-c]\u0026quot;, \u0026quot;a\u0026quot;, false, ErrBadPattern}, {\u0026quot;[\u0026quot;, \u0026quot;a\u0026quot;, false, ErrBadPattern}, {\u0026quot;[^\u0026quot;, \u0026quot;a\u0026quot;, false, ErrBadPattern}, {\u0026quot;[^bc\u0026quot;, \u0026quot;a\u0026quot;, false, ErrBadPattern}, {\u0026quot;a[\u0026quot;, \u0026quot;a\u0026quot;, false, nil}, {\u0026quot;a[\u0026quot;, \u0026quot;ab\u0026quot;, false, ErrBadPattern}, {\u0026quot;*x\u0026quot;, \u0026quot;xxx\u0026quot;, true, nil}, ","date":1529988339,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1543733643,"objectID":"7fe0a226cf29c3dd21d78e54b4170815","permalink":"https://mooncaker816.github.io/2018/06/26/path/","publishdate":"2018-06-26T12:45:39+08:00","relpermalink":"/2018/06/26/path/","section":"post","summary":"1. Path包概要 1.1 概述","tags":["Path"],"title":"Path","type":"post"},{"authors":null,"categories":["Golang"],"content":"Or-Channel  使用场景：\n当你需要同时监测多个信号时，只要接收到其中任一个信号，就认为信号接收成功，需要进行下一步处理\n 代码：\nfunc or(channels ...\u0026lt;-chan interface{}) \u0026lt;-chan interface{} { switch len(channels) { case 0: return nil case 1: return channels[0] } orDone := make(chan interface{}) go func() { defer close(orDone) switch len(channels) { case 2: select { case \u0026lt;-channels[0]: case \u0026lt;-channels[1]: } default: select { case \u0026lt;-channels[0]: case \u0026lt;-channels[1]: case \u0026lt;-channels[2]: case \u0026lt;-or(append(channels[3:], orDone)...): } } }() return orDone }  测试：\nfunc TestOr(t *testing.T) { st := time.Now() r := rand.New(rand.NewSource(time.Now().Unix())) \u0026lt;-or( randSig(r), randSig(r), randSig(r), randSig(r), randSig(r), ) fmt.Printf(\u0026quot;closed after %v!\\n\u0026quot;, time.Since(st)) } func randSig(r *rand.Rand) \u0026lt;-chan interface{} { ch := make(chan interface{}) go func() { defer close(ch) sec := time.Duration(r.Int63n(10)+3) * time.Second fmt.Printf(\u0026quot;closing after %v!\\n\u0026quot;, sec) time.Sleep(sec) }() return ch }  结果：\nclosing after 4s! closing after 10s! closing after 3s! closing after 9s! closing after 11s! closed after 3.001062582s!  ","date":1528873332,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1528873332,"objectID":"638a59d27e77ddf7e33f67539fcebe13","permalink":"https://mooncaker816.github.io/2018/06/13/go%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F1/","publishdate":"2018-06-13T15:02:12+08:00","relpermalink":"/2018/06/13/go%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F1/","section":"post","summary":"Or-Channel","tags":["Go patterns"],"title":"Go并发模式1","type":"post"},{"authors":null,"categories":["golang","算法"],"content":"第二十九章 Ephemeris for Physical Observations of the Sun 1. 日面计算 $P$ 为日轴方位角，自日面北点量起的太阳自转轴北端的方位角，向东为正\n$B_0$ 为日面中心的日面纬度\n$L_0$ 为日面中心的日面经度\n根据之前章节的算法，先计算太阳视黄经$λ$(包含光行差修正)，$λ\u0026rsquo;$为$λ$的黄经章动修正值，$ε$为真黄赤交角\n再计算 \\begin{cases} θ = (JD - 2398220)\\frac {360°}{25.38}\\\\[2ex] I = 7°.25,(太阳赤道与黄道的倾角)\\\\[2ex] K = 73°.6667 + 1°.3958333\\frac {JD - 2396758}{36525},(太阳赤道与黄道的升交点的黄经)\\\\[2ex] \\tan x = -\\cos λ\u0026rsquo;\\tan ε\\\\[2ex] \\tan y = -\\cos (λ - K)\\tan I \\end{cases} 那么 \\begin{cases} P = x+y\\\\[2ex] \\sin B_0 = \\sin(λ - K)\\sin I\\\\[2ex] \\tan η = \\frac {-\\sin(λ - K)\\cos I}{-\\cos (λ - K)}\\\\[2ex] L_0 = η-θ \\end{cases}\n// Ephemeris returns the apparent orientation of the sun at the given jd. // 计算日面参数 // // Results: //\tP: Position angle of the solar north pole. //\tB0: Heliographic latitude of the center of the solar disk. //\tL0: Heliographic longitude of the center of the solar disk. func Ephemeris(jd float64, e *pp.V87Planet) (P, B0, L0 unit.Angle) { θ := unit.Angle((jd - 2398220) * 2 * math.Pi / 25.38) I := unit.AngleFromDeg(7.25) K := unit.AngleFromDeg(73.6667) + unit.AngleFromDeg(1.3958333).Mul((jd-2396758)/base.JulianCentury) L, _, R := solar.TrueVSOP87(e, jd) Δψ, Δε := nutation.Nutation(jd) ε0 := nutation.MeanObliquity(jd) ε := ε0 + Δε λ := L - unit.AngleFromSec(20.4898).Div(R) λp := λ + Δψ sλK, cλK := (λ - K).Sincos() sI, cI := I.Sincos() tx := -(λp.Cos() * ε.Tan()) ty := -(cλK * I.Tan()) P = unit.Angle(math.Atan(tx) + math.Atan(ty)) B0 = unit.Angle(math.Asin(sλK * sI)) η := unit.Angle(math.Atan2(-sλK*cI, -cλK)) L0 = (η - θ).Mod1() return } // Cycle returns the jd of the start of the given synodic rotation. // // Argument c is the \u0026quot;Carrington\u0026quot; cycle number. // // Result is a dynamical time (not UT). func Cycle(c int) (jde float64) { cf := float64(c) jde = 2398140.227 + 27.2752316*cf m := 281.96*math.Pi/180 + 26.882476*math.Pi/180*cf s2m, c2m := math.Sincos(2 * m) return jde + .1454*math.Sin(m) - .0085*s2m - .0141*c2m } ","date":1527474929,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1527474929,"objectID":"9c52754549b4a9c669b379c3a446b7bc","permalink":"https://mooncaker816.github.io/2018/05/28/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9527/","publishdate":"2018-05-28T10:35:29+08:00","relpermalink":"/2018/05/28/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9527/","section":"post","summary":"第二十九章 Ephemeris for Physical Observations of the Sun","tags":["天文算法"],"title":"天文算法27","type":"post"},{"authors":null,"categories":["golang","算法"],"content":"第二十八章 Equation of Time 均时差 1. 均时差的概念 均时差\n2. 计算时差  VSOP87理论计算  $$E = L_0 - 0°.0057183 - α + Δψ·\\cos ε$$ 其中$α$为太阳地心视赤经，$Δψ$为赤经章动，$ε$为真黄赤交角，$L_0$为太阳平黄经 $$L_0 = 280.4664567 + 360007.6982779τ + 0.03032028τ^2 + τ^3 /49931 - τ^4 /15300 - τ^5 /2000000$$ $τ$为儒略日千年数\n// E computes the \u0026quot;equation of time\u0026quot; for the given JDE. // 计算时差 // // Parameter e must be a planetposition.V87Planet object for Earth obtained // with planetposition.LoadPlanet. // // Result is equation of time as an hour angle. func E(jde float64, e *pp.V87Planet) unit.HourAngle { τ := base.J2000Century(jde) * .1 // J2000儒略日千年数 L0 := l0(τ) // code duplicated from solar.ApparentEquatorialVSOP87 so that // we can keep Δψ and cε s, β, R := solar.TrueVSOP87(e, jde) // 真太阳黄经 Δψ, Δε := nutation.Nutation(jde) a := unit.AngleFromSec(-20.4898).Div(R) //光行差 λ := s + Δψ + a //视黄经 ε := nutation.MeanObliquity(jde) + Δε // 真黄赤交角 sε, cε := ε.Sincos() α, _ := coord.EclToEq(λ, β, sε, cε) // 视赤经 // (28.1) p. 183 E := L0 - unit.AngleFromDeg(.0057183) - unit.Angle(α) + Δψ.Mul(cε) return unit.HourAngle((E + math.Pi).Mod1() - math.Pi) } // (28.2) p. 183 // 太阳平黄经 func l0(τ float64) unit.Angle { return unit.AngleFromDeg(base.Horner(τ, 280.4664567, 360007.6982779, .03032028, 1./49931, -1./15300, -1./2000000)) }   低精度时差计算  $$E = y\\sin 2L_0 - 2e\\sin M + 4ey\\sin M \\cos 2L_0 - \\frac 12y^2\\sin 4L_0 - \\frac 54 e^2\\sin 2M$$ 其中$y = \\tan^2(ε/2)，ε是平黄赤交角,L_0为太阳平黄经，e为地球轨道离心率，M为太阳平近点角$\n// ESmart computes the \u0026quot;equation of time\u0026quot; for the given JDE. // 低精度计算时差 // // Result is equation of time as an hour angle. // // Result is less accurate that E() but the function has the advantage // of not requiring the V87Planet object. func ESmart(jde float64) unit.HourAngle { ε := nutation.MeanObliquity(jde) // 平黄赤交角 t := ε.Mul(.5).Tan() y := t * t T := base.J2000Century(jde) L0 := l0(T * .1) e := solar.Eccentricity(T) //地球轨道离心率 M := solar.MeanAnomaly(T) // 太阳平近点角 s2L0, c2L0 := L0.Mul(2).Sincos() sM := M.Sin() // (28.3) p. 185, with double angle identity return unit.HourAngle(y*s2L0 - 2*e*sM + 4*e*y*sM*c2L0 - y*y*s2L0*c2L0 - 1.25*e*e*M.Mul(2).Sin()) } ","date":1527470736,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1527470736,"objectID":"a94d5f9d59b7ee20cb8b5c0b1444299c","permalink":"https://mooncaker816.github.io/2018/05/28/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9526/","publishdate":"2018-05-28T09:25:36+08:00","relpermalink":"/2018/05/28/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9526/","section":"post","summary":"第二十八章 Equation of Time 均时差","tags":["天文算法"],"title":"天文算法26","type":"post"},{"authors":null,"categories":["golang","算法"],"content":"第二十七章 分点和至点 Equinoxes and Solstices 分点（英语：equinox，或称二分点）是想像中天球赤道在天球上的位置，是每年太阳穿过天球赤道和黄道在天球上交点的天文事件[1]，这造成地球上各地的白天和夜晚几乎等长。\n二至点（亦称至点）可以是太阳在一年之中离地球赤道最远的两个事件中的任何一个，英文的字源（solstice） 来自拉丁文的太阳（sol）和保持直立（sistere），因为在至点时太阳直射的地球纬度是他能抵达的最南或最北的极值，而至点所在之日是一年之中日夜长短差异最大的一天。\n分点和至点时刻是指：太阳的地心视黄经(含光行差和章动)为90的整数倍时对应的时刻。因太阳黄纬不是真正为零的，所以在分点时刻太阳赤纬也不是真正为零的。\n1. 近似时刻计算(最大误差1分钟) 先找到平分点或平至点$JDE_0$\n当$year \\in [-1000,1000)$时， \\begin{cases} Y = \\frac {year}{1000}\\\\[2ex] 春分点：JDE_0 = 1721139.29189 + 365242.13740Y + 0.06134Y^2 + 0.00111Y^3 - 0.00071Y^4\\\\[2ex] 夏至点：JDE_0 = 1721233.25401 + 365241.72562Y - 0.05323Y^2 + 0.00907Y^3 + 0.00025Y^4\\\\[2ex] 秋分点：JDE_0 = 1721325.70455 + 365242.49558Y - 0.11677Y^2 - 0.00297Y^3 + 0.00074Y^4\\\\[2ex] 冬至点：JDE_0 = 1721414.39987 + 365242.88257Y - 0.00769Y^2 - 0.00933Y^3 - 0.00006Y^4\\\\[2ex] \\end{cases} 当$year \\in [1000,3000]$时， \\begin{cases} Y = \\frac {year-2000}{1000}\\\\[2ex] 春分点：JDE_0 = 2451623.80984 + 365242.37404Y + 0.05169Y^2 - 0.00411Y^3 - 0.00057Y^4\\\\[2ex] 夏至点：JDE_0 = 2451716.56767 + 365241.62603Y + 0.00325Y^2 + 0.00888Y^3 - 0.00030Y^4\\\\[2ex] 秋分点：JDE_0 = 2451810.21715 + 365242.01767Y - 0.11575Y^2 + 0.00337Y^3 + 0.00078Y^4\\\\[2ex] 冬至点：JDE_0 = 2451900.05952 + 365242.74049Y - 0.06223Y^2 - 0.00823Y^3 + 0.00032Y^4\\\\[2ex] \\end{cases} 再计算 \\begin{cases} T \u0026amp;= \\frac {JDE_0 - 2451545.0}{36525}\\\\[2ex] W \u0026amp;= 35999°.373T - 2°.47\\\\[2ex] Δλ \u0026amp;= 1 + 0.0334\\cos W + 0.0007\\cos (2W)\\\\[2ex] S \u0026amp;= \\sum A\\cos(B+CT) \\end{cases} 其中$A,B,C$分别为下表中的系数项那么$$JDE = JDE_0 + \\frac {0.00001S}{Δλ} days$$ 注意此时得到的力学时DT，可以按需再转为UT\nvar ( mc0 = []float64{1721139.29189, 365242.13740, .06134, .00111, -.00071} jc0 = []float64{1721233.25401, 365241.72562, -.05232, .00907, .00025} sc0 = []float64{1721325.70455, 365242.49558, -.11677, -.00297, .00074} dc0 = []float64{1721414.39987, 365242.88257, -.00769, -.00933, -.00006} mc2 = []float64{2451623.80984, 365242.37404, .05169, -.00411, -.00057} jc2 = []float64{2451716.56767, 365241.62603, .00325, .00888, -.00030} sc2 = []float64{2451810.21715, 365242.01767, -.11575, .00337, .00078} dc2 = []float64{2451900.05952, 365242.74049, -.06223, -.00823, .00032} ) type term struct { a, b, c float64 } var terms = []term{ {485, 324.96, 1934.136}, {203, 337.23, 32964.467}, {199, 342.08, 20.186}, {182, 27.85, 445267.112}, {156, 73.14, 45036.886}, {136, 171.52, 22518.443}, {77, 222.54, 65928.934}, {74, 296.72, 3034.906}, {70, 243.58, 9037.513}, {58, 119.81, 33718.147}, {52, 297.17, 150.678}, {50, 21.02, 2281.226}, {45, 247.54, 29929.562}, {44, 325.15, 31555.956}, {29, 60.93, 4443.417}, {18, 155.12, 67555.328}, {17, 288.79, 4562.452}, {16, 198.04, 62894.029}, {14, 199.76, 31436.921}, {12, 95.39, 14577.848}, {12, 287.11, 31931.756}, {12, 320.81, 34777.259}, {9, 227.73, 1222.114}, {8, 15.45, 16859.074}, } // March returns the JDE of the March equinox for the given year. // 计算y年春分点力学时，y∈[-1000,3000] // // Results are valid for the years -1000 to +3000. // // Accuracy is within one minute of time for the years 1951-2050. func March(y int) float64 { if y \u0026lt; 1000 { return eq(y, mc0) } return eq(y-2000, mc2) } // June returns the JDE of the June solstice for the given year. // 计算y年夏至点力学时，y∈[-1000,3000] // // Results are valid for the years -1000 to +3000. // // Accuracy is within one minute of time for the years 1951-2050. func June(y int) float64 { if y \u0026lt; 1000 { return eq(y, jc0) } return eq(y-2000, jc2) } // September returns the JDE of the September equinox for the given year. // 计算y年秋分点力学时，y∈[-1000,3000] // // Results are valid for the years -1000 to +3000. // // Accuracy is within one minute of time for the years 1951-2050. func September(y int) float64 { if y \u0026lt; 1000 { return eq(y, sc0) } return eq(y-2000, sc2) } // December returns the JDE of the December solstice for a given year. // 计算y年冬至点力学时，y∈[-1000,3000] // // Results are valid for the years -1000 to +3000. // // Accuracy is within one minute of time for the years 1951-2050. func December(y int) float64 { if y \u0026lt; 1000 { return eq(y, dc0) } return eq(y-2000, dc2) } func eq(y int, c []float64) float64 { J0 := base.Horner(float64(y)*.001, c...) T := base.J2000Century(J0) W := 35999.373*math.Pi/180*T - 2.47*math.Pi/180 Δλ := 1 + .0334*math.Cos(W) + .0007*math.Cos(2*W) S := 0. for i := len(terms) - 1; i \u0026gt;= 0; i-- { t := \u0026amp;terms[i] S += t.a * math.Cos((t.b+t.c*T)*math.Pi/180) } return J0 + .00001*S/Δλ }  2. 高精度分至点时刻计算 　先用低精度方法算出近似时刻，再采用VSOP87理论计算出该时刻的太阳视黄经$λ$，\n再根据各个分至点的几何度数按以下公式求该近似时刻的修正量，循环迭代，直至满足要求。 $$+58\\sin (k90° - λ)$$ 其中k=0,1,2,3分别对应春夏秋冬四个分至点\n// March2 returns a more accurate JDE of the March equinox. // 高精度计算春分点力学时 // // Result is accurate to one second of time. // // Parameter e must be a V87Planet object representing Earth, obtained with // the package planetposition and code similar to // //\te, err := planetposition.LoadPlanet(planetposition.Earth, \u0026quot;\u0026quot;) //\tif err != nil { //\t.... // // See example under June2. func March2(y int, e *pp.V87Planet) float64 { if y \u0026lt; 1000 { return eq2(y, e, 0, mc0) } return eq2(y-2000, e, 0, mc2) } // June2 returns a more accurate JDE of the June solstice. // 高精度计算夏至点力学时 // // Result is accurate to one second of time. // // Parameter e must be a V87Planet object representing Earth, obtained with // the package planetposition. func June2(y int, e *pp.V87Planet) float64 { if y \u0026lt; 1000 { return eq2(y, e, math.Pi/2, jc0) } return eq2(y-2000, e, math.Pi/2, jc2) } // September2 returns a more accurate JDE of the September equinox. // 高精度计算秋分点力学时 // // Result is accurate to one second of time. // // Parameter e must be a V87Planet object representing Earth, obtained with // the package planetposition and code similar to // //\te, err := planetposition.LoadPlanet(planetposition.Earth, \u0026quot;\u0026quot;) //\tif err != nil { //\t.... // // See example under June2. func September2(y int, e *pp.V87Planet) float64 { if y \u0026lt; 1000 { return eq2(y, e, math.Pi, sc0) } return eq2(y-2000, e, math.Pi, sc2) } // December2 returns a more accurate JDE of the December solstice. // 高精度计算冬至点力学时 // // Result is accurate to one second of time. // // Parameter e must be a V87Planet object representing Earth, obtained with // the package planetposition and code similar to // //\te, err := planetposition.LoadPlanet(planetposition.Earth, \u0026quot;\u0026quot;) //\tif err != nil { //\t.... // // See example under June2. func December2(y int, e *pp.V87Planet) float64 { if y \u0026lt; 1000 { return eq2(y, e, math.Pi*3/2, dc0) } return eq2(y-2000, e, math.Pi*3/2, dc2) } //先用低精度方法算出近似时刻，再采用VSOP87理论计算出该时刻的太阳视黄经λ， //再根据各个分至点的几何度数求该近似时刻的修正量，循环迭代，直至满足要求。 func eq2(y int, e *pp.V87Planet, q unit.Angle, c []float64) float64 { J0 := base.Horner(float64(y)*.001, c...) for { λ, _, _ := solar.ApparentVSOP87(e, J0) c := 58 * (q - λ).Sin() // (27.1) p. 180 J0 += c if math.Abs(c) \u0026lt; .000005 { break } } return J0 } ","date":1527296280,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1527296280,"objectID":"bc1022050a2c5fda9a614473a7c7df80","permalink":"https://mooncaker816.github.io/2018/05/26/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9525/","publishdate":"2018-05-26T08:58:00+08:00","relpermalink":"/2018/05/26/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9525/","section":"post","summary":"第二十七章 分点和至点 Equinoxes and Solstices","tags":["天文算法"],"title":"天文算法25","type":"post"},{"authors":null,"categories":["golang","算法"],"content":"第二十六章 太阳直角坐标 Rectangular Coordinates of the Sun 太阳的地心赤道直角坐标$X,Y,Z$。原点在地心。$X$轴的方向指向春分点（经度为0），$Y$轴平放在赤道面上， 经度是90°，$Z$轴方向是北极。\n1. Date 平分点参考系 \\begin{cases} X \u0026amp;= R\\cos β\\cos ☉\\\\[2ex] Y \u0026amp;= R(\\cos β\\sin ☉\\cos ε - \\sin β\\sin ε)\\\\[2ex] Z \u0026amp;= R(\\cos β\\sin ☉\\sin ε + \\sin β\\cos ε) \\end{cases} 其中$☉,β,R$是太阳的地心几何黄经,黄纬,日地距离（可由solar.TrueVSOP87求出），$ε$是平黄赤交角。\n因为 Date 黄道坐标中，太阳的纬度不超过 1.2 角秒， 所以可以看成$\\cos β=1$\n// Position returns rectangular coordinates referenced to the mean equinox // of date. // Date 平分点太阳地心直角坐标 func Position(e *pp.V87Planet, jde float64) (x, y, z float64) { // (26.1) p. 171 s, β, R := solar.TrueVSOP87(e, jde) sε, cε := nutation.MeanObliquity(jde).Sincos() ss, cs := s.Sincos() sβ := β.Sin() x = R * cs y = R * (ss*cε - sβ*sε) z = R * (ss*sε + sβ*cε) return }  2. J2000标准分点参考系和B1950平分点参考系 通过VSOP87计算给定时刻地球的相对于 J2000.0 分点的日心黄经$L$和黄纬$B$，及距离$R$ $$☉ = L + 180°， β = -B$$ 计算 \\begin{cases} X \u0026amp;= R\\cos β*cos ☉\\\\[2ex] Y \u0026amp;= R\\cos β*sin ☉\\\\[2ex] Z \u0026amp;= R\\sin β \\end{cases}\n上述坐标仍是黄道坐标，J2000参考系的赤道坐标为： \\begin{cases} X_0 \u0026amp;= 1.000000000000X+0.000000440360Y-0.000000190919Z\\\\[2ex] Y_0 \u0026amp;= -0.000000479966X+0.917482137087Y-0.397776982902Z\\\\[2ex] Z_0 \u0026amp;= 0.000000000000X+0.397776982902Y+0.917482137087Z \\end{cases}\n// PositionJ2000 returns rectangular coordinates referenced to equinox J2000. // J2000太阳直角坐标 func PositionJ2000(e *pp.V87Planet, jde float64) (x, y, z float64) { x, y, z = xyz(e, jde) // (26.3) p. 174 return x + .00000044036*y - .000000190919*z, -.000000479966*x + .917482137087*y - .397776982902*z, .397776982902*y + .917482137087*z } func xyz(e *pp.V87Planet, jde float64) (x, y, z float64) { l, b, r := e.Position2000(jde) s := l + math.Pi β := -b ss, cs := s.Sincos() sβ, cβ := β.Sincos() // (26.2) p. 172 x = r * cβ * cs y = r * cβ * ss z = r * sβ return }  B1950平分点参考系坐标： \\begin{cases} X_0 \u0026amp;=0.999925702634X+0.012189716217Y+0.000011134016Z\\\\[2ex] Y_0 \u0026amp;=-0.011179418036X+0.917413998946Y-0.397777041885Z\\\\[2ex] Z_0 \u0026amp;=-0.004859003787X+0.397747363646Y+0.917482111428Z \\end{cases}\n// PositionB1950 returns rectangular coordinates referenced to B1950. // B1950 平分点参考系太阳直角坐标 // // Results are referenced to the mean equator and equinox of the epoch B1950 // in the FK5 system, not FK4. func PositionB1950(e *pp.V87Planet, jde float64) (x, y, z float64) { x, y, z = xyz(e, jde) return .999925702634*x + .012189716217*y + .000011134016*z, -.011179418036*x + .917413998946*y - .397777041885*z, -.004859003787*x + .397747363646*y + .917482111428*z }  3. 任意其它平分点参考系 　先计算出J2000标准分点标准$X_0,Y_0,Z_0$\n然后按岁差计算中的方法计算出$ζ,z,θ$,\n\\begin{cases} X_x \u0026amp;= \\cos ζ\\cos z\\cos θ - \\sin ζ\\sin z\\\\[2ex] X_y \u0026amp;= \\sin ζ\\cos z + \\cos ζ\\sin z\\cos θ\\\\[2ex] X_z \u0026amp;= \\cos ζ\\sin θ\\\\[2ex] \\end{cases} \\begin{cases} Y_x \u0026amp;= -\\cos ζ\\sin z - \\sin ζ\\cos z\\cos θ\\\\[2ex] Y_y \u0026amp;= \\cos ζ\\cos z - \\sin ζ\\sin z\\cos θ\\\\[2ex] Y_z \u0026amp;= -\\sin ζ\\sin θ\\\\[2ex] \\end{cases} \\begin{cases} Z_x \u0026amp;= -\\cos z\\sin θ\\\\[2ex] Z_y \u0026amp;= -\\sin z\\sin θ\\\\[2ex] Z_z \u0026amp;= \\cos θ \\end{cases} 那么 \\begin{cases} X′ \u0026amp;= X_xX_0 + Y_xY_0 + Z_xZ_0\\\\[2ex] Y′ \u0026amp;= X_yX_0 + Y_yY_0 + Z_yZ_0\\\\[2ex] Z′ \u0026amp;= X_zX_0 + Y_zY_0 + Z_zZ_0 \\end{cases}\n// PositionEquinox returns rectangular coordinates referenced to an arbitrary epoch. // 任意其它平分点参考系太阳直角坐标 // // Position will be computed for given Julian day \u0026quot;jde\u0026quot; but referenced to mean // equinox \u0026quot;epoch\u0026quot; (year). func PositionEquinox(e *pp.V87Planet, jde, epoch float64) (xp, yp, zp float64) { x0, y0, z0 := PositionJ2000(e, jde) t := (epoch - 2000) * .01 ζ := base.Horner(t, ζt...) * t * math.Pi / 180 / 3600 z := base.Horner(t, zt...) * t * math.Pi / 180 / 3600 θ := base.Horner(t, θt...) * t * math.Pi / 180 / 3600 sζ, cζ := math.Sincos(ζ) sz, cz := math.Sincos(z) sθ, cθ := math.Sincos(θ) xx := cζ*cz*cθ - sζ*sz xy := sζ*cz + cζ*sz*cθ xz := cζ * sθ yx := -cζ*sz - sζ*cz*cθ yy := cζ*cz - sζ*sz*cθ yz := -sζ * sθ zx := -cz * sθ zy := -sz * sθ zz := cθ return xx*x0 + yx*y0 + zx*z0, xy*x0 + yy*y0 + zy*z0, xz*x0 + yz*y0 + zz*z0 } ","date":1527227979,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1527227979,"objectID":"73762fc7877ed30791ee965a2d619094","permalink":"https://mooncaker816.github.io/2018/05/25/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9524/","publishdate":"2018-05-25T13:59:39+08:00","relpermalink":"/2018/05/25/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9524/","section":"post","summary":"第二十六章 太阳直角坐标 Rectangular Coordinates of the Sun","tags":["天文算法"],"title":"天文算法24","type":"post"},{"authors":null,"categories":["golang","算法"],"content":"第二十五章 太阳坐标 Solar Coordinates 1. 低精度太阳黄经 当计算精度要求为0.01度，计算太阳位置时可假设地球运动是一个纯椭圆，也就说忽略月球及行星摄动。\n 太阳真黄经\n$T$为J2000起算的儒略世纪数\n\\begin{align} 太阳几何平黄经：L_0 \u0026amp;= 280°.46646 + 36000°.76983T + 0°.0003032T^2\\\\[2ex] 太阳平近点角： M \u0026amp;= 357°.52911 + 35999°.05029T - 0°.0001537T^2\\\\[2ex] 地球轨道离心率： e \u0026amp;= 0.016708634 - 0.000042037T - 0.0000001267T^2\\\\[2ex] 太阳中心方程 ： C \u0026amp;= +(1°.914602 - 0°.004817T - 0°.000014T^2)\\sin M\\\\[2ex] \u0026amp;+(0°.019993 - 0°.000101T)\\sin 2M\\\\[2ex] \u0026amp;+ 0°.000289\\sin 3M \\end{align} 那么，太阳的真黄经是：$☉ = L_0 + C$ 真近点角是：$ν = M + C$\n日地距离(AU)为：$R =\\frac {1.000001018(1-e^2)}{1+e\\cos ν}$\n// True returns true geometric longitude and anomaly of the sun referenced to the mean equinox of date. // 计算太阳真黄经s，真近点角ν // // Argument T is the number of Julian centuries since J2000. // See base.J2000Century. // // Results: // s = true geometric longitude, ☉ // ν = true anomaly func True(T float64) (s, ν unit.Angle) { // (25.2) p. 163 L0 := unit.AngleFromDeg(base.Horner(T, 280.46646, 36000.76983, 0.0003032)) M := MeanAnomaly(T) C := unit.AngleFromDeg(base.Horner(T, 1.914602, -0.004817, -.000014)* M.Sin() + (0.019993-.000101*T)*M.Mul(2).Sin() + 0.000289*M.Mul(3).Sin()) return (L0 + C).Mod1(), (M + C).Mod1() } // MeanAnomaly returns the mean anomaly of Earth at the given T. // 太阳平近点角 // // Argument T is the number of Julian centuries since J2000. // See base.J2000Century. // // Result is not normalized to the range 0..2π. func MeanAnomaly(T float64) unit.Angle { // (25.3) p. 163 return unit.AngleFromDeg(base.Horner(T, 357.52911, 35999.05029, -0.0001537)) } // Eccentricity returns eccentricity of the Earth's orbit around the sun. // 地球轨道离心率 // // Argument T is the number of Julian centuries since J2000. // See base.J2000Century. func Eccentricity(T float64) float64 { // (25.4) p. 163 return base.Horner(T, 0.016708634, -0.000042037, -0.0000001267) } // Radius returns the Sun-Earth distance in AU. // 日地距离，单位为 AU // // Argument T is the number of Julian centuries since J2000. // See base.J2000Century. func Radius(T float64) float64 { _, ν := True(T) e := Eccentricity(T) // (25.5) p. 164 return 1.000001018 * (1 - e*e) / (1 + e*ν.Cos()) }  太阳视黄经\n太阳视黄经$λ$ = 太阳真黄经$☉$ + 章动修正 + 光行差修正\n如果精度要求不高，可以采用以下公式： \\begin{cases} Ω \u0026amp;= 125°.04 - 1934°.136T\\\\[2ex] λ \u0026amp;= ☉ - 0°.00569 -0°.00478\\sin Ω \\end{cases}\n// ApparentLongitude returns apparent longitude of the Sun referenced // to the true equinox of date. // 太阳视黄经，考虑了章动和光行差 // // Argument T is the number of Julian centuries since J2000. // See base.J2000Century. // // Result includes correction for nutation and aberration. func ApparentLongitude(T float64) unit.Angle { Ω := node(T) s, _ := True(T) return s - unit.AngleFromDeg(.00569) - unit.AngleFromDeg(.00478).Mul(Ω.Sin()) } func node(T float64) unit.Angle { return unit.AngleFromDeg(125.04 - 1934.136*T) }  J2000的太阳真黄经$☉_2000 = ☉ - 0°.01397(year-2000), 1900\\leq year \\leq 2100$\n// True2000 returns true geometric longitude and anomaly of the sun referenced to equinox J2000. // // Argument T is the number of Julian centuries since J2000. // See base.J2000Century. // // Results are accurate to .01 degree for years 1900 to 2100. // // Results: // s = true geometric longitude, ☉ // ν = true anomaly // J2000的太阳真黄经，真近点角 func True2000(T float64) (s, ν unit.Angle) { s, ν = True(T) s -= unit.AngleFromDeg(.01397).Mul(T * 100) return }  太阳地心赤经$α$，地心赤纬$δ$\n\\begin{cases} \\tan α = \\frac {\\cos ε\\sin ☉}{\\cos ☉}\\\\[2ex] \\sin δ = \\sin ε\\sin ☉ \\end{cases}\n// TrueEquatorial returns the true geometric position of the Sun as equatorial coordinates. // 太阳真赤经，真赤纬 func TrueEquatorial(jde float64) (α unit.RA, δ unit.Angle) { s, _ := True(base.J2000Century(jde)) ε := nutation.MeanObliquity(jde) ss, cs := s.Sincos() sε, cε := ε.Sincos() // (25.6, 25.7) p. 165 α = unit.RAFromRad(math.Atan2(cε*ss, cs)) δ = unit.Angle(math.Asin(sε * ss)) return }  太阳地心视赤经，视赤纬\n$☉$补上黄经章动及光行差得到太阳视黄经$λ$，$ε$补上交角章动$+0.00256\\cos Ω$ \\begin{cases} \\tan α = \\frac {\\cos ε\\sin λ}{\\cos λ}\\\\[2ex] \\sin δ = \\sin ε\\sin λ \\end{cases}\n// ApparentEquatorial returns the apparent position of the Sun as equatorial coordinates. // 太阳视赤经，视赤纬 // // α: right ascension in radians // δ: declination in radians func ApparentEquatorial(jde float64) (α unit.RA, δ unit.Angle) { T := base.J2000Century(jde) λ := ApparentLongitude(T) ε := nutation.MeanObliquity(jde) sλ, cλ := λ.Sincos() // (25.8) p. 165 ε += unit.AngleFromDeg(.00256).Mul(node(T).Cos()) sε, cε := ε.Sincos() α = unit.RAFromRad(math.Atan2(cε*sλ, cλ)) δ = unit.Angle(math.Asin(sε * sλ)) return }   2. 高精度太阳黄经  太阳地心黄经，地心黄纬 先采用VSOP87理论计算地球位置得到地球的日心黄经$L$，黄纬$β$，日地距离$R$ 再计算地心黄经$☉ = L + 180°$,黄纬$β=-B$\n令$λ′ = ☉ - 1°.397T - 0°.00031T^2$\n那么 \\begin{cases} Δ☉ = -0\u0026rdquo;.09033\\\\[2ex] Δβ = +0\u0026rdquo;.03916(\\cos(λ′) - \\sin(λ′)) \\end{cases}\n// TrueVSOP87 returns the true geometric position of the sun as ecliptic coordinates. // 根据VSOP87理论计算太阳真黄经，真黄纬，日地距离 // // Result computed by full VSOP87 theory. Result is at equator and equinox // of date in the FK5 frame. It does not include nutation or aberration. // // s: ecliptic longitude // β: ecliptic latitude // R: range in AU func TrueVSOP87(e *pp.V87Planet, jde float64) (s, β unit.Angle, R float64) { l, b, r := e.Position(jde) //VSOP87算出的地球的日心黄经，黄纬，日地距离 s = l + math.Pi // FK5 correction. λp := base.Horner(base.J2000Century(jde), s.Rad(), -1.397*math.Pi/180, -.00031*math.Pi/180) sλp, cλp := math.Sincos(λp) Δβ := unit.AngleFromSec(.03916).Mul(cλp - sλp) // (25.9) p. 166 s -= unit.AngleFromSec(.09033) return s.Mod1(), Δβ - b, r }  太阳地心视黄经\n与日心视黄经一样，对日心黄经进行章动和光行差修正 章动可以由章动公式求得，光行差可以由以下公式求得$$-20\u0026rdquo;.4898/R$$\n// ApparentVSOP87 returns the apparent position of the sun as ecliptic coordinates. // 根据VSOP87理论计算太阳视黄经，视黄纬，日地距离，考虑了章动和光行差 // 即真黄经+黄经章动+光行差，真黄纬，日地距离不变 // // Result computed by VSOP87, at equator and equinox of date in the FK5 frame, // and includes effects of nutation and aberration. // // λ: ecliptic longitude // β: ecliptic latitude // R: range in AU func ApparentVSOP87(e *pp.V87Planet, jde float64) (λ, β unit.Angle, R float64) { // note: see duplicated code in ApparentEquatorialVSOP87. s, β, R := TrueVSOP87(e, jde) Δψ, _ := nutation.Nutation(jde) a := aberration(R) return s + Δψ + a, β, R } // Low precision formula. The high precision formula is not implemented // because the low precision formula already gives position results to the // accuracy given on p. 165. The high precision formula the represents lots // of typing with associated chance of typos, and no way to test the result. // 低精度光行差修正项 func aberration(R float64) unit.Angle { // (25.10) p. 167 return unit.AngleFromSec(-20.4898).Div(R) }  太阳地心视赤经，视赤纬\n算法同低精度太阳地心视赤经，视赤纬一致\n// ApparentEquatorialVSOP87 returns the apparent position of the sun as equatorial coordinates. // 根据VSOP87理论计算太阳视赤经，视赤纬，日地距离，考虑了章动和光行差 // 即先计算视黄经，视黄纬，此时考虑交角章动，用真黄赤交角转为赤道坐标 // // Result computed by VSOP87, at equator and equinox of date in the FK5 frame, // and includes effects of nutation and aberration. // // α: right ascension // δ: declination // R: range in AU func ApparentEquatorialVSOP87(e *pp.V87Planet, jde float64) (α unit.RA, δ unit.Angle, R float64) { // note: duplicate code from ApparentVSOP87 so we can keep Δε. // see also duplicate code in time.E(). s, β, R := TrueVSOP87(e, jde) Δψ, Δε := nutation.Nutation(jde) a := aberration(R) λ := s + Δψ + a ε := nutation.MeanObliquity(jde) + Δε sε, cε := ε.Sincos() α, δ = coord.EclToEq(λ, β, sε, cε) return }  ","date":1527206814,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1527206814,"objectID":"793407c5ec1eba88347c6475837e8d84","permalink":"https://mooncaker816.github.io/2018/05/25/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9523/","publishdate":"2018-05-25T08:06:54+08:00","relpermalink":"/2018/05/25/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9523/","section":"post","summary":"第二十五章 太阳坐标 Solar Coordinates","tags":["天文算法"],"title":"天文算法23","type":"post"},{"authors":null,"categories":["golang","算法"],"content":"第二十四章 Reduction of Ecliptical Elements from one Equinox to another one 略","date":1527206660,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1527206660,"objectID":"cbb90ef0e0219837f60f4299494d53b1","permalink":"https://mooncaker816.github.io/2018/05/25/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9522/","publishdate":"2018-05-25T08:04:20+08:00","relpermalink":"/2018/05/25/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9522/","section":"post","summary":"第二十四章 Reduction of Ecliptical Elements from one Equinox to another one","tags":["天文算法"],"title":"天文算法22","type":"post"},{"authors":null,"categories":["golang","算法"],"content":"第二十三章 Apparent Place of a Star 1. 平，视位置 任意时刻恒星的平位置是：当观测者站在不动的太阳上（严格的说是太阳系的质心）看到它在天球上的视位置，并且，它的位置坐标涉及 Date 黄道平分点（或 Date 赤道平分点）。\n任意时刻恒星的视位置是：当观测者站在移动着的地心看到它在天球上的位置，其视坐标涉及瞬时赤道、黄道及分点\n2. 平转视的影响因素  恒星的自行运动  第二十一章已经给出计算方法\n 岁差  第二十一章已经给出计算方法\n 章动  赤经章动和赤纬章动\n\\begin{cases} Δα_1=(\\cos ε+\\sin ε\\sin α\\tan δ)Δψ-\\cos α\\tan δΔε\\\\[2ex] Δδ_1 = \\sin ε\\cos αΔψ + \\sin αΔε \\end{cases} 其中$Δψ,Δε$可以使用章动章节给出的方法计算，$ε$是平黄赤交角\n// Nutation returns corrections due to nutation for equatorial coordinates // of an object. // // Results are invalid for objects very near the celestial poles. // 章动导致的赤道坐标修正 func Nutation(α unit.RA, δ unit.Angle, jd float64) (Δα1 unit.HourAngle, Δδ1 unit.Angle) { ε := nutation.MeanObliquity(jd) sε, cε := ε.Sincos() Δψ, Δε := nutation.Nutation(jd) sα, cα := α.Sincos() tδ := δ.Tan() // (23.1) p. 151 Δα1 = unit.HourAngle((cε+sε*sα*tδ)*Δψ.Rad() - cα*tδ*Δε.Rad()) Δδ1 = Δψ.Mul(sε*cα) + Δε.Mul(sα) return }   周年光行差  黄道周年光行差：\n$λ,β$是恒星的黄经和黄纬，$K$是光行差常数（20\u0026rdquo;.49552），$Θ$是太阳真黄经(也叫几何黄经)，$e$是地球 轨道的离心率，$π$轨道近日点经度\n\\begin{cases} Θ 可使用后续章节的方法计算\\\\[2ex] e = 0.016708617 - 0.000042037T - 0.0000001236T^2\\\\[2ex] π = 102°.93735 + 1°.71953T + 0°.00046T^2 \\end{cases} $T$是J2000.0起算的儒略世纪数 则 \\begin{cases} Δλ \u0026amp;= \\frac {-K\\cos (Θ-λ)+eK\\cos (π-λ)}{\\cos β}\\\\[2ex] Δβ \u0026amp;= -K\\sin β(\\sin (Θ-λ)-e\\sin (π-λ)) \\end{cases}\n// κ is the constnt of aberration in radians. var κ = unit.AngleFromSec(20.49552) // longitude of perihelian of Earth's orbit. // 近日点经度 func perihelion(T float64) unit.Angle { return unit.AngleFromDeg(base.Horner(T, 102.93735, 1.71946, .00046)) } // EclipticAberration returns corrections due to aberration for ecliptic // coordinates of an object. // 光行差导致的黄道坐标的修正 func EclipticAberration(λ, β unit.Angle, jd float64) (Δλ, Δβ unit.Angle) { T := base.J2000Century(jd) s, _ := solar.True(T) //太阳真黄经 e := solar.Eccentricity(T) //地球轨道离心率 π := perihelion(T) //地球近日点经度 sβ, cβ := β.Sincos() ssλ, csλ := (s - λ).Sincos() sπλ, cπλ := (π - λ).Sincos() // (23.2) p. 151 Δλ = κ.Mul((e*cπλ - csλ) / cβ) Δβ = -κ.Mul(sβ * (ssλ - e*sπλ)) return }  赤道周年光行差： \\begin{cases} Δα_2 \u0026amp;= -K\\frac {\\cos α\\cos Θ\\cos ε + \\sin α\\sin Θ}{\\cos δ} + eK\\frac {\\cos α\\cos π\\cos ε + \\sin α\\sin π}{\\cos δ}\\\\[2ex] Δδ_2 \u0026amp;= -K(\\cos Θ\\cos ε(\\tan ε\\cos δ - \\sin α\\sin δ)+\\cos α\\sin δ\\sin Θ)\\\\[2ex] \u0026amp;+eK(\\cos π\\cos ε(\\tan ε\\cos δ - \\sin α\\sin δ)+\\cos α\\sin δ\\sin π) \\end{cases}\n// Aberration returns corrections due to aberration for equatorial // coordinates of an object. // 光行差导致的赤道坐标的修正 func Aberration(α unit.RA, δ unit.Angle, jd float64) (Δα2 unit.HourAngle, Δδ2 unit.Angle) { ε := nutation.MeanObliquity(jd) T := base.J2000Century(jd) s, _ := solar.True(T) e := solar.Eccentricity(T) π := perihelion(T) sα, cα := α.Sincos() sδ, cδ := δ.Sincos() ss, cs := s.Sincos() sπ, cπ := π.Sincos() cε := ε.Cos() tε := ε.Tan() q1 := cα * cε // (23.3) p. 152 Δα2 = unit.HourAngle(κ.Rad() * (e*(q1*cπ+sα*sπ) - (q1*cs + sα*ss)) / cδ) q2 := cε * (tε*cδ - sα*sδ) q3 := cα * sδ Δδ2 = κ.Mul(e*(cπ*q2+sπ*q3) - (cs*q2 + ss*q3)) return }  Ron_Vondrak法：\n// AberrationRonVondrak uses the Ron-Vondrák expression to compute corrections // due to aberration for equatorial coordinates of an object. // RonVondrak方法计算光行差引起的赤道坐标的修正 func AberrationRonVondrak(α unit.RA, δ unit.Angle, jd float64) (Δα unit.HourAngle, Δδ unit.Angle) { T := base.J2000Century(jd) r := \u0026amp;rv{ T: T, L2: 3.1761467 + 1021.3285546*T, L3: 1.7534703 + 628.3075849*T, L4: 6.2034809 + 334.0612431*T, L5: 0.5995465 + 52.9690965*T, L6: 0.8740168 + 21.3299095*T, L7: 5.4812939 + 7.4781599*T, L8: 5.3118863 + 3.8133036*T, Lp: 3.8103444 + 8399.6847337*T, D: 5.1984667 + 7771.3771486*T, Mp: 2.3555559 + 8328.6914289*T, F: 1.6279052 + 8433.4661601*T, } var Xp, Yp, Zp float64 // sum smaller terms first for i := 35; i \u0026gt;= 0; i-- { x, y, z := rvTerm[i](r) Xp += x Yp += y Zp += z } sα, cα := α.Sincos() sδ, cδ := δ.Sincos() // (23.4) p. 156 Δα = unit.HourAngle((Yp*cα - Xp*sα) / (c * cδ)) Δδ = unit.Angle(-((Xp*cα+Yp*sα)*sδ - Zp*cδ) / c) return } const c = 17314463350 // unit is 1e-8 AU / day type rv struct { T, L2, L3, L4, L5, L6, L7, L8, Lp, D, Mp, F float64 } type rvFunc func(*rv) (x, y, z float64) var rvTerm = [36]rvFunc{ func(r *rv) (x, y, z float64) { // 1 sA, cA := math.Sincos(r.L3) return (-1719914-2*r.T)*sA - 25*cA, (25-13*r.T)*sA + (1578089+156*r.T)*cA, (10+32*r.T)*sA + (684185-358*r.T)*cA }, func(r *rv) (x, y, z float64) { // 2 sA, cA := math.Sincos(2 * r.L3) return (6434+141*r.T)*sA + (28007-107*r.T)*cA, (25697-95*r.T)*sA + (-5904-130*r.T)*cA, (11141-48*r.T)*sA + (-2559-55*r.T)*cA }, func(r *rv) (x, y, z float64) { // 3 sA, cA := math.Sincos(r.L5) return 715 * sA, 6*sA - 657*cA, -15*sA - 282*cA }, func(r *rv) (x, y, z float64) { // 4 sA, cA := math.Sincos(r.Lp) return 715 * sA, -656 * cA, -285 * cA }, func(r *rv) (x, y, z float64) { // 5 sA, cA := math.Sincos(3 * r.L3) return (486-5*r.T)*sA + (-236-4*r.T)*cA, (-216-4*r.T)*sA + (-446+5*r.T)*cA, -94*sA - 193*cA }, func(r *rv) (x, y, z float64) { // 6 sA, cA := math.Sincos(r.L6) return 159 * sA, 2*sA - 147*cA, -6*sA - 61*cA }, func(r *rv) (x, y, z float64) { // 7 cA := math.Cos(r.F) return 0, 26 * cA, -59 * cA }, func(r *rv) (x, y, z float64) { // 8 sA, cA := math.Sincos(r.Lp + r.Mp) return 39 * sA, -36 * cA, -16 * cA }, func(r *rv) (x, y, z float64) { // 9 sA, cA := math.Sincos(2 * r.L5) return 33*sA - 10*cA, -9*sA - 30*cA, -5*sA - 13*cA }, func(r *rv) (x, y, z float64) { // 10 sA, cA := math.Sincos(2*r.L3 - r.L5) return 31*sA + cA, sA - 28*cA, -12 * cA }, func(r *rv) (x, y, z float64) { // 11 sA, cA := math.Sincos(3*r.L3 - 8*r.L4 + 3*r.L5) return 8*sA - 28*cA, 25*sA + 8*cA, 11*sA + 3*cA }, func(r *rv) (x, y, z float64) { // 12 sA, cA := math.Sincos(5*r.L3 - 8*r.L4 + 3*r.L5) return 8*sA - 28*cA, -25*sA - 8*cA, -11*sA + -3*cA }, func(r *rv) (x, y, z float64) { // 13 sA, cA := math.Sincos(2*r.L2 - r.L3) return 21 * sA, -19 * cA, -8 * cA }, func(r *rv) (x, y, z float64) { // 14 sA, cA := math.Sincos(r.L2) return -19 * sA, 17 * cA, 8 * cA }, func(r *rv) (x, y, z float64) { // 15 sA, cA := math.Sincos(r.L7) return 17 * sA, -16 * cA, -7 * cA }, func(r *rv) (x, y, z float64) { // 16 sA, cA := math.Sincos(r.L3 - 2*r.L5) return 16 * sA, 15 * cA, sA + 7*cA }, func(r *rv) (x, y, z float64) { // 17 sA, cA := math.Sincos(r.L8) return 16 * sA, sA - 15*cA, -3*sA - 6*cA }, func(r *rv) (x, y, z float64) { // 18 sA, cA := math.Sincos(r.L3 + r.L5) return 11*sA - cA, -sA - 10*cA, -sA - 5*cA }, func(r *rv) (x, y, z float64) { // 19 sA, cA := math.Sincos(2*r.L2 - 2*r.L3) return -11 * cA, -10 * sA, -4 * sA }, func(r *rv) (x, y, z float64) { // 20 sA, cA := math.Sincos(r.L3 - r.L5) return -11*sA - 2*cA, -2*sA + 9*cA, -sA + 4*cA }, func(r *rv) (x, y, z float64) { // 21 sA, cA := math.Sincos(4 * r.L3) return -7*sA - 8*cA, -8*sA + 6*cA, -3*sA + 3*cA }, func(r *rv) (x, y, z float64) { // 22 sA, cA := math.Sincos(3*r.L3 - 2*r.L5) return -10 * sA, 9 * cA, 4 * cA }, func(r *rv) (x, y, z float64) { // 23 sA, cA := math.Sincos(r.L2 - 2*r.L3) return -9 * sA, -9 * cA, -4 * cA }, func(r *rv) (x, y, z float64) { // 24 sA, cA := math.Sincos(2*r.L2 - 3*r.L3) return -9 * sA, -8 * cA, -4 * cA }, func(r *rv) (x, y, z float64) { // 25 sA, cA := math.Sincos(2 * r.L6) return -9 * cA, -8 * sA, -3 * sA }, func(r *rv) (x, y, z float64) { // 26 sA, cA := math.Sincos(2*r.L2 - 4*r.L3) return -9 * cA, 8 * sA, 3 * sA }, func(r *rv) (x, y, z float64) { // 27 sA, cA := math.Sincos(3*r.L3 - 2*r.L4) return 8 * sA, -8 * cA, -3 * cA }, func(r *rv) (x, y, z float64) { // 28 sA, cA := math.Sincos(r.Lp + 2*r.D - r.Mp) return 8 * sA, -7 * cA, -3 * cA }, func(r *rv) (x, y, z float64) { // 29 sA, cA := math.Sincos(8*r.L2 - 12*r.L3) return -4*sA - 7*cA, -6*sA + 4*cA, -3*sA + 2*cA }, func(r *rv) (x, y, z float64) { // 30 sA, cA := math.Sincos(8*r.L2 - 14*r.L3) return -4*sA - 7*cA, 6*sA - 4*cA, 3*sA - 2*cA }, func(r *rv) (x, y, z float64) { // 31 sA, cA := math.Sincos(2 * r.L4) return -6*sA - 5*cA, -4*sA + 5*cA, -2*sA + 2*cA }, func(r *rv) (x, y, z float64) { // 32 sA, cA := math.Sincos(3*r.L2 - 4*r.L3) return -sA - cA, -2*sA - 7*cA, sA - 4*cA }, func(r *rv) (x, y, z float64) { // 33 sA, cA := math.Sincos(2*r.L3 - 2*r.L5) return 4*sA - 6*cA, -5*sA - 4*cA, -2*sA - 2*cA }, func(r *rv) (x, y, z float64) { // 34 sA, cA := math.Sincos(3*r.L2 - 3*r.L3) return -7 * cA, -6 * sA, -3 * sA }, func(r *rv) (x, y, z float64) { // 35 sA, cA := math.Sincos(2*r.L3 - 2*r.L4) return 5*sA - 5*cA, -4*sA - 5*cA, -2*sA - 2*cA }, func(r *rv) (x, y, z float64) { // 36 sA, cA := math.Sincos(r.Lp - 2*r.D) return 5 * sA, -5 * cA, -2 * cA }, }   周年视差  该算法忽略\n","date":1527163283,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1527163283,"objectID":"471940309f1cf7224181924ecb84f33e","permalink":"https://mooncaker816.github.io/2018/05/24/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9521/","publishdate":"2018-05-24T20:01:23+08:00","relpermalink":"/2018/05/24/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9521/","section":"post","summary":"第二十三章 Apparent Place of a Star","tags":["天文算法"],"title":"天文算法21","type":"post"},{"authors":null,"categories":["golang","算法"],"content":"第二十二章 章动和黄赤交角 Nutation and the Obliquity of the Ecliptic 1. 名词解释 章动\n2. 章动的分量 　章动可以很容易的分解为黄道的水平分量和的垂直分量。黄道上的分量记为$Δψ$，称为黄经章动；它影响了天球上所有天体的经度。黄道的垂直分量记为$Δε$，称为交角章动，它影响了黄赤交角。\n3. 较精确计算章动 // Nutation returns nutation in longitude (Δψ) and nutation in obliquity (Δε) // for a given JDE. // // JDE = UT + ΔT, see package deltat. // // Computation is by 1980 IAU theory, with terms \u0026lt; .0003″ neglected. // 计算 jde 对应的章动 func Nutation(jde float64) (Δψ, Δε unit.Angle) { T := base.J2000Century(jde) D := base.Horner(T, 297.85036, 445267.11148, -0.0019142, 1./189474) * math.Pi / 180 M := base.Horner(T, 357.52772, 35999.050340, -0.0001603, -1./300000) * math.Pi / 180 N := base.Horner(T, 134.96298, 477198.867398, 0.0086972, 1./56250) * math.Pi / 180 F := base.Horner(T, 93.27191, 483202.017538, -0.0036825, 1./327270) * math.Pi / 180 Ω := base.Horner(T, 125.04452, -1934.136261, 0.0020708, 1./450000) * math.Pi / 180 // sum in reverse order to accumulate smaller terms first var Δψs, Δεs float64 for i := len(table22A) - 1; i \u0026gt;= 0; i-- { row := table22A[i] arg := row.d*D + row.m*M + row.n*N + row.f*F + row.ω*Ω s, c := math.Sincos(arg) Δψs += s * (row.s0 + row.s1*T) Δεs += c * (row.c0 + row.c1*T) } Δψ = unit.AngleFromSec(Δψs * .0001) Δε = unit.AngleFromSec(Δεs * .0001) return }  4. 粗略计算章动 Δψ精度为0.5″,Δε精度为0.1″\n// ApproxNutation returns a fast approximation of nutation in longitude (Δψ) // and nutation in obliquity (Δε) for a given JDE. // // Accuracy is 0.5″ in Δψ, 0.1″ in Δε. // 精度要求为0.5″ in Δψ, 0.1″ in Δε func ApproxNutation(jde float64) (Δψ, Δε unit.Angle) { T := (jde - base.J2000) / 36525 Ω := (125.04452 - 1934.136261*T) * math.Pi / 180 L := (280.4665 + 36000.7698*T) * math.Pi / 180 N := (218.3165 + 481267.8813*T) * math.Pi / 180 sΩ, cΩ := math.Sincos(Ω) s2L, c2L := math.Sincos(2 * L) s2N, c2N := math.Sincos(2 * N) s2Ω, c2Ω := math.Sincos(2 * Ω) Δψ = unit.AngleFromSec(-17.2*sΩ - 1.32*s2L - 0.23*s2N + 0.21*s2Ω) Δε = unit.AngleFromSec(9.2*cΩ + 0.57*c2L + 0.1*c2N - 0.09*c2Ω) return }  5. 黄赤交角  平黄赤交角$ε_0$：黄道与平赤道的夹角\n$$ε_0 = 23°26\u0026rsquo;21\u0026rdquo;.448 - 46\u0026rdquo;.8150T - 0\u0026rdquo;.00059T^2 + 0\u0026rdquo;.001813T^3$$\nT是J2000.0起算的儒略世纪数\n　当时间范围很长，上述公式的精度并不令人满意：2000年误差1\u0026rdquo;，4000误差为10\u0026rdquo;。Laskar提供了以下改良的的公式，式中U是J2000.0起算的儒略万年数，即U=T/100： \\begin{align} ε_0 =\u0026amp; 23°26\u0026rsquo;21\u0026rdquo;.448 - 4680\u0026rdquo;.93U - 1.55U^2 + 1999.25U^3 - 51.38U^4 - 249.67U^5 \\\\[2ex] \u0026amp;-39.05U^6 + 7.12U^7 + 27.87U^8 + 5.79U^9 + 2.45U^{10} \\end{align} 该表达式的精度是：1000年后误差0\u0026rdquo;.01(公元 1000 到 3000)，10000年后误差数个角秒。\n该表达式适用于|U|\u0026lt;1，即 J2000.0 起算前后各 10000 年的范围内。\n// MeanObliquity returns mean obliquity (ε₀) following the IAU 1980 // polynomial. // // Accuracy is 1″ over the range 1000 to 3000 years and 10″ over the range // 0 to 4000 years. // 平黄赤交角 - 精度一般，2000年误差 1\u0026quot;，4000年误差为 10\u0026quot; func MeanObliquity(jde float64) unit.Angle { // (22.2) p. 147 return unit.AngleFromSec(base.Horner(base.J2000Century(jde), unit.FromSexaSec(' ', 23, 26, 21.448), -46.815, -0.00059, 0.001813)) } // MeanObliquityLaskar returns mean obliquity (ε₀) following the Laskar // 1986 polynomial. // // Accuracy over the range 1000 to 3000 years is .01″. // // Accuracy over the valid date range of -8000 to +12000 years is // \u0026quot;a few seconds.\u0026quot; // 平黄赤交角 - 精度较好，1000年后误差0\u0026quot;.01(公元 1000 到 3000)，10000年后误差数个角秒 // 适用范围：J2000.0 起算前后各10000年的范围内。 func MeanObliquityLaskar(jde float64) unit.Angle { // (22.3) p. 147 return unit.AngleFromSec(base.Horner(base.J2000Century(jde)*.01, unit.FromSexaSec(' ', 23, 26, 21.448), -4680.93, -1.55, 1999.25, -51.38, -249.67, -39.05, 7.12, 27.87, 5.79, 2.45)) }  真黄赤交角：黄道与真赤道的夹角\n$$ε = ε_0 + Δε$$\n ","date":1527065934,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1527065934,"objectID":"984c154bb43b3291da7cecb71630b88d","permalink":"https://mooncaker816.github.io/2018/05/23/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9520/","publishdate":"2018-05-23T16:58:54+08:00","relpermalink":"/2018/05/23/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9520/","section":"post","summary":"第二十二章 章动和黄赤交角 Nutation and the Obliquity of the Ecliptic","tags":["天文算法"],"title":"天文算法20","type":"post"},{"authors":null,"categories":["golang","算法"],"content":"第二十一章 岁差 1. 名词解释 Precession\n2. 赤道坐标岁差的近似计算 　当两个历元相差不远，并且如果星体没有太靠近天极，下面的公式可以用来计算在这两个历元之间的，相对于起始历元的截至历元的年度平均岁差：$$Δα = m + n\\sin α\\tan δ$$ 其中$m = 3s.07496 + 0s.00186T, n = 1s.33621 - 0s.00057T$ $$Δδ = n*cos(α)$$ 其中$n = 20\u0026rdquo;.0431 - 0\u0026rdquo;.0085T$\nT是J2000.0起算的儒略世纪数\n// ApproxAnnualPrecession returns approximate annual precision in right // ascension and declination. // // The two epochs should be within a few hundred years. // The declinations should not be too close to the poles. // 近似计算截至历元相对于起始历元的年度平均岁差，俩历元不能相差太远，且天体不能靠近天极 func ApproxAnnualPrecession(eq *coord.Equatorial, epochFrom, epochTo float64) (Δα unit.HourAngle, Δδ unit.Angle) { m, nα, nδ := mn(epochFrom, epochTo) sα, cα := eq.RA.Sincos() // (21.1) p. 132 Δα = m + nα.Mul(sα*eq.Dec.Tan()) Δδ = nδ.Mul(cα) return } // mn as separate function for testing purposes // 计算截至历元相对于起始历元的平均年度岁差要用的变量 m,n func mn(epochFrom, epochTo float64) (m, nα unit.HourAngle, nδ unit.Angle) { T := (epochTo - epochFrom) * .01 m = unit.HourAngleFromSec(3.07496 + 0.00186*T) nα = unit.HourAngleFromSec(1.33621 - 0.00057*T) nδ = unit.AngleFromSec(20.0431 - 0.0085*T) return } // ApproxPosition uses ApproxAnnualPrecession to compute a simple and quick // precession while still considering proper motion. // // Both eqFrom and eqTo must be non-nil, although they may point to the same // struct. EqTo is returned for convenience. // 两历元之间坐标的换算，考虑岁差和自行运动（mα，mδ） func ApproxPosition(eqFrom, eqTo *coord.Equatorial, epochFrom, epochTo float64, mα unit.HourAngle, mδ unit.Angle) *coord.Equatorial { Δα, Δδ := ApproxAnnualPrecession(eqFrom, epochFrom, epochTo) dy := epochTo - epochFrom eqTo.RA = eqFrom.RA.Add((Δα + mα).Mul(dy)) eqTo.Dec = eqFrom.Dec + (Δδ + mδ).Mul(dy) return eqTo }  3. 赤道坐标岁差的精确计算 设T是J2000.0起算的儒略世纪数，t是某一起始历元到终止历元之间的时间差，单位也是儒略世纪数。 \\begin{cases} ζ = ( 2306\u0026rdquo;.2181 + 1\u0026rdquo;.39656T - 0\u0026rdquo;.000139T^2)t + (0\u0026rdquo;.30188 - 0\u0026rdquo;.000344T)t^2 + 0\u0026rdquo;.017998t^3\\\\[2ex] z = ( 2306\u0026rdquo;.2181 + 1\u0026rdquo;.39656T - 0\u0026rdquo;.000139T^2)t + (1\u0026rdquo;.09468 + 0\u0026rdquo;.000066T)t^2 + 0\u0026rdquo;.018203t^3\\\\[2ex] θ = ( 2004\u0026rdquo;.3109 - 0\u0026rdquo;.85330T - 0\u0026rdquo;.000217T^2)t - (0\u0026rdquo;.42665 + 0\u0026rdquo;.000217T)t^2 - 0\u0026rdquo;.041833t^3 \\end{cases} 当T=0时，即起始历元正好就是J2000.0, \\begin{cases} ζ = 2306\u0026rdquo;.2181t + 0\u0026rdquo;.30188t^2 + 0\u0026rdquo;.017998t^3\\\\[2ex] z = 2306\u0026rdquo;.2181t + 1\u0026rdquo;.09468t^2 + 0\u0026rdquo;.018203t^3\\\\[2ex] θ = 2004\u0026rdquo;.3109t - 0\u0026rdquo;.42665t^2 - 0\u0026rdquo;.041833t^3 \\end{cases} 再计算 \\begin{cases} A \u0026amp;= \\cos δ_0\\sin(α_0 + ζ)\\\\[2ex] B \u0026amp;= \\cos θ\\cos δ_0\\cos(α_0 +ζ) - \\sin θ\\sin δ_0\\\\[2ex] C \u0026amp;= \\sin θ\\cos δ_0\\cos(α_0 +ζ) + \\cos θ\\sin δ_0 \\end{cases} 则$$\\tan(α-z) = A/B,\\sin δ = C$$ 如果星体接近天极，使用$\\cos δ = \\sqrt {A^2+B^2}$代替$\\sin δ = C$\n$α,δ$即为经过岁差转换后的赤道坐标\n// Precessor represents precession from one epoch to another. // // Construct with NewPrecessor, then call method Precess. // After construction, Precess may be called multiple times to precess // different coordinates with the same initial and final epochs. // 计算赤道坐标精确岁差要用到的变量 type Precessor struct { ζ unit.RA z unit.Angle sθ, cθ float64 } const d = math.Pi / 180 const s = d / 3600 // Package variables allow these slices to be reused. (As composite // literals inside of NewPrecessor they would be reallocated on every // function call.) var ( // coefficients from (21.2) p. 134 ζT = []float64{2306.2181 * s, 1.39656 * s, -0.000139 * s} zT = []float64{2306.2181 * s, 1.39656 * s, -0.000139 * s} θT = []float64{2004.3109 * s, -0.8533 * s, -0.000217 * s} // coefficients from (21.3) p. 134 ζt = []float64{2306.2181 * s, 0.30188 * s, 0.017998 * s} zt = []float64{2306.2181 * s, 1.09468 * s, 0.018203 * s} θt = []float64{2004.3109 * s, -0.42665 * s, -0.041833 * s} ) // NewPrecessor constructs a Precessor object and initializes it to precess // coordinates from epochFrom to epochTo. // 构造赤道坐标岁差计算要素 func NewPrecessor(epochFrom, epochTo float64) *Precessor { // (21.2) p. 134 ζCoeff := ζt zCoeff := zt θCoeff := θt if epochFrom != 2000 { T := (epochFrom - 2000) * .01 ζCoeff = []float64{ base.Horner(T, ζT...), 0.30188*s - 0.000344*s*T, 0.017998 * s} zCoeff = []float64{ base.Horner(T, zT...), 1.09468*s + 0.000066*s*T, 0.018203 * s} θCoeff = []float64{ base.Horner(T, θT...), -0.42665*s - 0.000217*s*T, -0.041833 * s} } t := (epochTo - epochFrom) * .01 p := \u0026amp;Precessor{ ζ: unit.RA(base.Horner(t, ζCoeff...) * t), z: unit.Angle(base.Horner(t, zCoeff...) * t), } θ := base.Horner(t, θCoeff...) * t p.sθ, p.cθ = math.Sincos(θ) return p } // Precess precesses coordinates eqFrom, leaving result in eqTo. // // The same struct may be used for eqFrom and eqTo. // EqTo is returned for convenience. // 赤道坐标的岁差转换计算 func (p *Precessor) Precess(eqFrom, eqTo *coord.Equatorial) *coord.Equatorial { // (21.4) p. 134 sδ, cδ := eqFrom.Dec.Sincos() sαζ, cαζ := (eqFrom.RA + p.ζ).Sincos() A := cδ * sαζ B := p.cθ*cδ*cαζ - p.sθ*sδ C := p.sθ*cδ*cαζ + p.cθ*sδ eqTo.RA = unit.RAFromRad(math.Atan2(A, B) + p.z.Rad()) if math.Abs(C) \u0026lt; base.CosSmallAngle { eqTo.Dec = unit.Angle(math.Asin(C)) } else { eqTo.Dec = unit.Angle(math.Acos(math.Hypot(A, B))) // near pole if C \u0026lt; 0 { eqTo.Dec = -eqTo.Dec } } return eqTo } // Position precesses equatorial coordinates from one epoch to another, // including proper motions. // // If proper motions are not to be considered or are not applicable, pass 0, 0 // for mα, mδ // // Both eqFrom and eqTo must be non-nil, although they may point to the same // struct. EqTo is returned for convenience. // 考虑自行运动的赤道坐标的转换 func Position(eqFrom, eqTo *coord.Equatorial, epochFrom, epochTo float64, mα unit.HourAngle, mδ unit.Angle) *coord.Equatorial { p := NewPrecessor(epochFrom, epochTo) t := epochTo - epochFrom eqTo.RA = unit.RAFromRad(eqFrom.RA.Rad() + mα.Rad()*t) eqTo.Dec = eqFrom.Dec + mδ*unit.Angle(t) return p.Precess(eqTo, eqTo) }  4. 黄道坐标岁差的精确计算 同上，我们先计算 \\begin{cases} η = (47\u0026rdquo;.0029 - 0\u0026rdquo;.06603T + 0\u0026rdquo;.000598T^2)t + (-0\u0026rdquo;.03302 + 0\u0026rdquo;.000598T)t^2 +0\u0026rdquo;.000060t^3\\\\[2ex] П = 174°.876384 + 3289\u0026rdquo;.4789T + 0\u0026rdquo;.60622T^2 (869\u0026rdquo;.8089 + 0\u0026rdquo;.50491T)t + 0\u0026rdquo;.03536t^2\\\\[2ex] p = (5029\u0026rdquo;.0966 + 2\u0026rdquo;.22226T - 0\u0026rdquo;.000042T^2)t + (1\u0026rdquo;.11113 - 0\u0026rdquo;.000042T)t^2 -0\u0026rdquo;.000006t^3 \\end{cases} 当$T=0$时， \\begin{cases} η = 47\u0026rdquo;.0029t -0\u0026rdquo;.03302t^2 +0\u0026rdquo;.000060t^3\\\\[2ex] П = 174°.876384 -869\u0026rdquo;.8089t +0\u0026rdquo;.03536t^2\\\\[2ex] p = 5029\u0026rdquo;.0966t +1\u0026rdquo;.11113t^2 -0\u0026rdquo;.000006t^3 \\end{cases} 再计算 \\begin{cases} A′ \u0026amp;= \\cos η\\cos β_0\\sin(П-λ_0) - \\sin η\\sin β_0\\\\[2ex] B′ \u0026amp;= \\cos β_0\\cos(П-λ_0)\\\\[2ex] C′ \u0026amp;= \\cos η\\sin β_0 + \\sin η\\cos β_0\\sin(П-λ_0) \\end{cases} 则$$\\tan(p +П-λ) = A′/B′,\\sin β = C′$$ 如果星体接近天极，使用$\\cos β = \\sqrt {A′^2+B′^2}$代替$\\sin β = C′$\n$λ,β$即为经过岁差转换后的黄道坐标\n// EclipticPrecessor represents precession from one epoch to another. // // Construct with NewEclipticPrecessor, then call method Precess. // After construction, Precess may be called multiple times to precess // different coordinates with the same initial and final epochs. // 计算黄道坐标精确岁差要用到的变量 type EclipticPrecessor struct { sη, cη float64 π, p unit.Angle } var ( // coefficients from (21.5) p. 136, scaled to radians ηT = []float64{47.0029 * s, -0.06603 * s, 0.000598 * s} πT = []float64{174.876384 * d, 3289.4789 * s, 0.60622 * s} pT = []float64{5029.0966 * s, 2.22226 * s, -0.000042 * s} // coefficients from (21.6) p. 136, scaled to radians ηt = []float64{47.0029 * s, -0.03302 * s, 0.000060 * s} πt = []float64{174.876384 * d, -869.8089 * s, 0.03536 * s} pt = []float64{5029.0966 * s, 1.11113 * s, -0.000006 * s} ) // NewEclipticPrecessor constructs an EclipticPrecessor object and initializes // it to precess coordinates from epochFrom to epochTo. // 构造黄道坐标岁差计算要素 func NewEclipticPrecessor(epochFrom, epochTo float64) *EclipticPrecessor { // (21.5) p. 136 ηCoeff := ηt πCoeff := πt pCoeff := pt if epochFrom != 2000 { T := (epochFrom - 2000) * .01 ηCoeff = []float64{ base.Horner(T, ηT...), -0.03302*s + 0.000598*s*T, 0.000060 * s} πCoeff = []float64{ base.Horner(T, πT...), -869.8089*s - 0.50491*s*T, 0.03536 * s} pCoeff = []float64{ base.Horner(T, pT...), 1.11113*s - 0.000042*s*T, -0.000006 * s} } t := (epochTo - epochFrom) * .01 p := \u0026amp;EclipticPrecessor{ π: unit.Angle(base.Horner(t, πCoeff...)), p: unit.Angle(base.Horner(t, pCoeff...) * t), } η := unit.Angle(base.Horner(t, ηCoeff...) * t) p.sη, p.cη = η.Sincos() return p } // EclipticPrecess precesses coordinates eclFrom, leaving result in eclTo. // // The same struct may be used for eclFrom and eclTo. // EclTo is returned for convenience. // 黄道坐标的岁差转换 func (p *EclipticPrecessor) Precess(eclFrom, eclTo *coord.Ecliptic) *coord.Ecliptic { // (21.7) p. 137 sβ, cβ := eclFrom.Lat.Sincos() sd, cd := (p.π - eclFrom.Lon).Sincos() A := p.cη*cβ*sd - p.sη*sβ B := cβ * cd C := p.cη*sβ + p.sη*cβ*sd eclTo.Lon = p.p + p.π - unit.Angle(math.Atan2(A, B)) if math.Abs(C) \u0026lt; base.CosSmallAngle { eclTo.Lat = unit.Angle(math.Asin(C)) } else { eclTo.Lat = unit.Angle(math.Acos(math.Hypot(A, B))) // near pole if C \u0026lt; 0 { eclTo.Lat = -eclTo.Lat } } return eclTo } // ReduceElements reduces orbital elements of a solar system body from one // equinox to another. // // This function is described in chapter 24, but is located in this // package so it can be a method of EclipticPrecessor. func (p *EclipticPrecessor) ReduceElements(eFrom, eTo *elementequinox.Elements) *elementequinox.Elements { ψ := p.π + p.p si, ci := eFrom.Inc.Sincos() snp, cnp := (eFrom.Node - p.π).Sincos() // (24.1) p. 159 eTo.Inc = unit.Angle(math.Acos(ci*p.cη + si*p.sη*cnp)) // (24.2) p. 159 eTo.Node = ψ + unit.Angle(math.Atan2(si*snp, p.cη*si*cnp-p.sη*ci)) // (24.3) p. 160 eTo.Peri = eFrom.Peri + unit.Angle(math.Atan2(-p.sη*snp, si*p.cη-ci*p.sη*cnp)) return eTo } // EclipticPosition precesses ecliptic coordinates from one epoch to another, // including proper motions. // // While eclFrom is given as ecliptic coordinates, proper motions mα, mδ are // still expected to be equatorial. If proper motions are not to be considered // or are not applicable, pass 0, 0. // // Both eclFrom and eclTo must be non-nil, although they may point to the same // struct. EclTo is returned for convenience. // 考虑自行运动的黄道坐标的转换， // 注意此处的mα，mδ是赤道坐标系中的数值，要先转换为黄道坐标mλ, mβ func EclipticPosition(eclFrom, eclTo *coord.Ecliptic, epochFrom, epochTo float64, mα unit.HourAngle, mδ unit.Angle) *coord.Ecliptic { p := NewEclipticPrecessor(epochFrom, epochTo) *eclTo = *eclFrom if mα != 0 || mδ != 0 { mλ, mβ := eqProperMotionToEcl(mα, mδ, epochFrom, eclFrom) t := epochTo - epochFrom eclTo.Lon += mλ.Mul(t) eclTo.Lat += mβ.Mul(t) } return p.Precess(eclTo, eclTo) } // 将自行运动由赤道坐标转黄道坐标 func eqProperMotionToEcl(mα unit.HourAngle, mδ unit.Angle, epoch float64, pos *coord.Ecliptic) (mλ, mβ unit.Angle) { ε := nutation.MeanObliquity(base.JulianYearToJDE(epoch)) sε, cε := ε.Sincos() α, δ := coord.EclToEq(pos.Lon, pos.Lat, sε, cε) sα, cα := α.Sincos() sδ, cδ := δ.Sincos() cβ := pos.Lat.Cos() mλ = (mδ.Mul(sε*cα) + unit.Angle(mα).Mul(cδ*(cε*cδ+sε*sδ*sα))).Div(cβ * cβ) mβ = (mδ.Mul(cε*cδ+sε*sδ*sα) - unit.Angle(mα).Mul(sε*cα*cδ)).Div(cβ) return }  5. 天体自行运动导致的坐标的转换 // ProperMotion3D takes the 3D equatorial coordinates of an object // at one epoch and computes its coordinates at a new epoch, considering // proper motion and radial velocity. // // Radial distance (r) must be in parsecs, radial velocitiy (mr) in // parsecs per year. // // Both eqFrom and eqTo must be non-nil, although they may point to the same // struct. EqTo is returned for convenience. // 自行运动导致的赤道坐标变化的精确计算(不在当成常量乘以时间间隔) func ProperMotion3D(eqFrom, eqTo *coord.Equatorial, epochFrom, epochTo, r, mr float64, mα unit.HourAngle, mδ unit.Angle) *coord.Equatorial { sα, cα := eqFrom.RA.Sincos() sδ, cδ := eqFrom.Dec.Sincos() x := r * cδ * cα y := r * cδ * sα z := r * sδ mrr := mr / r zmδ := z * mδ.Rad() mx := x*mrr - zmδ*cα - y*mα.Rad() my := y*mrr - zmδ*sα + x*mα.Rad() mz := z*mrr + r*mδ.Rad()*cδ t := epochTo - epochFrom xp := x + t*mx yp := y + t*my zp := z + t*mz eqTo.RA = unit.RAFromRad(math.Atan2(yp, xp)) eqTo.Dec = unit.Angle(math.Atan2(zp, math.Hypot(xp, yp))) return eqTo } ","date":1527057389,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1527057389,"objectID":"2af61588c38c34223b6994e76e46e40c","permalink":"https://mooncaker816.github.io/2018/05/23/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9519/","publishdate":"2018-05-23T14:36:29+08:00","relpermalink":"/2018/05/23/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9519/","section":"post","summary":"第二十一章 岁差","tags":["天文算法"],"title":"天文算法19","type":"post"},{"authors":null,"categories":["golang","算法"],"content":"第二十章 Smallest Circle containing three Celestial Bodies 1. 问题 设三点为A,B,C,对应三边为a,b,c,其中\u0008a为最长边，\n当$a\u0026gt;\\sqrt {b^2+c^2}$,则包含这三点的最小圆直径为a，\n当$a\u0026lt;\\sqrt {b^2+c^2}$,则包含这三点的最小圆直径为$$\\frac {2abc}{\\sqrt {(a+b+c)(a+b-c)(b+c-a)(a+c-b)}}$$\n证明\n给定三个天体的坐标，求最小圆直径。\n// Smallest finds the smallest circle containing three points. // // Arguments should represent coordinates in right ascension and declination // or longitude and latitude. Result Δ is the diameter of the circle, typeI // is true if solution is of type I. // //\ttype I Two points on circle, one interior. //\ttype II All three points on circle. // 根据三点坐标，求最小圆直径 func Smallest(r1, d1, r2, d2, r3, d3 unit.Angle) (Δ unit.Angle, typeI bool) { // Using haversine formula, but reimplementing SepHav here to reuse // the computed cosines. cd1 := d1.Cos() cd2 := d2.Cos() cd3 := d3.Cos() a := 2 * math.Asin(math.Sqrt(base.Hav(d2-d1)+cd1*cd2*base.Hav(r2-r1))) b := 2 * math.Asin(math.Sqrt(base.Hav(d3-d2)+cd2*cd3*base.Hav(r3-r2))) c := 2 * math.Asin(math.Sqrt(base.Hav(d1-d3)+cd3*cd1*base.Hav(r1-r3))) if b \u0026gt; a { a, b = b, a } if c \u0026gt; a { a, c = c, a } if a*a \u0026gt;= b*b+c*c { return unit.Angle(a), true } // (20.1) p. 128 return unit.Angle(2 * a * b * c / math.Sqrt((a+b+c)*(a+b-c)*(b+c-a)*(a+c-b))), false } ","date":1527037312,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1527037312,"objectID":"f3a2af822ff9ee12b99c6ef99c1ca455","permalink":"https://mooncaker816.github.io/2018/05/23/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9518/","publishdate":"2018-05-23T09:01:52+08:00","relpermalink":"/2018/05/23/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9518/","section":"post","summary":"第二十章 Smallest Circle containing three Celestial Bodies","tags":["天文算法"],"title":"天文算法18","type":"post"},{"authors":null,"categories":["golang","算法"],"content":"第十九章 Bodies in Straight Line 1. 定义 　当天体位于同一个天球大圆时，我们称之为天体处在同一\u0026rdquo;直线\u0026rdquo;上。\n假设有三个天体,赤道系坐标分别为$(α_1,δ_1),(α_2,δ_2),(α_3,δ_3)$，当它们\u0026rdquo;共线\u0026rdquo;时，有：$$\\tan δ_1\\sin (α_2-α_3)+\\tan δ_2\\sin (α_3-α_1)+\\tan δ_3\\sin (α_1-α_2)=0$$ 上述公式对黄道坐标系同样适用。\n　利用该公式，我们就可以插值求得共线的时间点\n2. 计算行星与两个恒星共线的时间点 　对于恒星，我们可以认为在一定观测时间范围内是静止的。所以在进行插值计算时，应该当做常数。如$(α_1,δ_1),(α_2,δ_2)$为恒星坐标，则插值时保持不变。\n对于运动的行星，考虑一段时间范围内的坐标，进行插值并求零点。\n// Time computes the time at which a moving body is on a straight line (great // circle) between two fixed points, such as stars. // // Coordinates may be right ascensions and declinations or longitudes and // latitudes. Fixed points are r1, d1, r2, d2. Moving body is an ephemeris // of 5 rows, r3, d3, starting at time t1 and ending at time t5. Time scale // is arbitrary. // // Result is time of alignment. // 计算一个运动的天体和另外两个在观测时间内默认为不动的天体在一条直线上的时间点 func Time(r1, d1, r2, d2 unit.Angle, r3, d3 []unit.Angle, t1, t5 float64) (float64, error) { if len(r3) != 5 || len(d3) != 5 { return 0, errors.New(\u0026quot;r3, d3 must be length 5\u0026quot;) } gc := make([]float64, 5) for i, r3i := range r3 { // (19.1) p. 121 gc[i] = d1.Tan()*(r2-r3i).Sin() + d2.Tan()*(r3i-r1).Sin() + d3[i].Tan()*(r1-r2).Sin() } l5, err := interp.NewLen5(t1, t5, gc) if err != nil { return 0, err } return l5.Zero(false) }  3. 计算3点\u0026rdquo;近似共线\u0026rdquo;时的球面角和离共线大圆的角距离 如上图，$S_1,S_2,S_3$为三个天体，此时它们几乎\u0026rdquo;共线\u0026rdquo;,$C_1$为球面角$\\angle PS_2S_1$，$C_2$为球面角$\\angle PS_2S_3$，我们所求的就是球面角$\\angle S_1S_2S_3$以及$S_2$与经过$S_1,S_3$的大圆之间的角距离（可以看作离共线还差多少度）\n Meeus 计算三天体球面角$\\angle S_1S_2S_3$  \\begin{cases} \\tan C_1 \u0026amp;= \\frac {\\sin (α_2-α_1)}{\\cos δ_2\\tan δ_1-\\sin δ_2\\cos (α_2-α_1)}\\\\[2ex] \\tan C_2 \u0026amp;= \\frac {\\sin (α_3-α_2)}{\\cos δ_2\\tan δ_3-\\sin δ_2\\cos (α_3-α_2)} \\end{cases} $C_1 + C_2$即为所求\n// Angle returns the angle between great circles defined by three points. // // Coordinates may be right ascensions and declinations or longitudes and // latitudes. If r1, d1, r2, d2 defines one line and r2, d2, r3, d3 defines // another, the result is the angle between the two lines. // // Algorithm by Meeus. // 计算第一点第二点经过的大圆和第二点第三点经过的大圆之间的角度 func Angle(r1, d1, r2, d2, r3, d3 unit.Angle) unit.Angle { sd2, cd2 := d2.Sincos() sr21, cr21 := (r2 - r1).Sincos() sr32, cr32 := (r3 - r2).Sincos() C1 := math.Atan2(sr21, cd2*d1.Tan()-sd2*cr21) C2 := math.Atan2(sr32, cd2*d3.Tan()-sd2*cr32) return unit.Angle(C1 + C2) }   Meeus 计算$S_2$与经过$S_1,S_3$的大圆之间的角距离  　先计算： \\begin{cases} X_1 \u0026amp;= \\cos δ_1\\cos α_1\\\\[2ex] Y_1 \u0026amp;= \\cos δ_1\\sin α_1\\\\[2ex] Z_1 \u0026amp;= \\sin δ_1 \\end{cases} \\begin{cases} X_2 \u0026amp;= \\cos δ_2\\cos α_2\\\\[2ex] Y_2 \u0026amp;= \\cos δ_2\\sin α_2\\\\[2ex] Z_2 \u0026amp;= \\sin δ_2 \\end{cases} \\begin{cases} A \u0026amp;= Y_1Z_2-Z_1Y_2\\\\[2ex] B \u0026amp;= Z_1X_2-X_1Z_2\\\\[2ex] C \u0026amp;= X_1Y_2-Y_1X_2 \\end{cases} $$m = \\tan α_0, n = \\frac {\\tan δ_0}{\\cos α_0}$$ 则，$$\\sin ω = \\frac {A+Bm+Cn}{\\sqrt {A^2+B^2+C^2}\\sqrt{1+m^2+n^2}}$$ ω即为所求\n// Error returns an error angle of three nearly co-linear points. // // For the line defined by r1, d1, r2, d2, the result is the anglular distance // between that line and r0, d0. // // Algorithm by Meeus. // 计算一点到由另外两点组成的大圆之间的角距离 func Error(r1, d1, r2, d2, r0, d0 unit.Angle) unit.Angle { sr1, cr1 := r1.Sincos() sd1, cd1 := d1.Sincos() sr2, cr2 := r2.Sincos() sd2, cd2 := d2.Sincos() X1 := cd1 * cr1 X2 := cd2 * cr2 Y1 := cd1 * sr1 Y2 := cd2 * sr2 Z1 := sd1 Z2 := sd2 A := Y1*Z2 - Z1*Y2 B := Z1*X2 - X1*Z2 C := X1*Y2 - Y1*X2 m := r0.Tan() n := d0.Tan() / r0.Cos() return unit.Angle(math.Asin((A + B*m + C*n) / (math.Sqrt(A*A+B*B+C*C) * math.Sqrt(1+m*m+n*n)))) }   Pessens 同时计算上述两个量  \\begin{cases} a_1 \u0026amp;= \\cos δ_1\\cos α_1\\\\[2ex] a_2 \u0026amp;= \\cos δ_2\\cos α_2\\\\[2ex] a_3 \u0026amp;= \\cos δ_3\\cos α_3\\\\[2ex] \\end{cases} \\begin{cases} b_1 \u0026amp;= \\cos δ_1\\sin α_1\\\\[2ex] b_2 \u0026amp;= \\cos δ_2\\sin α_2\\\\[2ex] b_3 \u0026amp;= \\cos δ_3\\sin α_3\\\\[2ex] \\end{cases} \\begin{cases} c_1 \u0026amp;= \\sin δ_1\\\\[2ex] c_2 \u0026amp;= \\sin δ_2\\\\[2ex] c_3 \u0026amp;= \\sin δ_3\\\\[2ex] \\end{cases} \\begin{cases} l_1 \u0026amp;= b_1c_2-b_2c_1\\\\[2ex] l_2 \u0026amp;= b_2c_3-b_3c_2\\\\[2ex] l_3 \u0026amp;= b_1c_3-b_3c_1\\\\[2ex] \\end{cases} \\begin{cases} m_1 \u0026amp;= c_1a_2-c_2a_1\\\\[2ex] m_2 \u0026amp;= c_2a_3-c_3a_2\\\\[2ex] m_3 \u0026amp;= c_1a_3-c_3a_1\\\\[2ex] \\end{cases} \\begin{cases} n_1 \u0026amp;= a_1b_2-a_2b_1\\\\[2ex] n_2 \u0026amp;= a_2b_3-a_3b_2\\\\[2ex] n_3 \u0026amp;= a_1b_3-a_3b_1\\\\[2ex] \\end{cases} 则有： \\begin{cases} \\cos ψ \u0026amp;= \\frac {l_1l_2+m_1m_2+n_1n_2}{\\sqrt {l_1^2+m_1^2+n_1^2}\\sqrt{l_2^2+m_2^2+n_2^2}}\\\\[2ex] \\sin ω \u0026amp;= \\frac {a_2l_3+b_2m_3+c_2n_3}{\\sqrt {a_2^2+b_2^2+c_2^2}\\sqrt {l_3^2+m_3^2+n_3^2}} \\end{cases} ψ，ω即为所求。ψ可能与 Meeus 方法求解的值互余180°。（平面的夹角有两个，互余180°）\n// AngleError returns both an angle as in the function Angle, and an error // as in the function Error. // // The algorithm is by B. Pessens. // Angle和 Error 的合体版 // Angle 的值可能和之前 Angle 中计算的值互余180°（想象一下两个面的夹角） func AngleError(r1, d1, r2, d2, r3, d3 unit.Angle) (ψ, ω unit.Angle) { sr1, cr1 := r1.Sincos() sd1, cd1 := d1.Sincos() sr2, cr2 := r2.Sincos() sd2, cd2 := d2.Sincos() sr3, cr3 := r3.Sincos() sd3, cd3 := d3.Sincos() a1 := cd1 * cr1 a2 := cd2 * cr2 a3 := cd3 * cr3 b1 := cd1 * sr1 b2 := cd2 * sr2 b3 := cd3 * sr3 c1 := sd1 c2 := sd2 c3 := sd3 l1 := b1*c2 - b2*c1 l2 := b2*c3 - b3*c2 l3 := b1*c3 - b3*c1 m1 := c1*a2 - c2*a1 m2 := c2*a3 - c3*a2 m3 := c1*a3 - c3*a1 n1 := a1*b2 - a2*b1 n2 := a2*b3 - a3*b2 n3 := a1*b3 - a3*b1 ψ = unit.Angle(math.Acos((l1*l2 + m1*m2 + n1*n2) / (math.Sqrt(l1*l1+m1*m1+n1*n1) * math.Sqrt(l2*l2+m2*m2+n2*n2)))) ω = unit.Angle(math.Asin((a2*l3 + b2*m3 + c2*n3) / (math.Sqrt(a2*a2+b2*b2+c2*c2) * math.Sqrt(l3*l3+m3*m3+n3*n3)))) return } ","date":1526955311,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1526955311,"objectID":"ddee566d9570b183542f785b30c947a2","permalink":"https://mooncaker816.github.io/2018/05/22/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9517/","publishdate":"2018-05-22T10:15:11+08:00","relpermalink":"/2018/05/22/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9517/","section":"post","summary":"第十九章 Bodies in Straight Line","tags":["天文算法"],"title":"天文算法17","type":"post"},{"authors":null,"categories":["golang","算法"],"content":"第十八章 行星会合 Planetary Conjunctions 1. 定义 In astronomy, a conjunction occurs when two astronomical objects or spacecraft have either the same right ascension or the same ecliptic longitude, usually as observed from Earth.\n当两个天体位于同一赤经（黄经）时，我们称之为会合。会合并不意味着最小角距离。\n2. 计算会合的时间点以及纬度差 由定义可知，当两天体的经度差为0时，我们称之为会合。\n所以只要根据观测数据对经度差进行插值，再求零值对应的时间点即为会合时间。再根据这个时间点插值计算纬度差即可。\n 两个都为移动的天体（行星）  // Planetary computes a conjunction between two moving objects, such as planets. // // Conjunction is found with interpolation against length 5 ephemerides. // // T1, t5 are times of first and last rows of ephemerides. The scale is // arbitrary. // // R1, d1 is the ephemeris of the first object. The columns may be celestial // coordinates in right ascension and declination or ecliptic coordinates in // longitude and latitude. // // R2, d2 is the ephemeris of the second object, in the same frame as the first. // // Return value t is time of conjunction in the scale of t1, t5. // Δd is the amount that object 2 was \u0026quot;above\u0026quot; object 1 at the time of // conjunction. // 计算两个移动的天体赤经（黄经）相同的时间点 t 和该时刻的赤纬（黄纬）差 func Planetary(t1, t5 float64, r1, d1, r2, d2 []unit.Angle) (t float64, Δd unit.Angle, err error) { if len(r1) != 5 || len(d1) != 5 || len(r2) != 5 || len(d2) != 5 { err = errors.New(\u0026quot;Five rows required in ephemerides\u0026quot;) return } dr := make([]float64, 5, 10) dd := dr[5:10] for i, r := range r1 { dr[i] = (r2[i] - r).Rad() dd[i] = (d2[i] - d1[i]).Rad() } return conj(t1, t5, dr, dd) } func conj(t1, t5 float64, dr, dd []float64) (t float64, Δd unit.Angle, err error) { var l5 *interp.Len5 if l5, err = interp.NewLen5(t1, t5, dr); err != nil { return } if t, err = l5.Zero(true); err != nil { // 计算经度重合时的时间点 t return } if l5, err = interp.NewLen5(t1, t5, dd); err != nil { return } ΔdRad, err := l5.InterpolateXStrict(t) // 插值计算经度重合时的纬度差 return t, unit.Angle(ΔdRad), err }   一个为观测时间范围内默认不动的天体（恒星）  // Stellar computes a conjunction between a moving and non-moving object. // // Arguments and return values same as with Planetary, except the non-moving // object is r1, d1. The ephemeris of the moving object is r2, d2. // 计算一个移动的天体和一个在观测时间范围内默认为不动的天体（如恒星）赤经（黄经）相同的时间点 t 和该时刻的赤纬（黄纬）差 func Stellar(t1, t5 float64, r1, d1 unit.Angle, r2, d2 []unit.Angle) (t float64, Δd unit.Angle, err error) { if len(r2) != 5 || len(d2) != 5 { err = errors.New(\u0026quot;Five rows required in ephemeris\u0026quot;) return } dr := make([]float64, 5, 10) dd := dr[5:10] for i, r := range r2 { dr[i] = (r - r1).Rad() dd[i] = (d2[i] - d1).Rad() } return conj(t1, t5, dr, dd) } ","date":1526953067,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1526953067,"objectID":"f3d60bda88b5478bbfc0db9d7fa9eae0","permalink":"https://mooncaker816.github.io/2018/05/22/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9516/","publishdate":"2018-05-22T09:37:47+08:00","relpermalink":"/2018/05/22/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9516/","section":"post","summary":"第十八章 行星会合 Planetary Conjunctions","tags":["天文算法"],"title":"天文算法16","type":"post"},{"authors":null,"categories":["golang","算法"],"content":"第十七章 角距离 Angular Separation 1. 定义 　角距离，也称为角分离、视距离、或视分离，在数学(特别是几何学和三角学)和自然科学(包括天文学、地质学等等)，从不同于两个点物体的位置（即第三点）观察这两个物体，由观测者指向这两个物体的直线之间所夹角度的大小。角距离(或分离)与角度本身是同义的，但意义却是对两个天体(对恒星，是当从地球观测)之间线距离的建议(通常是很大或未知的)。\n2. 计算 2.1 余弦公式直接计算 $$\\cos d=\\sin δ_1 \\sin δ_2 + \\cos δ_1 \\cos δ_2 \\cos (α_1 -α_2)$$ 式中$α_1,δ_1,α_2,δ_2$分别对应两个天体的赤经和赤纬。\n当$d$接近于0或180度时，$\\left|\\cos d\\right|$接近于1，并且其值随$d$变化很小，所以得到的$d$不精确。此时需用以下公式计算：$$d = \\sqrt {(Δα\\cos δ)^2+(Δδ)^2}$$ 式中$Δα$是两个赤经的差，$Δδ$是两个赤纬的差，$δ$是两个赤纬的平均值。\n// Sep returns the angular separation between two celestial bodies. // // The algorithm is numerically naïve, and while patched up a bit for // small separations, remains unstable for separations near π. // 计算两天体之间的角距，r为赤经，d为赤纬 func Sep(r1, d1, r2, d2 unit.Angle) unit.Angle { sd1, cd1 := d1.Sincos() sd2, cd2 := d2.Sincos() cd := sd1*sd2 + cd1*cd2*(r1-r2).Cos() // (17.1) p. 109 if cd \u0026lt; base.CosSmallAngle { return unit.Angle(math.Acos(cd)) } // (17.2) p. 109 dm := (d1 + d2) / 2 return unit.Angle(math.Hypot((r2-r1).Rad()*dm.Cos(), (d2 - d1).Rad())) }  2.2 根据观测数据插值计算最小角距离 注意，不能先计算出各组数据点的角距离，再对角距离插值计算。因为当两个天体很近时，两天体间是线性的靠近再线性的离开。此时需要先对数据点插值，再把得出的数据套用2.1的方法进行计算。或者引入 u,v 坐标，先将原始数据转为 u,v 坐标，然后对 u,v 坐标点进行插值计算，得出最小值\n// MinSep returns the minimum separation between two moving objects. // // The motion is represented as an ephemeris of three rows, equally spaced // in time. Jd1, jd3 are julian day times of the first and last rows. // R1, d1, r2, d2 are coordinates at the three times. They must each be // slices of length 3. // // Result is obtained by computing separation at each of the three times // and interpolating a minimum. This may be invalid for sufficiently close // approaches. // // 计算两个天体之间的最小角距 // 此方法是将数据点计算成角距，然后直接对角距3点插值，求取最小值， // 当两个天体十分接近时，这个结果是不准确的，要使用方法MinSepRect func MinSep(jd1, jd3 float64, r1, d1, r2, d2 []unit.Angle) (unit.Angle, error) { if len(r1) != 3 || len(d1) != 3 || len(r2) != 3 || len(d2) != 3 { return 0, interp.ErrorNot3 } y := make([]float64, 3) for x, r := range r1 { y[x] = Sep(r, d1[x], r2[x], d2[x]).Rad() } d3, err := interp.NewLen3(jd1, jd3, y) if err != nil { return 0, err } _, dMin, err := d3.Extremum() return unit.Angle(dMin), err } // MinSepRect returns the minimum separation between two moving objects. // // Like MinSep, but using a method of rectangular coordinates that gives // accurate results even for close approaches. // 计算两个天体之间的最小角距 // 此方法是引入直角坐标 u,v,先将数据点转换成u,v 表达，然后对u,v插值，求取最小值， func MinSepRect(jd1, jd3 float64, r1, d1, r2, d2 []unit.Angle) (unit.Angle, error) { if len(r1) != 3 || len(d1) != 3 || len(r2) != 3 || len(d2) != 3 { return 0, interp.ErrorNot3 } uv := func(r1, d1, r2, d2 unit.Angle) (u, v float64) { sd1, cd1 := d1.Sincos() Δr := r2 - r1 tΔr := Δr.Tan() thΔr := (Δr / 2).Tan() K := 1 / (1 + sd1*sd1*tΔr*thΔr) sΔd := (d2 - d1).Sin() u = -K * (1 - (sd1/cd1)*sΔd) * cd1 * tΔr v = K * (sΔd + sd1*cd1*tΔr*thΔr) return } us := make([]float64, 3, 6) vs := us[3:6] for x, r := range r1 { us[x], vs[x] = uv(r, d1[x], r2[x], d2[x]) } u3, err := interp.NewLen3(-1, 1, us) if err != nil { panic(err) // bug not caller's fault. } v3, err := interp.NewLen3(-1, 1, vs) if err != nil { panic(err) // bug not caller's fault. } up0 := (us[2] - us[0]) / 2 vp0 := (vs[2] - vs[0]) / 2 up1 := us[0] + us[2] - 2*us[1] vp1 := vs[0] + vs[2] - 2*vs[1] up := up0 vp := vp0 dn := -(us[1]*up + vs[1]*vp) / (up*up + vp*vp) n := dn var u, v float64 for limit := 0; limit \u0026lt; 10; limit++ { u = u3.InterpolateN(n) v = v3.InterpolateN(n) if math.Abs(dn) \u0026lt; 1e-5 { return unit.Angle(math.Hypot(u, v)), nil // success } up := up0 + n*up1 vp := vp0 + n*vp1 dn = -(u*up + v*vp) / (up*up + vp*vp) n += dn } return 0, errors.New(\u0026quot;MinSepRect: failure to converge\u0026quot;) }  2.3 利用半正矢的特点提高当角距很小时的精确程度 根据半正矢公式$hav(d) = hav(Δδ) + \\cos δ_1 \\cos δ_2 hav(Δα)$,式中 $Δα = α_1 - α_2，Δδ = δ_1 - δ_2$， 又由$hav(d)=\\frac {1-\\cos d}{2}=\\sin^2(\\frac d2)$,可以有效的在0，180°附近提高计算机的精度。\n// SepHav returns the angular separation between two celestial bodies. // // The algorithm uses the haversine function and is superior to the naïve // algorithm of the Sep function. // 利用半正矢的特点提高当角距很小时的精确程度 func SepHav(r1, d1, r2, d2 unit.Angle) unit.Angle { // using (17.5) p. 115 return unit.Angle(2 * math.Asin(math.Sqrt(base.Hav(d2-d1)+ d1.Cos()*d2.Cos()*base.Hav(r2-r1)))) }  2.4 Pauwels公式 令 \\begin{cases} x \u0026amp;= \\cos δ_1\\sin δ_2 - \\sin δ_1\\cos δ_2\\cos (α_2-α_1)\\\\[2ex] x \u0026amp;= \\cos δ_2\\sin (α_2-α_1)\\\\[2ex] z \u0026amp;= \\sin δ_1\\sin δ_2 + \\cos δ_1\\cos δ_2\\cos (α_2-α_1)\\\\[2ex] \\end{cases} 则有：$$d=\\arctan (\\frac {\\sqrt {x^2+y^2}}{z})$$\n数学上来说，这与余弦定理完全等价，只不过是巧妙的将余弦转化为正切，而对于计算机来说， 反正切比反正弦能获得更高的精确度\n// SepPauwels returns the angular separation between two celestial bodies. // // The algorithm is a numerically stable form of that used in Sep. // 当z小于0时，返回值应该在90-180度之间 // 该方法与直接余弦定理求角距在数学上是等价的， // 但是对于计算机来说，arctan 比 arcsin能获得更高的精度 func SepPauwels(r1, d1, r2, d2 unit.Angle) unit.Angle { sd1, cd1 := d1.Sincos() sd2, cd2 := d2.Sincos() cdr := (r2 - r1).Cos() x := cd1*sd2 - sd1*cd2*cdr y := cd2 * (r2 - r1).Sin() z := sd1*sd2 + cd1*cd2*cdr return unit.Angle(math.Atan2(math.Hypot(x, y), z)) }  2.5 Relative Position Angle 定义即相关信息\n// RelativePosition returns the position angle of one body with respect to // another. // // The position angle result is measured counter-clockwise from North. // 1相对2的角距，从2的正北到1的角度 // https://en.wikipedia.org/wiki/Position_angle func RelativePosition(r1, d1, r2, d2 unit.Angle) unit.Angle { sΔr, cΔr := (r1 - r2).Sincos() sd2, cd2 := d2.Sincos() return unit.Angle(math.Atan2(sΔr, cd2*d1.Tan()-sd2*cΔr)) } ","date":1526899597,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1526899597,"objectID":"3222bee1959580ed543f24481a7a1a1a","permalink":"https://mooncaker816.github.io/2018/05/21/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9515/","publishdate":"2018-05-21T18:46:37+08:00","relpermalink":"/2018/05/21/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9515/","section":"post","summary":"第十七章 角距离 Angular Separation","tags":["天文算法"],"title":"天文算法15","type":"post"},{"authors":null,"categories":["golang","算法"],"content":"第十六章 大气折射 Atmospheric Refraction 1. 大气折射  大气折射（又称：蒙气差（蒙气即行星的大气）、折光差）即原本直线前进的光或其它电磁波在穿越大气层时，因为空气密度随着高度变化所产生的偏折。这种折射是光通过空气时因为密度的增加使速度降低（折射率增加）。大气折射在近地面时会产生海市蜃楼，让远方的物体出现或荡漾，和非幻觉的升高或降低，伸长或缩短。这个词也适用于声音的折射。无论是天体或地面上物体位置的测量都需要考虑大气折射。\n对天文或天体的折射，导致天体在天空中的位置看起来比实际为高。大地折射通常导致物体出现在比实际高的位置上，然而在靠近地面的空气被加热的下午，光线的曲折向上会使物体看似出现在比实际位置低的地方。\n折射不仅影响可见光，还包括所有的电磁波，然而在程度上不尽相同（见光的色散）。例如在可见光，蓝色受到的影响大于红色。这会对天体光谱在展开时的高解析图像造成影响。\n只要有可能，天文学家会安排在天体在天空中接近高度最高的顶点时才要观测。同样的，水手也不会观测一颗高度低于20°或更低恒星的位置。如果不能避免靠近地平线的观测，有可能使用具有修正系统，以弥补这种折射造成的影响。如果色散也是一个问题（如果是宽频的高解析观测），大气折射可以使用成对的旋转玻璃棱镜处理掉。但是当大气折射的总量是温度梯度、温度、压力和湿度（特别是在中红外波长时的水蒸气总量）的函数时，成功补偿这些修正量的工作可以让人为之望而却步。另一方面，测量师经常都会将他们的工作安排在下午折射程度最低的时候。\n在有很强的温度梯度、大气不均匀和空气动荡的时候，大气折射会变得很严重。这是造成恒星闪烁和日出与日落时太阳各种不同变形的原因。\n 2. 真纬度，视纬度 　真纬度即为天体的真实地平纬度(仰角)$h$，视纬度即为经过大气折射后观测到的纬度$h_0$。\n当已知真纬度$h$，可以由该$h$推算出一个矫正量R，视纬度$h_0 = h + R$\n当已知视纬度$h_0$，可以由该$h_0$推算出一个矫正量R，真纬度$h = h_0 - R$\n3. 矫正量R\u0026ndash;单位角分 3.1 $h_0 \\Rightarrow R,h$  $h_0\u0026gt;15°$时： $$R=58\u0026rdquo;.294\\tan(90-h_0)-0\u0026rdquo;.0668\\tan^3(90°-h_0)$$ $$h = h_0 - R$$\n// Gt15True returns refraction for obtaining true altitude when altitude // is greater than 15 degrees (about .26 radians.) // // h0 must be a measured apparent altitude of a celestial body. // // Result is refraction to be subtracted from h0 to obtain the true altitude // of the body. // 纬度大于15度时，由视纬度求真纬度的矫正量R func Gt15True(h0 unit.Angle) unit.Angle { // (16.1) p. 105 t := (math.Pi/2 - h0).Tan() return gt15true1.Mul(t) - gt15true2.Mul(t*t*t) }  Bennett公式，当$h\\in [0,90°]$时： $$R = \\frac {1}{\\tan(h_0 +\\frac {7.31}{h_0 +4.4})}$$ $$ΔR = -0.06sin(14.7R+13)$$ 对于任意$h_0$，这个公式的精度是$0.07′=4.2\u0026rdquo;$，最大误差发生在$h_0 =12°$。\n应当注意的是：当$h_0 =90°$时，$R=-0\u0026rdquo;.08$，理论上天顶应该不受折射影响，可以加上0.0013515′，从而为0。\n若考虑修正量，即$R=R+ΔR$，最大误差为$0.015′=0.9\u0026rdquo;$。\n当$h_0 =90°$时，计算的结果是$R=-0.89\u0026rdquo;$，不作第二项修正反而更好。\n// Bennett returns refraction for obtaining true altitude. // // h0 must be a measured apparent altitude of a celestial body in radians. // // Results are accurate to .07 arc min from horizon to zenith. // // Result is refraction to be subtracted from h0 to obtain the true altitude // of the body. // Bennett 公式，由视纬度求真纬度矫正量 R func Bennett(h0 unit.Angle) unit.Angle { // (16.3) p. 106 hd := h0.Deg() return unit.AngleFromMin(1 / math.Tan((hd+7.31/(hd+4.4))*math.Pi/180)) } // Bennett2 returns refraction for obtaining true altitude. // // Similar to Bennett, but a correction is applied to give a more accurate // result. // // Results are accurate to .015 arc min. Result unit is radians. // 带矫正量的Bennett公式 func Bennett2(h0 unit.Angle) unit.Angle { R := Bennett(h0).Min() return unit.AngleFromMin(R - .06*math.Sin((14.7*R+13)*math.Pi/180)) }   3.2 $h \\Rightarrow R,h_0$  $h\u0026gt;15°$时： $$R=58\u0026rdquo;.276\\tan(90°-h) -0\u0026rdquo;.0824\\tan^3(90°-h)$$ $$h_0 = h + R$$\n// Gt15Apparent returns refraction for obtaining apparent altitude when // altitude is greater than 15 degrees (about .26 radians.) // // h must be a computed true \u0026quot;airless\u0026quot; altitude of a celestial body. // // Result is refraction to be added to h to obtain the apparent altitude // of the body. // 纬度大于15度时，由真纬度求视纬度的矫正量R func Gt15Apparent(h unit.Angle) unit.Angle { // (16.2) p. 105 t := (math.Pi/2 - h).Tan() return gt15app1.Mul(t) - gt15app2.Mul(t*t*t) }  类Bennett公式 $$R = \\frac {1.02}{\\tan(h+\\frac{10.3}{h+5.11})}$$ 同样，$h=90°$时，该式算得$R$不等于零,差值是 0.0019279。\n// Saemundsson returns refraction for obtaining apparent altitude. // // h must be a computed true \u0026quot;airless\u0026quot; altitude of a celestial body in radians. // // Result is refraction to be added to h to obtain the apparent altitude // of the body. // // Results are consistent with Bennett to within 4 arc sec. // 由真纬度求视纬度矫正量，与Bennett公式对应 func Saemundsson(h unit.Angle) unit.Angle { // (16.4) p. 106 hd := h.Deg() return unit.AngleFromMin(1.02 / math.Tan((hd+10.3/(hd+5.11))*math.Pi/180)) }  ","date":1526876988,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1526876988,"objectID":"68c37bd67606327c2edbc5ceb21c6c86","permalink":"https://mooncaker816.github.io/2018/05/21/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9514/","publishdate":"2018-05-21T12:29:48+08:00","relpermalink":"/2018/05/21/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9514/","section":"post","summary":"第十六章 大气折射 Atmospheric Refraction","tags":["天文算法"],"title":"天文算法14","type":"post"},{"authors":null,"categories":["golang","算法"],"content":"第十五章 升，中天，降 Rising,Transit,Setting 1. 升，中天，降的概念 　升就是天体位于观测点地平线上即将升起的位置，由于大气的折射，当我们看到天体位于地平线上时，天体的真实位置在地平线之下 0°34′。而对于太阳，视升降一般指太阳圆盘上边缘的升与降，因此需加上16′的太阳半径进行计算。\n降与升类似，只是运动方向相反。\n中天是指天体位于本地子午圈上时的位置，即离天顶最近的位置。\n2. 计算升，中天，降的时刻  根据第十三章中计算本地仰角的公式计算时角H$$\\sin h = \\sin φ\\sin δ+\\cos φ\\cos δ\\cos H$$ 令$h_0=0$，则$$\\cos H_0=-\\tan φ\\tan δ$$ 但这只是理想状态，由于大气折射，我们要令$h_0=-0°34′$，对于太阳，令$h_0=-0°50′$，对于月亮，这个问题更复杂，因为$h_0$不是常数。考虑半径变化及地平视差，我们得到月亮的：$h_0 = 0.7275π - 0°34′$ 式中 $π$是月亮的地平视差（不是上章所说的视差角）。如果精度要球不高，$h_0$可以取均值$h_0 = 0°.125$，则$$\\cos H_0 = \\frac {\\sin h_0 - \\sin φ\\sin δ}{\\cos φ\\cos δ}$$\n 计算格林尼治D日0h（UT时）的视恒星时$θ_0$，并转为度单位,本地恒星时$θ=θ_0-L$,$L$为观测点经度，从格林尼治测量，向西为正，向东为负\n 天体的视赤经及视赤纬（单位是度）： \\begin{cases} α_1 和 δ_1， 在力学时 D-1 日 0h\\\\[2ex] α_2 和 δ_2， 在力学时 D 日 0h\\\\[2ex] α_3 和 δ_3， 在力学时 D+1 日 0h\\\\[2ex] \\end{cases} 我们先使用下式估算时间： $$\\cos H_0 = \\frac {\\sin h_0 - \\sin φ\\sin δ_2}{\\cos φ\\cos δ_2}$$\n 估算中天，升起，降落时间点，单位为日（带小数）\n$H_0$单位是度，$H_0$应转换到 0 度到 180 度。那么我们有： \\begin{cases} 中天：m_0 = (α_2 + L - θ_0)/360 \\\\[2ex] 升起：m_1 = m_0 - H_0 /360 \\\\[2ex] 降落：m_2 = m_0 + H_0 /360\\\\[2ex] \\end{cases} 式中$m$是$D$日的时间（即$D$日$m$时），单位是日。因此 $m$ 的值在 0 到 1，如果$m$的值超过这个范围，那么应加 1 或减 1。例如：m = 0.3744，则不用变；m = -0.1709，则应加 1 变为+0.8291；m = +1.1853 则应减 1 变 为+0.1853。\n 根据上一步求得的m,分别计算三个时刻点的格林威治恒星时$θ = θ_0 + 360.985647m$，式中$m$是$m_0、m_1、m_2$\n 考虑ΔT，得到一个$m_0+ΔT/86400$的时刻点，对该时刻点在所给的视赤经，视赤纬数据中插值求解得到新的中天时刻对应的天体视赤经α，视赤纬δ（单单求解中天用不着视赤纬数据，但升降需要）\n 计算中天时本地时角$H= θ - L - α$，新的中天即为$m_0 = m_0-\\frac{H}{360}$\n 同上，对升，降估计时间考虑$ΔT$并插值求解对应的视赤经$α$，视赤纬$δ$，再根据地平坐标转换公式，求得地平仰角$h$\n 再求分别对应的本地时角$H$,则新的升,降即为$$m= m + \\frac {h-h_0}{360\\cos δ\\cos φ\\sin H}$$\n  // ApproxTimes computes approximate UT rise, transit and set times for // a celestial object on a day of interest. // // The function argurments do not actually include the day, but do include // values computed from the day. // //\tp is geographic coordinates of observer. p 为地平坐标（仰角，方位角） //\th0 is \u0026quot;standard altitude\u0026quot; of the body. h0 为天体升，降时实际地平线纬度 //\tTh0 is apparent sidereal time at 0h UT at Greenwich. Th0 为格林威治0h UT视恒星时 //\tα, δ are right ascension and declination of the body. α, δ为天体0h DT视赤经，视赤纬 // // Th0 must be the time on the day of interest. // See sidereal.Apparent0UT. // // α, δ must be values at 0h dynamical time for the day of interest. // 近似计算升，中天，降时间 func ApproxTimes(p globe.Coord, h0 unit.Angle, Th0 unit.Time, α unit.RA, δ unit.Angle) (tRise, tTransit, tSet unit.Time, err error) { // approximate local hour angle sLat, cLat := p.Lat.Sincos() sδ1, cδ1 := δ.Sincos() cH0 := (h0.Sin() - sLat*sδ1) / (cLat * cδ1) // (15.1) p. 102 if cH0 \u0026lt; -1 || cH0 \u0026gt; 1 { err = ErrorCircumpolar return } H0 := unit.TimeFromRad(math.Acos(cH0)) // approximate transit, rise, set times. // (15.2) p. 102. mt := unit.TimeFromRad(α.Rad()+p.Lon.Rad()) - Th0 tTransit = mt.Mod1() tRise = (mt - H0).Mod1() tSet = (mt + H0).Mod1() return } // Times computes UT rise, transit and set times for a celestial object on // a day of interest. // // The function argurments do not actually include the day, but do include // a number of values computed from the day. // //\tp is geographic coordinates of observer. //\tΔT is delta T. //\th0 is \u0026quot;standard altitude\u0026quot; of the body. //\tTh0 is apparent sidereal time at 0h UT at Greenwich. //\tα3, δ3 are slices of three right ascensions and declinations. // // h0 unit is radians. // // Th0 must be the time on the day of interest, in seconds. // See sidereal.Apparent0UT. // // α3, δ3 must be values at 0h dynamical time for the day before, the day of, // and the day after the day of interest. Units are radians. // // Result units are seconds of day and are in the range [0,86400). // 对近似计算结果迭代，得到精确升，中天，降时间 func Times(p globe.Coord, ΔT unit.Time, h0 unit.Angle, Th0 unit.Time, α3 []unit.RA, δ3 []unit.Angle) (tRise, tTransit, tSet unit.Time, err error) { tRise, tTransit, tSet, err = ApproxTimes(p, h0, Th0, α3[1], δ3[1]) if err != nil { return } αf := make([]float64, 3) for i, α := range α3 { αf[i] = α.Rad() } δf := make([]float64, 3) for i, δ := range δ3 { δf[i] = δ.Rad() } var d3α, d3δ *interp.Len3 d3α, err = interp.NewLen3(-86400, 86400, αf) if err != nil { return } d3δ, err = interp.NewLen3(-86400, 86400, δf) if err != nil { return } // adjust tTransit { th0 := (Th0 + tTransit.Mul(360.985647/360)).Mod1() α := d3α.InterpolateX((tTransit + ΔT).Sec()) // local hour angle as Time H := th0 - unit.TimeFromRad(p.Lon.Rad()+α) tTransit -= H } // adjust tRise, tSet sLat, cLat := p.Lat.Sincos() adjustRS := func(m unit.Time) (unit.Time, error) { th0 := (Th0 + m.Mul(360.985647/360)).Mod1() ut := (m + ΔT).Sec() α := d3α.InterpolateX(ut) δ := d3δ.InterpolateX(ut) Hrad := th0.Rad() - p.Lon.Rad() - α sδ, cδ := math.Sincos(δ) sH, cH := math.Sincos(Hrad) h := math.Asin(sLat*sδ + cLat*cδ*cH) md := (unit.TimeFromRad(h) - h0.Time()).Div(cδ * cLat * sH) return m + md, nil } tRise, err = adjustRS(tRise) if err != nil { return } tSet, err = adjustRS(tSet) return } ","date":1526820607,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1526820607,"objectID":"1dc40da66c98278dca4ddda37ea6ae6e","permalink":"https://mooncaker816.github.io/2018/05/20/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9513/","publishdate":"2018-05-20T20:50:07+08:00","relpermalink":"/2018/05/20/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9513/","section":"post","summary":"第十五章 升，中天，降 Rising,Transit,Setting","tags":["天文算法"],"title":"天文算法13","type":"post"},{"authors":null,"categories":["golang","算法"],"content":"第十四章 The Parallactic Angle 1. 什么是Parallactic Angle 　Parallactic is NOT Parallax\n这里所说的 Parallactic Angle 并不是 Parallax，Parallax是从两个不同的视点看同一物体时这两条视线之间的夹角(或半角)，主要用来测定物体的距离，如秒差距这一距离单位就是利用视差角来定义的。\nIn spherical astronomy, the parallactic angle is the angle between the great circle through a celestial object and the zenith(天体与天顶所在的大圆，即天球地平经线), and the hour circle of the object（天体的时角，即天球赤道经线）.It is usually denoted q. In the triangle zenith—object—celestial pole, the parallactic angle will be the position angle of the zenith at the celestial object. Despite its name, this angle is unrelated with parallax. The parallactic angle is zero when the object crosses the meridian.\n换句话说，就是天体地平经线与天体赤道经线之间的角度。\n2. 计算Parallactic Angle $$\\tan q=\\frac {\\sin H}{\\tan φ\\cos δ -\\sin δ\\cos H}$$ 式中，$φ$是观测站地理纬度,$δ$是天体的赤纬，$H$是该时刻的时角。\n如何推导？\n如上图，P为天球极点，Z为天顶，X为观测目标，此时观测点为球心（地平坐标系），\n由观测站地理纬度$φ$可知，弧长 $\\newcommand{arc}[1]{\\stackrel{\\Large\\frown}{#1}}\\arc{PZ}= 90°-φ$,\n由天体的赤纬$δ$可知，弧长 $\\newcommand{arc}[1]{\\stackrel{\\Large\\frown}{#1}}\\arc{PX}= 90°-δ$,\n由天体的时角$H$可知，球面角 $\\angle ZPX = H$,\n假设 X 的仰角为$a$,则弧长 $\\newcommand{arc}[1]{\\stackrel{\\Large\\frown}{#1}}\\arc{ZX}= 90°-a$,\n根据球面余弦公式，我们有 \\begin{cases} \\cos (90°-a) \u0026amp;= \\cos (90°-φ)\\cos (90°-δ) + \\sin (90°-φ)\\sin (90°-δ)\\cos H\\\\[2ex] \\cos (90°-φ) \u0026amp;= \\cos (90°-a)\\cos (90°-δ) + \\sin (90°-a)\\sin (90°-δ)\\cos q \\end{cases} 即 \\begin{cases} \\sin a \u0026amp;= \\sin φ\\sin δ + \\cos φ\\cos δ\\cos H, \u0026amp;(1)\\\\[2ex] \\sin φ \u0026amp;= \\sin a\\sin δ + \\cos a\\cos δ\\cos q, \u0026amp;(2) \\end{cases} 根据正弦公式，我们有$$\\frac {\\sin H}{\\cos a} = \\frac {\\sin q}{\\cos φ},\\ \\ \\ (3)$$ 由(2)(3)可得 \\begin{align} \\tan q \u0026amp;= \\frac {\\sin q}{\\cos q}\\\\[2ex] \u0026amp; = \\frac {\\frac {\\sin H\\cos φ}{\\cos a}}{\\frac {\\sin φ-\\sin a\\sin δ}{\\cos a\\cos δ}}\\\\[2ex] \u0026amp; = \\frac {\\sin H\\cos φ\\cos δ}{\\sin φ-\\sin a\\sin δ} \\end{align} 再将(1)代入上式中， \\begin{align} \\tan q \u0026amp; = \\frac {\\sin H\\cos φ\\cos δ}{\\sin φ-\\sin δ(\\sin φ\\sin δ + \\cos φ\\cos δ\\cos H)}\\\\[2ex] \u0026amp; = \\frac {\\sin H\\cos φ\\cos δ}{\\sin φ\\cos^2δ - \\cos φ\\cos δ\\sin δ\\cos H}\\\\[2ex] \u0026amp; = \\frac {\\sin H}{\\tan φ\\cos δ - \\sin δ\\cos H} \\end{align} 得证\n另一种直接证明\n　当天体位于中天时恰好与天顶重合，则有$δ=φ$，此时$\\tan q = \\frac 00$，没有意义，也就是说角度由-90°跳到90°。\n当天体位于地平线上时，即$a=0°$时，由(2)式直接可得$$\\cos q = \\frac {\\sin φ}{\\cos δ}$$ 与时角$H$无关\n// ParallacticAngle returns parallactic angle of a celestial object. // //\tφ is geographic latitude of observer.观测点地理纬度 //\tδ is declination of observed object.天体赤纬 //\tH is hour angle of observed object.天体赤经（时角） // 计算天体的Parallactic Angle func ParallacticAngle(φ, δ unit.Angle, H unit.HourAngle) unit.Angle { sδ, cδ := δ.Sincos() sH, cH := H.Sincos() // (14.1) p. 98 return unit.Angle(math.Atan2(sH, φ.Tan()*cδ-sδ*cH)) } // ParallacticAngleOnHorizon is a special case of ParallacticAngle. // // The hour angle is not needed as an input and the math inside simplifies. // 当天体位于地平线上时，计算Parallactic Angle，与时角无关 func ParallacticAngleOnHorizon(φ, δ unit.Angle) unit.Angle { return unit.Angle(math.Acos(φ.Sin() / δ.Cos())) } ","date":1526782414,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1526782414,"objectID":"74342bc5b21c7a052ebb8482b79177bf","permalink":"https://mooncaker816.github.io/2018/05/20/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9512/","publishdate":"2018-05-20T10:13:34+08:00","relpermalink":"/2018/05/20/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9512/","section":"post","summary":"第十四章 The Parallactic Angle","tags":["天文算法"],"title":"天文算法12","type":"post"},{"authors":null,"categories":["golang","算法"],"content":"第十三章 坐标的转换 Transformation of Coordinates 1. 天球坐标系统 　天球坐标系统，是天文学上用来描绘天体在天球上位置的坐标系统。有许多不同的坐标系统都使用球面坐标投影在天球上，类似于使用在地球表面的地理坐标系统。这些坐标系统的不同处只在用来将天空分割成两个相等半球的大圆，也就是基面的不同。例如，地理坐标系统的基面是地球的赤道。每个坐标系统的命名都是依据其所选择的基面。\n\\begin{array}{c|ccc} 坐标系统 \u0026amp; 基面 \u0026amp; 极 \u0026amp; 坐标 \\\\\n\\hline 地平 \u0026amp; 地平面 \u0026amp; 天顶/天底 \u0026amp; 高度（也称为仰角） - 方位 - 子午圈 \\\\\n赤道 \u0026amp; 天球赤道 \u0026amp; 天极 \u0026amp; 赤纬 - 赤经或时角 \\\\\n黄道 \u0026amp; 黄道 \u0026amp; 黄极 \u0026amp; 黄纬 - 黄经 \\\\\n银河 \u0026amp; 银河平面 \u0026amp; 银极 \u0026amp; 银经 - 银纬 \\\\\n超星系 \u0026amp; 超星系平面 \u0026amp; \u0026amp; \\\\\n\\end{array}\n2. 地平坐标系 　地平坐标系，又作地平座标系，是天球坐标系统中的一种，以观测者所在地为中心点，所在地的地平线作为基础平面，将天球适当的分成能看见的上半球和看不见（被地球本身遮蔽）的下半球。上半球的顶点（最高点）称为天顶，下半球的顶点（最低点）称为地底。\n地平坐标系统是：\n 高度角（Altitude, Alt）或仰角又称地平纬度，是天体和观测者所在地的地平线的夹角，有时就称为高度或海拔标高（elevation, geometric height）。 方位角（Azimuth, Az）又称地平经度，是沿着地平线测量的角度（由正北方为起点向东方测量）。  因此地平坐标系有时也被称为高度/方位（Alt/Az）坐标系统。  注：方位角的测量可以从北点向东测量，也可从南点向西测量，两者相差180°。天文学家习惯从南点开始测量。\n 3. 赤道坐标系 　赤道坐标系统，又作赤道座标系统，大概是使用得最广泛的天球坐标系统，他的元素是:\n 赤纬Declination（ $\\delta$ ） 赤经Right ascension（ $\\alpha$ ）－也记为RA  　他与地理坐标系统非常相似，因为两者使用相同的基准平面和相同的极点。地球的赤道在天球上的投影就称为天球赤道，相同的，地理极点在天球上的投影就是天极。\n他有两种变化：\n 时角系统像地理坐标系统一样，被固定在地球的表面上。 赤经系统被固定于恒星上(实际上并非如此，请参考岁差和章动)。  因此，在经过一夜或数个夜晚，就能看出来星星在天空中的位置移动了，当然，这并非恒星在天球上的运动，只是地球运动造成的。因为岁差和章动的影响，在相当长的时间间隔下所做的观测，就必须注明所使用的特殊历元，为行星、恒星、星系等等的位置做记录。现在使用的历元是J2000.0分点，稍早期使用的是B1950.0分点。\n赤道坐标系统中与纬度相似的值是赤纬(缩写为Dec.)，是天体在天球赤道上方或下方的角度。与经度对应的是赤经(缩写为RA)，是与春分点的角度距离，不同于经度的是赤经以时、分、秒为单位，而非度、分、秒。因为地球的运动造成赤道坐标系统的视运动，就会造成恒星时和时角的相对变化。将天球运转一周的时间定为24小时，所以每小时天球会转动15度(360º / 24h = 15)。\n赤道坐标系统也是赤道仪上很普通的设备，也就是定位圈。定位圈与星图或星历表上的位置结合，可以让赤道仪很容易的指向已知天体在天球上的位置。 4. 黄道坐标系 黄道是由地球上观察太阳一年中在天球上的视运动所通过的路径，若以地球“不动”作参照的话就是太阳绕地球公转的轨道平面（黄道面）在天球上的投影。\n黄道与天赤道相交于两点：春分点与秋分点（这两点称二分点）；而黄道对应的两个几何极是北黄极（在天龙座）、与南黄极 (在剑鱼座)。\n在黄道上与黄道平行的小圆称黄纬，符号β，以由黄道面向北黄极方向为正值（0°至90°），向南黄极方向则为负值。垂直黄道的经度称黄经，符号为λ，由春分点起由西向东量度（0°至360°）。像赤道坐标系中的赤经一样，以春分点做为黄经的起点。\n因为地轴有进动现象，此坐标系的两个黄极亦会因岁差影响而使坐标数值逐渐移动，计算时必须说明坐标系参照的历元。现常采用的是J2000.0历元（之前的出版物多以B1950.0历元），在天文年历这类精度较高的刊物中，则参考当天或当月之瞬时分点计算。\n此坐标系特别适合标示太阳系内天体的位置，大多数行星（水星和冥王星除外）与许多小行星轨道平面与黄道的倾角都很小，故其黄纬值（β）都不大。\n5. 坐标系转换  $λ$和$β$代表黄经和黄纬 $α$和$δ$代表赤经和赤纬 $φ,A,h$代表观察者纬度，方位角，和仰角，其中默认A从南点向西测量 $ε$黄赤交角   注：如果给定的为视坐标，在转换为本地地平坐标时要先将视赤经（时角）转换为本地时角。\n例如：如果θ是本地恒星时，$θ_0$ 是格林尼治恒星时，L 是观者站经度（从格林尼治向西为正，东为负），那么本地时角为$ θ - α 或 θ_0 - L – α$\n 5.1 赤道转黄道($α,δ\\ \\Rightarrow\\ λ,β$) \\begin{align} \\sin β \u0026amp;=\\cos ε\\sin δ-\\sin α\\cos δ\\sin ε\\\\[2ex] \\cos λ\\cos β \u0026amp;=\\cos α\\cos δ\\\\[2ex] \\sin λ\\cos β \u0026amp;=\\sin ε\\sin δ+\\sin α\\cos δ\\cos ε \\end{align}\n// Obliquity represents the obliquity of the ecliptic. // 黄赤交角对应的 sin,cos 值 type Obliquity struct { S, C float64 // sine and cosine of obliquity } // NewObliquity constructs a new Obliquity. // // Struct members are initialized from the given value ε of the obliquity of // the ecliptic. // 计算黄赤交角对应的 sin,cos 值 func NewObliquity(ε unit.Angle) *Obliquity { r := \u0026amp;Obliquity{} r.S, r.C = ε.Sincos() return r } // Ecliptic coordinates are referenced to the plane of the ecliptic. // 黄道坐标结构 type Ecliptic struct { Lon unit.Angle // Longitude (λ)黄经 Lat unit.Angle // Latitude (β)黄纬 } // EqToEcl converts equatorial coordinates to ecliptic coordinates. // 赤道转黄道 func (ecl *Ecliptic) EqToEcl(eq *Equatorial, ε *Obliquity) *Ecliptic { ecl.Lon, ecl.Lat = EqToEcl(eq.RA, eq.Dec, ε.S, ε.C) return ecl } // EqToEcl converts equatorial coordinates to ecliptic coordinates. // //\tα: right ascension coordinate to transform //\tδ: declination coordinate to transform //\tsε: sine of obliquity of the ecliptic //\tcε: cosine of obliquity of the ecliptic // // Results: // //\tλ: ecliptic longitude黄经 //\tβ: ecliptic latitude黄纬 // 赤道转黄道 func EqToEcl(α unit.RA, δ unit.Angle, sε, cε float64) (λ, β unit.Angle) { sα, cα := α.Sincos() sδ, cδ := δ.Sincos() λ = unit.Angle(math.Atan2(sα*cε+(sδ/cδ)*sε, cα)) // (13.1) p. 93 β = unit.Angle(math.Asin(sδ*cε - cδ*sε*sα)) // (13.2) p. 93 return }  5.2 黄道转赤道($λ,β\\ \\Rightarrow\\ α,δ$) \\begin{align} \\sin δ \u0026amp;=\\sin ε\\sin λ\\cos β+\\cos ε\\sin β\\\\[2ex] \\cos α\\cos δ \u0026amp;=\\cos λ\\cos β\\\\[2ex] \\sin α\\cos δ \u0026amp;=\\cos ε\\sin λ\\cos β-\\sin ε\\sin β \\end{align}\n// Equatorial coordinates are referenced to the Earth's rotational axis. // 赤道坐标结构 type Equatorial struct { RA unit.RA // Right ascension (α)赤经（时角） Dec unit.Angle // Declination (δ)赤纬 } // EclToEq converts ecliptic coordinates to equatorial coordinates. // 黄道转赤道 func (eq *Equatorial) EclToEq(ecl *Ecliptic, ε *Obliquity) *Equatorial { eq.RA, eq.Dec = EclToEq(ecl.Lon, ecl.Lat, ε.S, ε.C) return eq } // EclToEq converts ecliptic coordinates to equatorial coordinates. // //\tλ: ecliptic longitude coordinate to transform //\tβ: ecliptic latitude coordinate to transform //\tsε: sine of obliquity of the ecliptic //\tcε: cosine of obliquity of the ecliptic // // Results: //\tα: right ascension赤经（时角） //\tδ: declination赤纬 // 黄道转赤道 func EclToEq(λ, β unit.Angle, sε, cε float64) (α unit.RA, δ unit.Angle) { sλ, cλ := λ.Sincos() sβ, cβ := β.Sincos() α = unit.RAFromRad(math.Atan2(sλ*cε-(sβ/cβ)*sε, cλ)) // (13.3) p. 93 δ = unit.Angle(math.Asin(sβ*cε + cβ*sε*sλ)) // (13.4) p. 93 return }  5.3 地平转赤道($φ,A,h\\ \\Rightarrow\\ α,δ$) \\begin{align} \\sin δ \u0026amp;=\\sin φ\\sin h-\\cos φ\\cos h\\cos A\\\\[2ex] \\cos δ\\cos α \u0026amp;=-\\cos φ\\sin h-\\sin φ\\cos h\\cos A\\\\[2ex] \\cos δ\\sin α \u0026amp;=-\\sin A\\cos h \\end{align}\n// HzToEq transforms horizontal coordinates to equatorial coordinates. // // Sidereal time st must be consistent with the equatorial coordinates // in the sense that if coordinates are apparent, sidereal time must be // apparent as well. // 地平转赤道 func (eq *Equatorial) HzToEq(hz *Horizontal, g globe.Coord, st unit.Time) *Equatorial { eq.RA, eq.Dec = HzToEq(hz.Az, hz.Alt, g.Lat, g.Lon, st) return eq } // HzToEq transforms horizontal coordinates to equatorial coordinates. // //\tA: azimuth方位角 //\th: elevation仰角 //\tφ: latitude of observer on Earth观测纬度 //\tψ: longitude of observer on Earth观测经度 //\tst: sidereal time at Greenwich at time of observation.恒星时 // // Sidereal time must be consistent with the equatorial coordinates // in the sense that tf coordinates are apparent, sidereal time must be // apparent as well. // 恒星时必须和所给条件保持一致 // // Results: // //\tα: right ascension赤经（时角） //\tδ: declination赤纬 // 地平转赤道 func HzToEq(A, h, φ, ψ unit.Angle, st unit.Time) (α unit.RA, δ unit.Angle) { sA, cA := A.Sincos() sh, ch := h.Sincos() sφ, cφ := φ.Sincos() H := math.Atan2(sA, cA*sφ+sh/ch*cφ) α = unit.RAFromRad(st.Rad() - ψ.Rad() - H) δ = unit.Angle(math.Asin(sφ*sh - cφ*ch*cA)) return }  5.4 赤道转地平($φ,α,δ\\ \\Rightarrow\\ A,h$) \\begin{align} \\sin h \u0026amp;= \\sin φ\\sin δ+\\cos φ\\cos δ\\cos α\\\\[2ex] \\cos A\\cos h \u0026amp;=-\\cos φ\\sin δ+\\sin φ\\cos δ\\cos α\\\\[2ex] \\sin A\\cos h \u0026amp;=\\cos δ\\sin α \\end{align}\n// Horizontal coordinates are referenced to the local horizon of an observer // on the surface of the Earth. // 地平坐标结构 type Horizontal struct { Az unit.Angle // Azimuth (A)方位角 Alt unit.Angle // Altitude (h)仰角 } // EqToHz computes Horizontal coordinates from equatorial coordinates. // // Argument g is the location of the observer on the Earth. Argument st // is the sidereal time at Greenwich. // // Sidereal time must be consistent with the equatorial coordinates. // If coordinates are apparent, sidereal time must be apparent as well. // 赤道转地平 func (hz *Horizontal) EqToHz(eq *Equatorial, g *globe.Coord, st unit.Time) *Horizontal { hz.Az, hz.Alt = EqToHz(eq.RA, eq.Dec, g.Lat, g.Lon, st) return hz } // EqToHz computes Horizontal coordinates from equatorial coordinates. // //\tα: right ascension coordinate to transform //\tδ: declination coordinate to transform //\tφ: latitude of observer on Earth //\tψ: longitude of observer on Earth //\tst: sidereal time at Greenwich at time of observation. // // Sidereal time must be consistent with the equatorial coordinates. // If coordinates are apparent, sidereal time must be apparent as well. // // Results: // //\tA: azimuth of observed point, measured westward from the South. //\th: elevation, or height of observed point above horizon. // 赤道转地平 func EqToHz(α unit.RA, δ, φ, ψ unit.Angle, st unit.Time) (A, h unit.Angle) { H := st.Rad() - ψ.Rad() - α.Rad() sH, cH := math.Sincos(H) sφ, cφ := φ.Sincos() sδ, cδ := δ.Sincos() A = unit.Angle(math.Atan2(sH, cH*sφ-(sδ/cδ)*cφ)) // (13.5) p. 93 h = unit.Angle(math.Asin(sφ*sδ + cφ*cδ*cH)) // (13.6) p. 93 return } ","date":1526713444,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1526713444,"objectID":"f2c058727e94691c2544b561c47f27d1","permalink":"https://mooncaker816.github.io/2018/05/19/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9511/","publishdate":"2018-05-19T15:04:04+08:00","relpermalink":"/2018/05/19/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9511/","section":"post","summary":"第十三章 坐标的转换 Transformation of Coordinates","tags":["天文算法"],"title":"天文算法11","type":"post"},{"authors":null,"categories":["golang","算法"],"content":"第十二章 格林威治恒星时 Sidereal Time at Greenwich 1. 恒星时 　恒星时是天文学和大地测量学标示的天球子午圈值，由于借用了时间的计量单位，所以常被误解为是一种时间单位。恒星时是根据地球自转来计算的，它的基础是恒星日（比地球的自转周期短约8.4毫秒）。由于地球环绕太阳的公转运动，恒星日比平太阳日（也就是日常生活中所使用的日）短约1/365（相应约四分钟或一度）。\n　恒星时的定义是一个地方的子午圈与天球的春分点之间的时角，因此地球上每个地方的恒星时都与它的经度有关。\n　由于地球的章动春分点在天球上并不固定，而是以18.6年的周期围绕着平均春分点摆动。因此恒星时又分真恒星时和平恒星时。真恒星时是通过直接测量子午线与实际的春分点之间的时角获得的，平恒星时则忽略了地球的章动。真恒星时与平恒星时之间的差异最大可达约0.4秒。\n　一个地方的当地恒星时与格林尼治天文台的恒星时之间的差就是这个地方的经度（参见天体导航）。因此通过观测恒星时可以确定当地的经度（假如格林尼治天文台的恒星时已知的话）或者可以确定时间（假如当地的经度已知的话）。\n 一颗恒星的时角$\\tau$ 、它的赤经$α$和当地的恒星时$θ$之间的关系为 $\\tau=\\theta -\\alpha$ 当地的恒星时等于位于天顶的恒星的赤经 当地的恒星时等于正位于中天恒星的赤经  　通过确定恒星时可以简化天文学的计算，比如通过恒星时和当地的纬度可以很方便地计算出哪些星正好在地平线以上。\n2. 恒星时的计算 2.1 格林威治0h平恒星时 　一个给定的世界时日期的(0h UT)，格林尼治子午圈的平恒星时可按如下计算。\n1. 先计算当天（0h UT）对应的$JD$\n2. 计算$T = \\frac {JD - 2451545.0}{36525}$\n3. 采用 IAU1982 的格林尼治子午圈的平恒星时表达式： $$θ_0 = 6h41m50s.54841 + 8640184s.812866T + 0s.093104T^2 - 0s.0000062T^3$$ 4. 若以度为单位，则上式为：$$θ_0 = 100.46061837 + 36000.770053608T + 0.000387933T^2 - T^3 / 38710000$$\n 注意，上述公式只适用于(0h UT）\n // jdToCFrac returns values for use in computing sidereal time at Greenwich. // // Cen is centuries from J2000 of the JD at 0h UT of argument jd. This is // the value to use for evaluating the IAU sidereal time polynomial. // DayFrac is the fraction of jd after 0h UT. It is used to compute the // final value of sidereal time. // 计算 T = cen，dayFrac 为此 jd 对应的天的小数 func jdToCFrac(jd float64) (cen, dayFrac float64) { j0, f := math.Modf(jd + .5) return base.J2000Century(j0 - .5), f }  // J2000Century returns the number of Julian centuries since J2000. // // The quantity appears as T in a number of time series. func J2000Century(jde float64) float64 { // The formula is given in a number of places in the book, for example // (12.1) p. 87. // (22.1) p. 143. // (25.1) p. 163. return (jde - J2000) / JulianCentury }  // Mean0UT returns mean sidereal time at Greenwich at 0h UT on the given JD. // // The result is in the range [0,86400). // 计算格林威治 0h UT 平恒星时，并化简为单位为秒一天之内的值[0,86400). func Mean0UT(jd float64) unit.Time { s, _ := mean0UT(jd) return s.Mod1() } // 计算格林威治 0h UT 平恒星时，并返回此 jd 一天中相对于0h的秒数，用于瞬时平恒星时的计算 func mean0UT(jd float64) (sidereal, dayFrac unit.Time) { cen, f := jdToCFrac(jd) // (12.2) p. 87 return unit.Time(base.Horner(cen, iau82...)), unit.TimeFromDay(f) }  2.2 格林威治任意 UT 平恒星时 　1. 计算0h 平恒星时\n2. UT * 1.00273790935\n3. 1 + 2 的结果即为格林威治瞬时平恒星时\n4. 若以度为单位，则：$$θ_0 = 280.46061837 + 360.98564736629(JD-2451545.0) + 0.000387933T^2 - T^3 / 38710000$$\n// Mean returns mean sidereal time at Greenwich for a given JD. // // Computation is by IAU 1982 coefficients. // The result is in the range [0,86400). // 计算格林威治 jd 时刻的瞬时平恒星时,化简结果至一天范围之内 func Mean(jd float64) unit.Time { return mean(jd).Mod1() } // 计算格林威治 jd 时刻的瞬时平恒星时 func mean(jd float64) unit.Time { s, f := mean0UT(jd) return s + f*1.00273790935 }  2.3 格林威治视恒星时 　要取得视恒星时，即真春分点起算的格林尼治时角，应加上修正值 $Δψ\\cos ε$，式中 $Δψ$ 是黄经章动，$ε$ 是真黄赤交角。这个修正值也就作赤经章动（也称作分点方程）。因为 $Δψ$ 是个小量，所以 $ε$ 误差 10\u0026rdquo;也没关系。\n如果 $Δψ$ 的单位是角秒（1 度是 3600 秒），则以时秒(1 小时是 3600 秒)为单位的修正值是：$\\frac {Δψ\\cos ε}{15}$\n// Apparent returns apparent sidereal time at Greenwich for the given JD. // // Apparent is mean plus the nutation in right ascension. // // The result is in the range [0,86400). // 计算格林威治瞬时视恒星时 func Apparent(jd float64) unit.Time { s := mean(jd) // Time n := nutation.NutationInRA(jd) // HourAngle return (s + n.Time()).Mod1() } // Apparent0UT returns apparent sidereal time at Greenwich at 0h UT // on the given JD. // // The result is in the range [0,86400). // 计算格林威治0h UT视恒星时 func Apparent0UT(jd float64) unit.Time { j0, f := math.Modf(jd + .5) cen := (j0 - .5 - base.J2000) / 36525 s := unit.Time(base.Horner(cen, iau82...)) + unit.TimeFromDay(f*1.00273790935) n := nutation.NutationInRA(j0) // HourAngle return (s + n.Time()).Mod1() } ","date":1526692812,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1526692812,"objectID":"35b5b4a3dedf74ff25edb524be7e02c6","permalink":"https://mooncaker816.github.io/2018/05/19/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9510/","publishdate":"2018-05-19T09:20:12+08:00","relpermalink":"/2018/05/19/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9510/","section":"post","summary":"第十二章 格林威治恒星时 Sidereal Time at Greenwich","tags":["天文算法"],"title":"天文算法10","type":"post"},{"authors":null,"categories":["golang","算法"],"content":"第十一章 地球球体 The Earth\u0026rsquo;s Globe 1. 椭球体 　天文学上，通常我们将地球看做一个近似的椭球体。如下图，所以子午圈截面为一个椭圆。如下图，假设上图中$C$为地心，$N$为北极，$S$为南极，$CF$为赤道半径，$NC = b, CF = a$,$O$为观察点，$HK$为地平面，$OP\\perp HK$,$OM//SN$，$OM$与$OH$的夹角是$φ$，$CF$与$CO$的夹角是$φ\u0026rsquo;$，$CO$的长度为$\\rho$\n则$φ$为$O$点的地理纬度，$\\angle OPF = φ$，$φ\u0026rsquo;$为$O$点的地心纬度,$\\rho$为$O$点的地心半径,在极点和赤道上$φ=φ′$，在其它纬度上$|φ′|\u0026lt;|φ|$\n地心纬度$φ\u0026rsquo;$与地理纬度$φ$的关系为：$\\tan φ′=\\frac {b^2}{a^2} \\tan φ，$(推导)\n由椭球体扁率$f=\\frac {a-b}a$,可知$b=a(1-f)$,子午圈椭圆离心率 \\begin{align} e \u0026amp;= \\frac ca\\\\[2ex] \u0026amp; = \\frac {\\sqrt {a^2-b^2}}{a}\\\\[2ex] \u0026amp; = \\sqrt {2f-f^2} \\end{align} 地心纬度$φ\u0026rsquo;$对应的归化纬度$u$,有 \\begin{cases} \\tan φ\u0026rsquo; = \\frac ba \\tan u\\\\[2ex] \\tan u = \\frac ba \\tan φ\\\\[2ex] \\end{cases} 且 \\begin{cases} \\rho \\cos φ\u0026rsquo; = a\\cos u, \\ (相当于子午圈椭圆上观察点O的x坐标)\\\\[2ex] \\rho \\sin φ\u0026rsquo; = b\\sin u, \\ (相当于子午圈椭圆上观察点O的y坐标) \\end{cases} 如果观察点的海拔高度为$H$,且$\\rho$以赤道半径$a$为单位，则有 \\begin{cases} \\rho \\cos φ\u0026rsquo; = cos u + \\frac Ha\\cos φ\\\\[2ex] \\rho \\sin φ\u0026rsquo; = \\frac ba\\sin u + \\frac Ha\\sin φ \\end{cases}\n// Ellipsoid represents an ellipsoid of revolution. // // Typical unit for Er is Km. // 地球椭球体 type Ellipsoid struct { Er float64 // equatorial radius 赤道半径 Fl float64 // flattening 地球扁率 } // IAU 1976 values. Radius in Km. var Earth76 = Ellipsoid{Er: 6378.14, Fl: 1 / 298.257} // A returns equatorial radius in units of e.Er. // // A is a common identifier for equatorial radius. // 子午圈椭圆长半轴（赤道半径） func (e Ellipsoid) A() float64 { return e.Er } // B returns polar radius in units of e.ER. // // B is a common identifier for polar radius. // // 子午圈椭圆短半轴（地心到极点的距离） func (e Ellipsoid) B() float64 { return e.Er * (1 - e.Fl) } // Eccentricity of a meridian. // 子午圈椭圆离心率 func (e Ellipsoid) Eccentricity() float64 { return math.Sqrt((2 - e.Fl) * e.Fl) } // ParallaxConstants computes parallax constants ρ sin φ′ and ρ cos φ′. // // Arguments are geographic latitude φ and height h above the ellipsoid. // For e.Er in Km, h must be in meters. // 海拔为h的观察点对应的ρ sin φ′，ρ cos φ′ func (e Ellipsoid) ParallaxConstants(φ unit.Angle, h float64) (s, c float64) { boa := 1 - e.Fl su, cu := math.Sincos(math.Atan(boa * φ.Tan())) s, c = φ.Sincos() hoa := h * 1e-3 / e.Er return su*boa + hoa*s, cu + hoa*c }  2. 其他椭球公式 　在椭球上给定的一点，地理纬度与地心纬度的差值为：$φ - φ′ = 692\u0026rdquo;.73sin(2φ) - 1\u0026rdquo;.16sin(4φ)$\n当$u=45°$时，$φ-φ′$达到最大值。 如果$φ_0$和$φ_0′$是此时相应的地理纬度和地心纬度，我们有：$$tan(φ_0) = a/b，tan(φ_0′) = b/a， φ_0+φ_0′=90°$$ 对于IAU1976($a = 6378.14km,b = 6356.755km,f=\\frac {1}{298.257}$) 有 \\begin{align} φ_0 = 45°05′46\u0026rdquo;.36,\\\\[2ex] φ_0′ = 44°54′13\u0026rdquo;.64,\\\\[2ex] φ_0 - φ_0′ = 11′32\u0026rdquo;.73 \\end{align} 海平面上，$$\\rho =0.9983271+0.0016764\\cos {2φ}-0.0000035\\cos {4φ}$$ 同纬度$φ$的圆的半径：$$R_p = \\frac {a\\cos φ}{\\sqrt{(1-e^2\\sin^2φ)}}$$ 因此，在同一纬度$φ$上，经度变化1度，相应的长度变化为$(π/180)R_p$,线速度为$ωR_p$,其中$ω = 7.292114992*10^{-5}(弧度/秒)$\n地球子午圈的曲率半径，在纬度$φ$：$$R_m=\\frac {a(1-e^2)}{(1-e^2\\sin ^2 φ)^{\\frac 32}}$$ 且纬度变化1度，相应的长度变化：$(π/180)R_m$,在赤道时，$R_m$达到最小值，值为$a(1-e^2)=6335.44km$， 在极点时达到最大值，值为$\\frac {a}{\\sqrt {1-e^2}}=6399.60km$\n// Rho is distance from Earth center to a point on the ellipsoid at latitude φ. // // Result unit is fraction of the equatorial radius. // 海平面上，ρ值计算 func Rho(φ unit.Angle) float64 { // Magic numbers... return .9983271 + .0016764*φ.Mul(2).Cos() - .0000035*φ.Mul(4).Cos() } // RadiusAtLatitude returns the radius of the circle that is the parallel of // latitude φ. // // Result unit is same as e.Er (typically Km.) // 同纬度圆半径 func (e Ellipsoid) RadiusAtLatitude(φ unit.Angle) float64 { s, c := φ.Sincos() return e.A() * c / math.Sqrt(1-(2-e.Fl)*e.Fl*s*s) } // OneDegreeOfLongitude returns the length of one degree of longitude. // // Argument rp is the radius of a circle that is a parallel of latitude // (as returned by Ellipsoid.RadiusAtLatitude.) // // Result is distance along one degree of the circle, in same units as rp. // 同纬度，计算经度变化1度时长度变化的值 func OneDegreeOfLongitude(rp float64) float64 { return rp * math.Pi / 180 } // RotationRate1996_5 is the rotational angular velocity of the Earth // with respect to the stars at the epoch 1996.5. // // Unit is radian/second. const RotationRate1996_5 = 7.292114992e-5 // RadiusOfCurvature of meridian at latitude φ. // // Result in units of e.ER, typically Km. // 纬度为φ，子午圈曲率半径 func (e Ellipsoid) RadiusOfCurvature(φ unit.Angle) float64 { s := φ.Sin() e2 := (2 - e.Fl) * e.Fl return e.A() * (1 - e2) / math.Pow(1-e2*s*s, 1.5) } // OneDegreeOfLatitude returns the length of one degree of latitude. // // Argument rm is the radius of curvature along a meridian. // (as returned by Ellipsoid.RadiusOfCurvature.) // Result is distance in units of rm along one degree of the meridian. // 同经度，计算纬度变化1度时长度变化的值 func OneDegreeOfLatitude(rm float64) float64 { return rm * math.Pi / 180 }  3. 地表两点间的距离 　假设经纬度是分别是$(L_1,φ_1),(L_2,φ_2)$，且这两点在海平面。 如果精度要求不高，可以把地球看作球形，平均半径为6371km。使用下式可得到两点间的角距离：$$\\cos d=\\sin φ_1\\sin φ_2 +\\cos φ_1\\cos φ_2\\cos(L_1-L_2)$$ 那么$$s = \\frac {6371πd}{180}$$ 高精度计算可使用以下方法： $$F=\\frac {φ_1+φ_2}{2},G=\\frac {φ_1-φ_2}{2},\\lambda = \\frac {L_1-L_2}{2}$$ $$S = \\sin^2G\\cos^2\\lambda+\\cos^2F\\sin^2\\lambda$$ $$C = \\cos^2G\\cos^2\\lambda+\\sin^2F\\sin^2\\lambda$$ $$\\tan ω = \\sqrt{\\frac SC}$$ $$R=\\frac{\\sqrt{SC}}{ω}$$ $$D=2ωa,H_1=\\frac{3R-1}{2C},H_2=\\frac{3R+1}{2S}$$ $$s=D(1+fH_1\\sin^2F\\cos^2G-fH_2\\cos^2F\\sin^2G)$$\n// Distance is distance between two points measured along the surface // of an ellipsoid. // // Accuracy is much better than that of ApproxAngularDistance or // ApproxLinearDistance. // // Result unit is units of e.Er, typically Km. // 地表两点距离 func (e Ellipsoid) Distance(c1, c2 Coord) float64 { // From AA, ch 11, p 84. s2f, c2f := sincos2((c1.Lat + c2.Lat) / 2) s2g, c2g := sincos2((c1.Lat - c2.Lat) / 2) s2λ, c2λ := sincos2((c1.Lon - c2.Lon) / 2) s := s2g*c2λ + c2f*s2λ c := c2g*c2λ + s2f*s2λ ω := math.Atan(math.Sqrt(s / c)) r := math.Sqrt(s*c) / ω d := 2 * ω * e.Er h1 := (3*r - 1) / (2 * c) h2 := (3*r + 1) / (2 * s) return d * (1 + e.Fl*(h1*s2f*c2g-h2*c2f*s2g)) } func sincos2(x unit.Angle) (s2, c2 float64) { s, c := x.Sincos() return s * s, c * c } ","date":1526630120,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1526630120,"objectID":"1ff27e865972ff7eeb66426c656e6cbd","permalink":"https://mooncaker816.github.io/2018/05/18/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%959/","publishdate":"2018-05-18T15:55:20+08:00","relpermalink":"/2018/05/18/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%959/","section":"post","summary":"第十一章 地球球体 The Earth\u0026rsquo;s Globe","tags":["天文算法"],"title":"天文算法9","type":"post"},{"authors":null,"categories":["golang","算法"],"content":"第十章 力学时和世界时 Dynamical Time \u0026amp; Universal Time 1. 力学时 　力学时（Dynamical Time，简称DT）是一种从历书时(ET)到地球时(TT)过渡的时间尺度。分为地球力学时（Temps Dynamique Terrestrique，简称TDT）和质心力学时（Temps Dynamique Barycentrique，简称TDB）两种。\n　1958年国际天文学联合会（IAU）决定从1960年开始使用以地球公转运动为基准的历书时（ET）代替以地球自转为基准的世界时（UT），目的是解决由于地球自转速度不均匀导致的世界时的时间尺度不均匀的问题。但是由于历书时所用的基准地球运动的理论框架是牛顿力学，根据广义相对论可知，在以太阳为中心的坐标系和以地球为中心的坐标系中时间将会不同。为解决这一问题，1976年国际天文学联合会分别定义了地球力学时（TDT）和质心力学时（TDB）。这两个时间尺度可以看作是历书时在两个坐标系中的实现。1991年，地球力学时被重新精确定义后改名为地球时（TT）。\n　太阳系质心力学时（TDB）和地心力学时（TDT） 的区分。这两个系统最多相差 0.0017 秒，此种差异与地球以椭圆轨道绕日运动有关(相对论效应)。因这一差异小到可以被大多数实际应用忽略，故此处我们对质心力学时和地球力学时不加区分，统称为力学时(TD)。\n　2. 世界时 　世界时（Universal Time，简称UT）是一种以格林尼治子夜起算的平太阳时。世界时是以地球自转为基准得到的时间尺度，其精度受到地球自转不均匀变化和极移的影响，为了解决这种影响，1955年国际天文联合会定义了UT0、UT1和UT2三个系统：\n UT0系统是由一个天文台的天文观测直接测定的世界时，没有考虑极移造成的天文台地理坐标变化。该系统曾长期被认为是稳定均匀的时间计量系统，得到过广泛应用。 UT1系统是在UT0的基础上加入了极移改正 Δλ，修正地轴摆动的影响。UT1是目前使用的世界时标准。被作为目前世界民用时间标准UTC在增减闰秒时的参照标准。 UT2系统是UT1的平滑处理版本，在UT1基础上加入了地球自转速率的季节性改正 ΔT。 它们之间的关系可以表示为： \\begin{align} UT1 = UT0 + Δλ\\\\[2ex] UT2 = UT1 + ΔT \\end{align}  　3. 协调世界时 　协调世界时（英语：Coordinated Universal Time，法语：Temps Universel Coordonné，简称UTC）是最主要的世界时间标准，其以原子时秒长为基础，在时刻上尽量接近于格林尼治标准时间。\n　协调世界时是世界上调节时钟和时间的主要时间标准，它与0度经线的平太阳时相差不超过1秒，并不遵守夏令时。协调世界时是最接近格林威治标准时间（GMT）的几个替代时间系统之一。对于大多数用途来说，UTC时间被认为能与GMT时间互换，但GMT时间已不再被科学界所确定。\n　UTC基于国际原子时，并通过不规则的加入闰秒来抵消地球自转变慢的影响。闰秒在必要的时候会被插入到UTC中，以保证协调世界时（UTC）与世界时（UT1）相差不超过0.9秒。\n　为了保证协调世界时很接近世界时UT1，UTC从基于TAI的线性方程转变成另一方程时，偶尔会出现不连续点。这些不连续点以闰秒的形式体现出来，这些不连续点就是造成了UTC天的长度不规则的闰秒。IERS规定不连续点仅出现在6月或12月底，但也有规定将3月或者9月作为备选。国际地球自转服务组织(IERS)跟踪并公布UTC时间和世界时的差别，即$DUT1 = UT1 - UTC$，另外，IERS也负责引入不连续的闰秒来保证它们的时间差DUT1在±0.9秒之间。\n　4. 计算力学时和世界时之间的差值 　由于地球自转一直在变缓，而且变缓规律难以预测，力学时和世界时之间的精确差值 $ΔT = TD - UT$ 只能由天文观测值推算。\n书中给出了1620年至1998年的ΔT数据，所以在此之间的时间可以通过插值法来计算，其余时期的数据可以用以下方式推算：\n 令 $t=\\frac {year-2000}{100}$\n// c2000 returns centuries from calendar year 2000.0. // // Arg should be a calendar year. // 计算年份y距离2000年的世纪数 func c2000(y float64) float64 { return (y - 2000) * .01 }  $ΔT = 2177 + 497t + 44.1t^2, year \u0026lt; +948 $\n// PolyBefore948 returns a polynomial approximation of ΔT valid for calendar // years before 948. // +948年之前的ΔT推算公式 func PolyBefore948(year float64) (ΔT unit.Time) { // (10.1) p. 78 return unit.Time(base.Horner(c2000(year), 2177, 497, 44.1)) }  $ΔT = 102 + 102t + 25.3t^2, +948 \\leq year \\leq +1600 || year \\geq +2000 $\n// Poly948to1600 returns a polynomial approximation of ΔT valid for calendar // years 948 to 1600. // +984年至1600年的ΔT推算公式 func Poly948to1600(year float64) (ΔT unit.Time) { // (10.2) p. 78 return unit.Time(base.Horner(c2000(year), 102, 102, 25.3)) }  若 $+2000 \\leq year \\leq +2100$, 还要在第3步的基础上加上一个修正量$+0.37(year-2100)$\n// PolyAfter2000 returns a polynomial approximation of ΔT valid for calendar // years after 2000. // 2000年以后的ΔT推算公式 func PolyAfter2000(year float64) (ΔT unit.Time) { ΔT = Poly948to1600(year) if year \u0026lt; 2100 { ΔT += unit.Time(.37 * (year - 2100)) } return }  经验公式：\n5.0 $\\ 儒略日世纪数\\theta=\\frac {JDE-J1900.0}{36525},J1900.0=2415020.0(1899-12-31)$\n// jc1900 returns julian centuries from the epoch J1900.0 // // Arg should be a julian day, technically JDE. // 计算儒略日jde距离J1900.0的世纪数 func jc1900(jde float64) float64 { return (jde - base.J1900) / base.JulianCentury }  5.1 $\\ 1800 - 1997$：(最大误差2.3秒) \\begin{align} ΔT = \u0026amp;-1.02 + 91.02\\theta + 265.90\\theta^2 - 839.16\\theta^3 - 1545.20\\theta^4 \\\\[2ex] \u0026amp;+ 3603.62\\theta^5 + 4385.98\\theta^6 - 6993.23\\theta^7 - 6090.04\\theta^8 \\\\[2ex] \u0026amp;+ 6298.12\\theta^9 + 4102.86\\theta^{10} - 2137.64\\theta^{11} - 1081.51\\theta^{12} \\end{align}\n// Poly1800to1997 returns a polynomial approximation of ΔT valid for years // 1800 to 1997. // // The accuracy is within 2.3 seconds. // 1800至1997ΔT经验公式，最大误差2.3秒 func Poly1800to1997(jde float64) (ΔT unit.Time) { return unit.Time(base.Horner(jc1900(jde), -1.02, 91.02, 265.90, -839.16, -1545.20, 3603.62, 4385.98, -6993.23, -6090.04, 6298.12, 4102.86, -2137.64, -1081.51)) }  5.2 $\\ 1800 - 1899$：(最大误差0.9秒) \\begin{align} ΔT = \u0026amp;-2.50 + 228.95\\theta + 5218.61\\theta^2 + 56282.84\\theta^3 + 324011.78\\theta^4 \\\\[2ex] \u0026amp;+ 1061660.75\\theta^5 + 2087298.89\\theta^6 + 2513807.78\\theta^7 + 1818961.41\\theta^8 \\\\[2ex] \u0026amp;+ 727058.63\\theta^9 + 123563.95\\theta^{10} \\end{align}\n// Poly1800to1899 returns a polynomial approximation of ΔT valid for years // 1800 to 1899. // // The accuracy is within 0.9 seconds. // 1800至1899ΔT经验公式，最大误差0.9秒 func Poly1800to1899(jde float64) (ΔT unit.Time) { return unit.Time(base.Horner(jc1900(jde), -2.50, 228.95, 5218.61, 56282.84, 324011.78, 1061660.75, 2087298.89, 2513807.78, 1818961.41, 727058.63, 123563.95)) }  5.3 $\\ 1900 - 1997$：(最大误差0.9秒) \\begin{align} ΔT = \u0026amp;-2.44 + 87.24\\theta + 815.20\\theta^2 - 2637.80\\theta^3 - 18756.33\\theta^4 \\\\[2ex] \u0026amp;+ 124906.15\\theta^5 - 303191.19\\theta^6 + 372919.88\\theta^7 - 232424.66\\theta^8 \\\\[2ex] \u0026amp;+ 58353.42\\theta^9 \\end{align}\n// Poly1900to1997 returns a polynomial approximation of ΔT valid for years // 1900 to 1997. // // The accuracy is within 0.9 seconds. // 1900至1997ΔT经验公式，最大误差0.9秒 func Poly1900to1997(jde float64) (ΔT unit.Time) { return unit.Time(base.Horner(jc1900(jde), -2.44, 87.24, 815.20, -2637.80, -18756.33, 124906.15, -303191.19, 372919.88, -232424.66, 58353.42)) }  ","date":1526522194,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1526522194,"objectID":"e9d53176992144cb22fe59d4a6c267d9","permalink":"https://mooncaker816.github.io/2018/05/17/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%958/","publishdate":"2018-05-17T09:56:34+08:00","relpermalink":"/2018/05/17/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%958/","section":"post","summary":"第十章 力学时和世界时 Dynamical Time \u0026amp; Universal Time","tags":["天文算法"],"title":"天文算法8","type":"post"},{"authors":null,"categories":["golang","算法"],"content":"第九章 犹太历和穆斯林历 略\n","date":1526518594,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1526518594,"objectID":"c085d23185e1107b18c10261238c83e1","permalink":"https://mooncaker816.github.io/2018/05/17/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%957/","publishdate":"2018-05-17T08:56:34+08:00","relpermalink":"/2018/05/17/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%957/","section":"post","summary":"第九章 犹太历和穆斯林历","tags":["天文算法"],"title":"天文算法7","type":"post"},{"authors":null,"categories":["golang","算法"],"content":"第八章 复活节日 Date of Easter 对西方的节日没有多少了解，这里就直接给出书中的算法吧~\n1. 格里历复活节算法 \\begin{array}{l|ccc} 被除数 \u0026amp; 除数 \u0026amp; 商 \u0026amp; 余数 \\\\\n\\hline 年份y \u0026amp; 19 \u0026amp; - \u0026amp; a \\\\\n年份y \u0026amp; 100 \u0026amp; b \u0026amp; c \\\\\nb \u0026amp; 4 \u0026amp; d \u0026amp; e \\\\\nb+8 \u0026amp; 25 \u0026amp; f \u0026amp; - \\\\\nb-f+1 \u0026amp; 3 \u0026amp; g \u0026amp; - \\\\\n19a+b-d-g+15 \u0026amp; 30 \u0026amp; - \u0026amp; h \\\\\nc \u0026amp; 4 \u0026amp; i \u0026amp; k \\\\\n32+2e+2i-h-k \u0026amp; 7 \u0026amp; - \u0026amp; l \\\\\na+11h+22l \u0026amp; 451 \u0026amp; m \u0026amp; - \\\\\nh+l-7m+114 \u0026amp; 31 \u0026amp; n \u0026amp; p \\\\\n\\end{array}\n得 $$n = 月份, \\ p+1 = 日期$$\n// Gregorian returns month and day of Easter in the Gregorian calendar. // 格里历复活节日算法 func Gregorian(y int) (m, d int) { a := y % 19 b, c := y/100, y%100 d, e := b/4, b%4 f := (b + 8) / 25 g := (b - f + 1) / 3 h := (19*a + b - d - g + 15) % 30 i, k := c/4, c%4 l := (32 + 2*e + 2*i - h - k) % 7 m = (a + 11*h + 22*l) / 451 n := h + l - 7*m + 114 n, p := n/31, n%31 return n, p + 1 }  2. 儒略历复活节算法 \\begin{array}{l|ccc} 被除数 \u0026amp; 除数 \u0026amp; 商 \u0026amp; 余数 \\\\\n\\hline 年份y \u0026amp; 4 \u0026amp; - \u0026amp; a \\\\\n年份y \u0026amp; 7 \u0026amp; - \u0026amp; b \\\\\n年份y \u0026amp; 19 \u0026amp; - \u0026amp; c \\\\\n19c+15 \u0026amp; 30 \u0026amp; - \u0026amp; d \\\\\n2a+4b-d+34 \u0026amp; 7 \u0026amp; - \u0026amp; e \\\\\nd+e+114 \u0026amp; 31 \u0026amp; f \u0026amp; g \\\\\n\\end{array}\n得 $$f = 月份, \\ g+1 = 日期$$\n// Julian returns month and day of Easter in the Julian calendar. // 儒略历复活节日算法 func Julian(y int) (m, d int) { a := y % 4 b := y % 7 c := y % 19 d = (19*c + 15) % 30 e := (2*a + 4*b - d + 34) % 7 f := d + e + 114 f, g := f/31, f%31 return f, g + 1 } ","date":1526514044,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1526514044,"objectID":"5ee54d19845d47de71079e101f48b63e","permalink":"https://mooncaker816.github.io/2018/05/17/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%956/","publishdate":"2018-05-17T07:40:44+08:00","relpermalink":"/2018/05/17/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%956/","section":"post","summary":"第八章 复活节日 Date of Easter","tags":["天文算法"],"title":"天文算法6","type":"post"},{"authors":null,"categories":["golang","算法"],"content":"第七章 儒略日 Julian Day 1. 儒略历和格里高利历 1.1 定义  儒略历，是格里历的前身，由罗马共和国独裁官儒略·凯撒采纳埃及亚历山大的希腊数学家兼天文学家索西琴尼计算的历法，在公元前45年1月1日起执行，取代旧罗马历历法的历法。一年设12个月，大小月交替，四年一闰，平年365日，闰年于二月底增加一闰日，年平均长度为365.25日。由于累积误差随着时间越来越大，1582年后由教皇格里高利十三世改良，变为格里历，即沿用至今的公历。但大英帝国、北美十三州等直到1752年才从儒略历改用格里历。现今儒略历只有苏格兰昔德兰群岛之富拉岛、阿索斯神权共和国和一些北非的柏柏尔人使用。\n格里历（拉丁语：Calendarium Gregorianum，又译、国瑞历、额我略历、格列高利历、格里高利历、葛瑞格里历、格列高历，也称基督历[1]），是由意大利医生兼哲学家阿洛伊修斯·里利乌斯改革儒略历制定的历法，由罗马大公教会教宗格列高利十三世在1582年颁行。公历是阳历的一种，于1912年在中国引进采用，因农历等中国传统历法是阴阳历，故公历在中文中又称阳历、西历、新历、公历。格里历与儒略历一样，格里历也是每四年在2月底置一闰日，但格里历特别规定，除非能被400整除，所有的世纪年（能被100整除）都不设闰日；如此，每四百年，格里历仅有97个闰年，比儒略历减少3个闰年 [注 1]。 格里历的历年平均长度为365.2425日，接近平均回归年的365.242199074日，即约每3300年误差一日，也更接近春分点回归年的365.24237日，即约每8000年误差一日；而儒略历的历年为365.25日，约每128年就误差一日[注 1]。到1582年时，儒略历的春分日（3月21日）与地球公转到春分点的实际时间已相差10天。因此，格里历开始实行时，将儒略历1582年10月4日星期四的次日，为格里历1582年10月15日星期五，即有10天被删除，但原星期的周期保持不变。格里历的纪年沿用儒略历，自传统的耶稣诞生年开始，称为“公元”，亦称“西元”。\n 1.2 区别 　由定义可见，儒略历和格里高利历都属于阳历，后者是以太阳回归年为基础，对前者置润误差进行调整后的历法。所以两者之间最大的不同就是置润规则。\n1.2.1 置润规则  儒略历\n能被4整除的年份为闰年（产生多润的原因，从而使儒略历在日期上落后于格里历）\n 格里历\n能被4整除但不能被100整除的非世纪年 + 能被400整除的世纪年，即要在儒略历闰年中扣除那些不能被400整除的世纪年（如1600，1700等）\n  // LeapYearJulian returns true if year y in the Julian calendar is a leap year. // 儒略历闰年判断 func LeapYearJulian(y int) bool { return y%4 == 0 } // LeapYearGregorian returns true if year y in the Gregorian calendar is a leap year. // 格里历闰年判断 func LeapYearGregorian(y int) bool { return (y%4 == 0 \u0026amp;\u0026amp; y%100 != 0) || y%400 == 0 }  1.2.2 转换 　知道了这个不同，我们就能推导出两种历法之间实际的相差天数，如下：\n 1582年：\n格里历10月15日，合儒略历10月5日，或之后的日期：格里历日期减10日等于儒略历日期。 1583年——1699年：\n格里历日期减10日等于儒略历日期。 1700年（格里历没有闰日，但儒略历有）：\n格里历2月28日，合儒略历2月18日，或之前的日期：格里历日期减10日等于儒略历日期。\n格里历3月1日，合儒略历2月19日，或之后的日期：格里历日期减11日等于儒略历日期。 1701年——1799年：\n格里历日期减11日等于儒略历日期。 1800年（格里历没有闰日，但儒略历有）：\n格里历2月28日，合儒略历2月17日，或之前的日期：格里历日期减11日等于儒略历日期。\n格里历3月1日，合儒略历2月18日，或之后的日期：格里历日期减12日等于儒略历日期。 1801年——1899年：\n格里历日期减12日等于儒略历日期。 1900年（格里历没有闰日，但儒略历有）：\n格里历2月28日，合儒略历2月16日，或之前的日期：格里历日期减12日等于儒略历日期。\n格里历3月1日，合儒略历2月17日，或之后的日期：格里历日期减13日等于儒略历日期。 1901年——2099年：\n格里历日期减13日等于儒略历日期。 2100年（格里历没有闰日，但儒略历有）：\n格里历2月28日，合儒略历2月15日，或之前的日期：格里历日期减13日等于儒略历日期。\n格里历3月1日，合儒略历2月16日，或之后的日期：格里历日期减14日等于儒略历日期。  2. 儒略日 Julian Day  儒略日（Julian Day）\n儒略日是在儒略周期内以连续的日数计算时间的计时法，主要是天文学家在使用。\n 儒略日数（Julian Day Number，JDN）\n儒略日数的计算是从格林威治标准时间的中午开始，包含一个整天的时间，起点的时间（0日）回溯至儒略历的公元前4713年1月1日中午12点（在格里历是公元前4714年11月24日），这个日期是三种多年周期的共同起点，且是历史上最接近现代的一个起点。例如，2000年1月1日的UT12:00是儒略日2,451,545。\n 儒略日期（Julian date，JD）\n儒略日期是以格林威治标准时中午12:00的儒略日加上那一天的瞬时时间的分数。儒略日期是儒略日添加小数部分所表示的儒略日数。例如，2013年1月1日00:30:00（UT）是儒略日期2,456,293.520833。\n 儒略周期（Julian Period）\n儒略周期是开始于公元前4713年，长达7980年的纪年法，被用于历史上各种不同历法的日期转换。公元2018年是儒略周期的6731年，下一个儒略周期将开始于公元3268年。\n 儒略日起点\n儒略日的起点订在西元前4713年（天文学上记为 -4712年）1月1日格林威治时间平午（世界时12:00），即JD 0指定为UT时间B.C.4713年1月1日12:00到UC时间B.C.4713年1月2日12:00的24小时。每一天赋予了一个唯一的数字，顺数而下，如：1996年1月1日12:00:00的儒略日是2450084。这个日期是考虑了太阳、月亮的轨道运行周期，以及当时收税的间隔而订出来的。Joseph Scaliger定义儒略周期为7980年，是因28、19、15的最小公倍数为28×19×15=7980。其中：\n28年为一太阳周期（solar cycle），经过一太阳周期，则星期的日序与月的日序会重复。\n19年为一太阴周期，或称默冬章（Metonic cycle），因235朔望月=19回归年，经过一太阴周期则阴历月年的日序重复。\n15年为一小纪（indiction cycle），此为罗马皇帝君士坦丁一世所颁，每15年评定财产价值以供课税，成为古罗马用的一个纪元单位，\n故以7980年为一儒略周期，而所选的起点公元前4713年，则是这三个循环周期同时开始的最近年份。\n 简化儒略日（MJD）\n由于儒略日数字位数太多，国际天文学联合会于1973年采用简化儒略日（MJD），其定义为MJD = JD - 2400000.5。MJD相应的起点是1858年11月17日世界时0时。\n  　算法中主要用的是 儒略日期（Julian date，JD），后续简称为儒略日\n3. 儒略日和阳历日期（格里历、儒略历日期）的转换 3.1 阳历日期$(Y,M,D)$ $\\Rightarrow$ 儒略日$(JD)$  设$Y$为给定年份，$M$为月份，$D$为该月日期（可以带小数）。\n 若 $M \u0026gt; 2$，$Y$和$M$不变，\n 若 $M =1或2$，以$Y–1$代$Y$，以$M+12$代$M$，换句话说，如果日期在1月或2月，则被看作是在前一年的13月或14月。\n 对格里历有 ：$A = \\lfloor \\frac {Y}{100}\\rfloor$ $B = 2 - A + \\lfloor \\frac{A}{4}\\rfloor$\n 对儒略历，取 $B = 0$\n 要求的儒略日即为：$$JD = \\lfloor 365.25(Y+4716)\\rfloor+\\lfloor30.6001(M+1)\\rfloor+D+B-1524.5$$\n   此处作对30.6001取值的解释是为了确保小数在运算时的准确性，如30.6 * 5 应该等于153，但是很多计算机得出的结果是152.999 9998。\n另一种方式就是用306代替，最后再除以10取整\n // FloorDiv returns the integer floor of the fractional value (x / y). // // It uses integer math only, so is more efficient than using floating point // intermediate values. This function can be used in many places where INT() // appears in AA. As with built in integer division, it panics with y == 0. func FloorDiv(x, y int) (q int) { q = x / y if (x \u0026lt; 0) != (y \u0026lt; 0) \u0026amp;\u0026amp; x%y != 0 { q-- } return } // FloorDiv64 returns the integer floor of the fractional value (x / y). // // It uses integer math only, so is more efficient than using floating point // intermediate values. This function can be used in many places where INT() // appears in AA. As with built in integer division, it panics with y == 0. func FloorDiv64(x, y int64) (q int64) { q = x / y if (x \u0026lt; 0) != (y \u0026lt; 0) \u0026amp;\u0026amp; x%y != 0 { q-- } return }  // CalendarGregorianToJD converts a Gregorian year, month, and day of month // to Julian day. // // Negative years are valid, back to JD 0. The result is not valid for // dates before JD 0. // 格里历日期转儒略日 func CalendarGregorianToJD(y, m int, d float64) float64 { switch m { case 1, 2: y-- m += 12 } a := base.FloorDiv(y, 100) b := 2 - a + base.FloorDiv(a, 4) // (7.1) p. 61 return float64(base.FloorDiv64(36525*(int64(y+4716)), 100)) + float64(base.FloorDiv(306*(m+1), 10)+b) + d - 1524.5 } // CalendarJulianToJD converts a Julian year, month, and day of month to Julian day. // // Negative years are valid, back to JD 0. The result is not valid for // dates before JD 0. // 儒略历日期转儒略日 func CalendarJulianToJD(y, m int, d float64) float64 { switch m { case 1, 2: y-- m += 12 } return float64(base.FloorDiv64(36525*(int64(y+4716)), 100)) + float64(base.FloorDiv(306*(m+1), 10)) + d - 1524.5 }  3.2 儒略日$(JD)$ $\\Rightarrow$ 阳历日期$(y,m,d)$  将 $JD$ 加上 0.5，令$Z$为其整数部分，$F$ 为尾数（小数）部分。 若 $Z$ \u0026lt; 2299161，取 $A$ = $Z$;\n若 $Z$ 大于等于 2299161，计算 \\begin{align} α \u0026amp;=\\lfloor \\frac {Z-1867216.25}{36524.25}\\rfloor\\\\[2ex] A \u0026amp;=Z+1+α-\\lfloor \\frac α4\\rfloor \\end{align} 然后计算 \\begin{align} B \u0026amp;= A+1524\\\\[2ex] C \u0026amp;= \\lfloor \\frac {B-122.1}{365.25}\\rfloor\\\\[2ex] D \u0026amp;= \\lfloor 365.25C\\rfloor\\\\[2ex] E \u0026amp;= \\lfloor \\frac {B-D}{30.6001}\\rfloor\\\\[2ex] \\end{align} 该月日期（带小数部分）则为：$$d = B - D - \\lfloor 30.6001E\\rfloor + F$$ 月份 m 为： \\begin{cases} m = E – 1 ;\u0026amp; \\text {if $E$ \u0026lt; 14}\\\\[2ex] m = E – 13 ;\u0026amp; \\text {if $E$ $\\geq$ 14} \\end{cases} 年份为 y： \\begin{cases} y = C – 4716 ;\u0026amp; \\text {if $m$ \u0026gt; 2}\\\\[2ex] y = C – 4715 ;\u0026amp; \\text {if $m$ $\\leq$ 2} \\end{cases}  // JDToCalendar returns the calendar date for the given jd. // // Note that this function returns a date in either the Julian or Gregorian // Calendar, as appropriate. // 儒略日转公历日期 // 如果儒略日对应的格里历时间点在1582-10-15 12点之前，则转为儒略历日期 // 如果儒略日对应的格里历时间点在1582-10-15 12点之后，则转为格里历日期 func JDToCalendar(jd float64) (year, month int, day float64) { zf, f := math.Modf(jd + .5) z := int64(zf) a := z // if z \u0026gt;= 2299151 { // typo 应该是2299161对应于现实格里历起始日1582-10-15中午12点 if z \u0026gt;= 2299161 { // typo 应该是2299161对应于现实格里历起始日1582-10-15中午12点 α := base.FloorDiv64(z*100-186721625, 3652425) a = z + 1 + α - base.FloorDiv64(α, 4) } b := a + 1524 c := base.FloorDiv64(b*100-12210, 36525) d := base.FloorDiv64(36525*c, 100) e := int(base.FloorDiv64((b-d)*1e4, 306001)) // compute return values day = float64(int(b-d)-base.FloorDiv(306001*e, 1e4)) + f switch e { default: month = e - 1 case 14, 15: month = e - 13 } switch month { default: year = int(c) - 4716 case 1, 2: year = int(c) - 4715 } return } // jdToCalendarGregorian returns the Gregorian calendar date for the given jd. // // Note that it returns a Gregorian date even for dates before the start of // the Gregorian calendar. The function is useful when working with Go // time.Time values because they are always based on the Gregorian calendar. // 始终转为格里历，忽略儒略历转格里历被扣除的那10天，即把1582-10-15 12点之前的日期也当成格里历算 func jdToCalendarGregorian(jd float64) (year, month int, day float64) { zf, f := math.Modf(jd + .5) z := int64(zf) α := base.FloorDiv64(z*100-186721625, 3652425) a := z + 1 + α - base.FloorDiv64(α, 4) b := a + 1524 c := base.FloorDiv64(b*100-12210, 36525) d := base.FloorDiv64(36525*c, 100) e := int(base.FloorDiv64((b-d)*1e4, 306001)) // compute return values day = float64(int(b-d)-base.FloorDiv(306001*e, 1e4)) + f switch e { default: month = e - 1 case 14, 15: month = e - 13 } switch month { default: year = int(c) - 4716 case 1, 2: year = int(c) - 4715 } return } // JDToTime takes a JD and returns a Go time.Time value. // 儒略历转为格里历日期对应的 Go Time 类型 func JDToTime(jd float64) time.Time { // time.Time is always Gregorian y, m, d := jdToCalendarGregorian(jd) t := time.Date(y, time.Month(m), 0, 0, 0, 0, 0, time.UTC) return t.Add(time.Duration(d * 24 * float64(time.Hour))) } // TimeToJD takes a Go time.Time and returns a JD as float64. // // Any time zone offset in the time.Time is ignored and the time is // treated as UTC. // Go Time 类型转为儒略日（默认日期为格里历） func TimeToJD(t time.Time) float64 { ut := t.UTC() y, m, _ := ut.Date() d := ut.Sub(time.Date(y, m, 0, 0, 0, 0, 0, time.UTC)) // time.Time is always Gregorian return CalendarGregorianToJD(y, int(m), float64(d)/float64(24*time.Hour)) }  3.3 儒略日$(JD)$ $\\Rightarrow$ 星期几 　因为儒略日0.0(-4712-1-1 12:00) 是星期一，往后7天一循环就能得出星期几了\n计算该日0时的儒略日，加上1.5，再除以7，所得余数将指示出星期几：\n若余数为0，则为星期日，1为星期一，2为星期二，3为星期三，4为星期四，5为星期五，6为星期六。\n儒略历到格里高利历的换算并不影响星期。 因而，在1582年10月4日星期四接下来的一天便是10月15日星期五。\n// DayOfWeek determines the day of the week for a given JD. // // The value returned is an integer in the range 0 to 6, where 0 represents // Sunday. This is the same convention followed in the time package of the // Go standard library. // 儒略日0.0为-4712-1-1 12:00 星期一，往后7天一循环就能得出星期几了 func DayOfWeek(jd float64) int { return int(jd+1.5) % 7 }  3.4 日阳历日期$(Y,M,D)$ $\\Rightarrow$ 年内序数日$(N)$ 　年内的序数日$N$可由以下公式得出：$$N = \\lfloor \\frac {275M}{9}\\rfloor - K\\lfloor \\frac {M+9}{12}\\rfloor + D - 30 $$ 此处$M$为月份，$D$为该月日期，闰年$K = 1$，平年$K = 2$\n$N$ 取整数，自1月1日开始取值1，直至12月31日取值365（或闰年取值366）。\n　如何推导出这个公式？\n乍一看挺没头绪的，我们先来看一个数列$$ a_m = \\lfloor \\frac {5(m+1)}{9}\\rfloor, (m=0,1,2,\\dots,12)$$\n\\begin{array}{c|ccl} m \u0026amp; a_m \u0026amp; a_m - a_{m-1} \u0026amp; 当月天数 \\\\\n\\hline 0 \u0026amp; 0 \u0026amp; - \u0026amp; - \\\\\n1 \u0026amp; 1 \u0026amp; 1 \u0026amp; 31 \\\\\n2 \u0026amp; 1 \u0026amp; 0 \u0026amp; 30(看做30) \\\\\n3 \u0026amp; 2 \u0026amp; 1 \u0026amp; 31 \\\\\n4 \u0026amp; 2 \u0026amp; 0 \u0026amp; 30 \\\\\n5 \u0026amp; 3 \u0026amp; 1 \u0026amp; 31 \\\\\n6 \u0026amp; 3 \u0026amp; 0 \u0026amp; 30 \\\\\n7 \u0026amp; 4 \u0026amp; 1 \u0026amp; 31 \\\\\n8 \u0026amp; 5 \u0026amp; 1 \u0026amp; 31 \\\\\n9 \u0026amp; 5 \u0026amp; 0 \u0026amp; 30 \\\\\n10 \u0026amp; 6 \u0026amp; 1 \u0026amp; 31 \\\\\n11 \u0026amp; 6 \u0026amp; 0 \u0026amp; 30 \\\\\n12 \u0026amp; 7 \u0026amp; 1 \u0026amp; 31 \\end{array}\n　如果把$m$看成是月份，并且暂时把二月看成是30天，那么第二列恰好是$当月天数-30$，所以我们就可以用以下公式来表示每个月的天数。 $$D_m = 30 + a_m - a_{m-1}$$\n　所以从1月到m月的总天数： \\begin{align} S_m = \u0026amp; D_1+D_2+,\\dots,+D_m\\\\[2ex] = \u0026amp; 30 + a_m - a_{m-1} + \\\\[2ex] \u0026amp; 30 + a_{m-1} - a_{m-2} + \\\\[2ex] \u0026amp; \\cdots \\\\[2ex] \u0026amp; 30 + a_2 - a_1 + \\\\[2ex] \u0026amp; 30 + a_1 - a_0 \\\\[2ex] = \u0026amp; 30m + a_m - a_0\\\\[2ex] = \u0026amp; 30m + \\lfloor \\frac {5(m+1)}{9}\\rfloor \\end{align}\n　由于上述表达式只有在2月等于30天的情况下才成立，所以当$m\\geq 2$时还要根据平年、闰年分别减去相应的天数2，1，得到1月到$m$月的总天数和为： \\begin{align} S_m=30m + \\lfloor \\frac {5(m+1)}{9}\\rfloor - \\lfloor \\frac {m+10}{12}\\rfloor k,\\ 其中 \\end{align} \\begin{cases} k = 1 , \\ 闰年\\\\[2ex] k = 2 , \\ 平年 \\end{cases}\n　所以$M$月$D$日的年内序数$N$为： \\begin{align} N \u0026amp;= S_{M-1} + D\\\\[2ex] \u0026amp;= 30(M-1) + \\lfloor \\frac {5M}{9}\\rfloor - \\lfloor \\frac {M+9}{12}\\rfloor k + D\\\\[2ex] \u0026amp;= \\lfloor \\frac {275M}{9}\\rfloor - \\lfloor \\frac {M+9}{12}\\rfloor k -30 + D\\\\[2ex] \\end{align}\n// DayOfYearGregorian computes the day number within the year of the Gregorian // calendar. // 格里历年内序数 func DayOfYearGregorian(y, m, d int) int { return DayOfYear(y, m, d, LeapYearGregorian(y)) } // DayOfYearJulian computes the day number within the year of the Julian // calendar. // 儒略历年内序数 func DayOfYearJulian(y, m, d int) int { return DayOfYear(y, m, d, LeapYearJulian(y)) } // DayOfYear computes the day number within the year. // // This form of the function is not specific to the Julian or Gregorian // calendar, but you must tell it whether the year is a leap year. // 输入闰年标识，计算年内序数 func DayOfYear(y, m, d int, leap bool) int { k := 2 if leap { k-- } return wholeMonths(m, k) + d } // m月之前的所有月份天数之和 func wholeMonths(m, k int) int { return 275*m/9 - k*((m+9)/12) - 30 }  3.5 年内序数日$(N)$ $\\Rightarrow$ 阳历日期$(M,D)$ // DayOfYearToCalendar returns the calendar month and day for a given // day of year and leap year status. // 年内序数求对应的日期 func DayOfYearToCalendar(n int, leap bool) (m, d int) { k := 2 if leap { k-- } if n \u0026lt; 32 { m = 1 } else { m = (900*(k+n) + 98*275) / 27500 } return m, n - wholeMonths(m, k) } ","date":1526434071,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1526434071,"objectID":"6e0d0dd99ec83aca3e6fd1692e09cf2b","permalink":"https://mooncaker816.github.io/2018/05/16/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%955/","publishdate":"2018-05-16T09:27:51+08:00","relpermalink":"/2018/05/16/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%955/","section":"post","summary":"第七章 儒略日 Julian Day","tags":["天文算法"],"title":"天文算法5","type":"post"},{"authors":null,"categories":["golang","算法"],"content":"第六章 排序 Sort Go 标准库已经够了，所以就略了\n","date":1526376889,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1526376889,"objectID":"c23f96ea26ea33478d6e7b251864cb46","permalink":"https://mooncaker816.github.io/2018/05/15/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%954/","publishdate":"2018-05-15T17:34:49+08:00","relpermalink":"/2018/05/15/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%954/","section":"post","summary":"第六章 排序 Sort","tags":["天文算法"],"title":"天文算法4","type":"post"},{"authors":null,"categories":["golang","算法"],"content":"第五章 迭代 Iteration 1. 什么是迭代算法  　迭代法（英语：Iterative Method），在计算数学中，迭代是通过从一个初始估计出发寻找一系列近似解来解决问题（一般是解方程或者方程组）的数学过程，为实现这一过程所使用的方法统称。\n　跟迭代法相对应的是直接法（或者称为一次解法），即一次性解决问题，例如通过开方解决方程 $ x^{2}=4$。一般如果可能，直接解法总是优先考虑的。但当遇到复杂问题时，特别是在未知量很多，方程为非线性时，我们无法找到直接解法（例如五次以及更高次的代数方程没有解析解，参见阿贝尔定理），这时候或许可以通过迭代法寻求方程（组）的近似解。\n　最常见的迭代法是牛顿法。其他还包括最速下降法、共轭迭代法、变尺度迭代法、最小二乘法、线性规划、非线性规划、单纯型法、惩罚函数法、斜率投影法、遗传算法、模拟退火等等。\n 　以上是 wiki 上对迭代算法的描述，可以看出，迭代法的主要用途就是求解近似根，这一点我们再第三章插值函数逆推插值点的介绍中已经得到了运用。下面我们主要介绍牛顿迭代法和二分迭代法。\n2. 牛顿迭代法  　首先，选择一个接近函数$f(x)$零点的 $x_0$，计算相应的 $f(x_0)$和切线斜率 $f\u0026rsquo;(x_0)$。然后我们计算穿过点 $(x_0,f(x_0))$并且斜率为 $f\u0026rsquo;(x_0)$的直线和 $x$轴的交点的 $x$坐标，也就是求如下方程的解： $$0=(x-x_0)f\u0026rsquo;(x_0)+f(x_0)$$ 我们将新求得的点的$x$坐标命名为$x_1$，通常$x_1$会比$x_0$更接近方程$f(x)=0$的解。因此我们现在可以利用$x_1$开始下一轮迭代。迭代公式可化简为如下所示： $$x_{n+1}=x_n - \\frac {f(x_n)}{f\u0026rsquo;(x_n)}$$ 已经证明，如果$f\u0026rsquo;$是连续的，并且待求的零点$x$是孤立的，那么在零点$x$周围存在一个区域，只要初始值$x_0$位于这个邻近区域内，那么牛顿法必定收敛。\n　并且，如果$f\u0026rsquo;(x)\\neq 0$，那么牛顿法将具有平方收敛的性能。粗略的说，这意味着每迭代一次，牛顿法结果的有效数字将增加一倍。\n // BetterFunc is a convience type definition. type BetterFunc func(float64) float64  // DecimalPlaces iterates to a fixed number of decimal places. // // Inputs are an improvement function, a starting value, the number of // decimal places desired in the result, and an iteration limit. // better 为迭代公式，start 为起始点，places 为视作迭代结束的最大精度值的小数点位数, // maxIterations 为迭代最大次数 func DecimalPlaces(better BetterFunc, start float64, places, maxIterations int) (float64, error) { d := math.Pow(10, float64(-places)) for i := 0; i \u0026lt; maxIterations; i++ { n := better(start) if math.Abs(n-start) \u0026lt; d { return n, nil } start = n } return 0, errors.New(\u0026quot;Maximum iterations reached\u0026quot;) } // FullPrecison iterates to (nearly) the full precision of a float64. // // To allow for a little bit of floating point jitter, FullPrecision iterates // to 15 significant figures, which is the maximum number of full significant // figures representable in a float64, but still a couple of bits shy of the // full representable precision. // 和 DecimalPlaces 功能类似，只不过默认迭代结束的标志为小于float64的最大精度15 func FullPrecision(better BetterFunc, start float64, maxIterations int) (float64, error) { for i := 0; i \u0026lt; maxIterations; i++ { n := better(start) if math.Abs((n-start)/n) \u0026lt; 1e-15 { return n, nil } start = n } return 0, errors.New(\u0026quot;Maximum iterations reached\u0026quot;) }  3. 二分迭代法 　二分迭代法，顾名思义，就是计算中点的函数值，并与当前低值和高值比较，\n 若与低值同号，则把该值作为新的低值，继续迭代\n 若与高值同号，则把该值作为新的高值，继续迭代\n  // RootFunc is a convience type definition. type RootFunc func(float64) float64  // BinaryRoot finds a root between given bounds by binary search. // // Inputs are a function on x and the bounds on x. A root must exist between // the given bounds, otherwise the result is not meaningful. // 因为float64 的小数bit位最多为52位(10进制为15位有效数字)， // 即每次迭代理论上能提升一位精度，所以最多52次就应该跳出迭代 func BinaryRoot(f RootFunc, lower, upper float64) float64 { yLower := f(lower) var mid float64 for j := 0; j \u0026lt; 52; j++ { mid = (lower + upper) / 2 yMid := f(mid) if yMid == 0 { break } if math.Signbit(yLower) == math.Signbit(yMid) { // 与低值同号，替代低值 lower = mid yLower = yMid } else { upper = mid //与高值同号，替换高值 } } return mid } ","date":1526363316,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1526363316,"objectID":"b020e3839ddf572dfee7a79e354c84c2","permalink":"https://mooncaker816.github.io/2018/05/15/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%953/","publishdate":"2018-05-15T13:48:36+08:00","relpermalink":"/2018/05/15/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%953/","section":"post","summary":"第五章 迭代 Iteration","tags":["天文算法"],"title":"天文算法3","type":"post"},{"authors":null,"categories":["golang","算法"],"content":"第四章 拟合 Curve Fitting 1. 什么是拟合  曲线拟合(Curve Fitting)的数学定义是指用连续曲线近似地刻画或比拟平面上一组离散点所表示的坐标之间的函数关系，是一种用解析表达式逼近离散数据的方法。曲线拟合通俗的说法就是“拉曲线”，也就是将现有数据透过数学方法来代入一条数学方程式的表示方法。科学和工程遇到的很多问题，往往只能通过诸如采样、实验等方法获得若干离散的数据，根据这些数据，如果能够找到一个连续的函数（也就是曲线）或者更加密集的离散方程，使得实验数据与方程的曲线能够在最大程度上近似吻合，就可以根据曲线方程对数据进行数学计算，对实验结果进行理论分析，甚至对某些不具备测量条件的位置的结果进行估算。\n 2. 最小二乘拟合 　考虑 N 个数据点，它们的坐标是$(x_1,y_1),(x_2,y_2),\\dots,(x_n,y_n)$ 假设这些值中的 X 是严格的精确值，Y 的值是测量值(含有一些误差)。 对于一个给定的 X，如$x_1$，对应的值$y_1$与曲线 C 上对应的 Y 值将存在一个差值$d_1$，我们称这个差值为偏差、误差或残差，它可能是正、负或零。类似的，$x_2,\\dots,x_n$,对应的差值为 $d_2,\\dots,d_n$。\n　我们用 $d_1^2+d_2^2+\\cdots+d_n^2$ 作为衡量曲线 C 拟合的“最佳”程度，这个值越小越好，越大则越不好。因此，我们做以下定义：任何一种类型的曲线，它们都有一个共同的特性， 当 $$\\sum_{i=1}^n d_i^2$$最小时，称为最佳拟合曲线。\n　一条曲线具有这一特性时，称之为“最小二乘拟合”， 这样的曲线称为“最小二乘曲线”。\n2.1 线性拟合 　 线性方程\n假设拟合的曲线为直线$y=ax+b$,则最小二乘差方和为： $$\\sum_{i=1}^n[y_i-(ax_i+b)]^2$$ 所以问题转化为求解上述关于a,b的二元函数的最小值\n对上式中a求偏导\n\\begin{multline} \\shoveleft \\begin{aligned} \\frac \\partial {\\partial a}\\sum_{i=1}^n[y_i-(ax_i+b)]^2 \u0026amp;= -2\\sum_{i=1}^n({x_iy_i}-a{x_i^2}-b {x_i})\\\\[2ex] \u0026amp; =-2\\sum_{i=1}^n{x_i}[{y_i}-(a{x_i}+b)]\\\\[2ex] \\end{aligned} \\end{multline}\n\\begin{multline} \\shoveleft \\text {由极值的必要条件可知，}\\\\[2ex] \\shoveleft -2\\sum_{i=1}^n{x_i}[{y_i}-(a{x_i}+b)] = 0\\\\[2ex] \\shoveleft \\therefore \\sum_{i=1}^n{x_iy_i}-a\\sum_{i=1}^n{x_i^2}-b\\sum_{i=1}^n{x_i}=0 \\end{multline}\n同理对b求偏导可得： \\begin{align} \\sum_{i=1}^n{y_i}-a\\sum_{i=1}^n{x_i}-bn=0 \\end{align}\n求解关于a,b 的二元一次方程组， \\begin{cases} \\sum\\limits_{i=1}^n{x_iy_i}-a\\sum\\limits_{i=1}^n{x_i^2}-b\\sum\\limits_{i=1}^n{x_i}=0 \\\\[2ex] \\sum\\limits_{i=1}^n{y_i}-a\\sum\\limits_{i=1}^n{x_i}-bn=0 \\end{cases}\n得 \\begin{align} a \u0026amp;= \\frac {\\sum\\limits_{i=1}^n{x_i}\\sum\\limits_{i=1}^n{y_i}-n\\sum\\limits_{i=1}^n{x_iy_i}}{ (\\sum\\limits_{i=1}^n{x_i})^2-n\\sum\\limits_{i=1}^n{x_i}^2}\\\\[2ex] b \u0026amp;= \\frac {\\sum\\limits_{i=1}^n{x_i}\\sum\\limits_{i=1}^n{x_iy_i}-\\sum\\limits_{i=1}^n{y_i} \\sum\\limits_{i=1}^n{x_i}^2}{(\\sum\\limits_{i=1}^n{x_i})^2-n\\sum\\limits_{i=1}^n{x_i}^2} \\end{align}\n 皮尔逊相关系数r\n定义\n由定义可知， \\begin{align} r=\\frac {\\sum\\limits_{i=1}^n(x_i-\\bar x)(y_i-\\bar y)}{\\sqrt {\\sum\\limits_{i=1}^n(x_i-\\bar x)^2}\\sqrt {\\sum\\limits_{i=1}^n(y_i-\\bar y)^2}}, \\\\[2ex] \\text {其中 } \\bar x=\\frac 1n\\sum_{i=1}^nx_i,\\bar y=\\frac 1n\\sum_{i=1}^ny_i \\end{align}\n\\begin{multline} \\shoveleft \\begin{aligned} 化简 \\ \\ \u0026amp; \\sum\\limits_{i=1}^n(x_i-\\bar x)(y_i-\\bar y)\\\\[2ex] = \u0026amp; \\sum\\limits_{i=1}^n(x_iy_i-x_i\\bar y-\\bar xy_i+\\bar x\\bar y)\\\\[2ex] = \u0026amp; \\sum\\limits_{i=1}^nx_iy_i - \\sum\\limits_{i=1}^nx_i\\bar y - \\sum\\limits_{i=1}^n\\bar xy_i+\\sum\\limits_{i=1}^n\\bar x\\bar y\\\\[2ex] = \u0026amp; \\sum\\limits_{i=1}^nx_iy_i - \\frac 1n\\sum\\limits_{i=1}^ny_i\\sum\\limits_{i=1}^nx_i - \\frac 1n\\sum\\limits_{i=1}^nx_i\\sum\\limits_{i=1}^ny_i + \\frac 1n\\sum\\limits_{i=1}^nx_i\\sum\\limits_{i=1}^ny_i\\\\[2ex] = \u0026amp; \\sum\\limits_{i=1}^nx_iy_i - \\frac 1n\\sum\\limits_{i=1}^ny_i\\sum\\limits_{i=1}^nx_i\\\\[2ex] 化简 \\ \\ \u0026amp; \\sum\\limits_{i=1}^n(x_i-\\bar x)^2\\\\[2ex] = \u0026amp; \\sum\\limits_{i=1}^n(x_i^2-2x_i\\bar x+\\bar x^2)\\\\[2ex] = \u0026amp; \\sum\\limits_{i=1}^nx_i^2 - 2\\bar x\\sum\\limits_{i=1}^nx_i + n\\bar x^2\\\\[2ex] = \u0026amp; \\sum\\limits_{i=1}^nx_i^2 - 2n\\bar x^2 + n\\bar x^2\\\\[2ex] = \u0026amp; \\sum\\limits_{i=1}^nx_i^2 - n\\bar x^2\\\\[2ex] = \u0026amp; \\sum\\limits_{i=1}^nx_i^2 - \\frac 1n(\\sum\\limits_{i=1}^nx_i)^2\\\\[2ex] 同上 \\ \\ \u0026amp; \\sum\\limits_{i=1}^n(y_i-\\bar y)^2\\\\[2ex] = \u0026amp; \\sum\\limits_{i=1}^ny_i^2 - \\frac 1n(\\sum\\limits_{i=1}^ny_i)^2\\\\[2ex] \\end{aligned} \\end{multline} \\begin{multline} \\shoveleft \\begin{aligned} \\therefore \\ \\ r\u0026amp;=\\frac {\\sum\\limits_{i=1}^nx_iy_i - \\frac 1n\\sum\\limits_{i=1}^ny_i\\sum\\limits_{i=1}^nx_i}{\\sqrt{\\sum\\limits_{i=1}^nx_i^2 - \\frac 1n(\\sum\\limits_{i=1}^nx_i)^2}\\sqrt{\\sum\\limits_{i=1}^ny_i^2 - \\frac 1n(\\sum\\limits_{i=1}^ny_i)^2}}\\\\[2ex] \u0026amp; =\\frac {n\\sum\\limits_{i=1}^nx_iy_i - \\sum\\limits_{i=1}^ny_i\\sum\\limits_{i=1}^nx_i}{\\sqrt{n\\sum\\limits_{i=1}^nx_i^2 - (\\sum\\limits_{i=1}^nx_i)^2}\\sqrt{n\\sum\\limits_{i=1}^ny_i^2 - (\\sum\\limits_{i=1}^ny_i)^2}} \\end{aligned} \\end{multline}\n　这个系数介于+1 到-1 之间。如果值为+1 或-1，说明 x 和 y 之间有完全的线性关系，所有的点(x,y)精确的在同一条直线上。如果 r = +1，y 随 x 单调递增，如果 r = -1，y 随 x 单调递减。\n 代码\n　到这里我们就已经推导出求解线性方程和相关系数的公式，再结合代码看看\n// Linear fits a line to sample data. // // Argument p is a list of data points. Results a and b are coefficients // of the best fit line y = ax + b. // 求解线性拟合直线 // sx = ∑x sy = ∑y sxy = ∑xy sx2 = ∑x^2 func Linear(p []struct{ X, Y float64 }) (a, b float64) { var sx, sy, sx2, sxy float64 for i := range p { x := p[i].X y := p[i].Y sx += x sy += y sx2 += x * x sxy += x * y } n := float64(len(p)) d := n*sx2 - sx*sx // (4.2) p. 36 a = (n*sxy - sx*sy) / d b = (sy*sx2 - sx*sxy) / d return } // CorrelationCoefficient returns a correlation coefficient for sample data. // 求解相关系数 r func CorrelationCoefficient(p []struct{ X, Y float64 }) float64 { var sx, sy, sx2, sy2, sxy float64 for i := range p { x := p[i].X y := p[i].Y sx += x sy += y sx2 += x * x sy2 += y * y sxy += x * y } n := float64(len(p)) // (4.3) p. 38 return (n*sxy - sx*sy) / (math.Sqrt(n*sx2-sx*sx) * math.Sqrt(n*sy2-sy*sy)) }   2.2 二次曲线拟合  二次方程$y = ax^2 + bx + c$\n　假设我们希望画一条逼近 N 个点的最佳二次曲线：$y = ax^2 + bx + c$ 这是一个纵轴的抛物线。同一次直线类似，差方和为$$\\sum_{i=1}^n[y_i-(ax_i^2+bx_i+c)]^2$$ 依次对上式中的a,b,c求偏导，得 \\begin{align} \\sum_{i=1}^n(-2x_i^2y_i+2ax_i^4+2bx_i^3+2cx_i^2) = 0\\\\[2ex] \\sum_{i=1}^n(-2x_iy_i+2ax_i^3+2bx_i^2+2cx_i) = 0\\\\[2ex] \\sum_{i=1}^n(-2y_i+2ax_i^2+2bx_i+2c) = 0\\\\[2ex] \\end{align} \\begin{multline} \\begin{aligned} \\therefore \u0026amp; \\sum_{i=1}^nx_i^2y_i=\\sum_{i=1}^nax_i^4+\\sum_{i=1}^nbx_i^3+\\sum_{i=1}^ncx_i^2\\\\[2ex] \u0026amp; \\sum_{i=1}^nx_iy_i=\\sum_{i=1}^nax_i^3+\\sum_{i=1}^nbx_i^2+\\sum_{i=1}^ncx_i\\\\[2ex] \u0026amp; \\sum_{i=1}^ny_i=\\sum_{i=1}^nax_i^2+\\sum_{i=1}^nbx_i+nc\\\\[2ex] \\end{aligned} \\end{multline}\n求解以下三元一次方程组 \\begin{cases} \\sum\\limits_{i=1}^nx_i^2y_i=\\sum\\limits_{i=1}^nax_i^4+\\sum\\limits_{i=1}^nbx_i^3+\\sum\\limits_{i=1}^ncx_i^2\\\\[2ex] \\sum\\limits_{i=1}^nx_iy_i=\\sum\\limits_{i=1}^nax_i^3+\\sum\\limits_{i=1}^nbx_i^2+\\sum\\limits_{i=1}^ncx_i\\\\[2ex] \\sum\\limits_{i=1}^ny_i=\\sum\\limits_{i=1}^nax_i^2+\\sum\\limits_{i=1}^nbx_i+nc\\\\[2ex] \\end{cases}\n得 \\begin{multline} \\shoveleft \\begin{aligned} a \u0026amp;= \\frac {NQV+PRT+PQU-Q^2T-P^2V-NRU}{D}\\\\[2ex] b \u0026amp;= \\frac {NSU+PQV+QRT-Q^2U-PST-NRV}{D}\\\\[2ex] c \u0026amp;= \\frac {QST+QRU+PRV-Q^2V-PSU-R^2T}{D}\\\\[2ex] \\end{aligned} \\end{multline}\n\\begin{multline} \\shoveleft \\begin{aligned} 其中\\ \u0026amp;P =\\sum\\limits_{i=1}^nx_i,\\ Q=\\sum\\limits_{i=1}^nx_i^2,\\ R=\\sum\\limits_{i=1}^nx_i^3,\\ S=\\sum\\limits_{i=1}^nx_i^4,\\\\[2ex] \u0026amp;T=\\sum\\limits_{i=1}^ny_i,\\ U=\\sum\\limits_{i=1}^nx_iy_i,\\ V=\\sum\\limits_{i=1}^nx_i^2y_i,\\\\[2ex] \u0026amp;D = NQS+2PQR-Q^3-P^2S-NR^2 \\end{aligned} \\end{multline}\n　至此我们的程序就能很方便的通过上述公式，对这 N 个点进行一次完整的遍历，计算上述 P,Q,R,S,T,U,V,D,即可求得拟合曲线方程。\n 代码\n// Quadratic fits y = ax² + bx + c to sample data. // // Argument p is a list of data points. Results a, b, and c are coefficients // of the best fit quadratic y = ax² + bx + c. // 求解二次拟合曲线系数 func Quadratic(p []struct{ X, Y float64 }) (a, b, c float64) { var P, Q, R, S, T, U, V float64 for i := range p { x := p[i].X y := p[i].Y x2 := x * x P += x Q += x2 R += x * x2 S += x2 * x2 T += y U += x * y V += x2 * y } N := float64(len(p)) // (4.5) p. 43 D := N*Q*S + 2*P*Q*R - Q*Q*Q - P*P*S - N*R*R // (4.6) p. 43 a = (N*Q*V + P*R*T + P*Q*U - Q*Q*T - P*P*V - N*R*U) / D b = (N*S*U + P*Q*V + Q*R*T - Q*Q*U - P*S*T - N*R*V) / D c = (Q*S*T + Q*R*U + P*R*V - Q*Q*V - P*S*U - R*R*T) / D return }  一般曲线拟合（多重线回归）\n　最佳线性拟合的原理可以被扩展到其它函数，这个函数可以含有超过两个未知的线性系数。 让我们考虑三个函数的线性组合的情况。 假设我们已知：$$y = af_0(x) + bf_1(x) + cf_2(x)$$ 式中$f_0$、$f_1$ 和 $f_2$ 是三个关于 x 的已知函数，但系数 a、 b 和 c 是未知的。此外，假设已知 3 个 x 对应的 y 值。那么 系数 a、b、c 可按如下得到。 求和计算： \\begin{align} M \u0026amp;= \\sum f_0^2 \u0026amp;U \u0026amp;= \\sum yf_0\\\\[2ex] P \u0026amp;= \\sum f_0f_1 \u0026amp;V \u0026amp;= \\sum yf_1\\\\[2ex] Q \u0026amp;= \\sum f_0f_2 \u0026amp;W \u0026amp;= \\sum yf_2\\\\[2ex] R \u0026amp;= \\sum f_1^2 \\\\[2ex] S \u0026amp;= \\sum f_1f_2 \\\\[2ex] T \u0026amp;= \\sum f_2^2 \\\\[2ex] \\end{align} $$D = MRT+2PQS-MS^2-RQ^2-TP^2$$ 那么： \\begin{align} a \u0026amp;= \\frac {U(RT-S^2)+V(QS-PT)+W(PS-QR)}{D}\\\\[2ex] b \u0026amp;= \\frac {U(SQ-PT)+V(MT-Q^2)+W(PQ-MS)}{D}\\\\[2ex] c \u0026amp;= \\frac {U(PS-RQ)+V(PQ-MS)+W(MR-P^2)}{D} \\end{align} 另一种特殊情况，考虑 y=af(x)，只有一个未知系数。 我们容易得到： $$a = \\frac {\\sum yf}{\\sum f^2}$$\n 代码\n// Func3 implements multiple linear regression for a linear combination // of three functions. // // Given sample data and three functions in x, Func3 returns coefficients // a, b, and c fitting y = aƒ₀(x) + bƒ₁(x) + cƒ₂(x) to sample data. // 多重线性回归 func Func3(p []struct{ X, Y float64 }, f0, f1, f2 func(float64) float64) (a, b, c float64) { var M, P, Q, R, S, T, U, V, W float64 for i := range p { x := p[i].X y := p[i].Y y0 := f0(x) y1 := f1(x) y2 := f2(x) M += y0 * y0 P += y0 * y1 Q += y0 * y2 R += y1 * y1 S += y1 * y2 T += y2 * y2 U += y * y0 V += y * y1 W += y * y2 } // (4.7) p. 44 D := M*R*T + 2*P*Q*S - M*S*S - R*Q*Q - T*P*P a = (U*(R*T-S*S) + V*(Q*S-P*T) + W*(P*S-Q*R)) / D b = (U*(S*Q-P*T) + V*(M*T-Q*Q) + W*(P*Q-M*S)) / D c = (U*(P*S-R*Q) + V*(P*Q-M*S) + W*(M*R-P*P)) / D return } // Func1 fits a linear multiple of a function to sample data. // // Given sample data and a function in x, Func1 returns coefficient // a fitting y = aƒ(x). func Func1(p []struct{ X, Y float64 }, f func(float64) float64) float64 { var syf, sf2 float64 // (4.8) p. 45 for i := range p { f := f(p[i].X) y := p[i].Y syf += y * f sf2 += f * f } return syf / sf2 }  ","date":1526211494,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1526211494,"objectID":"8f035875690ebe41a75afcb0cf2c8813","permalink":"https://mooncaker816.github.io/2018/05/13/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%952/","publishdate":"2018-05-13T19:38:14+08:00","relpermalink":"/2018/05/13/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%952/","section":"post","summary":"第四章 拟合 Curve Fitting","tags":["天文算法"],"title":"天文算法2","type":"post"},{"authors":null,"categories":["golang","算法"],"content":"①背景 计算精确的农历节气和日月合朔时间点，需要使用天文算法来实现。《Astronomical Algorithms》正是这么一本不那么让人望而生畏的介绍天文算法的书籍，国内比较出名的寿星万年历亦是基于此书中的算法。\n作为一名 Gopher 本想自造轮子来实现，但是万能的 Github 上已有前人身先士卒，直接上地址meeus，该库基本上完整的实现了Astronomical Algorithms中的算法，而且每一章节对应一个 package，浏览起来不会让人感觉没有头绪。\n好了，话不多说，接下来就结合书和代码来学习。\n②第一章Hints and Tips 略\n③第二章 About accuracy 略\n④第三章 Interpolation 插值  数学的数值分析领域中，内插或称插值（英语：interpolation)是一种通过已知的、离散的数据点，在范围内推求新数据点的过程或方法。求解科学和工程的问题时，通常有许多数据点借由采样、实验等方法获得，这些数据可能代表了有限个数值函数，其中自变量的值。\n 本章主要介绍了低阶等距节点牛顿插值和拉格朗日插值的应用。\n1. 牛顿插值 牛顿多项式\n差分\n2. 三点等距二阶差商的牛顿插值 2.1 插值公式 二阶牛顿插值多项式为: $N(x) = [y_0] + [y_0,y_1](x-x_0) + [y_0,y_1,y_2](x-x_0)(x-x_1)$，如下图 假设有三点$(x_0,y_0),(x_1,y_1),(x_2,y_2),x_0,x_1,x_2$等距(单位长度1) ,\n且$n$ 为插值因子,$x$距离$x_1$最近 \\begin{align} n\u0026amp;=(x-x_1)/单位长度\\\\\n\u0026amp;=x-x1 \\end{align}\n令 $a=y_1-y_0, b=y_2-y_1,c=b-a=y_0+y_2-2y_1$ 则有： \\begin{align} x-x_0 \u0026amp;= x-x_1 + 1\\\\\n\u0026amp;= n + 1 \\end{align} \\begin{align} f(x) \u0026amp;= y_0 + a(x-x_0)+(c/(x_2-x_0))(x-x_0)(x-x_1)\\\\\n\u0026amp;= y_0 + a(n+1) + 0.5c(n+1)n\\\\\n\u0026amp;= y_1-a + an + a + 0.5n(cn+c)\\\\\n\u0026amp;= y_1 + 0.5n(cn+b-a+2a)\\\\\n\u0026amp;= y_1 + 0.5n(cn+a+b)\\\\\n\\end{align}\n即为算法中三点插值的公式.\n 书中三点从1开始计数，公式为:$y_2+0.5n(cn+a+b)$\n 代码：\n// Len3 allows second difference interpolation. // 等距三点插值结构 type Len3 struct { x1, x3 float64 //x1,x3分别为起始点和终止点，无需给出x2，因为等距 y []float64 //y为x1,x2,x3对应的值的序列 a, b, c float64 //a=y2-y1, b=y3-y2, c=b-a=y3+y1-2y2 abSum, xSum, xDiff float64 //计数插值的中间变量 } // NewLen3 prepares a Len3 object from a table of three rows of x and y values. // // X values must be equally spaced, so only the first and last are supplied. // X1 must not equal x3. Y must be a slice of three y values. // 根据上述定义，创建三点插值结构 func NewLen3(x1, x3 float64, y []float64) (*Len3, error) { if len(y) != 3 { return nil, ErrorNot3 } if x3 == x1 { return nil, ErrorNoXRange } d := \u0026amp;Len3{ x1: x1, x3: x3, y: append([]float64{}, y...), } // differences. (3.1) p. 23 d.a = y[1] - y[0] d.b = y[2] - y[1] d.c = d.b - d.a // other intermediate values d.abSum = d.a + d.b d.xSum = x3 + x1 d.xDiff = x3 - x1 return d, nil }  考虑到实际问题中一般可能多于三点，此时只要选取目标点附近的三点即可，可用以下函数来自动构造\n// Len3ForInterpolateX is a special purpose Len3 constructor. // // Like NewLen3, it takes a table of x and y values, but it is not limited // to tables of 3 rows. An X value is also passed that represents the // interpolation target x value. Len3ForInterpolateX will locate the // appropriate three rows of the table for interpolating for x, and initialize // the Len3 object for those rows. // //\tx is the target for interpolation //\tx1 is the x value corresponding to the first y value of the table. //\txn is the x value corresponding to the last y value of the table. //\ty is all y values in the table. len(y) should be \u0026gt;= 3. // // 给定n个点，但是我们只需选取离目标点x最接近的三个点来做三点插值， // 此时可用以下函数来自动选择最优三点，来构造三点插值 // 同样，前提是n个点等距，且与y一一对应 func Len3ForInterpolateX(x, x1, xn float64, y []float64) (*Len3, error) { if len(y) \u0026gt; 3 { interval := (xn - x1) / float64(len(y)-1) if interval == 0 { return nil, ErrorNoXRange } nearestX := int((x-x1)/interval + .5) if nearestX \u0026lt; 1 { nearestX = 1 } else if nearestX \u0026gt; len(y)-2 { nearestX = len(y) - 2 } y = y[nearestX-1 : nearestX+2] xn = x1 + float64(nearestX+1)*interval x1 = x1 + float64(nearestX-1)*interval } return NewLen3(x1, xn, y) }  插值因子 $n$ 为：目标点 $x$ 与 中间点 $x_2$之差除以实际步长\n\\begin{equation} \\because n = 2(x - x_2)/(x_3-x_1), x_2 = x_1 + (x_3-x_1)/2\\\\\n\\therefore n = [2x - (x_1+x_3)]/(x_3-x_1)\\\\\n\\end{equation}\n// InterpolateX interpolates for a given x value. // 计算插值因子n，调用非严格插值计算 func (d *Len3) InterpolateX(x float64) (y float64) { n := (2*x - d.xSum) / d.xDiff return d.InterpolateN(n) } // InterpolateXStrict interpolates for a given x value, // restricting x to the range x1 to x3 given to the constructor NewLen3. // 计算插值因子n，调用严格插值计算 func (d *Len3) InterpolateXStrict(x float64) (y float64, err error) { n := (2*x - d.xSum) / d.xDiff y, err = d.InterpolateNStrict(n) if err == ErrorNOutOfRange { err = ErrorXOutOfRange } return }  通过调用三点插值公式获得目标插值，这里分为严格模式和非严格模式，\n所谓严格模式就是指目标点一定在三点的范围之内且必须离我们选择的三点的中间点最近，确保插值子$|n|\u0026lt;=1$；\n非严格模式就没有上述规定，可能目标点已经超出三点范围，得出的结果也相对不如严格模式精确。\n// InterpolateN interpolates for a given interpolating factor n. // // This is interpolation formula (3.3) // // The interpolation factor n is x-x2 in units of the tabular x interval. // (See Meeus p. 24.) // 非严格插值计算，不用保证目标点插值因子绝对值小于等于1， // 即不用保证离我们所选三点中点距离小于一个步长 func (d *Len3) InterpolateN(n float64) (y float64) { return d.y[1] + n*.5*(d.abSum+n*d.c) } // InterpolateNStrict interpolates for a given interpolating factor n. // // N is restricted to the range [-1..1] corresponding to the range x1 to x3 // given to the constructor NewLen3. // 严格插值计算，必须保证目标点插值因子绝对值小于等于1， // 即必须保证离我们所选三点中点距离小于一个步长 func (d *Len3) InterpolateNStrict(n float64) (y float64, err error) { if n \u0026lt; -1 || n \u0026gt; 1 { return 0, ErrorNOutOfRange } return d.InterpolateN(n), nil }  2.2 极值： 因为 $y_1 + 0.5n(cn+a+b)$是关于 $n$ 的二次函数($c \\neq 0$时)，由二次函数的性质可知：\n当 $n=-(a+b)/(2c)$时，有极值$-(a+b)^2/(8c)$\n但是如果插值因子$|n|\u0026gt;1$,则无法取到(已超出插值函数的定义域)\n再由$n = [2x - (x_1+x_3)]/(x_3-x_1)$\n得出此时实际$x = [n(x_3-x_1)+(x_1+x_3)]/2$\n// Extremum returns the x and y values at the extremum. // // Results are restricted to the range of the table given to the constructor // NewLen3. func (d *Len3) Extremum() (x, y float64, err error) { if d.c == 0 { return 0, 0, ErrorNoExtremum } n := d.abSum / (-2 * d.c) // (3.5), p. 25 if n \u0026lt; -1 || n \u0026gt; 1 { return 0, 0, ErrorExtremumOutside } x = .5 * (d.xSum + d.xDiff*n) // 根据实际步长得出极值点x y = d.y[1] - (d.abSum*d.abSum)/(8*d.c) // (3.4), p. 25 return x, y, nil }  2.3 根 和普通方程类似，有时候我们需要求解插值函数的\u0026rdquo;根\u0026rdquo;，即 $y=0$所对应的插值点\n同样借助 $y=y_1+ 0.5n(cn+a+b)$,令 $y=0$\n得$n = -2y_1/(cn+a+b)$\n此时再利用迭代法求解近似根 $n_0$\n当插值曲线曲率比较大时，可采用以下修正量来进行迭代，直到满足精度要求为止\n$Δn_0 = -[ 2y_1 +n_0 (a+b+cn_0 ) ]/(a +b + 2cn_0 )$\n求解得到满足精度要求的 $n$ 后，再根据实际步长得出 $x$，即为\u0026rdquo;根\u0026rdquo;\n// Len3Zero finds a zero of the quadratic function represented by the table. // // That is, it returns an x value that yields y=0. // // Argument strong switches between two strategies for the estimation step. // when iterating to converge on the zero. // // Strong=false specifies a quick and dirty estimate that works well // for gentle curves, but can work poorly or fail on more dramatic curves. // // Strong=true specifies a more sophisticated and thus somewhat more // expensive estimate. However, if the curve has quick changes, This estimate // will converge more reliably and in fewer steps, making it a better choice. // // Results are restricted to the range of the table given to the constructor // NewLen3. // strong 为考虑修正量的迭代方式，更为精确 func (d *Len3) Zero(strong bool) (x float64, err error) { var f iterFunc if strong { // (3.7), p. 27 f = func(n0 float64) float64 { return n0 - (2*d.y[1]+n0*(d.abSum+d.c*n0))/(d.abSum+2*d.c*n0) } } else { // (3.6), p. 26 f = func(n0 float64) float64 { return -2 * d.y[1] / (d.abSum + d.c*n0) } } n0, ok := iterate(0, f) if !ok { return 0, ErrorNoConverge } if n0 \u0026gt; 1 || n0 \u0026lt; -1 { return 0, ErrorZeroOutside } return .5 * (d.xSum + d.xDiff*n0), nil // success } type iterFunc func(n0 float64) (n1 float64) func iterate(n0 float64, f iterFunc) (n1 float64, ok bool) { for limit := 0; limit \u0026lt; 50; limit++ { n1 = f(n0) if math.IsInf(n1, 0) || math.IsNaN(n1) { break // failure to converge } if math.Abs((n1-n0)/n0) \u0026lt; 1e-15 { return n1, true // success } n0 = n1 } return 0, false // failure to converge }  3. 五点等距四阶差商的牛顿插值 3.1 五点插值公式 五点和三点类似，这里直接给出公式，不再进行推导\n5点：$(x_1,y_1),(x_2,y_2),(x_3,y_3),(x_4,y_4),(x_5,y_5)$\n$y=y_3+ \\frac {n} {2}(b+c)+\\frac {n^2} {2}f+\\frac{n(n^2-1)}{12}(h+j)+\\frac {n^2(n^2-1)}{24k}$\n或者\n$y=y_3+n(\\frac {b+c}{2}-\\frac {h+j}{12})+n^2(\\frac {f}{2}-\\frac {k}{24})+n^3(\\frac {h+j}{12})+n^4(\\frac {k}{24})$\n// Len5 allows fourth difference interpolation. // 五点等距插值结构 type Len5 struct { x1, x5 float64 // x1为起始点，x5为终止点 y []float64 // y 为x1,x2,x3,x4,x5的一一映射 a, b, c, d float64 // a=y2-y1, b=y3-y2, c=y4-y3, d=y5-y4 e, f, g float64 // e=b-a, f=c-b, g=d-c h, j, k float64 // h=f-e, j=g-f, k=j-h y3 float64 // y3为中间点的 y 值 xSum, xDiff float64 // xSum=x1+x5, xDiff=x5-x1 interpCoeff []float64 // 插值函数对应插值因子 n 的各项系数（0-4） } // NewLen5 prepares a Len5 object from a table of five rows of x and y values. // // X values must be equally spaced, so only the first and last are supplied. // X1 must not equal x5. Y must be a slice of five y values. // 构造5点插值结构 func NewLen5(x1, x5 float64, y []float64) (*Len5, error) { if len(y) != 5 { return nil, ErrorNot5 } if x5 == x1 { return nil, ErrorNoXRange } d := \u0026amp;Len5{ x1: x1, x5: x5, y: append([]float64{}, y...), y3: y[2], } // differences d.a = y[1] - y[0] d.b = y[2] - y[1] d.c = y[3] - y[2] d.d = y[4] - y[3] d.e = d.b - d.a d.f = d.c - d.b d.g = d.d - d.c d.h = d.f - d.e d.j = d.g - d.f d.k = d.j - d.h // other intermediate values d.xSum = x5 + x1 d.xDiff = x5 - x1 d.interpCoeff = []float64{ // (3.8) p. 28 d.y3, (d.b+d.c)/2 - (d.h+d.j)/12, d.f/2 - d.k/24, (d.h + d.j) / 12, d.k / 24, } return d, nil } // InterpolateX interpolates for a given x value. func (d *Len5) InterpolateX(x float64) (y float64) { n := (4*x - 2*d.xSum) / d.xDiff return d.InterpolateN(n) } // InterpolateXStrict interpolates for a given x value, // restricting x to the range x1 to x5 given to the the constructor NewLen5. func (d *Len5) InterpolateXStrict(x float64) (y float64, err error) { n := (4*x - 2*d.xSum) / d.xDiff y, err = d.InterpolateNStrict(n) if err == ErrorNOutOfRange { err = ErrorXOutOfRange } return } // InterpolateN interpolates for a given interpolating factor n. // // The interpolation factor n is x-x3 in units of the tabular x interval. // (See Meeus p. 28.) // Horner 为工具函数，求解多项式之和，interpCoeff为多项式系数 func (d *Len5) InterpolateN(n float64) (y float64) { return base.Horner(n, d.interpCoeff...) } // InterpolateNStrict interpolates for a given interpolating factor n. // // N is restricted to the range [-1..1]. This is only half the range given // to the constructor NewLen5, but is the recommendation given on p. 31. func (d *Len5) InterpolateNStrict(n float64) (y float64, err error) { if n \u0026lt; -1 || n \u0026gt; 1 { return 0, ErrorNOutOfRange } return base.Horner(n, d.interpCoeff...), nil }  3.2 五点极值 函数的极值对应的插值因子 $n_m$ 可通过解以下方程得到：\n$n_m=\\frac {6b+6c-h-j+3n_m^2(h+j)+2n_m^3k}{k-12f}$\n和上面的一样，我们可以执行迭代。首次，把 $n_m=0$代 入方程右边,迭代求得$n_m$\n当我们最后得到$n_m$后，$x_m=\\frac {x_1+x_5}{2}+\\frac {x_5-x_1}{4}n_m$\n再代入5点插值函数就可以获得极值\n// Extremum returns the x and y values at the extremum. // // Results are restricted to the range of the table given to the constructor // NewLen5. (Meeus actually recommends restricting the range to one unit of // the tabular interval, but that seems a little harsh.) // 5点插值极值 func (d *Len5) Extremum() (x, y float64, err error) { // (3.9) p. 29 nCoeff := []float64{ 6*(d.b+d.c) - d.h - d.j, 0, 3 * (d.h + d.k), // 不应该是 d.h+d.j 吗？ 2 * d.k, } den := d.k - 12*d.f if den == 0 { return 0, 0, ErrorExtremumOutside } n0, ok := iterate(0, func(n0 float64) float64 { return base.Horner(n0, nCoeff...) / den }) if !ok { return 0, 0, ErrorNoConverge } if n0 \u0026lt; -2 || n0 \u0026gt; 2 { return 0, 0, ErrorExtremumOutside } x = .5*d.xSum + .25*d.xDiff*n0 y = base.Horner(n0, d.interpCoeff...) return x, y, nil }  3.3 五点求根 令$y=0$通过以下公式迭代求插值因子$n_0$,起始$n_0=0$\n$n_0=\\frac {-24y_3+n_0^2(k-12f)-2n_0^3(h+j)-n_0^4k}{2(6b+6c-h-j)}$\n当曲率比较大时，同样可以加入修正\n$Δn_0 =-\\frac {Mn_0^4+Nn_0^3+Pn_0^2+Qn_0+y_3}{4Mn_0^3+3Nn_0^2+2Pn_0+Q},$\n$(M=\\frac{k}{24},N=\\frac{h+j}{12},P=\\frac{f}{2}-M,Q=\\frac{b+c}{2}-N)$\n// Len5Zero finds a zero of the quartic function represented by the table. // // That is, it returns an x value that yields y=0. // // Argument strong switches between two strategies for the estimation step. // when iterating to converge on the zero. // // Strong=false specifies a quick and dirty estimate that works well // for gentle curves, but can work poorly or fail on more dramatic curves. // // Strong=true specifies a more sophisticated and thus somewhat more // expensive estimate. However, if the curve has quick changes, This estimate // will converge more reliably and in fewer steps, making it a better choice. // // Results are restricted to the range of the table given to the constructor // NewLen5. // strong 为带修正模式 func (d *Len5) Zero(strong bool) (x float64, err error) { var f iterFunc if strong { // (3.11), p. 29 M := d.k / 24 N := (d.h + d.j) / 12 P := d.f/2 - M Q := (d.b+d.c)/2 - N numCoeff := []float64{d.y3, Q, P, N, M} denCoeff := []float64{Q, 2 * P, 3 * N, 4 * M} f = func(n0 float64) float64 { return n0 - base.Horner(n0, numCoeff...)/base.Horner(n0, denCoeff...) } } else { // (3.10), p. 29 numCoeff := []float64{ -24 * d.y3, 0, d.k - 12*d.f, -2 * (d.h + d.j), -d.k, } den := 12*(d.b+d.c) - 2*(d.h+d.j) f = func(n0 float64) float64 { return base.Horner(n0, numCoeff...) / den } } n0, ok := iterate(0, f) if !ok { return 0, ErrorNoConverge } if n0 \u0026gt; 2 || n0 \u0026lt; -2 { return 0, ErrorZeroOutside } x = .5*d.xSum + .25*d.xDiff*n0 return x, nil }  4. 四点等距中间点插值 假设有$(x_1,y_1),(x_2,y_2),(x_3,y_3),(x_4,y_4)$ 那么 $x_2$到 $x_3$ 之间的中点对应的函数值为： $y = [ 9(y_2 +y_3 ) - y_1 - y_4 ] / 16$\n// Len4Half interpolates a center value from a table of four rows. func Len4Half(y []float64) (float64, error) { if len(y) != 4 { return 0, ErrorNot4 } // (3.12) p. 32 return (9*(y[1]+y[2]) - y[0] - y[3]) / 16, nil }  5. 横坐标不等间距插值：拉格朗日插值 \\begin{align} y=y_1L_1+y_2L_2+\\cdots+y_nL_n\\\\[2ex] L_i = \\prod_{ \\substack{ i+1\\\\\ni \\neq j }}^n \\frac {x-x_j}{x_i-x_j} \\end{align}\n上式是一个 $n-1$ 阶的多项式，这是利用 $y_1,y_2,\\dots y_n$ 所能得到的唯一的一个 $n-1$ 阶多项式（注：多项式 插值具有唯一性）。但拉格朗日公式本身有个缺点，就是没有给出所需的数据点数量，以争取达到理想的精度。不过， 当我们希望表达一个函数的明确的插值多项式时，而$x$ 又远离插值节点，那么使用拉格朗日公式是有益的。\n// Lagrange performs interpolation with unequally-spaced abscissae. // // Given a table of X and Y values, interpolate a new y value for argument x. // // X values in the table do not have to be equally spaced; they do not even // have to be in order. They must however, be distinct. // table 中包含了 n 个点且xi 必须互异,x 为目标插值点 func Lagrange(x float64, table []struct{ X, Y float64 }) (y float64) { // method of BASIC program, p. 33. sum := 0. for i := range table { xi := table[i].X prod := 1. for j := range table { if i != j { xj := table[j].X prod *= (x - xj) / (xi - xj) } } sum += table[i].Y * prod } return sum } // LagrangePoly uses the formula of Lagrange to produce an interpolating // polynomial. // // X values in the table do not have to be equally spaced; they do not even // have to be in order. They must however, be distinct. // // The returned polynomial will be of degree n-1 where n is the number of rows // in the table. It can be evaluated for x using common.Horner. // 构造拉格朗日多项式，返回各项系数(0-n) func LagrangePoly(table []struct{ X, Y float64 }) []float64 { // Method not fully described by Meeus, but needed for numerical solution // to Example 3.g. sum := make([]float64, len(table)) prod := make([]float64, len(table)) last := len(table) - 1 for i := range table { xi := table[i].X yi := table[i].Y prod[last] = 1 den := 1. n := last for j := range table { if i != j { xj := table[j].X prod[n-1] = prod[n] * -xj for k := n; k \u0026lt; last; k++ { prod[k] -= prod[k+1] * xj } n-- den *= (xi - xj) } } for j, pj := range prod { sum[j] += yi * pj / den } } return sum } ","date":1526132597,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1526132597,"objectID":"16c74c8076fc6f3ed63eb3f42ad7cc37","permalink":"https://mooncaker816.github.io/2018/05/12/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%951/","publishdate":"2018-05-12T21:43:17+08:00","relpermalink":"/2018/05/12/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%951/","section":"post","summary":"①背景","tags":["天文算法"],"title":"天文算法1","type":"post"},{"authors":null,"categories":["Linux"],"content":"cp - copy 拷贝目录，文件 Usage： Usage: cp [OPTION]... [-T] SOURCE DEST or: cp [OPTION]... SOURCE... DIRECTORY or: cp [OPTION]... -t DIRECTORY SOURCE... Copy SOURCE to DEST, or multiple SOURCE(s) to DIRECTORY. Mandatory arguments to long options are mandatory for short options too. -a, --archive same as -dR --preserve=all --attributes-only don't copy the file data, just the attributes --backup[=CONTROL] make a backup of each existing destination file -b like --backup but does not accept an argument --copy-contents copy contents of special files when recursive -d same as --no-dereference --preserve=links -f, --force if an existing destination file cannot be opened, remove it and try again (this option is ignored when the -n option is also used) -i, --interactive prompt before overwrite (overrides a previous -n option) -H follow command-line symbolic links in SOURCE -l, --link hard link files instead of copying -L, --dereference always follow symbolic links in SOURCE -n, --no-clobber do not overwrite an existing file (overrides a previous -i option) -P, --no-dereference never follow symbolic links in SOURCE -p same as --preserve=mode,ownership,timestamps --preserve[=ATTR_LIST] preserve the specified attributes (default: mode,ownership,timestamps), if possible additional attributes: context, links, xattr, all -c deprecated, same as --preserve=context --no-preserve=ATTR_LIST don't preserve the specified attributes --parents use full source file name under DIRECTORY -R, -r, --recursive copy directories recursively --reflink[=WHEN] control clone/CoW copies. See below --remove-destination remove each existing destination file before attempting to open it (contrast with --force) --sparse=WHEN control creation of sparse files. See below --strip-trailing-slashes remove any trailing slashes from each SOURCE argument -s, --symbolic-link make symbolic links instead of copying -S, --suffix=SUFFIX override the usual backup suffix -t, --target-directory=DIRECTORY copy all SOURCE arguments into DIRECTORY -T, --no-target-directory treat DEST as a normal file -u, --update copy only when the SOURCE file is newer than the destination file or when the destination file is missing -v, --verbose explain what is being done -x, --one-file-system stay on this file system -Z set SELinux security context of destination file to default type --context[=CTX] like -Z, or if CTX is specified then set the SELinux or SMACK security context to CTX --help display this help and exit --version output version information and exit By default, sparse SOURCE files are detected by a crude heuristic and the corresponding DEST file is made sparse as well. That is the behavior selected by --sparse=auto. Specify --sparse=always to create a sparse DEST file whenever the SOURCE file contains a long enough sequence of zero bytes. Use --sparse=never to inhibit creation of sparse files. When --reflink[=always] is specified, perform a lightweight copy, where the data blocks are copied only when modified. If this is not possible the copy fails, or if --reflink=auto is specified, fall back to a standard copy. The backup suffix is '~', unless set with --suffix or SIMPLE_BACKUP_SUFFIX. The version control method may be selected via the --backup option or through the VERSION_CONTROL environment variable. Here are the values: none, off never make backups (even if --backup is given) numbered, t make numbered backups existing, nil numbered if numbered backups exist, simple otherwise simple, never always make simple backups As a special case, cp makes a backup of SOURCE when the force and backup options are given and SOURCE and DEST are the same name for an existing, regular file.  常用选项： -a / -p：连同文件属性一起复制（用户组属性受 id 权限限制）\n-i（interactive）：覆盖询问\n-r（recursive）： 用于目录的递归复制\n-u （update）：source 比 destination 新才复制\n 覆盖询问  [root@78063f0fe2e8 ~]# cp ~/.bashrc /tmp/bashrc [root@78063f0fe2e8 ~]# cp -i ~/.bashrc /tmp/bashrc cp: overwrite ‘/tmp/bashrc’? y   连同文件属性一起复制  [root@78063f0fe2e8 ~]# cd /tmp [root@78063f0fe2e8 tmp]# cp /var/log/wtmp . [root@78063f0fe2e8 tmp]# ls -l /var/log/wtmp wtmp -rw-rw-r-- 1 root utmp 0 Apr 2 18:38 /var/log/wtmp -rw-r--r-- 1 root root 0 Apr 21 06:23 wtmp [root@78063f0fe2e8 tmp]# cp -a /var/log/wtmp wtmp2 [root@78063f0fe2e8 tmp]# ls -l /var/log/wtmp wtmp2 -rw-rw-r-- 1 root utmp 0 Apr 2 18:38 /var/log/wtmp -rw-rw-r-- 1 root utmp 0 Apr 2 18:38 wtmp2   用于目录的递归复制  [root@78063f0fe2e8 tmp]# cp /etc /tmp cp: omitting directory ‘/etc’ [root@78063f0fe2e8 tmp]# cp -r /etc /tmp   rm - remove 删除目录或文件 Usage： Usage: rm [OPTION]... FILE... Remove (unlink) the FILE(s). -f, --force ignore nonexistent files and arguments, never prompt -i prompt before every removal -I prompt once before removing more than three files, or when removing recursively; less intrusive than -i, while still giving protection against most mistakes --interactive[=WHEN] prompt according to WHEN: never, once (-I), or always (-i); without WHEN, prompt always --one-file-system when removing a hierarchy recursively, skip any directory that is on a file system different from that of the corresponding command line argument --no-preserve-root do not treat '/' specially --preserve-root do not remove '/' (default) -r, -R, --recursive remove directories and their contents recursively -d, --dir remove empty directories -v, --verbose explain what is being done --help display this help and exit --version output version information and exit By default, rm does not remove directories. Use the --recursive (-r or -R) option to remove each listed directory, too, along with all of its contents. To remove a file whose name starts with a '-', for example '-foo', use one of these commands: rm -- -foo rm ./-foo Note that if you use rm to remove a file, it might be possible to recover some of its contents, given sufficient expertise and/or time. For greater assurance that the contents are truly unrecoverable, consider using shred.  常用选项： -f（force）：忽略不存在的文件\n-i（interactive）：询问删除\n-r（recursive）：递归删除\nsh-4.2# cd /tmp sh-4.2# ls bashrc\tmingle1 tmpxq2sylvo-ascii.cast wtmp2 ks-script-hE5IPf test1 wtmp\tyum.log sh-4.2# rm -i bashrc rm: remove regular file ‘bashrc’? y sh-4.2# ls ks-script-hE5IPf mingle1 test1 tmpxq2sylvo-ascii.cast wtmp\twtmp2 yum.log sh-4.2# rmdir mingle1 sh-4.2# rmdir test1 rmdir: failed to remove ‘test1’: Directory not empty sh-4.2# rm -rf test1 sh-4.2# ls ks-script-hE5IPf tmpxq2sylvo-ascii.cast wtmp\twtmp2 yum.log sh-4.2# touch ./-aaa- sh-4.2# ls -aaa- ks-script-hE5IPf tmpxq2sylvo-ascii.cast wtmp wtmp2 yum.log sh-4.2# rm -f -aaa- rm: invalid option -- 'a' Try 'rm ./-aaa-' to remove the file ‘-aaa-’. Try 'rm --help' for more information. sh-4.2# rm -f ./-aaa- sh-4.2# ls ks-script-hE5IPf tmpxq2sylvo-ascii.cast wtmp\twtmp2 yum.log sh-4.2# rm -rf wtmp* sh-4.2# ls ks-script-hE5IPf tmpxq2sylvo-ascii.cast yum.log   mv - move 移动文件或目录，更名 Usage： Usage: mv [OPTION]... [-T] SOURCE DEST or: mv [OPTION]... SOURCE... DIRECTORY or: mv [OPTION]... -t DIRECTORY SOURCE... Rename SOURCE to DEST, or move SOURCE(s) to DIRECTORY. Mandatory arguments to long options are mandatory for short options too. --backup[=CONTROL] make a backup of each existing destination file -b like --backup but does not accept an argument -f, --force do not prompt before overwriting -i, --interactive prompt before overwrite -n, --no-clobber do not overwrite an existing file If you specify more than one of -i, -f, -n, only the final one takes effect. --strip-trailing-slashes remove any trailing slashes from each SOURCE argument -S, --suffix=SUFFIX override the usual backup suffix -t, --target-directory=DIRECTORY move all SOURCE arguments into DIRECTORY -T, --no-target-directory treat DEST as a normal file -u, --update move only when the SOURCE file is newer than the destination file or when the destination file is missing -v, --verbose explain what is being done -Z, --context set SELinux security context of destination file to default type --help display this help and exit --version output version information and exit The backup suffix is '~', unless set with --suffix or SIMPLE_BACKUP_SUFFIX. The version control method may be selected via the --backup option or through the VERSION_CONTROL environment variable. Here are the values: none, off never make backups (even if --backup is given) numbered, t make numbered backups existing, nil numbered if numbered backups exist, simple otherwise simple, never always make simple backups  常用选项： -f（force）：不询问直接覆盖\n-i（ interactive）： 询问覆盖\n-u（update）：source 新于 destination 才会 move\n 普通移动  sh-4.2# cd /tmp sh-4.2# cp ~/.bashrc bashrc1 sh-4.2# cp ~/.bashrc bashrc2 sh-4.2# ls bashrc1 bashrc2 ks-script-hE5IPf tmp8u627nsx-ascii.cast yum.log sh-4.2# mkdir mvtest sh-4.2# ls bashrc1 bashrc2 ks-script-hE5IPf mvtest tmp8u627nsx-ascii.cast yum.log sh-4.2# mv bashrc1 bashrc2 mvtest sh-4.2# ls ks-script-hE5IPf mvtest tmp8u627nsx-ascii.cast yum.log sh-4.2# cd mvtest sh-4.2# ls bashrc1 bashrc2   重命名  sh-4.2# cd .. sh-4.2# ls ks-script-hE5IPf mvtest tmp8u627nsx-ascii.cast yum.log sh-4.2# mv mvtest mvtest2 sh-4.2# ls ks-script-hE5IPf mvtest2 tmp8u627nsx-ascii.cast yum.log  ","date":1524318600,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1524318600,"objectID":"1f2483338ada817eb95e36a1844b487a","permalink":"https://mooncaker816.github.io/2018/04/21/linux-centos-%E5%91%BD%E4%BB%A4%E4%B9%8B-cprmmv/","publishdate":"2018-04-21T13:50:00Z","relpermalink":"/2018/04/21/linux-centos-%E5%91%BD%E4%BB%A4%E4%B9%8B-cprmmv/","section":"post","summary":"cp - copy 拷贝目录，文件","tags":["Centos"],"title":"Linux Centos 命令之 cp,rm,mv","type":"post"},{"authors":null,"categories":["Linux"],"content":"touch - 创建空文件，修改时间 Usage： Usage: touch [OPTION]... FILE... Update the access and modification times of each FILE to the current time. A FILE argument that does not exist is created empty, unless -c or -h is supplied. A FILE argument string of - is handled specially and causes touch to change the times of the file associated with standard output. Mandatory arguments to long options are mandatory for short options too. -a change only the access time -c, --no-create do not create any files -d, --date=STRING parse STRING and use it instead of current time -f (ignored) -h, --no-dereference affect each symbolic link instead of any referenced file (useful only on systems that can change the timestamps of a symlink) -m change only the modification time -r, --reference=FILE use this file's times instead of current time -t STAMP use [[CC]YY]MMDDhhmm[.ss] instead of current time --time=WORD change the specified time: WORD is access, atime, or use: equivalent to -a WORD is modify or mtime: equivalent to -m --help display this help and exit --version output version information and exit Note that the -d and -t options accept different time-date formats.  mtime ：modification time （默认）\n文件的内容被修改时会更新\nctime ：status time\n文件的属性或权限被修改时会更新\natime ： access time\n文件的内容被读取时会更新\n[root@78063f0fe2e8 etc]# ls -l login.defs -rw-r--r-- 1 root root 2028 Nov 4 2016 login.defs [root@78063f0fe2e8 etc]# ls -l login.defs --time=atime -rw-r--r-- 1 root root 2028 Nov 4 2016 login.defs [root@78063f0fe2e8 etc]# ls -l login.defs --time=ctime -rw-r--r-- 1 root root 2028 Apr 20 14:19 login.defs  常用选项： -a（access） ：仅修改访问时间\n-c（）：仅修改文件时间，若文件不存在则不创建新文件\n-m（modification）： 仅修改 mtime\n-t （time）：想要修改的时间[YYMMDDhhmm]\n-d（date）：修改的日期\n 新建空文件  sh-4.2# cd /tmp sh-4.2# touch testtouch sh-4.2# ls -l testtouch -rw-r--r-- 1 root root 0 Apr 21 07:52 testtouch sh-4.2# ls -l testtouch --time=atime -rw-r--r-- 1 root root 0 Apr 21 07:52 testtouch sh-4.2# ls -l testtouch --time=ctime -rw-r--r-- 1 root root 0 Apr 21 07:52 testtouch   修改时间  sh-4.2# cp -a ~/.bashrc bashrc sh-4.2# ls -l bashrc -rw-r--r-- 1 root root 176 Dec 29 2013 bashrc sh-4.2# ls -l bashrc --time=atime -rw-r--r-- 1 root root 176 Dec 29 2013 bashrc sh-4.2# ls -l bashrc --time=ctime -rw-r--r-- 1 root root 176 Apr 21 07:53 bashrc sh-4.2# touch -d \u0026quot;2 days ago\u0026quot; bashrc sh-4.2# ls -l bashrc -rw-r--r-- 1 root root 176 Apr 19 07:55 bashrc sh-4.2# ls -l bashrc --time=atime -rw-r--r-- 1 root root 176 Apr 19 07:55 bashrc sh-4.2# ls -l bashrc --time=ctime -rw-r--r-- 1 root root 176 Apr 21 07:55 bashrc sh-4.2# touch -t 1801011000 bashrc sh-4.2# ls -l bashrc -rw-r--r-- 1 root root 176 Jan 1 10:00 bashrc sh-4.2# ls -l bashrc --time=ctime -rw-r--r-- 1 root root 176 Apr 21 07:57 bashrc sh-4.2# ls -l bashrc --time=atime -rw-r--r-- 1 root root 176 Jan 1 10:00 bashrc   cat - concatenate 浏览文件 Usage： Usage: cat [OPTION]... [FILE]... Concatenate FILE(s), or standard input, to standard output. -A, --show-all equivalent to -vET -b, --number-nonblank number nonempty output lines, overrides -n -e equivalent to -vE -E, --show-ends display $ at end of each line -n, --number number all output lines -s, --squeeze-blank suppress repeated empty output lines -t equivalent to -vT -T, --show-tabs display TAB characters as ^I -u (ignored) -v, --show-nonprinting use ^ and M- notation, except for LFD and TAB --help display this help and exit --version output version information and exit With no FILE, or when FILE is -, read standard input. Examples: cat f - g Output f's contents, then standard input, then g's contents. cat Copy standard input to standard output.  常用选项： -A（All）：显示所有，包括特殊字符，等价于-vET\n-v（verbose）：列出看不出来的特殊字符\n-T（Tab）：将 Tab 按键以^I 显示出来\n-b（blank）：列出行号，空白行不标号\n-n（number）：列出行号，空白行也有\n-E（End）：将结尾的断行字符$显示出来\nsh-4.2# cat /etc/issue \\S Kernel \\r on an \\m sh-4.2# cat -n /etc/issue 1\t\\S 2\tKernel \\r on an \\m 3 sh-4.2# cat -b /etc/issue 1\t\\S 2\tKernel \\r on an \\m sh-4.2# cd /tmp sh-4.2# ls bashrc\tmvtest2 testtouch\tyum.log ks-script-hE5IPf test.conf tmpk3saal44-ascii.cast sh-4.2# cat -A test.conf ^Ihello$ this is a test file only...$ sh-4.2# cat -An test.conf 1\t^Ihello$ 2\tthis is a test file only...$   tac - 反向 cat Usage： Usage: tac [OPTION]... [FILE]... Write each FILE to standard output, last line first. With no FILE, or when FILE is -, read standard input. Mandatory arguments to long options are mandatory for short options too. -b, --before attach the separator before instead of after -r, --regex interpret the separator as a regular expression -s, --separator=STRING use STRING as the separator instead of newline --help display this help and exit --version output version information and exit  tac 没有 -n 选项\n[root@78063f0fe2e8 ~]# tac /etc/issue Kernel \\r on an \\m \\S  nl - 添加行号显示文件 Usage： Usage: nl [OPTION]... [FILE]... Write each FILE to standard output, with line numbers added. With no FILE, or when FILE is -, read standard input. Mandatory arguments to long options are mandatory for short options too. -b, --body-numbering=STYLE use STYLE for numbering body lines -d, --section-delimiter=CC use CC for separating logical pages -f, --footer-numbering=STYLE use STYLE for numbering footer lines -h, --header-numbering=STYLE use STYLE for numbering header lines -i, --line-increment=NUMBER line number increment at each line -l, --join-blank-lines=NUMBER group of NUMBER empty lines counted as one -n, --number-format=FORMAT insert line numbers according to FORMAT -p, --no-renumber do not reset line numbers at logical pages -s, --number-separator=STRING add STRING after (possible) line number -v, --starting-line-number=NUMBER first line number on each logical page -w, --number-width=NUMBER use NUMBER columns for line numbers --help display this help and exit --version output version information and exit By default, selects -v1 -i1 -l1 -sTAB -w6 -nrn -hn -bt -fn. CC are two delimiter characters for separating logical pages, a missing second character implies :. Type \\\\ for \\. STYLE is one of: a number all lines t number only nonempty lines n number no lines pBRE number only lines that contain a match for the basic regular expression, BRE FORMAT is one of: ln left justified, no leading zeros rn right justified, no leading zeros rz right justified, leading zeros  [root@78063f0fe2e8 ~]# nl /etc/issue 1\t\\S 2\tKernel \\r on an \\m [root@78063f0fe2e8 ~]# nl /etc/issue -b a 1\t\\S 2\tKernel \\r on an \\m 3 [root@78063f0fe2e8 ~]# nl /etc/issue -b a -n rz 000001\t\\S 000002\tKernel \\r on an \\m 000003 [root@78063f0fe2e8 ~]# nl /etc/issue -b a -n ln 1 \\S 2 Kernel \\r on an \\m 3 [root@78063f0fe2e8 ~]# nl /etc/issue -b a -n rn 1\t\\S 2\tKernel \\r on an \\m 3 [root@78063f0fe2e8 ~]# nl /etc/issue -b a -n rn -w 3 1\t\\S 2\tKernel \\r on an \\m 3 [root@78063f0fe2e8 ~]# nl /etc/issue -b a -n rz -w 3 001\t\\S 002\tKernel \\r on an \\m 003  more - 一页一页显示文件内容 Usage： more: unknown option -help Usage: more [options] file... Options: -d display help instead of ring bell -f count logical, rather than screen lines -l suppress pause after form feed -p do not scroll, clean screen and display text -c do not scroll, display text and clean line ends -u suppress underlining -s squeeze multiple blank lines into one -NUM specify the number of lines per screenful +NUM display file beginning from line number NUM +/STRING display file beginning from search string match -V output version information and exit  空格：向下翻一页\nEnter：向下一行\n/字符串：向下查询字符串\nq：退出查看\nb：往回翻页\nless - more 的进阶 略\n","date":1524318600,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1524318600,"objectID":"7e7c8df5f2f98eb965e03ae5679a8af5","permalink":"https://mooncaker816.github.io/2018/04/21/linux-centos-%E5%91%BD%E4%BB%A4%E4%B9%8B-touchcattacmoreless/","publishdate":"2018-04-21T13:50:00Z","relpermalink":"/2018/04/21/linux-centos-%E5%91%BD%E4%BB%A4%E4%B9%8B-touchcattacmoreless/","section":"post","summary":"touch - 创建空文件，修改时间","tags":["Centos"],"title":"Linux Centos 命令之 touch,cat,tac,more,less","type":"post"},{"authors":null,"categories":["Linux"],"content":"mkdir - make directory 创建目录 Usage： Usage: mkdir [OPTION]... DIRECTORY... Create the DIRECTORY(ies), if they do not already exist. Mandatory arguments to long options are mandatory for short options too. -m, --mode=MODE set file mode (as in chmod), not a=rwx - umask -p, --parents no error if existing, make parent directories as needed -v, --verbose print a message for each created directory -Z set SELinux security context of each created directory to the default type --context[=CTX] like -Z, or if CTX is specified then set the SELinux or SMACK security context to CTX --help display this help and exit --version output version information and exit  常用选项： -m（mode）：按指定权限创建目录，若没有该选项则按 umask 的默认设置创建\n-p（parent）：递归创建所有目录\n-v（verbose）： 打印出每个创建的目录\n 递归创建目录  [root@78063f0fe2e8 ~]# mkdir -pv /tmp/test1/test2/test3 mkdir: created directory ‘/tmp/test1’ mkdir: created directory ‘/tmp/test1/test2’ mkdir: created directory ‘/tmp/test1/test2/test3’   目录的权限由 umask 决定  [root@78063f0fe2e8 ~]# umask 0022 [root@78063f0fe2e8 ~]# umask -S u=rwx,g=rx,o=rx [root@78063f0fe2e8 ~]# ls /tmp/test1 -l total 4 drwxr-xr-x 3 root root 4096 Apr 21 05:01 test2  022是指对应三个组别分别要减去的权限分数，777-022=755=（rwxr-xr-x）\n 指定创建权限为711的目录  [root@78063f0fe2e8 ~]# mkdir /tmp/mingle -m 711 [root@78063f0fe2e8 ~]# ls /tmp/mingle -ld drwx--x--x 2 root root 4096 Apr 21 05:10 /tmp/mingle   rmdir - remove empty directory 删除空目录 Usage： Usage: rmdir [OPTION]... DIRECTORY... Remove the DIRECTORY(ies), if they are empty. --ignore-fail-on-non-empty ignore each failure that is solely because a directory is non-empty -p, --parents remove DIRECTORY and its ancestors; e.g., 'rmdir -p a/b/c' is similar to 'rmdir a/b/c a/b a' -v, --verbose output a diagnostic for every directory processed --help display this help and exit --version output version information and exit  常用选项： -p（parent）：递归删除空目录\n-v（verbose）：打印出每个删除的目录\n[root@78063f0fe2e8 ~]# mkdir -p /tmp/test1/test2/test3 [root@78063f0fe2e8 ~]# rmdir -pv /tmp/test1/test2/test3 rmdir: removing directory, ‘/tmp/test1/test2/test3’ rmdir: removing directory, ‘/tmp/test1/test2’ rmdir: removing directory, ‘/tmp/test1’ rmdir: removing directory, ‘/tmp’ rmdir: failed to remove directory ‘/tmp’: Directory not empty   pwd - print working directory 打印当前路径 Usage： pwd [-LP]  常用选项： -L（link）：若为软链，则显示软链路径(默认)\n-P（）：若为软链，则显示为实际指向路径\n[root@78063f0fe2e8 mail]# ls -ld /var/mail lrwxrwxrwx 1 root root 10 Apr 2 18:38 /var/mail -\u0026gt; spool/mail [root@78063f0fe2e8 mail]# pwd /var/mail [root@78063f0fe2e8 mail]# pwd -P /var/spool/mail [root@78063f0fe2e8 mail]# pwd -L /var/mail   cd - change directory 切换当前路径 常用目录： \u0026rdquo;.\u0026rdquo; ： 当前目录\n\u0026rdquo;..\u0026rdquo; ：上级目录\n\u0026rdquo;-\u0026rdquo; ：前一个工作目录\n\u0026ldquo;~\u0026ldquo;,\u0026rdquo; \u0026ldquo; ：当前用户所在的主目录 \u0026ldquo;~account\u0026rdquo; ：account 这个用户所在的主目录\n[root@78063f0fe2e8 mail]# cd [root@78063f0fe2e8 ~]# [root@78063f0fe2e8 ~]# cd /tmp [root@78063f0fe2e8 tmp]# cd [root@78063f0fe2e8 ~]# cd ~root [root@78063f0fe2e8 ~]# cd - /root [root@78063f0fe2e8 ~]# cd .. [root@78063f0fe2e8 /]# cd - /root [root@78063f0fe2e8 ~]# cd /var/mail [root@78063f0fe2e8 mail]#  ","date":1524315000,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1524315000,"objectID":"854d1e2ab9eb4f3e5f02342f437a2263","permalink":"https://mooncaker816.github.io/2018/04/21/linux-centos-%E5%91%BD%E4%BB%A4%E4%B9%8B-mkdirrmdirpwdcd/","publishdate":"2018-04-21T12:50:00Z","relpermalink":"/2018/04/21/linux-centos-%E5%91%BD%E4%BB%A4%E4%B9%8B-mkdirrmdirpwdcd/","section":"post","summary":"mkdir - make directory 创建目录","tags":["Centos"],"title":"Linux Centos 命令之 mkdir,rmdir,pwd,cd","type":"post"},{"authors":null,"categories":["Linux"],"content":"ls - list 列出文件与目录 Usage： Usage: ls [OPTION]... [FILE]... List information about the FILEs (the current directory by default). Sort entries alphabetically if none of -cftuvSUX nor --sort is specified. Mandatory arguments to long options are mandatory for short options too. -a, --all do not ignore entries starting with . -A, --almost-all do not list implied . and .. --author with -l, print the author of each file -b, --escape print C-style escapes for nongraphic characters --block-size=SIZE scale sizes by SIZE before printing them; e.g., '--block-size=M' prints sizes in units of 1,048,576 bytes; see SIZE format below -B, --ignore-backups do not list implied entries ending with ~ -c with -lt: sort by, and show, ctime (time of last modification of file status information); with -l: show ctime and sort by name; otherwise: sort by ctime, newest first -C list entries by columns --color[=WHEN] colorize the output; WHEN can be 'never', 'auto', or 'always' (the default); more info below -d, --directory list directories themselves, not their contents -D, --dired generate output designed for Emacs' dired mode -f do not sort, enable -aU, disable -ls --color -F, --classify append indicator (one of */=\u0026gt;@|) to entries --file-type likewise, except do not append '*' --format=WORD across -x, commas -m, horizontal -x, long -l, single-column -1, verbose -l, vertical -C --full-time like -l --time-style=full-iso -g like -l, but do not list owner --group-directories-first group directories before files; can be augmented with a --sort option, but any use of --sort=none (-U) disables grouping -G, --no-group in a long listing, don't print group names -h, --human-readable with -l, print sizes in human readable format (e.g., 1K 234M 2G) --si likewise, but use powers of 1000 not 1024 -H, --dereference-command-line follow symbolic links listed on the command line --dereference-command-line-symlink-to-dir follow each command line symbolic link that points to a directory --hide=PATTERN do not list implied entries matching shell PATTERN (overridden by -a or -A) --indicator-style=WORD append indicator with style WORD to entry names: none (default), slash (-p), file-type (--file-type), classify (-F) -i, --inode print the index number of each file -I, --ignore=PATTERN do not list implied entries matching shell PATTERN -k, --kibibytes default to 1024-byte blocks for disk usage -l use a long listing format -L, --dereference when showing file information for a symbolic link, show information for the file the link references rather than for the link itself -m fill width with a comma separated list of entries -n, --numeric-uid-gid like -l, but list numeric user and group IDs -N, --literal print raw entry names (don't treat e.g. control characters specially) -o like -l, but do not list group information -p, --indicator-style=slash append / indicator to directories -q, --hide-control-chars print ? instead of nongraphic characters --show-control-chars show nongraphic characters as-is (the default, unless program is 'ls' and output is a terminal) -Q, --quote-name enclose entry names in double quotes --quoting-style=WORD use quoting style WORD for entry names: literal, locale, shell, shell-always, c, escape -r, --reverse reverse order while sorting -R, --recursive list subdirectories recursively -s, --size print the allocated size of each file, in blocks -S sort by file size --sort=WORD sort by WORD instead of name: none (-U), size (-S), time (-t), version (-v), extension (-X) --time=WORD with -l, show time as WORD instead of default modification time: atime or access or use (-u) ctime or status (-c); also use specified time as sort key if --sort=time --time-style=STYLE with -l, show times using style STYLE: full-iso, long-iso, iso, locale, or +FORMAT; FORMAT is interpreted like in 'date'; if FORMAT is FORMAT1\u0026lt;newline\u0026gt;FORMAT2, then FORMAT1 applies to non-recent files and FORMAT2 to recent files; if STYLE is prefixed with 'posix-', STYLE takes effect only outside the POSIX locale -t sort by modification time, newest first -T, --tabsize=COLS assume tab stops at each COLS instead of 8 -u with -lt: sort by, and show, access time; with -l: show access time and sort by name; otherwise: sort by access time -U do not sort; list entries in directory order -v natural sort of (version) numbers within text -w, --width=COLS assume screen width instead of current value -x list entries by lines instead of by columns -X sort alphabetically by entry extension -1 list one file per line SELinux options: --lcontext Display security context. Enable -l. Lines will probably be too wide for most displays. -Z, --context Display security context so it fits on most displays. Displays only mode, user, group, security context and file name. --scontext Display only security context and file name. --help display this help and exit --version output version information and exit SIZE is an integer and optional unit (example: 10M is 10*1024*1024). Units are K, M, G, T, P, E, Z, Y (powers of 1024) or KB, MB, ... (powers of 1000). Using color to distinguish file types is disabled both by default and with --color=never. With --color=auto, ls emits color codes only when standard output is connected to a terminal. The LS_COLORS environment variable can change the settings. Use the dircolors command to set it. Exit status: 0 if OK, 1 if minor problems (e.g., cannot access subdirectory), 2 if serious trouble (e.g., cannot access command-line argument).  常用选项： -a：列出所有文件\n-d：列出目录本身，而不是其内容\n-h：以适合人类阅读的格式输出（size 大小转为 K，M，G 等）\n-i：打印出每个文件的 inode编号\ninode 参考：http://www.ruanyifeng.com/blog/2011/12/inode.html\n-l：以长格式显示完整信息\ndrwxr-xr-x 2 root root 4096 Nov 5 2016 srv dr-xr-xr-x 13 root root 0 Apr 21 03:02 sys drwxrwxrwt 1 root root 4096 Apr 20 21:17 tmp drwxr-xr-x 1 root root 4096 Apr 2 18:38 usr drwxr-xr-x 1 root root 4096 Apr 2 18:38 var  drwxr-xr-x:\n常用文件类型：（-普通文件，d 目录，l 软链接文件）\n权限设置：rwxr-xr-x (拥有者权限 rwx，所属组权限r-x，其他权限r-x)\n","date":1524311400,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1524311400,"objectID":"288dffccd86f6cff89f09c5823375ee4","permalink":"https://mooncaker816.github.io/2018/04/21/linux-centos-%E5%91%BD%E4%BB%A4%E4%B9%8B-ls/","publishdate":"2018-04-21T11:50:00Z","relpermalink":"/2018/04/21/linux-centos-%E5%91%BD%E4%BB%A4%E4%B9%8B-ls/","section":"post","summary":"ls - list 列出文件与目录","tags":["Centos"],"title":"Linux Centos 命令之 ls","type":"post"},{"authors":null,"categories":["Golang"],"content":"bytes和strings函数比对 bytesstrings函数签名功能函数签名功能func explode(s []byte, n int) [][]byte以每个utf8字符为单位，将前n个字符对应的[]byte型组成新的slice返回func explode(s string, n int) []string以每个utf8字符为单位，将前n个字符对应的string型组成新的slice返回func countGeneric(s, sep []byte) int返回s中有几个sep，若sep为空，则返回sutf8.RuneCount(s) + 1func countGeneric(s, substr string) int返回s中有几个substr，若substr为空，则返回sutf8.RuneCount(s) + 1func Contains(b, subslice []byte) boolb中是否含有subslicefunc Contains(s, substr string) bools中是否含有substrfunc ContainsAny(b []byte, chars string) boolb中是否含有字符串charsfunc ContainsAny(s, chars string) bools中是否含有字符串chars中的任意一个unicode字符func ContainsRune(b []byte, r rune) boolb中是否含有rune rfunc ContainsRune(s string, r rune) bools中是否含有rune rfunc indexBytePortable(s []byte, c byte) int（并没有导出也没有用于内部）返回s中c的位置，若不含有c，则返回-1func LastIndex(s, sep []byte) int返回s中最后一个sep的位置，若sep为空，返回s的长度，若不含sep，则返回-1func LastIndex(s, substr string) int返回s中最后一个substr的位置，若substr为空，返回s的长度，若不含substr，则返回-1func LastIndexByte(s []byte, c byte) int返回最后一个c的位置，没有则返回-1func LastIndexByte(s string, c byte) int返回最后一个c的位置，没有则返回-1func IndexRune(s []byte, r rune) int返回第一个r的位置，如果r无法解码为utf8又不是\\uFFFD，认为没找到返回-1func IndexRune(s string, r rune) int返回第一个r的位置，如果r无法解码为utf8又不是\\uFFFD，认为没找到返回-1func IndexAny(s []byte, chars string) int返回chars中任意一个unicode字符在s中第一次出现的位置func IndexAny(s, chars string) int返回chars中任意一个unicode字符在s中第一次出现的位置func LastIndexAny(s []byte, chars string) int返回chars中任意一个unicode字符在s中最后一次出现的位置func LastIndexAny(s, chars string) int返回chars中任意一个unicode字符在s中最后一次出现的位置func genSplit(s, sep []byte, sepSave, n int) [][]byte按sep划分s，返回前n个组成的slice，每个slice中sep的保留位数有sepSave决定，n小于0时，返回所有划分组成的slicefunc genSplit(s, sep string, sepSave, n int) []string按sep划分s，返回前n个组成的slice，每个slice中sep的保留位数有sepSave决定，n小于0时，返回所有划分组成的slicefunc SplitN(s, sep []byte, n int) [][]byte按sep划分s，返回前n个划分的slice组成的slice，每个划分的slice不包含sep，n小于0返回所有划分组成的slicefunc SplitN(s, sep string, n int) []string按sep划分s，返回前n个划分的string组成的slice，每个划分的string不包含sep，n小于0返回所有划分组成的slicefunc SplitAfterN(s, sep []byte, n int) [][]byte按sep划分s，返回前n个划分的slice组成slice，每个划分包含sepfunc SplitAfterN(s, sep string, n int) []string按sep划分s，返回前n个划分的string组成slice，每个划分包含sepfunc Split(s, sep []byte) [][]byte返回所有的由sep划分的slice组成的slice，每个划分不包含sepfunc Split(s, sep string) []string返回所有的由sep划分的string组成的slice，每个划分不包含sepfunc SplitAfter(s, sep []byte) [][]byte返回所有的由sep划分的slice组成的slice，每个划分包含sepfunc SplitAfter(s, sep string) []string返回所有的由sep划分的string组成的slice，每个划分包含sepfunc Fields(s []byte) [][]byte按unicode.IsSpace划分s（所有连续的whitespce当成一个sep），返回所有的划分组成的slicefunc Fields(s string) []string按unicode.IsSpace划分s（所有连续的whitespce当成一个sep），返回所有的划分组成的slicefunc FieldsFunc(s []byte, f func(rune) bool) [][]byte如果s中对应的一个rune满足f，则这个rune就是s的一个分隔符，返回s中所有分隔符划分的子slice的slicefunc FieldsFunc(s string, f func(rune) bool) []string如果s中对应的一个rune满足f，则这个rune就是s的一个分隔符，返回s中所有分隔符划分的子string的slicefunc Join(s [][]byte, sep []byte) []byte将s中的元素用sep拼接起来，返回一个新的slicefunc Join(a []string, sep string) string 将s中的元素用sep拼接起来，返回一个新的stringfunc HasPrefix(s, prefix []byte) bool判断s是否以prefix开头func HasPrefix(s, prefix string) bool判断s是否以prefix开头func HasSuffix(s, suffix []byte) bool判断s是否以suffix结尾func HasSuffix(s, suffix string) bool判断s是否以suffix结尾func Map(mapping func(r rune) rune, s []byte) []byte将s中对应的每个rune字符作用映射f得到新的字符，再将这些字符转为utf8存储在一个新的slice中返回func Map(mapping func(rune) rune, s string) string将s中对应的每个rune字符作用映射f得到新的字符，再将这些字符存储在一个新的string中返回func Repeat(b []byte, count int) []byte重复b count次，返回新的slicefunc Repeat(s string, count int) string重复s count次，返回新的stringfunc ToUpper(s []byte) []byte转为大写func ToUpper(s string) string转为大写func ToLower(s []byte) []byte 转为小写func ToLower(s string) string转为小写func ToTitle(s []byte) []byte转为Titlefunc ToTitle(s string) string转为Titlefunc ToUpperSpecial(c unicode.SpecialCase, s []byte) []byte只将SpecialCase范围里的字符转为大写func ToUpperSpecial(c unicode.SpecialCase, s string) string只将SpecialCase范围里的字符转为大写func ToLowerSpecial(c unicode.SpecialCase, s []byte) []byte只将SpecialCase范围里的字符转为小写func ToLowerSpecial(c unicode.SpecialCase, s string) string只将SpecialCase范围里的字符转为小写func ToTitleSpecial(c unicode.SpecialCase, s []byte) []byte只将SpecialCase范围里的字符转为Titlefunc ToTitleSpecial(c unicode.SpecialCase, s string) string只将SpecialCase范围里的字符转为Titlefunc isSeparator(r rune) boolr是否可以作为一个词（unicode）的分隔符\nascii码，数字，字母，下划线不可以\n非ascii码，unicode的数字，字母不可以，剩下其他认为是unicode的space可以func isSeparator(r rune) boolr是否可以作为一个词（unicode）的分隔符\nascii码，数字，字母，下划线不可以\n非ascii码，unicode的数字，字母不可以，剩下其他认为是unicode的space可以func Title(s []byte) []byte 调用Map，s中非词分隔符的字符转换为Titlefunc Title(s string) string调用Map，s中非词分隔符的字符转换为Titlefunc TrimLeftFunc(s []byte, f func(r rune) bool) []byte以左边起第一个不满足f的rune对应的utf8码开始到s末尾的子slicefunc TrimLeftFunc(s string, f func(rune) bool) string以左边起第一个不满足f的rune对应的utf8码开始到s末尾的子stringfunc TrimRightFunc(s []byte, f func(r rune) bool) []byte以s头开始到从右边起第一个不满足f的rune对应的utf8码为终点的子slicefunc TrimRightFunc(s string, f func(rune) bool) string以s头开始到从右边起第一个不满足f的rune对应的utf8码为终点的子stringfunc TrimFunc(s []byte, f func(r rune) bool) []byte 去掉左边和去掉右边的结合体func TrimFunc(s string, f func(rune) bool) string去掉左边和去掉右边的结合体func TrimPrefix(s, prefix []byte) []byte去掉prefix后的子slicefunc TrimPrefix(s, prefix string) string去掉prefix后的子stringfunc TrimSuffix(s, suffix []byte) []byte去掉suffix后的子slicefunc TrimSuffix(s, suffix string) string去掉suffix后的子stringfunc IndexFunc(s []byte, f func(r rune) bool) int返回s中第一个满足f的rune字符对应的utf8码的起始位置func IndexFunc(s string, f func(rune) bool) int返回s中第一个满足f的rune字符对应的utf8码的起始位置func LastIndexFunc(s []byte, f func(r rune) bool) int返回s中最后一个满足f的rune字符对应的utf8码的起始位置func LastIndexFunc(s string, f func(rune) bool) int返回s中最后一个满足f的rune字符对应的utf8码的起始位置func indexFunc(s []byte, f func(r rune) bool, truth bool)返回s中第一个在f作用下得到truth的rune字符对应的utf8码的起始位置func indexFunc(s string, f func(rune) bool, truth bool) int返回s中第一个在f作用下得到truth的rune字符对应的utf8码的起始位置func lastIndexFunc(s []byte, f func(r rune) bool, truth bool) int返回s中最后一个在f作用下得到truth的rune字符对应的utf8码的起始位置func lastIndexFunc(s string, f func(rune) bool, truth bool) int返回s中最后一个在f作用下得到truth的rune字符对应的utf8码的起始位置func makeASCIISet(chars string) (as asciiSet, ok bool)返回s中碰到非ascii码之前所有ascii码的集合，以及s中是否都是ascii码\n可以把asciiSet看成是一个32字节长度的值，其中低16字节共计128位表达128个ascii码[0,127]，高16字节用来比对非ascii码\n具体存储：\nasciiSet是一个含有8个元素的数组，每个元素有32位，共计256位，\n其中元素的位置保存了该字符（uint8）对应的高3位（c5）的信息，\n元素的内容保存了每个字符低5位（1 func makeASCIISet(chars string) (as asciiSet, ok bool)返回s中碰到非ascii码之前所有ascii码的集合，以及s中是否都是ascii码\n可以把asciiSet看成是一个32字节长度的值，其中低16字节共计128位表达128个ascii码[0,127]，高16字节用来比对非ascii码\n具体存储：\nasciiSet是一个含有8个元素的数组，每个元素有32位，共计256位，\n其中元素的位置保存了该字符（uint8）对应的高3位（c5）的信息，\n元素的内容保存了每个字符低5位（1 func (as *asciiSet) contains(c byte) boolc是否在as中func (as *asciiSet) contains(c byte) boolc是否在as中func makeCutsetFunc(cutset string) func(r rune) bool返回一个判断r是否在cutset字符串中的函数\n若为单字节字符串，则返回一个直接比较r是否和cutset相同的函数\n根据cutset创建一个ascii码的集合，\n如果全是ascii，则返回一个用来判断r是否在上述集合中的函数\n如果含有非ascii，则返回一个逐一循环cutset中rune字符，判断r是否其中之一的函数func makeCutsetFunc(cutset string) func(rune) bool返回一个判断r是否在cutset字符串中的函数\n若为单字节字符串，则返回一个直接比较r是否和cutset相同的函数\n根据cutset创建一个ascii码的集合，\n如果全是ascii，则返回一个用来判断r是否在上述集合中的函数\n如果含有非ascii，则返回一个逐一循环cutset中rune字符，判断r是否其中之一的函数func Trim(s []byte, cutset string) []byte将s左右两端连续属于cutset的rune字符去除，保留中间的子slicefunc Trim(s string, cutset string) string将s左右两端连续属于cutset的rune字符去除，保留中间的子stringfunc TrimLeft(s []byte, cutset string) []byte将s左边连续属于cutset的rune字符去除，返回剩下的子slicefunc TrimLeft(s string, cutset string) string将s左边连续属于cutset的rune字符去除，返回剩下的子stringfunc TrimRight(s []byte, cutset string) []byte将s右边连续属于cutset的rune字符去除，返回剩下的子slicefunc TrimRight(s string, cutset string) string将s右边连续属于cutset的rune字符去除，返回剩下的子stringfunc TrimSpace(s []byte) []byte去除s左右两端的whitespce，保留剩下的子slicefunc TrimSpace(s string) string去除s左右两端的whitespce，保留剩下的子stringfunc Runes(s []byte) []rune返回s对应的rune类型的slicefunc Replace(s, old, new []byte, n int) []byte将s中前n个old替换成new，返回一个新的slice，n为负数或者nold个数时，替换所有oldfunc Replace(s, old, new string, n int) string将s中前n个old替换成new，返回一个新的string，n为负数或者nold个数时，替换所有oldfunc EqualFold(s, t []byte) bool判断s和t在不区分大小写（包括unicode case）的情况下是否相等func EqualFold(s, t string) bool判断s和t在不区分大小写（包括unicode case）的情况下是否相等func indexRabinKarp(s, sep []byte) int返回第一个sep在s中的位置\nRabin-Karp字符串匹配算法和前面介绍的《朴素字符串匹配算法》类似，也是对应每一个字符进行比较，不同的是Rabin-Karp采用了把字符进行预处理，也就是对每个字符进行对应进制数并取模运算，类似于通过某种函数计算其函数值，比较的是每个字符的函数值。预处理时间O(m)，匹配时间是O((n-m+1)m)。\nRabin-Karp算法的思想：\n假设待匹配字符串的长度为M，目标字符串的长度为N（NM）；\n首先计算待匹配字符串的hash值，计算目标字符串前M个字符的hash值；\n比较前面计算的两个hash值，比较次数N-M+1：\n若hash值不相等，则继续计算目标字符串的下一个长度为M的字符子串的hash值\n若hash值相同，则需要使用朴素算法再次判断是否为相同的字串；func indexRabinKarp(s, substr string) int返回第一个sep在s中的位置\nRabin-Karp字符串匹配算法和前面介绍的《朴素字符串匹配算法》类似，也是对应每一个字符进行比较，不同的是Rabin-Karp采用了把字符进行预处理，也就是对每个字符进行对应进制数并取模运算，类似于通过某种函数计算其函数值，比较的是每个字符的函数值。预处理时间O(m)，匹配时间是O((n-m+1)m)。\nRabin-Karp算法的思想：\n假设待匹配字符串的长度为M，目标字符串的长度为N（NM）；\n首先计算待匹配字符串的hash值，计算目标字符串前M个字符的hash值；\n比较前面计算的两个hash值，比较次数N-M+1：\n若hash值不相等，则继续计算目标字符串的下一个长度为M的字符子串的hash值\n若hash值相同，则需要使用朴素算法再次判断是否为相同的字串；func hashStr(sep []byte) (uint32, uint32)计算sep的hash，用于Rabin-Karp算法func hashStr(sep string) (uint32, uint32)计算sep的hash，用于Rabin-Karp算法func hashStrRev(sep string) (uint32, uint32)计算reverse(sep)的hash，用于Rabin-Karp算法","date":1515888000,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1543733643,"objectID":"a7a34993f509a5a7ef30f0dc84d1501c","permalink":"https://mooncaker816.github.io/2018/01/14/go-%E6%A0%87%E5%87%86%E5%BA%93%E5%AD%A6%E4%B9%A0/","publishdate":"2018-01-14T00:00:00Z","relpermalink":"/2018/01/14/go-%E6%A0%87%E5%87%86%E5%BA%93%E5%AD%A6%E4%B9%A0/","section":"post","summary":"bytes和strings函数比对","tags":["Go 标准库","Strings","Bytes"],"title":"Go 标准库学习","type":"post"},{"authors":null,"categories":["Golang"],"content":"Ex 9.1 Add a function Withdraw(amount int) bool to the gopl.io/ch9/bank1 program. The result should indicate whether the transaction succeeded or failed due to insufﬁcient funds. The message sent to the monitor goroutine must contain both the amount to withdraw and a new channel over which the monitor goroutine can send the boolean result back to Withdraw.\n// Copyright © 2016 Alan A. A. Donovan \u0026amp; Brian W. Kernighan. // License: https://creativecommons.org/licenses/by-nc-sa/4.0/ package bank_test import ( \u0026quot;fmt\u0026quot; \u0026quot;testing\u0026quot; \u0026quot;The_Go_Programming_Language_Exercises/CH9/ex9.1\u0026quot; ) func TestBank(t *testing.T) { done := make(chan struct{}) // Alice go func() { bank.Deposit(200) fmt.Println(\u0026quot;=\u0026quot;, bank.Balance()) done \u0026lt;- struct{}{} }() // Bob go func() { bank.Deposit(100) done \u0026lt;- struct{}{} }() go func() { fmt.Println(bank.Withdraw(500)) done \u0026lt;- struct{}{} }() // Wait for both transactions. \u0026lt;-done \u0026lt;-done \u0026lt;-done if got, want := bank.Balance(), 300; got != want { t.Errorf(\u0026quot;Balance = %d, want %d\u0026quot;, got, want) } }  Ex 9.2 Rewrite the PopCount example from Section 2.6.2 so that it initializes the l table using sync.Once the ﬁrst time it is needed. (Realistically, the cost of synchronization would be prohibitive for a small and highly optimized function like PopCount.)\n// Copyright © 2016 Alan A. A. Donovan \u0026amp; Brian W. Kernighan. // License: https://creativecommons.org/licenses/by-nc-sa/4.0/ // See page 45. // (Package doc comment intentionally malformed to demonstrate golint.) //!+ package popcount import \u0026quot;sync\u0026quot; // pc[i] is the population count of i. var pc [256]byte var loadpcOnce sync.Once //func init() { //\tfor i := range pc { //\tpc[i] = pc[i/2] + byte(i\u0026amp;1) //\t} //} // PopCount returns the population count (number of set bits) of x. func PopCount(x uint64) int { loadpcOnce.Do(loadpc) return int(pc[byte(x\u0026gt;\u0026gt;(0*8))] + pc[byte(x\u0026gt;\u0026gt;(1*8))] + pc[byte(x\u0026gt;\u0026gt;(2*8))] + pc[byte(x\u0026gt;\u0026gt;(3*8))] + pc[byte(x\u0026gt;\u0026gt;(4*8))] + pc[byte(x\u0026gt;\u0026gt;(5*8))] + pc[byte(x\u0026gt;\u0026gt;(6*8))] + pc[byte(x\u0026gt;\u0026gt;(7*8))]) } func loadpc() { for i := range pc { pc[i] = pc[i/2] + byte(i\u0026amp;1) } } //!-  Ex 9.3 Extend the Func type and the (*Memo).Get method so that callers may provide an optional done channel through which they can cancel the operation (§8.9). The results of a cancelled Func call should not be cached.\n// Copyright © 2016 Alan A. A. Donovan \u0026amp; Brian W. Kernighan. // License: https://creativecommons.org/licenses/by-nc-sa/4.0/ // See page 278. // Package memo provides a concurrency-safe non-blocking memoization // of a function. Requests for different keys proceed in parallel. // Concurrent requests for the same key block until the first completes. // This implementation uses a monitor goroutine. package memo import \u0026quot;errors\u0026quot; import \u0026quot;time\u0026quot; //!+Func // Func is the type of the function to memoize. type Func func(key string) (interface{}, error) // A result is the result of calling a Func. type result struct { value interface{} err error } type entry struct { res result ready chan struct{} // closed when res is ready } //!-Func //!+get // A request is a message requesting that the Func be applied to key. type request struct { key string response chan\u0026lt;- result // the client wants a single result } type Memo struct{ requests chan request } // New returns a memoization of f. Clients must subsequently call Close. func New(f Func) *Memo { memo := \u0026amp;Memo{requests: make(chan request)} go memo.server(f) return memo } func (memo *Memo) Get(key string) (interface{}, error) { response := make(chan result) memo.requests \u0026lt;- request{key, response} res := \u0026lt;-response return res.value, res.err } func (memo *Memo) Close() { close(memo.requests) } //!-get //!+monitor func (memo *Memo) server(f Func) { var done = make(chan struct{}) // Cancel traversal when input is detected. go func() { //os.Stdin.Read(make([]byte, 1)) // read a single byte time.Sleep(300 * time.Millisecond) close(done) }() cancelled := func() bool { select { case \u0026lt;-done: return true default: return false } } cache := make(map[string]*entry) for req := range memo.requests { if cancelled() { //close(memo.requests) break } e := cache[req.key] if e == nil { // This is the first request for this key. e = \u0026amp;entry{ready: make(chan struct{})} cache[req.key] = e go e.call(f, req.key) // call f(key) if cancelled() { delete(cache, req.key) } } go e.deliver(req.response, done) } } func (e *entry) call(f Func, key string) { // Evaluate the function. e.res.value, e.res.err = f(key) // Broadcast the ready condition. close(e.ready) } func (e *entry) deliver(response chan\u0026lt;- result, done \u0026lt;-chan struct{}) { // Wait for the ready condition. select { case \u0026lt;-e.ready: response \u0026lt;- e.res case \u0026lt;-done: response \u0026lt;- result{nil, errors.New(\u0026quot;request cancelled\u0026quot;)} } } ","date":1515024000,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1543733643,"objectID":"063ea8f7125fb15fbeae2dc58e9bcb54","permalink":"https://mooncaker816.github.io/2018/01/04/the-go-programming-language-ex11/","publishdate":"2018-01-04T00:00:00Z","relpermalink":"/2018/01/04/the-go-programming-language-ex11/","section":"post","summary":"Ex 9.1 Add a function Withdraw(amount int) bool to the gopl.io/ch9/bank1 program. The result should indicate whether the transaction succeeded or failed due to insufﬁcient funds. The message sent to the monitor goroutine must contain both the amount to withdraw and a new channel over which the monitor goroutine can send the boolean result back to Withdraw.\n","tags":["The Go Programming Language Ex","Go goroutine","Go cache store"],"title":"The Go Programming Language Ex（11）","type":"post"},{"authors":null,"categories":["Golang"],"content":"Ex 8.6 Add depth-limiting to the concurrent crawler. That is, if the user sets -depth=3, then only URLs reachable by at most three links will be fetched.\n// Copyright © 2016 Alan A. A. Donovan \u0026amp; Brian W. Kernighan. // License: https://creativecommons.org/licenses/by-nc-sa/4.0/ // See page 241. // Crawl2 crawls web links starting with the command-line arguments. // // This version uses a buffered channel as a counting semaphore // to limit the number of concurrent calls to links.Extract. package main import ( \u0026quot;fmt\u0026quot; \u0026quot;log\u0026quot; \u0026quot;os\u0026quot; \u0026quot;gopl.io/ch5/links\u0026quot; ) //!+sema // tokens is a counting semaphore used to // enforce a limit of 20 concurrent requests. var tokens = make(chan struct{}, 20) func crawl(url string, deepth int, f *os.File) work { tokens \u0026lt;- struct{}{} // acquire a token list, err := links.Extract(url) fmt.Fprintln(f, deepth, \u0026quot; \u0026quot;, url, \u0026quot; \u0026quot;, len(list)) \u0026lt;-tokens // release the token deepth++ if err != nil { log.Print(err) } return work{list, deepth} } //!-sema type work struct { worklist []string workdeepth int } const DEEPTH = 2 //!+ func main() { wkpool := make(chan work) var n int // number of pending sends to worklist f, _ := os.Create(\u0026quot;stat\u0026quot;) defer f.Close() // Start with the command-line arguments. n++ go func() { wkpool \u0026lt;- work{os.Args[1:], 0} }() // Crawl the web concurrently. seen := make(map[string]bool) for ; n \u0026gt; 0; n-- { wk := \u0026lt;-wkpool if wk.workdeepth \u0026gt; DEEPTH { continue } for _, link := range wk.worklist { if !seen[link] { seen[link] = true n++ go func(link string, deepth int, f *os.File) { wkpool \u0026lt;- crawl(link, deepth, f) }(link, wk.workdeepth, f) } } } }  Ex 8.8 Using a select statement, add a timeout to the echo server from Section 8.3 so that it disconnects any client that shouts nothing within 10 seconds.\n//client package main import ( \u0026quot;io\u0026quot; \u0026quot;log\u0026quot; \u0026quot;net\u0026quot; \u0026quot;os\u0026quot; ) func init() { log.SetFlags(log.Ldate | log.Lmicroseconds) } //!+ func main() { f, err := os.Open(\u0026quot;a\u0026quot;) defer f.Close() conn, err := net.Dial(\u0026quot;tcp\u0026quot;, \u0026quot;localhost:8000\u0026quot;) if err != nil { log.Fatal(err) } log.Println(\u0026quot;connected!\u0026quot;) done := make(chan struct{}) go func() { io.Copy(os.Stdout, conn) // NOTE: ignoring errors log.Println(\u0026quot;done\u0026quot;) done \u0026lt;- struct{}{} // signal the main goroutine }() go func() { mustCopy(conn, os.Stdin) //conn.Close() err = conn.(*net.TCPConn).CloseWrite() //经实验：必须要关，否则无法通知服务端输入已结束（但不应该是服务端根据EOF来判断吗？） log.Println(\u0026quot;write finished in client: \u0026quot;, err) }() \u0026lt;-done // wait for background goroutine to finish log.Printf(\u0026quot;local in server: %#v\\n\u0026quot;, conn.LocalAddr()) log.Printf(\u0026quot;remote in server: %#v\\n\u0026quot;, conn.RemoteAddr()) log.Println(\u0026quot;finish print\u0026quot;) //err = conn.(*net.TCPConn).CloseRead() //log.Println(\u0026quot;read finished in client: \u0026quot;, err) err = conn.Close() log.Println(err) } //!- func mustCopy(dst io.Writer, src io.Reader) { if _, err := io.Copy(dst, src); err != nil { log.Fatal(err) } }  //server // Copyright © 2016 Alan A. A. Donovan \u0026amp; Brian W. Kernighan. // License: https://creativecommons.org/licenses/by-nc-sa/4.0/ // See page 224. // Reverb2 is a TCP server that simulates an echo. package main import ( \u0026quot;bufio\u0026quot; \u0026quot;fmt\u0026quot; \u0026quot;log\u0026quot; \u0026quot;net\u0026quot; \u0026quot;strings\u0026quot; \u0026quot;sync\u0026quot; \u0026quot;time\u0026quot; ) func init() { log.SetFlags(log.Ldate | log.Lmicroseconds) } func echo(c net.Conn, shout string, delay time.Duration, wg *sync.WaitGroup) { defer wg.Done() fmt.Fprintln(c, \u0026quot;\\t\u0026quot;, strings.ToUpper(shout)) time.Sleep(delay) fmt.Fprintln(c, \u0026quot;\\t\u0026quot;, shout) time.Sleep(delay) fmt.Fprintln(c, \u0026quot;\\t\u0026quot;, strings.ToLower(shout)) } //!+ func handleConn(c net.Conn) { msg := make(chan string) go func(c net.Conn) { //for { input := bufio.NewScanner(c) for input.Scan() { fmt.Println(\u0026quot;getting: \u0026quot;, input.Text()) msg \u0026lt;- input.Text() } msg \u0026lt;- \u0026quot;eof\u0026quot; //} }(c) ticker := time.NewTicker(5 * time.Second) var wg sync.WaitGroup label1: for { select { case \u0026lt;-ticker.C: ticker.Stop() c.Close() fmt.Println(\u0026quot;connect closed!!\u0026quot;) return case s := \u0026lt;-msg: if s == \u0026quot;eof\u0026quot; { break label1 } ticker.Stop() fmt.Println(s) wg.Add(1) go echo(c, s, 1*time.Second, \u0026amp;wg) } } // NOTE: ignoring potential errors from input.Err() //err := c.(*net.TCPConn).CloseRead() //log.Println(\u0026quot;read finished in server: \u0026quot;, err) log.Println(\u0026quot;finish scan\u0026quot;) log.Printf(\u0026quot;local in server: %#v\\n\u0026quot;, c.LocalAddr()) log.Printf(\u0026quot;remote in server: %#v\\n\u0026quot;, c.RemoteAddr()) wg.Wait() err := c.(*net.TCPConn).CloseWrite() //err := c.Close() log.Println(\u0026quot;finished in server: \u0026quot;, err) } //!- func main() { l, err := net.Listen(\u0026quot;tcp\u0026quot;, \u0026quot;localhost:8000\u0026quot;) if err != nil { log.Fatal(err) } for { conn, err := l.Accept() if err != nil { log.Print(err) // e.g., connection aborted continue } go handleConn(conn) } }  //client $ ./ex8.3 2018/01/03 17:01:15.985187 connected! 2018/01/03 17:01:20.989292 done 2018/01/03 17:01:20.989515 local in server: \u0026amp;net.TCPAddr{IP:net.IP{0x7f, 0x0, 0x0, 0x1}, Port:49954, Zone:\u0026quot;\u0026quot;} 2018/01/03 17:01:20.989576 remote in server: \u0026amp;net.TCPAddr{IP:net.IP{0x7f, 0x0, 0x0, 0x1}, Port:8000, Zone:\u0026quot;\u0026quot;} 2018/01/03 17:01:20.989596 finish print 2018/01/03 17:01:20.989774 \u0026lt;nil\u0026gt;  //server ./ex8.8 2018/01/03 17:01:20.989248 connect closed!! 127.0.0.1:8000 127.0.0.1:49954  Ex 8.9 // Copyright © 2016 Alan A. A. Donovan \u0026amp; Brian W. Kernighan. // License: https://creativecommons.org/licenses/by-nc-sa/4.0/ // See page 250. // The du3 command computes the disk usage of the files in a directory. package main // The du3 variant traverses all directories in parallel. // It uses a concurrency-limiting counting semaphore // to avoid opening too many files at once. import ( \u0026quot;flag\u0026quot; \u0026quot;io/ioutil\u0026quot; \u0026quot;log\u0026quot; \u0026quot;os\u0026quot; \u0026quot;path/filepath\u0026quot; \u0026quot;sync\u0026quot; \u0026quot;time\u0026quot; ) var vFlag = flag.Bool(\u0026quot;v\u0026quot;, false, \u0026quot;show verbose progress messages\u0026quot;) func init() { log.SetFlags(log.Ldate | log.Lmicroseconds) } //!+ func main() { // ...determine roots... //!- flag.Parse() // Determine the initial directories. roots := flag.Args() if len(roots) == 0 { roots = []string{\u0026quot;.\u0026quot;} } //!+ // Traverse each root of the file tree in parallel. //fileSizes := make(chan int64) var m sync.WaitGroup for _, root := range roots { var tick \u0026lt;-chan time.Time if *vFlag { tick = time.Tick(100 * time.Millisecond) } var fileSizes chan int64 var n sync.WaitGroup fileSizes = make(chan int64) n.Add(1) go walkDir(root, \u0026amp;n, fileSizes) go func() { n.Wait() close(fileSizes) }() m.Add(1) go func(root string, tick \u0026lt;-chan time.Time) { defer m.Done() var nfiles, nbytes int64 loop: for { select { case size, ok := \u0026lt;-fileSizes: if !ok { break loop // fileSizes was closed } nfiles++ nbytes += size case \u0026lt;-tick: printDiskUsage(root, nfiles, nbytes) } } printDiskUsage(root, nfiles, nbytes) // final totals }(root, tick) } m.Wait() } //!- func printDiskUsage(root string, nfiles, nbytes int64) { log.Printf(\u0026quot;%s: %d files %.1f GB\\n\u0026quot;, root, nfiles, float64(nbytes)/1e9) } // walkDir recursively walks the file tree rooted at dir // and sends the size of each found file on fileSizes. //!+walkDir func walkDir(dir string, n *sync.WaitGroup, fileSizes chan\u0026lt;- int64) { defer n.Done() for _, entry := range dirents(dir) { if entry.IsDir() { n.Add(1) subdir := filepath.Join(dir, entry.Name()) go walkDir(subdir, n, fileSizes) } else { fileSizes \u0026lt;- entry.Size() } } } //!-walkDir //!+sema // sema is a counting semaphore for limiting concurrency in dirents. var sema = make(chan struct{}, 20) // dirents returns the entries of directory dir. func dirents(dir string) []os.FileInfo { sema \u0026lt;- struct{}{} // acquire token defer func() { \u0026lt;-sema }() // release token // ... //!-sema entries, err := ioutil.ReadDir(dir) if err != nil { //fmt.Fprintf(os.Stderr, \u0026quot;du: %v\\n\u0026quot;, err) return nil } return entries }  $ ./ex8.9 -v /etc /usr /bin /var 2018/01/03 20:36:21.368337 /bin: 36 files 0.0 GB 2018/01/03 20:36:21.370797 /etc: 308 files 0.0 GB 2018/01/03 20:36:21.483464 /var: 2270 files 6.1 GB 2018/01/03 20:36:21.483846 /usr: 4322 files 1.9 GB 2018/01/03 20:36:21.571401 /var: 2449 files 6.3 GB 2018/01/03 20:36:21.599092 /usr: 9322 files 2.1 GB 2018/01/03 20:36:21.678850 /usr: 18130 files 2.6 GB 2018/01/03 20:36:21.782177 /usr: 47807 files 3.2 GB 2018/01/03 20:36:21.872339 /usr: 65859 files 3.7 GB 2018/01/03 20:36:21.920744 /usr: 89008 files 3.9 GB  Ex 8.12 Make the broadcaster announce the current set of clients to each new arrival. This requires that the clients set and the entering and leaving channels record the client name too.\nEx 8.13 Make the chat server disconnect idle clients, such as those that have sent no messages in the last ﬁve minutes. Hint: calling conn.Close() in another goroutine unblocks active Read calls such as the one done by input.Scan().\nEx 8.14 Change the chat server’s network protocol so that each client provides its name on entering. Use that name instead of the network address when preﬁxing each message with its sender’s identity.\n只需要添加自定义协议，在压包解包的时候按协议进行就行，待做。。。\nEx 8.15 Failure of any client program to read data in a timely manner ultimately causes all clients to get stuck. Modify the broadcaster to skip a message rather than wait if a client writer is not ready to accept it. Alternatively, add buffering to each client’s outgoing message channel so that most messages are not dropped; the broadcaster should use a non-blocking send to this channel.\n将broadcaster中向各个客户端发送消息的部分写入go routine，并将客户端发送通道定义为缓存通道\n// Copyright © 2016 Alan A. A. Donovan \u0026amp; Brian W. Kernighan. // License: https://creativecommons.org/licenses/by-nc-sa/4.0/ // See page 254. //!+ // Chat is a server that lets clients chat with each other. package main import ( \u0026quot;bufio\u0026quot; \u0026quot;fmt\u0026quot; \u0026quot;log\u0026quot; \u0026quot;net\u0026quot; \u0026quot;time\u0026quot; ) //!+broadcaster type client chan\u0026lt;- string // an outgoing message channel var ( entering = make(chan client) leaving = make(chan client) messages = make(chan string) // all incoming client messages ) func broadcaster() { clients := make(map[client]bool) // all connected clients for { select { case msg := \u0026lt;-messages: // Broadcast incoming message to all // clients' outgoing message channels. for cli := range clients { cli \u0026lt;- msg } case cli := \u0026lt;-entering: clients[cli] = true case cli := \u0026lt;-leaving: delete(clients, cli) close(cli) } } } //!-broadcaster //!+handleConn func handleConn(conn net.Conn) { inittime := time.Now() itimestr := \u0026quot;[\u0026quot; + inittime.Format(\u0026quot;2006-01-02 15:04:05\u0026quot;) + \u0026quot;]\u0026quot; ch := make(chan string) // outgoing client messages go clientWriter(conn, ch) lastmsgtime := make(chan time.Time) who := conn.RemoteAddr().String() go func(t time.Time) { for { select { case t = \u0026lt;-lastmsgtime: default: } if time.Now().After(t.Add(20 * time.Second)) { ch \u0026lt;- fmt.Sprintf(\u0026quot;[%s] no msg in last 20 sec since %s, closing connect!\u0026quot;, time.Now().Format(\u0026quot;2006-01-02 15:04:05\u0026quot;), t.Format(\u0026quot;2006-01-02 15:04:05\u0026quot;)) time.Sleep(1 * time.Second) conn.Close() //leaving \u0026lt;- ch //messages \u0026lt;- who + \u0026quot; has left\u0026quot; break } } }(inittime) ch \u0026lt;- itimestr + \u0026quot; \u0026quot; + \u0026quot;You are \u0026quot; + who messages \u0026lt;- itimestr + \u0026quot; \u0026quot; + who + \u0026quot; has arrived\u0026quot; entering \u0026lt;- ch input := bufio.NewScanner(conn) for input.Scan() { messages \u0026lt;- \u0026quot;[\u0026quot; + time.Now().Format(\u0026quot;2006-01-02 15:04:05\u0026quot;) + \u0026quot;]\u0026quot; + \u0026quot; \u0026quot; + who + \u0026quot;: \u0026quot; + input.Text() lastmsgtime \u0026lt;- time.Now() } // NOTE: ignoring potential errors from input.Err() leaving \u0026lt;- ch messages \u0026lt;- \u0026quot;[\u0026quot; + time.Now().Format(\u0026quot;2006-01-02 15:04:05\u0026quot;) + \u0026quot;]\u0026quot; + \u0026quot; \u0026quot; + who + \u0026quot; has left\u0026quot; conn.Close() } func clientWriter(conn net.Conn, ch \u0026lt;-chan string) { for msg := range ch { fmt.Fprintln(conn, msg) // NOTE: ignoring network errors } } //!-handleConn //!+main func main() { listener, err := net.Listen(\u0026quot;tcp\u0026quot;, \u0026quot;localhost:8000\u0026quot;) if err != nil { log.Fatal(err) } go broadcaster() for { conn, err := listener.Accept() if err != nil { log.Print(err) continue } go handleConn(conn) } }  $ ./netcat1 [2018-01-04 01:09:14] You are 127.0.0.1:55627 [2018-01-04 01:09:18] 127.0.0.1:55630 has arrived [2018-01-04 01:09:20] 127.0.0.1:55630: sdf [2018-01-04 01:09:24] 127.0.0.1:55635 has arrived [2018-01-04 01:09:28] 127.0.0.1:55635: ththth [2018-01-04 01:09:34] no msg in last 20 sec since 2018-01-04 01:09:14, closing connect! 2018/01/04 01:09:35 done $ ./netcat2 [2018-01-04 01:09:18] You are 127.0.0.1:55630 sdf [2018-01-04 01:09:20] 127.0.0.1:55630: sdf [2018-01-04 01:09:24] 127.0.0.1:55635 has arrived [2018-01-04 01:09:28] 127.0.0.1:55635: ththth [2018-01-04 01:09:35] 127.0.0.1:55627 has left [2018-01-04 01:09:40] no msg in last 20 sec since 2018-01-04 01:09:20, closing connect! 2018/01/04 01:09:41 done $ ./netcat3 [2018-01-04 01:09:24] You are 127.0.0.1:55635 ththth [2018-01-04 01:09:28] 127.0.0.1:55635: ththth [2018-01-04 01:09:35] 127.0.0.1:55627 has left [2018-01-04 01:09:41] 127.0.0.1:55630 has left [2018-01-04 01:09:48] no msg in last 20 sec since 2018-01-04 01:09:28, closing connect! 2018/01/04 01:09:49 done ","date":1514937600,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1543733643,"objectID":"47a89c75c4341e37d8b46838e0a087da","permalink":"https://mooncaker816.github.io/2018/01/03/the-go-programming-language-ex10/","publishdate":"2018-01-03T00:00:00Z","relpermalink":"/2018/01/03/the-go-programming-language-ex10/","section":"post","summary":"Ex 8.6 Add depth-limiting to the concurrent crawler. That is, if the user sets -depth=3, then only URLs reachable by at most three links will be fetched.\n","tags":["The Go Programming Language Ex","Go goroutine","Go breadth first crawler","Go select","Go chat room"],"title":"The Go Programming Language Ex（10）","type":"post"},{"authors":null,"categories":["Golang"],"content":"Ex 8.1 Modify clock2 to accept a port number, and write a program, clockwall, that acts as a client of several clock servers at once, reading the times from each one and displaying the results in a table, akin to the wall of clocks seen in some business ofﬁces. If you have access to geographically distributed computers, run instances remotely ; otherwise run local instances on different ports with fake time zones.\n$ TZ=US/Eastern ./clock2 -port 8010 \u0026amp; $ TZ=Asia/Tokyo ./clock2 -port 8020 \u0026amp; $ TZ=Europe/London ./clock2 -port 8030 \u0026amp; $ clockwall NewYork=localhost:8010 London=localhost:8020 Tokyo=localhost:8030\n//clockwall package main import ( \u0026quot;html/template\u0026quot; \u0026quot;log\u0026quot; \u0026quot;net\u0026quot; \u0026quot;net/http\u0026quot; ) type City struct { Name string Addr string Time string } type cities []City const templ = ` \u0026lt;h1\u0026gt;current times:\u0026lt;/h1\u0026gt; \u0026lt;table\u0026gt; \u0026lt;tr style='text-align: left'\u0026gt; \u0026lt;th\u0026gt;City\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;Time\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; {{range . }} \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;{{.Name}}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{.Time}}\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; {{end}} \u0026lt;/table\u0026gt; ` var report = template.Must(template.New(\u0026quot;result\u0026quot;). Parse(templ)) var cs = cities{ {\u0026quot;NewYork\u0026quot;, \u0026quot;localhost:8010\u0026quot;, \u0026quot;\u0026quot;}, {\u0026quot;Tokyo\u0026quot;, \u0026quot;localhost:8020\u0026quot;, \u0026quot;\u0026quot;}, {\u0026quot;London\u0026quot;, \u0026quot;localhost:8030\u0026quot;, \u0026quot;\u0026quot;}, } func main() { for i := range cs { go func(c *City) { conn, err := net.Dial(\u0026quot;tcp\u0026quot;, c.Addr) if err != nil { log.Fatal(err) } defer conn.Close() buf := make([]byte, 20) for { n, _ := conn.Read(buf) c.Time = string(buf[:n]) } }(\u0026amp;cs[i]) } http.HandleFunc(\u0026quot;/gettime\u0026quot;, cs.gettime) log.Fatal(http.ListenAndServe(\u0026quot;localhost:8000\u0026quot;, nil)) } func (cs cities) gettime(w http.ResponseWriter, req *http.Request) { if err := report.Execute(w, cs); err != nil { log.Fatal(err) } }  //clock package main import ( \u0026quot;flag\u0026quot; \u0026quot;io\u0026quot; \u0026quot;log\u0026quot; \u0026quot;net\u0026quot; \u0026quot;time\u0026quot; ) func handleConn(c net.Conn) { defer c.Close() for { _, err := io.WriteString(c, time.Now().Format(\u0026quot;15:04:05\\n\u0026quot;)) if err != nil { return // e.g., client disconnected } time.Sleep(1 * time.Second) } } func main() { port := flag.String(\u0026quot;port\u0026quot;, \u0026quot;8000\u0026quot;, \u0026quot;port num\u0026quot;) flag.Parse() address := \u0026quot;localhost:\u0026quot; + *port listener, err := net.Listen(\u0026quot;tcp\u0026quot;, address) if err != nil { log.Fatal(err) } //!+ for { conn, err := listener.Accept() if err != nil { log.Print(err) // e.g., connection aborted continue } go handleConn(conn) // handle connections concurrently } //!- }  //启动服务器 TZ=US/Eastern ./clock -port 8010 \u0026amp; TZ=Asia/Tokyo ./clock -port 8020 \u0026amp; TZ=Europe/London ./clock -port 8030  Ex 8.3 In netcat3, the interface value conn has the concrete type *net.TCPConn, which represents a TCP connection. A TCP connection consists of two halves that may be closed independently using its CloseRead and CloseWrite methods. Modify the main goroutine of netcat3 to close only the write half of the connection so that the program will continue to print the ﬁnal echoes from the reverb1 server even after the standard input has been closed. (Doing this for the reverb2 server is harder; see Exercise 8.4.)\npackage main import ( \u0026quot;io\u0026quot; \u0026quot;log\u0026quot; \u0026quot;net\u0026quot; \u0026quot;os\u0026quot; ) //!+ func main() { conn, err := net.Dial(\u0026quot;tcp\u0026quot;, \u0026quot;localhost:8000\u0026quot;) if err != nil { log.Fatal(err) } done := make(chan struct{}) go func() { io.Copy(os.Stdout, conn) // NOTE: ignoring errors log.Println(\u0026quot;done\u0026quot;) done \u0026lt;- struct{}{} // signal the main goroutine }() mustCopy(conn, os.Stdin) //conn.Close() if conn, ok := conn.(*net.TCPConn); ok { conn.CloseWrite() } \u0026lt;-done // wait for background goroutine to finish } //!- func mustCopy(dst io.Writer, src io.Reader) { if _, err := io.Copy(dst, src); err != nil { log.Fatal(err) } }  Ex 8.4 Modify the reverb2 server to use a sync.WaitGroup per connection to count the number of active echo goroutines. When it falls to zero, close the write half of the TCP connection as described in Exercise 8.3. Verify that your modiﬁed netcat3 client from that exercise waits for the ﬁnal echoes of multiple concurrent shouts, even after the standard input has been closed.\n//client package main import ( \u0026quot;io\u0026quot; \u0026quot;log\u0026quot; \u0026quot;net\u0026quot; \u0026quot;os\u0026quot; ) func init() { log.SetFlags(log.Ldate | log.Lmicroseconds) } //!+ func main() { f, err := os.Open(\u0026quot;a\u0026quot;) defer f.Close() conn, err := net.Dial(\u0026quot;tcp\u0026quot;, \u0026quot;localhost:8000\u0026quot;) if err != nil { log.Fatal(err) } done := make(chan struct{}) go func() { io.Copy(os.Stdout, conn) // NOTE: ignoring errors log.Println(\u0026quot;done\u0026quot;) done \u0026lt;- struct{}{} // signal the main goroutine }() mustCopy(conn, f) //conn.Close() log.Printf(\u0026quot;local in server: %#v\\n\u0026quot;, conn.LocalAddr()) log.Printf(\u0026quot;remote in server: %#v\\n\u0026quot;, conn.RemoteAddr()) err = conn.(*net.TCPConn).CloseWrite() //经实验：必须要关，否则无法通知服务端输入已结束（但不应该是服务端根据EOF来判断吗？） log.Println(\u0026quot;write finished in client: \u0026quot;, err) \u0026lt;-done // wait for background goroutine to finish log.Println(\u0026quot;finish print\u0026quot;) //err = conn.(*net.TCPConn).CloseRead() //log.Println(\u0026quot;read finished in client: \u0026quot;, err) err = conn.Close() log.Println(err) } //!- func mustCopy(dst io.Writer, src io.Reader) { if _, err := io.Copy(dst, src); err != nil { log.Fatal(err) } }  //server // Copyright © 2016 Alan A. A. Donovan \u0026amp; Brian W. Kernighan. // License: https://creativecommons.org/licenses/by-nc-sa/4.0/ // See page 224. // Reverb2 is a TCP server that simulates an echo. package main import ( \u0026quot;bufio\u0026quot; \u0026quot;fmt\u0026quot; \u0026quot;log\u0026quot; \u0026quot;net\u0026quot; \u0026quot;strings\u0026quot; \u0026quot;sync\u0026quot; \u0026quot;time\u0026quot; ) func init() { log.SetFlags(log.Ldate | log.Lmicroseconds) } func echo(c net.Conn, shout string, delay time.Duration, wg *sync.WaitGroup) { defer wg.Done() fmt.Fprintln(c, \u0026quot;\\t\u0026quot;, strings.ToUpper(shout)) time.Sleep(delay) fmt.Fprintln(c, \u0026quot;\\t\u0026quot;, shout) time.Sleep(delay) fmt.Fprintln(c, \u0026quot;\\t\u0026quot;, strings.ToLower(shout)) } //!+ func handleConn(c net.Conn) { input := bufio.NewScanner(c) var wg sync.WaitGroup for input.Scan() { wg.Add(1) go echo(c, input.Text(), 1*time.Second, \u0026amp;wg) fmt.Println(input.Text()) } // NOTE: ignoring potential errors from input.Err() //err := c.(*net.TCPConn).CloseRead() //log.Println(\u0026quot;read finished in server: \u0026quot;, err) log.Println(\u0026quot;finish scan\u0026quot;) log.Printf(\u0026quot;local in server: %#v\\n\u0026quot;, c.LocalAddr()) log.Printf(\u0026quot;remote in server: %#v\\n\u0026quot;, c.RemoteAddr()) wg.Wait() err := c.(*net.TCPConn).CloseWrite() //err := c.Close() log.Println(\u0026quot;finished in server: \u0026quot;, err) } //!- func main() { l, err := net.Listen(\u0026quot;tcp\u0026quot;, \u0026quot;localhost:8000\u0026quot;) if err != nil { log.Fatal(err) } for { conn, err := l.Accept() if err != nil { log.Print(err) // e.g., connection aborted continue } go handleConn(conn) } }  //client $ ./ex8.3 2018/01/02 08:56:18.122881 local in server: \u0026amp;net.TCPAddr{IP:net.IP{0x7f, 0x0, 0x0, 0x1}, Port:59580, Zone:\u0026quot;\u0026quot;} 2018/01/02 08:56:18.123015 remote in server: \u0026amp;net.TCPAddr{IP:net.IP{0x7f, 0x0, 0x0, 0x1}, Port:8000, Zone:\u0026quot;\u0026quot;} 2018/01/02 08:56:18.123035 write finished in client: \u0026lt;nil\u0026gt; A F B C D E G e b c f d g a e a d b f c g 2018/01/02 08:56:20.125582 done 2018/01/02 08:56:20.125625 finish print 2018/01/02 08:56:20.125699 \u0026lt;nil\u0026gt;  //server $ ./ex8.4 a b c d e f g 2018/01/02 08:56:18.123125 finish scan 2018/01/02 08:56:18.123409 local in server: \u0026amp;net.TCPAddr{IP:net.IP{0x7f, 0x0, 0x0, 0x1}, Port:8000, Zone:\u0026quot;\u0026quot;} 2018/01/02 08:56:18.123427 remote in server: \u0026amp;net.TCPAddr{IP:net.IP{0x7f, 0x0, 0x0, 0x1}, Port:59580, Zone:\u0026quot;\u0026quot;} 2018/01/02 08:56:20.125383 finished in server: \u0026lt;nil\u0026gt;   conn是双向的（从各自local，remote属性相反可以看出），客户端本身对连接的关闭，只会影响客户端本身通过该连接的相关操作，不会影响服务器端连接；反之亦然！ 经过实验，客户端通过标准输入向conn写入消息时，即使写入EOF，服务器端也还会继续等待客户端输入的到来，只有当客户端CloseWrite()后，服务器端才会放弃等待输入，继续后面的逻辑；反之服务器端写，客户端读，也是这种情况。似乎与练习要达到的效果有些出入（手动ctrl-d，文件EOF都不行）~ ","date":1514764800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1543733643,"objectID":"284a5265ab060633d3caa934e94ce8f6","permalink":"https://mooncaker816.github.io/2018/01/01/the-go-programming-language-ex9/","publishdate":"2018-01-01T00:00:00Z","relpermalink":"/2018/01/01/the-go-programming-language-ex9/","section":"post","summary":"Ex 8.1 Modify clock2 to accept a port number, and write a program, clockwall, that acts as a client of several clock servers at once, reading the times from each one and displaying the results in a table, akin to the wall of clocks seen in some business ofﬁces. If you have access to geographically distributed computers, run instances remotely ; otherwise run local instances on different ports with fake time zones.\n","tags":["The Go Programming Language Ex","Go goroutine","Go TCP Conn"],"title":"The Go Programming Language Ex（9）","type":"post"},{"authors":null,"categories":["Golang"],"content":"Ex 7.1 Using the ideas from ByteCounter, implement counters for words and for lines. You will ﬁnd bufio.ScanWords useful.\npackage main import ( \u0026quot;bufio\u0026quot; \u0026quot;bytes\u0026quot; \u0026quot;fmt\u0026quot; ) func main() { var c ByteCounter c.Write([]byte(\u0026quot;hello\u0026quot;)) fmt.Println(c) // \u0026quot;5\u0026quot;, = len(\u0026quot;hello\u0026quot;) c = 0 // reset the counter var name = \u0026quot;Dolly\u0026quot; fmt.Fprintf(\u0026amp;c, \u0026quot;hello, %s\u0026quot;, name) fmt.Println(c) // \u0026quot;12\u0026quot;, = len(\u0026quot;hello, Dolly\u0026quot;) var w WordCounter w.Write([]byte(\u0026quot;hello world, 世界\u0026quot;)) fmt.Println(w) w = 0 var str = \u0026quot;你 好\u0026quot; fmt.Fprintf(\u0026amp;w, \u0026quot;hello, %s\u0026quot;, str) fmt.Println(w) var l LineCounter l.Write([]byte(\u0026quot;hello world, 世界\\nabc\\nosjoij\\nwefw\u0026quot;)) fmt.Println(l) } type ByteCounter int func (c *ByteCounter) Write(p []byte) (int, error) { *c += ByteCounter(len(p)) // convert int to ByteCounter return len(p), nil } type WordCounter int func (w *WordCounter) Write(p []byte) (int, error) { scanner := bufio.NewScanner(bytes.NewReader(p)) scanner.Split(bufio.ScanWords) var count int for scanner.Scan() { count++ } *w += WordCounter(count) return count, nil } type LineCounter int func (l *LineCounter) Write(p []byte) (int, error) { scanner := bufio.NewScanner(bytes.NewReader(p)) scanner.Split(bufio.ScanLines) var count int for scanner.Scan() { count++ } *l += LineCounter(count) return count, nil }  $ go run counter.go 5 12 3 3 4  Ex 7.2 Write a function CountingWriter with the signature below that, given an io.Writer, returns a new Writer that wraps the original, and a pointer to an int64 variable that at any moment contains the number of bytes written to the new Writer.\nfunc CountingWriter(w io.Writer) (io.Writer, *int64)\npackage main import ( \u0026quot;fmt\u0026quot; \u0026quot;io\u0026quot; \u0026quot;os\u0026quot; ) type byteCounter struct { n int64 w io.Writer } func (c *byteCounter) Write(p []byte) (int, error) { c.n += int64(len(p)) var err error if c.w != nil { _, err = c.w.Write(p) } return len(p), err } func CountingWriter(w io.Writer) (io.Writer, *int64) { var b byteCounter b.w = w return \u0026amp;b, \u0026amp;b.n } func main() { w, n := CountingWriter(os.Stdout) fmt.Fprintf(w, \u0026quot;hello, word!\\n\u0026quot;) fmt.Printf(\u0026quot;writer count [%d]\\n\u0026quot;, *n) fmt.Fprintf(w, \u0026quot;1234567890\\n\u0026quot;) fmt.Printf(\u0026quot;writer count [%d]\\n\u0026quot;, *n) }  $ go run counting.go hello, word! writer count [13] 1234567890 writer count [24]  Ex 7.11 Add additional handlers so that clients can create, read, update, and delete database entries. For example, a request of the form /update?item=socks\u0026amp;price=6 will update the price of an item in the inventory and report an error if the item does not exist or if the price is invalid. (Warning: this change introduces concurrent variable updates.)\npackage main import ( \u0026quot;fmt\u0026quot; \u0026quot;log\u0026quot; \u0026quot;net/http\u0026quot; \u0026quot;strconv\u0026quot; \u0026quot;sync\u0026quot; ) var mu sync.Mutex func main() { db := database{\u0026quot;shoes\u0026quot;: 50, \u0026quot;socks\u0026quot;: 5} http.HandleFunc(\u0026quot;/list\u0026quot;, db.list) http.HandleFunc(\u0026quot;/price\u0026quot;, db.price) http.HandleFunc(\u0026quot;/update\u0026quot;, db.update) http.HandleFunc(\u0026quot;/add\u0026quot;, db.add) http.HandleFunc(\u0026quot;/delete\u0026quot;, db.delete) log.Fatal(http.ListenAndServe(\u0026quot;localhost:8000\u0026quot;, nil)) } type dollars float32 func (d dollars) String() string { return fmt.Sprintf(\u0026quot;$%.2f\u0026quot;, d) } type database map[string]dollars func (db database) list(w http.ResponseWriter, req *http.Request) { for item, price := range db { fmt.Fprintf(w, \u0026quot;%s: %s\\n\u0026quot;, item, price) } } func (db database) price(w http.ResponseWriter, req *http.Request) { item := req.URL.Query().Get(\u0026quot;item\u0026quot;) if price, ok := db[item]; ok { fmt.Fprintf(w, \u0026quot;%s\\n\u0026quot;, price) } else { w.WriteHeader(http.StatusNotFound) // 404 fmt.Fprintf(w, \u0026quot;no such item: %q\\n\u0026quot;, item) } } func (db database) update(w http.ResponseWriter, req *http.Request) { mu.Lock() defer mu.Unlock() item := req.URL.Query().Get(\u0026quot;item\u0026quot;) if _, ok := db[item]; ok { newpricestr := req.URL.Query().Get(\u0026quot;price\u0026quot;) newprice, err := strconv.ParseFloat(newpricestr, 32) if err != nil { w.Write([]byte(\u0026quot;price invalid!\u0026quot;)) } else { db[item] = dollars(float32(newprice)) w.Write([]byte(\u0026quot;new price updated!\\n\\n\u0026quot;)) db.list(w, req) } } else { fmt.Fprintf(w, \u0026quot;no such item: %q\\n\u0026quot;, item) } } func (db database) add(w http.ResponseWriter, req *http.Request) { mu.Lock() defer mu.Unlock() item := req.URL.Query().Get(\u0026quot;item\u0026quot;) if _, ok := db[item]; ok { fmt.Fprintf(w, \u0026quot;%s already exist!\u0026quot;, item) } else { newpricestr := req.URL.Query().Get(\u0026quot;price\u0026quot;) if len(newpricestr) \u0026lt;= 0 { newpricestr = \u0026quot;0\u0026quot; } newprice, err := strconv.ParseFloat(newpricestr, 32) if err != nil { w.Write([]byte(\u0026quot;price invalid!\u0026quot;)) } else { db[item] = dollars(float32(newprice)) fmt.Fprintf(w, \u0026quot;%s added!\\n\\n\u0026quot;, item) db.list(w, req) } } } func (db database) delete(w http.ResponseWriter, req *http.Request) { mu.Lock() defer mu.Unlock() item := req.URL.Query().Get(\u0026quot;item\u0026quot;) if _, ok := db[item]; ok { delete(db, item) fmt.Fprintf(w, \u0026quot;%s deleted!\\n\\n\u0026quot;, item) db.list(w, req) } else { fmt.Fprintf(w, \u0026quot;%s not exist!\u0026quot;, item) } }  Ex 7.12 Change the handler for /list to print its output as an HTML table, not text. You may ﬁnd the html/template package (§4.6) useful.\npackage main import ( \u0026quot;fmt\u0026quot; \u0026quot;html/template\u0026quot; \u0026quot;log\u0026quot; \u0026quot;net/http\u0026quot; \u0026quot;strconv\u0026quot; \u0026quot;sync\u0026quot; ) var mu sync.Mutex const templ = ` \u0026lt;h1\u0026gt;current prices:\u0026lt;/h1\u0026gt; \u0026lt;table\u0026gt; \u0026lt;tr style='text-align: left'\u0026gt; \u0026lt;th\u0026gt;Item\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;Price\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; {{range $key, $value := . }} \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;{{$key}}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{$value}}\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; {{end}} \u0026lt;/table\u0026gt; ` var report = template.Must(template.New(\u0026quot;result\u0026quot;). Parse(templ)) func main() { db := database{\u0026quot;shoes\u0026quot;: 50, \u0026quot;socks\u0026quot;: 5} http.HandleFunc(\u0026quot;/list\u0026quot;, db.list) http.HandleFunc(\u0026quot;/price\u0026quot;, db.price) http.HandleFunc(\u0026quot;/update\u0026quot;, db.update) http.HandleFunc(\u0026quot;/add\u0026quot;, db.add) http.HandleFunc(\u0026quot;/delete\u0026quot;, db.delete) log.Fatal(http.ListenAndServe(\u0026quot;localhost:8000\u0026quot;, nil)) } type dollars float32 func (d dollars) String() string { return fmt.Sprintf(\u0026quot;$%.2f\u0026quot;, d) } type database map[string]dollars func (db database) list(w http.ResponseWriter, req *http.Request) { if err := report.Execute(w, db); err != nil { log.Fatal(err) } } func (db database) price(w http.ResponseWriter, req *http.Request) { item := req.URL.Query().Get(\u0026quot;item\u0026quot;) if price, ok := db[item]; ok { fmt.Fprintf(w, \u0026quot;%s\\n\u0026quot;, price) } else { w.WriteHeader(http.StatusNotFound) // 404 fmt.Fprintf(w, \u0026quot;no such item: %q\\n\u0026quot;, item) } } func (db database) update(w http.ResponseWriter, req *http.Request) { mu.Lock() defer mu.Unlock() item := req.URL.Query().Get(\u0026quot;item\u0026quot;) if _, ok := db[item]; ok { newpricestr := req.URL.Query().Get(\u0026quot;price\u0026quot;) newprice, err := strconv.ParseFloat(newpricestr, 32) if err != nil { w.Write([]byte(\u0026quot;price invalid!\u0026quot;)) } else { db[item] = dollars(float32(newprice)) w.Write([]byte(\u0026quot;new price updated!\\n\\n\u0026quot;)) db.list(w, req) } } else { fmt.Fprintf(w, \u0026quot;no such item: %q\\n\u0026quot;, item) } } func (db database) add(w http.ResponseWriter, req *http.Request) { mu.Lock() defer mu.Unlock() item := req.URL.Query().Get(\u0026quot;item\u0026quot;) if _, ok := db[item]; ok { fmt.Fprintf(w, \u0026quot;%s already exist!\u0026quot;, item) } else { newpricestr := req.URL.Query().Get(\u0026quot;price\u0026quot;) if len(newpricestr) \u0026lt;= 0 { newpricestr = \u0026quot;0\u0026quot; } newprice, err := strconv.ParseFloat(newpricestr, 32) if err != nil { w.Write([]byte(\u0026quot;price invalid!\u0026quot;)) } else { db[item] = dollars(float32(newprice)) fmt.Fprintf(w, \u0026quot;%s added!\\n\\n\u0026quot;, item) db.list(w, req) } } } func (db database) delete(w http.ResponseWriter, req *http.Request) { mu.Lock() defer mu.Unlock() item := req.URL.Query().Get(\u0026quot;item\u0026quot;) if _, ok := db[item]; ok { delete(db, item) fmt.Fprintf(w, \u0026quot;%s deleted!\\n\\n\u0026quot;, item) db.list(w, req) } else { fmt.Fprintf(w, \u0026quot;%s not exist!\u0026quot;, item) } } ","date":1514678400,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1543733643,"objectID":"7f97cd22793fc45e8a2223135146c9f7","permalink":"https://mooncaker816.github.io/2017/12/31/the-go-programming-language-ex8/","publishdate":"2017-12-31T00:00:00Z","relpermalink":"/2017/12/31/the-go-programming-language-ex8/","section":"post","summary":"Ex 7.1 Using the ideas from ByteCounter, implement counters for words and for lines. You will ﬁnd bufio.ScanWords useful.\n","tags":["The Go Programming Language Ex","Go Interface","Go Scanner"],"title":"The Go Programming Language Ex（8）","type":"post"},{"authors":null,"categories":["Golang"],"content":"Ex 6.1 Implement these additional methods:\nfunc (*IntSet) Len() int // return the number of elements\nfunc (*IntSet) Remove(x int) //remove x from the set\nfunc (*IntSet) Clear() // remove all elements from the set\nfunc (*IntSet) Copy() *IntSet // return a copy of the set\nEx 6.2 Deﬁne a variadic (*IntSet).AddAll(\u0026hellip;int) method that allows a list of values to be added, such as s.AddAll(1, 2, 3).\nEx 6.3 (*IntSet).UnionWith computes the union of two sets using |, the word-parallel bitwise OR operator. Implement methods for IntersectWith, DifferenceWith, and SymmetricDifference for the corresponding set operations. (The symmetric difference of two sets contains the elements present in one set or the other but not both.)\nEx 6.4 Add a method Elems that returns a slice containing the elements of the set, suitable for iterating over with a range loop.\nEx 6.5 The type of each word used by IntSet is uint64, but 64-bit arithmetic may be inefﬁcient on a 32-bit platform. Modify the program to use the uint type, which is the most efﬁcient unsigned integer type for the platform. Instead of dividing by 64, deﬁne a constant holding the effective size of uint in bits, 32 or 64. You can use the perhaps too-clever expression 32 \u0026lt;\u0026lt; (^uint(0) \u0026gt;\u0026gt; 63) for this purpose.\npackage main import ( \u0026quot;bytes\u0026quot; \u0026quot;fmt\u0026quot; ) const wordlen = 32 \u0026lt;\u0026lt; (^uint(0) \u0026gt;\u0026gt; 63) //当前计算机的位数 type IntSet struct { words []uint } func (s *IntSet) Add(x int) { word, bit := x/wordlen, uint(x%wordlen) for word \u0026gt;= len(s.words) { s.words = append(s.words, 0) } s.words[word] |= 1 \u0026lt;\u0026lt; bit } func (s *IntSet) Has(x int) bool { word, bit := x/wordlen, uint(x%wordlen) return word \u0026lt; len(s.words) \u0026amp;\u0026amp; s.words[word]\u0026amp;(1\u0026lt;\u0026lt;bit) != 0 } func (s *IntSet) UnionWith(t *IntSet) { for i, tword := range t.words { if i \u0026lt; len(s.words) { s.words[i] |= tword } else { s.words = append(s.words, tword) } } } func (s *IntSet) String() string { var buf bytes.Buffer buf.WriteByte('{') for i, word := range s.words { if word == 0 { continue } for j := 0; j \u0026lt; wordlen; j++ { if word\u0026amp;(1\u0026lt;\u0026lt;uint(j)) != 0 { if buf.Len() \u0026gt; len(\u0026quot;{\u0026quot;) { buf.WriteByte(' ') } fmt.Fprintf(\u0026amp;buf, \u0026quot;%d\u0026quot;, wordlen*i+j) } } } buf.WriteByte('}') return buf.String() } func (s *IntSet) Len() int { var count int for _, n := range s.words { for n != 0 { count++ n = n \u0026amp; (n - 1) } } return count } func (s *IntSet) Remove(x int) { word, bit := x/wordlen, uint(x%wordlen) if word \u0026lt; len(s.words) { s.words[word] \u0026amp;= ^(1 \u0026lt;\u0026lt; bit) } } func (s *IntSet) Clear() { s.words = []uint{0} } func (s *IntSet) Copy() *IntSet { ns := IntSet{make([]uint, len(s.words))} copy(ns.words, s.words) return \u0026amp;ns } func (s *IntSet) AddAll(x ...int) { for _, v := range x { s.Add(v) } } func (s *IntSet) IntersectWith(t *IntSet) *IntSet { tmp := make([]uint, 0) for i, tword := range t.words { if i \u0026lt; len(s.words) { tmp = append(tmp, s.words[i]\u0026amp;tword) } } return \u0026amp;IntSet{tmp} } func (s *IntSet) SymmetricDifference(t *IntSet) *IntSet { tmp := make([]uint, 0) if len(t.words) \u0026gt; len(s.words) { for i, tword := range t.words { if i \u0026lt; len(s.words) { tmp = append(tmp, s.words[i]^tword) } else { tmp = append(tmp, tword) } } } else { for i, sword := range s.words { if i \u0026lt; len(t.words) { tmp = append(tmp, t.words[i]^sword) } else { tmp = append(tmp, sword) } } } return \u0026amp;IntSet{tmp} } func (s *IntSet) DifferenceWith(t *IntSet) *IntSet { tmp := make([]uint, 0) for i, sword := range s.words { if i \u0026lt; len(t.words) { tmp = append(tmp, sword\u0026amp;^t.words[i]) } else { tmp = append(tmp, sword) } } return \u0026amp;IntSet{tmp} } func (s *IntSet) Elems() []int { tmp := make([]int, 0) for i, word := range s.words { if word == 0 { continue } for j := 0; j \u0026lt; wordlen; j++ { if word\u0026amp;(1\u0026lt;\u0026lt;uint(j)) != 0 { tmp = append(tmp, wordlen*i+j) } } } return tmp } func main() { var set1, set2, set3 IntSet set1.Add(1) set1.Add(22) set2.Add(333) fmt.Println(\u0026quot;set1:\u0026quot;, \u0026amp;set1) fmt.Println(\u0026quot;set1 是否包含1：\u0026quot;, set1.Has(1), \u0026quot;set1 是否包含333：\u0026quot;, set1.Has(333)) fmt.Println(\u0026quot;before union with {333}: \u0026quot;, \u0026amp;set1) fmt.Println(\u0026quot;len: \u0026quot;, set1.Len()) set1.UnionWith(\u0026amp;set2) fmt.Println(\u0026quot;after union with {333}: \u0026quot;, \u0026amp;set1) fmt.Println(\u0026quot;len: \u0026quot;, set1.Len()) set1.Remove(22) fmt.Println(\u0026quot;after remove 22: \u0026quot;, \u0026amp;set1) fmt.Println(\u0026quot;len: \u0026quot;, set1.Len()) set3 = *set1.Copy() fmt.Println(\u0026quot;copy set1 to set3: \u0026quot;, \u0026amp;set3) set1.Clear() fmt.Println(\u0026quot;after clear set1: \u0026quot;, \u0026amp;set1, \u0026amp;set3) set3.AddAll(4444, 55555) fmt.Println(\u0026quot;after add all set3: \u0026quot;, \u0026amp;set3) set2.AddAll(55555, 666666) fmt.Println(\u0026quot;se2:\u0026quot;, \u0026amp;set2) fmt.Println(\u0026quot;se3:\u0026quot;, \u0026amp;set3) fmt.Println(\u0026quot;set2交set3:\u0026quot;, set2.IntersectWith(\u0026amp;set3)) fmt.Println(\u0026quot;set2 DifferenceWith set3:\u0026quot;, set2.DifferenceWith(\u0026amp;set3)) fmt.Println(\u0026quot;set3 DifferenceWith set2:\u0026quot;, set3.DifferenceWith(\u0026amp;set2)) fmt.Println(\u0026quot;set2 SymmetricDifference set3:\u0026quot;, set2.SymmetricDifference(\u0026amp;set3)) fmt.Println(\u0026quot;set3 SymmetricDifference set2:\u0026quot;, set3.SymmetricDifference(\u0026amp;set2)) fmt.Println(\u0026quot;elem slice in set2:\u0026quot;, set2.Elems()) }  $ go run bitmap.go set1: {1 22} set1 是否包含1： true set1 是否包含333： false before union with {333}: {1 22} len: 2 after union with {333}: {1 22 333} len: 3 after remove 22: {1 333} len: 2 copy set1 to set3: {1 333} after clear set1: {} {1 333} after add all set3: {1 333 4444 55555} se2: {333 55555 666666} se3: {1 333 4444 55555} set2交set3: {333 55555} set2 DifferenceWith set3: {666666} set3 DifferenceWith set2: {1 4444} set2 SymmetricDifference set3: {1 4444 666666} set3 SymmetricDifference set2: {1 4444 666666} elem slice in set2: [333 55555 666666] ","date":1514505600,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1543733643,"objectID":"276f08573c6e75e9f386bdd719bfbda5","permalink":"https://mooncaker816.github.io/2017/12/29/the-go-programming-language-ex7/","publishdate":"2017-12-29T00:00:00Z","relpermalink":"/2017/12/29/the-go-programming-language-ex7/","section":"post","summary":"Ex 6.1 Implement these additional methods:\nfunc (*IntSet) Len() int // return the number of elements\nfunc (*IntSet) Remove(x int) //remove x from the set\nfunc (*IntSet) Clear() // remove all elements from the set\nfunc (*IntSet) Copy() *IntSet // return a copy of the set\n","tags":["The Go Programming Language Ex","Go Method","Go BitMap"],"title":"The Go Programming Language Ex（7）","type":"post"},{"authors":null,"categories":["Golang"],"content":"Ex 5.1 Change the findlinks program to traverse the n.FirstChild linked list using recursive calls to visit instead of a loop.\npackage main import ( \u0026quot;fmt\u0026quot; \u0026quot;os\u0026quot; \u0026quot;golang.org/x/net/html\u0026quot; ) func main() { doc, err := html.Parse(os.Stdin) if err != nil { fmt.Fprintf(os.Stderr, \u0026quot;findlinks1: %v\\n\u0026quot;, err) os.Exit(1) } for _, link := range visit(nil, doc) { fmt.Println(link) } } // visit appends to links each link found in n and returns the result. func visit(links []string, n *html.Node) []string { if n == nil { return links } else { if n.Type == html.ElementNode \u0026amp;\u0026amp; n.Data == \u0026quot;a\u0026quot; { for _, a := range n.Attr { if a.Key == \u0026quot;href\u0026quot; { links = append(links, a.Val) } } } links = visit(links, n.FirstChild) links = visit(links, n.NextSibling) } return links }  $ ./ex1.7 http://www.baidu.com | ./ex5.1 / javascript:; javascript:; javascript:; / javascript:; https://passport.baidu.com/v2/?login\u0026amp;tpl=mn\u0026amp;u=http%3A%2F%2Fwww.baidu.com%2F http://news.baidu.com http://www.hao123.com http://map.baidu.com http://v.baidu.com http://tieba.baidu.com http://xueshu.baidu.com https://passport.baidu.com/v2/?login\u0026amp;tpl=mn\u0026amp;u=http%3A%2F%2Fwww.baidu.com%2F http://www.baidu.com/gaoji/preferences.html http://www.baidu.com/more/ http://news.baidu.com/ns?cl=2\u0026amp;rn=20\u0026amp;tn=news\u0026amp;word= http://tieba.baidu.com/f?kw=\u0026amp;fr=wwwt http://zhidao.baidu.com/q?ct=17\u0026amp;pn=0\u0026amp;tn=ikaslist\u0026amp;rn=10\u0026amp;word=\u0026amp;fr=wwwt http://music.baidu.com/search?fr=ps\u0026amp;ie=utf-8\u0026amp;key= http://image.baidu.com/search/index?tn=baiduimage\u0026amp;ps=1\u0026amp;ct=201326592\u0026amp;lm=-1\u0026amp;cl=2\u0026amp;nc=1\u0026amp;ie=utf-8\u0026amp;word= http://v.baidu.com/v?ct=301989888\u0026amp;rn=20\u0026amp;pn=0\u0026amp;db=0\u0026amp;s=25\u0026amp;ie=utf-8\u0026amp;word= http://map.baidu.com/m?word=\u0026amp;fr=ps01000 http://wenku.baidu.com/search?word=\u0026amp;lm=0\u0026amp;od=0\u0026amp;ie=utf-8 //www.baidu.com/more/ //www.baidu.com/cache/sethelp/help.html http://home.baidu.com http://ir.baidu.com http://e.baidu.com/?refer=888 http://www.baidu.com/duty/ http://jianyi.baidu.com/ http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=11000002000001  Ex 5.2 Write a function to populate a mapping from element names—p, div, span, and so on—to the number of elements with that name in an HTML document tree.\npackage main import ( \u0026quot;fmt\u0026quot; \u0026quot;os\u0026quot; \u0026quot;golang.org/x/net/html\u0026quot; ) func main() { doc, err := html.Parse(os.Stdin) if err != nil { fmt.Fprintf(os.Stderr, \u0026quot;findlinks1: %v\\n\u0026quot;, err) os.Exit(1) } m := make(map[string]int) for k, v := range check(m, doc) { fmt.Printf(\u0026quot;%s:%d\\n\u0026quot;, k, v) } } func check(m map[string]int, n *html.Node) map[string]int { if n == nil { return m } else { if n.Type == html.ElementNode { m[n.Data]++ } m = check(m, n.FirstChild) m = check(m, n.NextSibling) } return m }  $ ./ex1.7 http://www.baidu.com | ./ex5.2 body:1 img:2 map:1 area:1 a:32 i:3 head:1 title:1 style:3 ul:1 meta:4 link:11 form:1 span:5 li:4 p:3 html:1 script:13 noscript:1 div:21 input:14 b:2  Ex 5.5 Implement countWordsAndImages. (See Exercise 4.9 for word-splitting.)\npackage main import ( \u0026quot;bufio\u0026quot; \u0026quot;fmt\u0026quot; \u0026quot;net/http\u0026quot; \u0026quot;strings\u0026quot; \u0026quot;golang.org/x/net/html\u0026quot; ) func main() { url := \u0026quot;http://www.baidu.com\u0026quot; w, i, err := CountWordsAndImages(url) if err != nil { fmt.Println(\u0026quot;CountWordsAndImages error: \u0026quot;, err) } fmt.Printf(\u0026quot;words = %d,images = %d\\n\u0026quot;, w, i) } func CountWordsAndImages(url string) (words, images int, err error) { resp, err := http.Get(url) if err != nil { return } doc, err := html.Parse(resp.Body) resp.Body.Close() if err != nil { err = fmt.Errorf(\u0026quot;parsing HTML: %s\u0026quot;, err) return } words, images = countWordsAndImages(doc) return } func countWordsAndImages(n *html.Node) (words, images int) { if n == nil { return } else { if n.Type == html.ElementNode { if n.Data == \u0026quot;img\u0026quot; { images++ } } else if n.Type == html.TextNode { scanner := bufio.NewScanner(strings.NewReader(n.Data)) scanner.Split(bufio.ScanWords) for scanner.Scan() { words++ } } w1, i1 := countWordsAndImages(n.FirstChild) words += w1 images += i1 w2, i2 := countWordsAndImages(n.NextSibling) words += w2 images += i2 } return }  $ go run countwi.go words = 2805,images = 2  Ex 5.6 Modify the corner function in gopl.io/ch3/surface (§3.2) to use named results and a bare return statement.\npackage main import ( \u0026quot;fmt\u0026quot; \u0026quot;math\u0026quot; \u0026quot;os\u0026quot; ) const ( width, height = 600, 320 // canvas size in pixels cells = 100 // number of grid cells xyrange = 30.0 // axis ranges (-xyrange..+xyrange) xyscale = width / 2 / xyrange // pixels per x or y unit zscale = height * 0.4 // pixels per z unit angle = math.Pi / 6 // angle of x, y axes (=30°) ) var sin30, cos30 = math.Sin(angle), math.Cos(angle) // sin(30°), cos(30°) func main() { //fmt.Printf(\u0026quot;\u0026lt;svg xmlns='http://www.w3.org/2000/svg' \u0026quot;+ f, err := os.Create(\u0026quot;test.svg\u0026quot;) if err != nil { fmt.Println(\u0026quot;create file error \u0026quot;, err) return } fmt.Fprintf(f, \u0026quot;\u0026lt;svg xmlns='http://www.w3.org/2000/svg' \u0026quot;+ \u0026quot;style='stroke: grey; fill: white; stroke-width: 0.7' \u0026quot;+ \u0026quot;width='%d' height='%d'\u0026gt;\u0026quot;, width, height) for i := 0; i \u0026lt; cells; i++ { for j := 0; j \u0026lt; cells; j++ { ax, ay := corner(i+1, j) bx, by := corner(i, j) cx, cy := corner(i, j+1) dx, dy := corner(i+1, j+1) fmt.Fprintf(f, \u0026quot;\u0026lt;polygon points='%g,%g %g,%g %g,%g %g,%g'/\u0026gt;\\n\u0026quot;, ax, ay, bx, by, cx, cy, dx, dy) } } fmt.Fprintln(f, \u0026quot;\u0026lt;/svg\u0026gt;\u0026quot;) } func corner(i, j int) (sx, sy float64) { // Find point (x,y) at corner of cell (i,j). x := xyrange * (float64(i)/cells - 0.5) y := xyrange * (float64(j)/cells - 0.5) // Compute surface height z. z := f(x, y) // Project (x,y,z) isometrically onto 2-D SVG canvas (sx,sy). sx = width/2 + (x-y)*cos30*xyscale sy = height/2 + (x+y)*sin30*xyscale - z*zscale return } func f(x, y float64) float64 { r := math.Hypot(x, y) // distance from (0,0) return math.Sin(r) / r }  Ex 5.7 Develop startElement and endElement into a general HTML pre Print comment nodes, text nodes, and the attributes of each element (). Use short forms like  instead of  when an element has no children. Write a test to ensure that the output can be parsed successfully. (See Chapter 11.)\npackage main import ( \u0026quot;fmt\u0026quot; \u0026quot;net/http\u0026quot; \u0026quot;os\u0026quot; \u0026quot;golang.org/x/net/html\u0026quot; ) func main() { for _, url := range os.Args[1:] { outline(url) } } func outline(url string) error { resp, err := http.Get(url) if err != nil { return err } defer resp.Body.Close() doc, err := html.Parse(resp.Body) if err != nil { return err } forEachNode(doc, startElement, endElement) return nil } func forEachNode(n *html.Node, pre, post func(n *html.Node)) { if pre != nil { pre(n) } for c := n.FirstChild; c != nil; c = c.NextSibling { forEachNode(c, pre, post) } if post != nil { post(n) } } var depth int func startElement(n *html.Node) { if n.Type == html.ElementNode || n.Type == html.TextNode || n.Type == html.CommentNode { if n.DataAtom != 0 { //去除无法识别标签的节点，如空白的textnode等 var attr string for _, v := range n.Attr { attr += \u0026quot; \u0026quot; + v.Key + \u0026quot;='\u0026quot; + v.Val + \u0026quot;'\u0026quot; } if n.FirstChild == nil { fmt.Printf(\u0026quot;%*s\u0026lt;%s/\u0026gt;\\n\u0026quot;, depth*2, \u0026quot;\u0026quot;, n.Data) } else { fmt.Printf(\u0026quot;%*s\u0026lt;%s%s\u0026gt;\\n\u0026quot;, depth*2, \u0026quot;\u0026quot;, n.Data, attr) } depth++ } } } func endElement(n *html.Node) { if n.Type == html.ElementNode || n.Type == html.TextNode || n.Type == html.CommentNode { if n.DataAtom != 0 { depth-- if n.FirstChild != nil { fmt.Printf(\u0026quot;%*s\u0026lt;/%s\u0026gt;\\n\u0026quot;, depth*2, \u0026quot;\u0026quot;, n.Data) } } } }  $ ./ex5.7 http://gopl.io \u0026lt;html xmlns='http://www.w3.org/1999/xhtml'\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta/\u0026gt; \u0026lt;title\u0026gt; \u0026lt;/title\u0026gt; \u0026lt;script\u0026gt; \u0026lt;/script\u0026gt; \u0026lt;link/\u0026gt; \u0026lt;style\u0026gt; \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;table\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt; \u0026lt;a href='http://www.informit.com/store/go-programming-language-9780134190440'\u0026gt; \u0026lt;img/\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;br/\u0026gt; \u0026lt;div style='text-align: center'\u0026gt; \u0026lt;a href='http://www.amazon.com/dp/0134190440'\u0026gt; \u0026lt;img/\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;a href='http://www.informit.com/store/go-programming-language-9780134190440'\u0026gt; \u0026lt;img/\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;a href='http://www.barnesandnoble.com/w/1121601944'\u0026gt; \u0026lt;img/\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;br/\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td width='500'\u0026gt; \u0026lt;h1 class='center'\u0026gt; \u0026lt;/h1\u0026gt; \u0026lt;p class='biblio center'\u0026gt; \u0026lt;br/\u0026gt; \u0026lt;br/\u0026gt; \u0026lt;br/\u0026gt; \u0026lt;tt\u0026gt; \u0026lt;/tt\u0026gt; \u0026lt;tt\u0026gt; \u0026lt;/tt\u0026gt; \u0026lt;tt\u0026gt; \u0026lt;/tt\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;div id='toc'\u0026gt; \u0026lt;table\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt; \u0026lt;h1\u0026gt; \u0026lt;a href='ch1.pdf'\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;/h1\u0026gt; \u0026lt;h1\u0026gt; \u0026lt;a href='ch1.pdf'\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;/h1\u0026gt; \u0026lt;h1\u0026gt; \u0026lt;a href='ch1.pdf'\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;/h1\u0026gt; \u0026lt;h1\u0026gt; \u0026lt;/h1\u0026gt; \u0026lt;h1\u0026gt; \u0026lt;/h1\u0026gt; \u0026lt;h1\u0026gt; \u0026lt;/h1\u0026gt; \u0026lt;h1\u0026gt; \u0026lt;/h1\u0026gt; \u0026lt;h1\u0026gt; \u0026lt;/h1\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; \u0026lt;h1\u0026gt; \u0026lt;/h1\u0026gt; \u0026lt;h1\u0026gt; \u0026lt;/h1\u0026gt; \u0026lt;h1\u0026gt; \u0026lt;/h1\u0026gt; \u0026lt;h1\u0026gt; \u0026lt;/h1\u0026gt; \u0026lt;h1\u0026gt; \u0026lt;/h1\u0026gt; \u0026lt;h1\u0026gt; \u0026lt;/h1\u0026gt; \u0026lt;h1\u0026gt; \u0026lt;/h1\u0026gt; \u0026lt;h1\u0026gt; \u0026lt;a href='ch1.pdf'\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;/h1\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td colspan='2'\u0026gt; \u0026lt;h1\u0026gt; \u0026lt;a href='https://github.com/adonovan/gopl.io/'\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;a href='reviews.html'\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;a href='translations.html'\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;a href='errata.html'\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;/h1\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;p class='bio'\u0026gt; \u0026lt;a href='http://golang.org/s/oracle-user-manual'\u0026gt; \u0026lt;code\u0026gt; \u0026lt;/code\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;a href='http://golang.org/lib/godoc/analysis/help.html'\u0026gt; \u0026lt;code\u0026gt; \u0026lt;/code\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;a href='https://github.com/golang/tools/blob/master/refactor/eg/eg.go'\u0026gt; \u0026lt;code\u0026gt; \u0026lt;/code\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;a href='https://github.com/golang/tools/blob/master/refactor/rename/rename.go'\u0026gt; \u0026lt;code\u0026gt; \u0026lt;/code\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;p class='bio'\u0026gt; \u0026lt;a href='http://www.amazon.com/dp/0131103628?tracking_id=disfordig-20'\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;a href='http://www.amazon.com/dp/020161586X?tracking_id=disfordig-20'\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   遍历TextNode时，含有很多空节点（其实就是空格，也当成了一个节点），或许应该在parse阶段就抛弃这些不是节点的节点。本习题中，我暂时借用了元素节点的字段DataAtom atom.Atom，若为0，则说明该节点标签无法识别。   // A Node consists of a NodeType and some Data (tag name for element nodes, // content for text) and are part of a tree of Nodes. Element nodes may also // have a Namespace and contain a slice of Attributes. Data is unescaped, so // that it looks like \u0026ldquo;a\u0026lt;b\u0026rdquo; rather than \u0026ldquo;a\u0026lt;b\u0026rdquo;. For element nodes, DataAtom // is the atom for Data, or zero if Data is not a known tag name.\n Ex 5.8 Modify forEachNode so that the pre and post functions return a boolean re indicating whether to continue the traversal. Use it to write a function ElementByID with the following signature that ﬁnds the ﬁrst HTML element with the speciﬁed id attribute. The function should stop the traversal as soon as a match is found.\nfunc ElementByID(doc *html.Node, id string) *html.Node\npackage main import ( \u0026quot;fmt\u0026quot; \u0026quot;log\u0026quot; \u0026quot;net/http\u0026quot; \u0026quot;os\u0026quot; \u0026quot;golang.org/x/net/html\u0026quot; ) var custID = \u0026quot;css_index_result\u0026quot; //var custID = \u0026quot;toc\u0026quot; func main() { for _, url := range os.Args[1:] { outline(url) } } func outline(url string) error { resp, err := http.Get(url) if err != nil { return err } defer resp.Body.Close() doc, err := html.Parse(resp.Body) if err != nil { return err } //forEachNode(doc, \u0026quot;\u0026quot;, startElement, endElement) fmt.Printf(\u0026quot;%#v:\\n\u0026quot;, getElementByID(doc, custID)) return nil } func forEachNode(n *html.Node, id string, pre, post func(n *html.Node, id string) bool) *html.Node { var rtn *html.Node if pre != nil { if !pre(n, id) { rtn = n } } for c := n.FirstChild; c != nil \u0026amp;\u0026amp; rtn == nil; c = c.NextSibling { rtn = forEachNode(c, id, pre, post) } if post != nil { if !post(n, id) { rtn = n } } return rtn } var depth int func startElement(n *html.Node, id string) bool { if n.Type == html.ElementNode || n.Type == html.TextNode || n.Type == html.CommentNode { if n.DataAtom != 0 { //去除无法识别标签的节点，如空白的textnode等 var attr string for _, v := range n.Attr { attr += \u0026quot; \u0026quot; + v.Key + \u0026quot;='\u0026quot; + v.Val + \u0026quot;'\u0026quot; } if n.FirstChild == nil { fmt.Printf(\u0026quot;%*s\u0026lt;%s/\u0026gt;\\n\u0026quot;, depth*2, \u0026quot;\u0026quot;, n.Data) } else { fmt.Printf(\u0026quot;%*s\u0026lt;%s%s\u0026gt;\\n\u0026quot;, depth*2, \u0026quot;\u0026quot;, n.Data, attr) } depth++ } if n.Type == html.ElementNode { for _, v := range n.Attr { if v.Key == \u0026quot;id\u0026quot; \u0026amp;\u0026amp; v.Val == id { log.Printf(\u0026quot;%#v\\n\u0026quot;, n) return false } } } } return true } func endElement(n *html.Node, id string) bool { if n.Type == html.ElementNode || n.Type == html.TextNode || n.Type == html.CommentNode { if n.DataAtom != 0 { depth-- if n.FirstChild != nil { fmt.Printf(\u0026quot;%*s\u0026lt;/%s\u0026gt;\\n\u0026quot;, depth*2, \u0026quot;\u0026quot;, n.Data) } } } return true } func getElementByID(doc *html.Node, id string) *html.Node { return forEachNode(doc, id, startElement, endElement) }  $ ./ex5.7 http://www.baidu.com \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta/\u0026gt; \u0026lt;meta/\u0026gt; \u0026lt;meta/\u0026gt; \u0026lt;meta/\u0026gt; \u0026lt;link/\u0026gt; \u0026lt;link/\u0026gt; \u0026lt;link/\u0026gt; \u0026lt;link/\u0026gt; \u0026lt;link/\u0026gt; \u0026lt;link/\u0026gt; \u0026lt;link/\u0026gt; \u0026lt;link/\u0026gt; \u0026lt;link/\u0026gt; \u0026lt;link/\u0026gt; \u0026lt;link/\u0026gt; \u0026lt;title\u0026gt; \u0026lt;/title\u0026gt; \u0026lt;style id='css_index' index='index' type='text/css'\u0026gt; \u0026lt;/style\u0026gt; \u0026lt;style data-for='debug'\u0026gt; \u0026lt;/style\u0026gt; \u0026lt;style data-for='result' id='css_index_result' type='text/css'\u0026gt; 2018/01/02 17:53:11 \u0026amp;html.Node{Parent:(*html.Node)(0xc4201322a0), FirstChild:(*html.Node)(0xc4201336c0), LastChild:(*html.Node)(0xc4201336c0), PrevSibling:(*html.Node)(0xc4201335e0), NextSibling:(*html.Node)(0xc420133730), Type:0x3, DataAtom:0x6f905, Data:\u0026quot;style\u0026quot;, Namespace:\u0026quot;\u0026quot;, Attr:[]html.Attribute{html.Attribute{Namespace:\u0026quot;\u0026quot;, Key:\u0026quot;data-for\u0026quot;, Val:\u0026quot;result\u0026quot;}, html.Attribute{Namespace:\u0026quot;\u0026quot;, Key:\u0026quot;id\u0026quot;, Val:\u0026quot;css_index_result\u0026quot;}, html.Attribute{Namespace:\u0026quot;\u0026quot;, Key:\u0026quot;type\u0026quot;, Val:\u0026quot;text/css\u0026quot;}}} \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;/html\u0026gt; \u0026amp;html.Node{Parent:(*html.Node)(0xc4201322a0), FirstChild:(*html.Node)(0xc4201336c0), LastChild:(*html.Node)(0xc4201336c0), PrevSibling:(*html.Node)(0xc4201335e0), NextSibling:(*html.Node)(0xc420133730), Type:0x3, DataAtom:0x6f905, Data:\u0026quot;style\u0026quot;, Namespace:\u0026quot;\u0026quot;, Attr:[]html.Attribute{html.Attribute{Namespace:\u0026quot;\u0026quot;, Key:\u0026quot;data-for\u0026quot;, Val:\u0026quot;result\u0026quot;}, html.Attribute{Namespace:\u0026quot;\u0026quot;, Key:\u0026quot;id\u0026quot;, Val:\u0026quot;css_index_result\u0026quot;}, html.Attribute{Namespace:\u0026quot;\u0026quot;, Key:\u0026quot;type\u0026quot;, Val:\u0026quot;text/css\u0026quot;}}}:  Ex 5.12 The startElement and endElement functions in gopl.io/ch5/outline2 (§5.5) share a global variable, depth. Turn them into anonymous functions that share a variable local to the outline function.\n// Copyright © 2016 Alan A. A. Donovan \u0026amp; Brian W. Kernighan. // License: https://creativecommons.org/licenses/by-nc-sa/4.0/ // See page 133. // Outline prints the outline of an HTML document tree. package main import ( \u0026quot;fmt\u0026quot; \u0026quot;net/http\u0026quot; \u0026quot;os\u0026quot; \u0026quot;golang.org/x/net/html\u0026quot; ) func main() { for _, url := range os.Args[1:] { outline(url) } } func outline(url string) error { resp, err := http.Get(url) if err != nil { return err } defer resp.Body.Close() doc, err := html.Parse(resp.Body) if err != nil { return err } var depth int startElement := func(n *html.Node) { if n.Type == html.ElementNode { fmt.Printf(\u0026quot;%*s\u0026lt;%s\u0026gt;\\n\u0026quot;, depth*2, \u0026quot;\u0026quot;, n.Data) depth++ } } endElement := func(n *html.Node) { if n.Type == html.ElementNode { depth-- fmt.Printf(\u0026quot;%*s\u0026lt;/%s\u0026gt;\\n\u0026quot;, depth*2, \u0026quot;\u0026quot;, n.Data) } } //!+call forEachNode(doc, startElement, endElement) //!-call return nil } //!+forEachNode // forEachNode calls the functions pre(x) and post(x) for each node // x in the tree rooted at n. Both functions are optional. // pre is called before the children are visited (preorder) and // post is called after (postorder). func forEachNode(n *html.Node, pre, post func(n *html.Node)) { if pre != nil { pre(n) } for c := n.FirstChild; c != nil; c = c.NextSibling { forEachNode(c, pre, post) } if post != nil { post(n) } }  Ex 5.13 Modify crawl to make local copies of the pages it ﬁnds, creating directories as necessary. Don’t make copies of pages that come from a different domain. For example, if the original page comes from golang.org, save all ﬁles from there, but exclude ones from vimeo.com.\npackage main import ( \u0026quot;fmt\u0026quot; \u0026quot;io\u0026quot; \u0026quot;log\u0026quot; \u0026quot;net/http\u0026quot; \u0026quot;net/url\u0026quot; \u0026quot;os\u0026quot; \u0026quot;strconv\u0026quot; \u0026quot;strings\u0026quot; \u0026quot;time\u0026quot; \u0026quot;golang.org/x/net/html\u0026quot; \u0026quot;gopl.io/ch5/links\u0026quot; ) // Extract makes an HTTP GET request to the specified URL, parses // the response as HTML, and returns the links in the HTML document. func Extract(urlstr string) ([]string, error) { resp, err := http.Get(urlstr) if err != nil { return nil, err } if resp.StatusCode != http.StatusOK { resp.Body.Close() return nil, fmt.Errorf(\u0026quot;getting %s: %s\u0026quot;, urlstr, resp.Status) } doc, err := html.Parse(resp.Body) resp.Body.Close() if err != nil { return nil, fmt.Errorf(\u0026quot;parsing %s as HTML: %v\u0026quot;, urlstr, err) } var links []string visitNode := func(n *html.Node) { if n.Type == html.ElementNode \u0026amp;\u0026amp; n.Data == \u0026quot;a\u0026quot; { for _, a := range n.Attr { if a.Key != \u0026quot;href\u0026quot; { continue } link, err := resp.Request.URL.Parse(a.Val) if err != nil { continue // ignore bad URLs } links = append(links, link.String()) } } } forEachNode(doc, visitNode, nil) return links, nil } //!-Extract // Copied from gopl.io/ch5/outline2. func forEachNode(n *html.Node, pre, post func(n *html.Node)) { if pre != nil { pre(n) } for c := n.FirstChild; c != nil; c = c.NextSibling { forEachNode(c, pre, post) } if post != nil { post(n) } } func breadthFirst(f func(item string, host []string) []string, worklist []string) { seen := make(map[string]bool) host := make([]string, len(worklist)) for i, v := range worklist { u, err := url.Parse(v) if err != nil { fmt.Println(\u0026quot;initial url parse failed\u0026quot;) return } host[i] = u.Host } for len(worklist) \u0026gt; 0 { items := worklist worklist = nil for _, item := range items { if !seen[item] { seen[item] = true worklist = append(worklist, f(item, host)...) } } } } //!-breadthFirst //!+crawl func crawl(urlstr string, sl []string) []string { fmt.Println(urlstr) copycontent(urlstr, sl) list, err := links.Extract(urlstr) if err != nil { log.Print(err) } return list } func copycontent(s string, sl []string) { u, err := url.Parse(s) if err != nil { fmt.Println(\u0026quot;url parse failed\u0026quot;) return } for _, v := range sl { if u.Host == v { resp, err := http.Get(s) if err != nil { fmt.Println(err) return } if resp.StatusCode != http.StatusOK { resp.Body.Close() return } //fmt.Println(path) dir, _ := os.Getwd() //当前的目录 var filename, filepart, dirpart string ns := strings.Count(u.Path, \u0026quot;/\u0026quot;) if ns == 0 || ns == 1 \u0026amp;\u0026amp; len(u.Path) == 1 { filepart = \u0026quot;\u0026quot; filename = strconv.FormatInt(time.Now().Unix(), 10) + \u0026quot;.html\u0026quot; dirpart = \u0026quot;/\u0026quot; } else { filepart = u.Path[strings.LastIndex(u.Path, \u0026quot;/\u0026quot;)+1:] dirpart = u.Path[:strings.LastIndex(u.Path, \u0026quot;/\u0026quot;)+1] if strings.Contains(filepart, \u0026quot;.\u0026quot;) { filename = filepart } else { dirpart = u.Path filename = strconv.FormatInt(time.Now().Unix(), 10) + \u0026quot;.html\u0026quot; } } fullpath := dir + \u0026quot;/\u0026quot; + u.Host + dirpart _, err = os.Stat(fullpath) if err != nil { err = os.MkdirAll(fullpath, os.ModePerm) //在当前目录下生成md目录 if err != nil { fmt.Println(\u0026quot;create folder failed! \u0026quot;, fullpath, err) return } } filename = dir + \u0026quot;/\u0026quot; + u.Host + dirpart + \u0026quot;/\u0026quot; + filename f, err := os.Create(filename) if err != nil { fmt.Println(\u0026quot;create file error:\u0026quot;, err, s) return } _, err = io.Copy(f, resp.Body) if err != nil { fmt.Println(\u0026quot;failed in copy\u0026quot;) return } resp.Body.Close() } } } func main() { breadthFirst(crawl, os.Args[1:]) } ","date":1514419200,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1543733643,"objectID":"c8c379d5913cc2dd95276e66109337bc","permalink":"https://mooncaker816.github.io/2017/12/28/the-go-programming-language-ex6/","publishdate":"2017-12-28T00:00:00Z","relpermalink":"/2017/12/28/the-go-programming-language-ex6/","section":"post","summary":"Ex 5.1 Change the findlinks program to traverse the n.FirstChild linked list using recursive calls to visit instead of a loop.\n","tags":["The Go Programming Language Ex","Go Func","Go crawler"],"title":"The Go Programming Language Ex（6）","type":"post"},{"authors":null,"categories":["Golang"],"content":"Ex 4.8 Modify charcount to count letters, digits, and so on in their Unicode categories, using functions like unicode.IsLetter.\npackage main import ( \u0026quot;bufio\u0026quot; \u0026quot;fmt\u0026quot; \u0026quot;io\u0026quot; \u0026quot;os\u0026quot; \u0026quot;unicode\u0026quot; ) func main() { counts := make(map[string]int) // counts of Unicode characters invalid, letter, digit, mark, other := 0, 0, 0, 0, 0 // count of invalid UTF-8 characters in := bufio.NewReader(os.Stdin) for { r, n, err := in.ReadRune() // returns rune, nbytes, error if err == io.EOF { break } if err != nil { fmt.Fprintf(os.Stderr, \u0026quot;charcount: %v\\n\u0026quot;, err) os.Exit(1) } if r == unicode.ReplacementChar \u0026amp;\u0026amp; n == 1 { invalid++ continue } else if unicode.IsLetter(r) { letter++ } else if unicode.IsDigit(r) { digit++ } else if unicode.IsMark(r) { mark++ } else { other++ fmt.Println(r) } } counts[\u0026quot;invalid\u0026quot;] = invalid counts[\u0026quot;letter\u0026quot;] = letter counts[\u0026quot;digit\u0026quot;] = digit counts[\u0026quot;mark\u0026quot;] = mark counts[\u0026quot;other\u0026quot;] = other for c, n := range counts { fmt.Printf(\u0026quot;%s\\t:%d\\n\u0026quot;, c, n) } }  ./ex4.8 sdfwwer 1434jipi三是奇偶i问 32 10 invalid\t:0 letter\t:17 digit\t:4 mark\t:0 other\t:2   显然汉字也被认为是letter 终端模拟EOF 为 ctrl + d  Ex 4.9 Write a program wordfreq to report the frequency of each word in an input text ﬁle. Call input.Split(bufio.ScanWords) before the ﬁrst call to Scan to break the input into words instead of lines.\npackage main import ( \u0026quot;bufio\u0026quot; \u0026quot;fmt\u0026quot; \u0026quot;strings\u0026quot; ) func main() { words := make(map[string]int) input := \u0026quot;foo bar baz foo 我们 foo 我们\u0026quot; scanner := bufio.NewScanner(strings.NewReader(input)) scanner.Split(bufio.ScanWords) for scanner.Scan() { //fmt.Println(scanner.Text()) words[scanner.Text()]++ } for k, v := range words { fmt.Printf(\u0026quot;%s : %d\\n\u0026quot;, k, v) } }  $ go run wordfreq.go baz : 1 我们 : 2 foo : 3 bar : 1  Ex4.13 The JSON-based web service of the Open Movie Database lets you s https://omdbapi.com/ for a movie by name and download its poster image. Write a tool poster that downloads the poster image for the movie named on the command line.\npackage main import ( \u0026quot;encoding/json\u0026quot; \u0026quot;fmt\u0026quot; \u0026quot;io\u0026quot; \u0026quot;net/http\u0026quot; \u0026quot;os\u0026quot; ) const OmdbAPI = \u0026quot;http://www.omdbapi.com/?i=tt3896198\u0026amp;apikey=7b94e6bd\u0026amp;t=\u0026quot; type Movie struct { Title string Year string Poster string Response string Errormsg string `json:\u0026quot;Error,omitempty\u0026quot;` } func main() { for i := 1; i \u0026lt; len(os.Args); i++ { url := OmdbAPI + os.Args[i] resp, err := http.Get(url) if err != nil { fmt.Println(\u0026quot;http get error \u0026quot;, err) return } defer resp.Body.Close() var result Movie err = json.NewDecoder(resp.Body).Decode(\u0026amp;result) if err != nil { fmt.Println(\u0026quot;decode failed\u0026quot;) return } fmt.Printf(\u0026quot;%#v\\n\u0026quot;, result) fmt.Printf(\u0026quot;%v\\n\u0026quot;, result) if result.Response == \u0026quot;false\u0026quot; { fmt.Println(result.Errormsg) } else { fmt.Println(\u0026quot;starting download poster\u0026quot;) result.Poster = \u0026quot;https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike92%2C5%2C5%2C92%2C30/sign=5a60b1a4cf8065386fe7ac41f6b4ca21/fd039245d688d43f4ee7a518781ed21b0ff43b89.jpg\u0026quot; posterres, err := http.Get(result.Poster) if err != nil { fmt.Println(\u0026quot;get poster url error, download failed\u0026quot;, err) return } else { filename := result.Title + \u0026quot;.jpg\u0026quot; f, err := os.Create(filename) if err != nil { fmt.Println(\u0026quot;create file error\u0026quot;) return } io.Copy(f, posterres.Body) } } } }  $ ./ex4.13 triangle triangleeeee main.Movie{Title:\u0026quot;Triangle\u0026quot;, Year:\u0026quot;2009\u0026quot;, Poster:\u0026quot;https://images-na.ssl-images-amazon.com/images/M/MV5BY2VlODI5ZmMtZDExYS00OWI4LWJiMWItZWZkZWRkNzlmZWI2XkEyXkFqcGdeQXVyMTQxNzMzNDI@._V1_SX300.jpg\u0026quot;, Response:\u0026quot;True\u0026quot;, Errormsg:\u0026quot;\u0026quot;} {Triangle 2009 https://images-na.ssl-images-amazon.com/images/M/MV5BY2VlODI5ZmMtZDExYS00OWI4LWJiMWItZWZkZWRkNzlmZWI2XkEyXkFqcGdeQXVyMTQxNzMzNDI@._V1_SX300.jpg True } starting download poster download finished main.Movie{Title:\u0026quot;\u0026quot;, Year:\u0026quot;\u0026quot;, Poster:\u0026quot;\u0026quot;, Response:\u0026quot;False\u0026quot;, Errormsg:\u0026quot;Movie not found!\u0026quot;} { False Movie not found!} Movie not found!  Ex 4.14 Create a web server that queries GitHub once and then allows navigation of the list of bug reports, milestones, and users.\npackage main import ( \u0026quot;encoding/json\u0026quot; \u0026quot;fmt\u0026quot; temp2 \u0026quot;html/template\u0026quot; \u0026quot;log\u0026quot; \u0026quot;net/http\u0026quot; \u0026quot;net/url\u0026quot; \u0026quot;os\u0026quot; \u0026quot;strings\u0026quot; temp1 \u0026quot;text/template\u0026quot; \u0026quot;time\u0026quot; ) const IssuesURL = \u0026quot;https://api.github.com/search/issues\u0026quot; //!+template const templ1 = `{{.TotalCount}} issues: {{range .Items}}---------------------------------------- Number: {{.Number}} User: {{.User.Login}} Title: {{.Title | printf \u0026quot;%.64s\u0026quot;}} Age: {{.CreatedAt | daysAgo}} days Milestone: {{.Milestone.Title}} {{end}}` const templ2 = ` \u0026lt;h1\u0026gt;{{.TotalCount}} issues\u0026lt;/h1\u0026gt; \u0026lt;table\u0026gt; \u0026lt;tr style='text-align: left'\u0026gt; \u0026lt;th\u0026gt;#\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;State\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;User\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;Title\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;Milestone\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; {{range .Items}} \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='{{.HTMLURL}}'\u0026gt;{{.Number}}\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{.State}}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='{{.User.HTMLURL}}'\u0026gt;{{.User.Login}}\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='{{.HTMLURL}}'\u0026gt;{{.Title}}\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='{{.Milestone.HTMLURL}}'\u0026gt;{{.Milestone.Title}}\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; {{end}} \u0026lt;/table\u0026gt; ` //!-template type IssuesSearchResult struct { TotalCount int `json:\u0026quot;total_count\u0026quot;` Items []*Issue } type Issue struct { Number int HTMLURL string `json:\u0026quot;html_url\u0026quot;` Title string State string User *User CreatedAt time.Time `json:\u0026quot;created_at\u0026quot;` Body string // in Markdown format Milestone *Milestone } type User struct { Login string HTMLURL string `json:\u0026quot;html_url\u0026quot;` } type Milestone struct { Title string HTMLURL string `json:\u0026quot;html_url\u0026quot;` } var report1 = temp1.Must(temp1.New(\u0026quot;issuelist1\u0026quot;). Funcs(temp1.FuncMap{\u0026quot;daysAgo\u0026quot;: daysAgo}). Parse(templ1)) var report2 = temp2.Must(temp2.New(\u0026quot;issuelist2\u0026quot;). Funcs(temp2.FuncMap{\u0026quot;daysAgo\u0026quot;: daysAgo}). Parse(templ2)) func main() { result, err := SearchIssues(os.Args[1:]) if err != nil { log.Fatal(err) } f1, err := os.Create(\u0026quot;report.txt\u0026quot;) if err := report1.Execute(f1, result); err != nil { log.Fatal(err) } f2, err := os.Create(\u0026quot;report.html\u0026quot;) if err := report2.Execute(f2, result); err != nil { log.Fatal(err) } } func daysAgo(t time.Time) int { return int(time.Since(t).Hours() / 24) } // SearchIssues queries the GitHub issue tracker. func SearchIssues(terms []string) (*IssuesSearchResult, error) { q := url.QueryEscape(strings.Join(terms, \u0026quot; \u0026quot;)) resp, err := http.Get(IssuesURL + \u0026quot;?q=\u0026quot; + q) if err != nil { return nil, err } // We must close resp.Body on all execution paths. // (Chapter 5 presents 'defer', which makes this simpler.) if resp.StatusCode != http.StatusOK { resp.Body.Close() return nil, fmt.Errorf(\u0026quot;search query failed: %s\u0026quot;, resp.Status) } var result IssuesSearchResult if err := json.NewDecoder(resp.Body).Decode(\u0026amp;result); err != nil { resp.Body.Close() return nil, err } resp.Body.Close() return \u0026amp;result, nil }  //report.txt 41 issues: ---------------------------------------- Number: 23188 User: ianlancetaylor Title: cmd/compile: incorrect order of evaluation according to spec Age: 7 days Milestone: Go1.11 ---------------------------------------- Number: 23183 User: terinjokes Title: net/http: muxer no longer redirects host patterns in go1.10 Age: 7 days Milestone: Go1.10 ---------------------------------------- Number: 23181 User: hirochachacha Title: cmd/buildid: rewrite algorithm is broken Age: 7 days Milestone: Go1.10 ---------------------------------------- Number: 23180 User: aarzilli Title: cmd/go: go test -c does not apply specified gcflags to all packa Age: 7 days Milestone: Go1.10 ---------------------------------------- Number: 23166 User: mvdan Title: x/tools/go/ssa/interp: tests consistently failing on darwin Age: 8 days Milestone: Go1.10 ---------------------------------------- Number: 23146 User: bradfitz Title: cmd/vet: stderr spam during testing Age: 12 days Milestone: Go1.10 ---------------------------------------- Number: 23122 User: rsc Title: all: remove support for OS X 10.8 and 10.9 Age: 13 days Milestone: Go1.11 ---------------------------------------- Number: 23098 User: mikioh Title: runtime: loop over allp causes a nil pointer dereference crash Age: 15 days Milestone: Go1.10 ---------------------------------------- Number: 23037 User: zolotov Title: cmd/go: add JSON output for building package failures while runn Age: 19 days Milestone: Go1.10 ---------------------------------------- Number: 23036 User: zolotov Title: cmd/test2json: filtering out testing service messages or mark th Age: 19 days Milestone: Go1.10 ---------------------------------------- Number: 23011 User: bradfitz Title: build: announce end of support for old macOS releases Age: 21 days Milestone: Go1.11 ---------------------------------------- Number: 23010 User: rsc Title: net/http: ResponseWriter panics in WriteHeaders that were former Age: 21 days Milestone: Go1.10 ---------------------------------------- Number: 23009 User: rsc Title: net/http/httputil: ReverseProxy change conflicts with future Rev Age: 21 days Milestone: Go1.10 ---------------------------------------- Number: 22984 User: rsc Title: cmd/go: test -json not cached Age: 22 days Milestone: Go1.10 ---------------------------------------- Number: 22924 User: chipaca Title: syscall: on linux 386 doesn't support syscalls that don't fail Age: 27 days Milestone: Go1.11 ---------------------------------------- Number: 22781 User: pciet Title: runtime: fatal error: sweep increased allocation count, go1.9.x Age: 39 days Milestone: Go1.9.3 ---------------------------------------- Number: 22637 User: ianlancetaylor Title: crypto: examine and probably remove OpenSSL derived code Age: 48 days Milestone: Go1.10 ---------------------------------------- Number: 22487 User: tklauser Title: lib/time: update tzdata before 1.10 release Age: 58 days Milestone: Go1.10 ---------------------------------------- Number: 22475 User: rsc Title: cmd/go: include GOROOT in linkActionID hash Age: 59 days Milestone: Go1.10 ---------------------------------------- Number: 22472 User: rsc Title: cmd/go: implement gccgo support for content-based staleness Age: 60 days Milestone: Go1.10 ---------------------------------------- Number: 22444 User: griesemer Title: cmd/compile: missing wrapper function for call of literal method Age: 62 days Milestone: Go1.11 ---------------------------------------- Number: 22429 User: TheTincho Title: cmd/compile: invalid instruction error for FMOVD when compiling Age: 63 days Milestone: Go1.9.3 ---------------------------------------- Number: 22349 User: alexbrainman Title: net: ipStackCapabilities.probe creates sockets that can escape i Age: 68 days Milestone: Go1.10 ---------------------------------------- Number: 22224 User: siebenmann Title: cmd/go: build failure on amd64 Linux with an error in TestTwoGop Age: 76 days Milestone: Go1.10 ---------------------------------------- Number: 22204 User: tmm1 Title: runtime: sigpanic during GC on android/arm64 Age: 77 days Milestone: Go1.10 ---------------------------------------- Number: 22155 User: rsc Title: cmd/go: GOROOT override using linker -X flag is probably not rig Age: 82 days Milestone: Go1.10 ---------------------------------------- Number: 21431 User: josharian Title: runtime: stack split at a bad time on mipsle Age: 135 days Milestone: Go1.10 ---------------------------------------- Number: 21282 User: dsnet Title: cmd/compile: incorrect type assertions on conflicting package na Age: 146 days Milestone: Go1.11 ---------------------------------------- Number: 21221 User: vibhavp Title: cmd/compile: internal compiler error: constant type mismatch whe Age: 150 days Milestone: Go1.11 ---------------------------------------- Number: 20790 User: mikioh Title: net: DefaultResolver.Lookup{Host,IPAddr} and LookupHost fail to Age: 185 days Milestone: Go1.11  //report.html \u0026lt;h1\u0026gt;41 issues\u0026lt;/h1\u0026gt; \u0026lt;table\u0026gt; \u0026lt;tr style='text-align: left'\u0026gt; \u0026lt;th\u0026gt;#\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;State\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;User\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;Title\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;Milestone\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/issues/23188'\u0026gt;23188\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;open\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/ianlancetaylor'\u0026gt;ianlancetaylor\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/issues/23188'\u0026gt;cmd/compile: incorrect order of evaluation according to spec\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/milestone/62'\u0026gt;Go1.11\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/issues/23183'\u0026gt;23183\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;open\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/terinjokes'\u0026gt;terinjokes\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/issues/23183'\u0026gt;net/http: muxer no longer redirects host patterns in go1.10\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/milestone/56'\u0026gt;Go1.10\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/issues/23181'\u0026gt;23181\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;open\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/hirochachacha'\u0026gt;hirochachacha\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/issues/23181'\u0026gt;cmd/buildid: rewrite algorithm is broken\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/milestone/56'\u0026gt;Go1.10\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/issues/23180'\u0026gt;23180\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;open\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/aarzilli'\u0026gt;aarzilli\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/issues/23180'\u0026gt;cmd/go: go test -c does not apply specified gcflags to all packages\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/milestone/56'\u0026gt;Go1.10\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/issues/23166'\u0026gt;23166\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;open\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/mvdan'\u0026gt;mvdan\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/issues/23166'\u0026gt;x/tools/go/ssa/interp: tests consistently failing on darwin\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/milestone/56'\u0026gt;Go1.10\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/issues/23146'\u0026gt;23146\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;open\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/bradfitz'\u0026gt;bradfitz\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/issues/23146'\u0026gt;cmd/vet: stderr spam during testing\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/milestone/56'\u0026gt;Go1.10\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/issues/23122'\u0026gt;23122\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;open\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/rsc'\u0026gt;rsc\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/issues/23122'\u0026gt;all: remove support for OS X 10.8 and 10.9\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/milestone/62'\u0026gt;Go1.11\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/issues/23098'\u0026gt;23098\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;open\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/mikioh'\u0026gt;mikioh\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/issues/23098'\u0026gt;runtime: loop over allp causes a nil pointer dereference crash\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/milestone/56'\u0026gt;Go1.10\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/issues/23037'\u0026gt;23037\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;open\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/zolotov'\u0026gt;zolotov\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/issues/23037'\u0026gt;cmd/go: add JSON output for building package failures while running go test on directory with several packages\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/milestone/56'\u0026gt;Go1.10\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/issues/23036'\u0026gt;23036\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;open\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/zolotov'\u0026gt;zolotov\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/issues/23036'\u0026gt;cmd/test2json: filtering out testing service messages or mark them in a special way\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/milestone/56'\u0026gt;Go1.10\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/issues/23011'\u0026gt;23011\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;open\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/bradfitz'\u0026gt;bradfitz\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/issues/23011'\u0026gt;build: announce end of support for old macOS releases\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/milestone/62'\u0026gt;Go1.11\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/issues/23010'\u0026gt;23010\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;open\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/rsc'\u0026gt;rsc\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/issues/23010'\u0026gt;net/http: ResponseWriter panics in WriteHeaders that were formerly ignored\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/milestone/56'\u0026gt;Go1.10\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/issues/23009'\u0026gt;23009\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;open\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/rsc'\u0026gt;rsc\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/issues/23009'\u0026gt;net/http/httputil: ReverseProxy change conflicts with future ReverseProxy plans\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/milestone/56'\u0026gt;Go1.10\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/issues/22984'\u0026gt;22984\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;open\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/rsc'\u0026gt;rsc\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/issues/22984'\u0026gt;cmd/go: test -json not cached\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/milestone/56'\u0026gt;Go1.10\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/issues/22924'\u0026gt;22924\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;open\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/chipaca'\u0026gt;chipaca\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/issues/22924'\u0026gt;syscall: on linux 386 doesn\u0026amp;#39;t support syscalls that don\u0026amp;#39;t fail\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/milestone/62'\u0026gt;Go1.11\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/issues/22781'\u0026gt;22781\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;open\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/pciet'\u0026gt;pciet\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/issues/22781'\u0026gt;runtime: fatal error: sweep increased allocation count, go1.9.x\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/milestone/63'\u0026gt;Go1.9.3\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/issues/22637'\u0026gt;22637\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;open\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/ianlancetaylor'\u0026gt;ianlancetaylor\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/issues/22637'\u0026gt;crypto: examine and probably remove OpenSSL derived code\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/milestone/56'\u0026gt;Go1.10\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/issues/22487'\u0026gt;22487\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;open\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/tklauser'\u0026gt;tklauser\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/issues/22487'\u0026gt;lib/time: update tzdata before 1.10 release\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/milestone/56'\u0026gt;Go1.10\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/issues/22475'\u0026gt;22475\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;open\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/rsc'\u0026gt;rsc\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/issues/22475'\u0026gt;cmd/go: include GOROOT in linkActionID hash\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/milestone/56'\u0026gt;Go1.10\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/issues/22472'\u0026gt;22472\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;open\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/rsc'\u0026gt;rsc\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/issues/22472'\u0026gt;cmd/go: implement gccgo support for content-based staleness\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/milestone/56'\u0026gt;Go1.10\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/issues/22444'\u0026gt;22444\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;open\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/griesemer'\u0026gt;griesemer\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/issues/22444'\u0026gt;cmd/compile: missing wrapper function for call of literal method expression\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/milestone/62'\u0026gt;Go1.11\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/issues/22429'\u0026gt;22429\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;open\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/TheTincho'\u0026gt;TheTincho\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/issues/22429'\u0026gt;cmd/compile: invalid instruction error for FMOVD when compiling for 387\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/milestone/63'\u0026gt;Go1.9.3\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/issues/22349'\u0026gt;22349\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;open\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/alexbrainman'\u0026gt;alexbrainman\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/issues/22349'\u0026gt;net: ipStackCapabilities.probe creates sockets that can escape into child process\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/milestone/56'\u0026gt;Go1.10\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/issues/22224'\u0026gt;22224\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;open\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/siebenmann'\u0026gt;siebenmann\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/issues/22224'\u0026gt;cmd/go: build failure on amd64 Linux with an error in TestTwoGopathShlibsGccgo from CL 69831 onward\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/milestone/56'\u0026gt;Go1.10\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/issues/22204'\u0026gt;22204\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;open\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/tmm1'\u0026gt;tmm1\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/issues/22204'\u0026gt;runtime: sigpanic during GC on android/arm64\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/milestone/56'\u0026gt;Go1.10\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/issues/22155'\u0026gt;22155\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;open\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/rsc'\u0026gt;rsc\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/issues/22155'\u0026gt;cmd/go: GOROOT override using linker -X flag is probably not right\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/milestone/56'\u0026gt;Go1.10\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/issues/21431'\u0026gt;21431\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;open\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/josharian'\u0026gt;josharian\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/issues/21431'\u0026gt;runtime: stack split at a bad time on mipsle\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/milestone/56'\u0026gt;Go1.10\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/issues/21282'\u0026gt;21282\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;open\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/dsnet'\u0026gt;dsnet\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/issues/21282'\u0026gt;cmd/compile: incorrect type assertions on conflicting package names\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/milestone/62'\u0026gt;Go1.11\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/issues/21221'\u0026gt;21221\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;open\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/vibhavp'\u0026gt;vibhavp\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/issues/21221'\u0026gt;cmd/compile: internal compiler error: constant type mismatch when comparing two unsafe.Pointer rvalues\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/milestone/62'\u0026gt;Go1.11\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/issues/20790'\u0026gt;20790\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;open\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/mikioh'\u0026gt;mikioh\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/issues/20790'\u0026gt;net: DefaultResolver.Lookup{Host,IPAddr} and LookupHost fail to parse a literal IPv6 address w/ zone\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;a href='https://github.com/golang/go/milestone/62'\u0026gt;Go1.11\u0026lt;/a\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt;  ","date":1514142000,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1543733643,"objectID":"89eaaab6c60976733146f69433936e17","permalink":"https://mooncaker816.github.io/2017/12/24/the-go-programming-language-ex5/","publishdate":"2017-12-24T19:00:00Z","relpermalink":"/2017/12/24/the-go-programming-language-ex5/","section":"post","summary":"Ex 4.8 Modify charcount to count letters, digits, and so on in their Unicode categories, using functions like unicode.IsLetter.\n","tags":["The Go Programming Language Ex","Go map","Go template","Go JSON"],"title":"The Go Programming Language Ex（5）","type":"post"},{"authors":null,"categories":["Golang"],"content":"Ex 4.1 Write a function that counts the number of bits that are different in two SHA256 hashes. (See PopCount from Section 2.6.2.)\npackage main import ( \u0026quot;crypto/sha256\u0026quot; \u0026quot;fmt\u0026quot; ) func main() { str1 := \u0026quot;abc\u0026quot; str2 := \u0026quot;xyz\u0026quot; hash1 := sha256.Sum256([]byte(str1)) hash2 := sha256.Sum256([]byte(str2)) var dif int for i := 0; i \u0026lt; 32; i++ { dif += popcount(hash1[i] ^ hash2[i]) } fmt.Printf(\u0026quot;there are %d different bits between these 2 hashes\\n\u0026quot;, dif) } func popcount(x byte) int { var count int for x != 0 { count++ x \u0026amp;= x - 1 } return count }  $ go run difhash.go there are 121 different bits between these 2 hashes  Ex 4.2 Write a program that prints the SHA256 hash of its standard input by default but supports a command-line ﬂag to print the SHA384 or SHA512 hash instead.\npackage main import ( \u0026quot;crypto/sha256\u0026quot; \u0026quot;crypto/sha512\u0026quot; \u0026quot;flag\u0026quot; \u0026quot;fmt\u0026quot; \u0026quot;log\u0026quot; ) func main() { method := flag.String(\u0026quot;sha\u0026quot;, \u0026quot;256\u0026quot;, \u0026quot;default is SHA256, optional 384,512\u0026quot;) flag.Parse() //去掉flag参数后剩余的输入参数，此处为需要计算hash的字符串 fmt.Printf(\u0026quot;there are %d non-flag input params\\n\u0026quot;, flag.NArg()) for i, str := range flag.Args() { switch *method { case \u0026quot;256\u0026quot;: c := sha256.Sum256([]byte(str)) fmt.Printf(\u0026quot;#%d:SHA256 of %s is %x\\n\u0026quot;, i, str, c) case \u0026quot;384\u0026quot;: c := sha512.Sum384([]byte(str)) fmt.Printf(\u0026quot;#%d:SHA384 of %s is %x\\n\u0026quot;, i, str, c) case \u0026quot;512\u0026quot;: c := sha512.Sum512([]byte(str)) fmt.Printf(\u0026quot;#%d:SHA512 of %s is %x\\n\u0026quot;, i, str, c) default: log.Fatal(\u0026quot;not support\u0026quot;) } } }  $ ./ex4.2 -sha 256 a b c abc there are 4 non-flag input params #0:SHA256 of a is ca978112ca1bbdcafac231b39a23dc4da786eff8147c4e72b9807785afee48bb #1:SHA256 of b is 3e23e8160039594a33894f6564e1b1348bbd7a0088d42c4acb73eeaed59c009d #2:SHA256 of c is 2e7d2c03a9507ae265ecf5b5356885a53393a2029d241394997265a1a25aefc6 #3:SHA256 of abc is ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad $ ./ex4.2 -sha 384 a b c abc there are 4 non-flag input params #0:SHA384 of a is 54a59b9f22b0b80880d8427e548b7c23abd873486e1f035dce9cd697e85175033caa88e6d57bc35efae0b5afd3145f31 #1:SHA384 of b is 98a906182cdcfb1eb4eb47117600f68958e2ddd140248b47984f4bde6587b89c8215c3da895a336e94ad1aca39015c40 #2:SHA384 of c is 40f98a05660bf871802ee59964de1945bd731a45cc7f48e4dadd92f34a7eeec089e149ad8c2434f11792e588b740d997 #3:SHA384 of abc is cb00753f45a35e8bb5a03d699ac65007272c32ab0eded1631a8b605a43ff5bed8086072ba1e7cc2358baeca134c825a7 $ ./ex4.2 -sha 512 a b c abc there are 4 non-flag input params #0:SHA512 of a is 1f40fc92da241694750979ee6cf582f2d5d7d28e18335de05abc54d0560e0f5302860c652bf08d560252aa5e74210546f369fbbbce8c12cfc7957b2652fe9a75 #1:SHA512 of b is 5267768822ee624d48fce15ec5ca79cbd602cb7f4c2157a516556991f22ef8c7b5ef7b18d1ff41c59370efb0858651d44a936c11b7b144c48fe04df3c6a3e8da #2:SHA512 of c is acc28db2beb7b42baa1cb0243d401ccb4e3fce44d7b02879a52799aadff541522d8822598b2fa664f9d5156c00c924805d75c3868bd56c2acb81d37e98e35adc #3:SHA512 of abc is ddaf35a193617abacc417349ae20413112e6fa4e89a97ea20a9eeee64b55d39a2192992a274fc1a836ba3c23a3feebbd454d4423643ce80e2a9ac94fa54ca49f $ ./ex4.2 -sha 777 a b c abc there are 4 non-flag input params 2017/12/22 20:53:41 not support $./ex4.2 a b c abc there are 4 non-flag input params #0:SHA256 of a is ca978112ca1bbdcafac231b39a23dc4da786eff8147c4e72b9807785afee48bb #1:SHA256 of b is 3e23e8160039594a33894f6564e1b1348bbd7a0088d42c4acb73eeaed59c009d #2:SHA256 of c is 2e7d2c03a9507ae265ecf5b5356885a53393a2029d241394997265a1a25aefc6 #3:SHA256 of abc is ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad  Ex 4.3 Rewrite reverse to use an array pointer instead of a slice.\npackage main import ( \u0026quot;fmt\u0026quot; ) func main() { s := [5]byte{1, 2, 3, 4, 5} fmt.Println(s) reverse(\u0026amp;s) fmt.Println(s) } func reverse(a *[5]byte) { for i, j := 0, len(a)-1; i \u0026lt; j; i, j = i+1, j-1 { a[i], a[j] = a[j], a[i] } }  $ go run reverse.go [1 2 3 4 5] [5 4 3 2 1]  Ex 4.4 Write a version of rotate that operates in a single pass.\npackage main import ( \u0026quot;fmt\u0026quot; \u0026quot;log\u0026quot; ) func main() { s := []int{0, 1, 2, 3, 4, 5, 6, 7, 8} rotate(\u0026amp;s, 3) fmt.Println(s) } func rotate(s *[]int, n int) { if n \u0026gt; len(*s) { log.Fatal(\u0026quot;invalid rotate num\u0026quot;) } var ls []int ls = append(ls, (*s)[n:]...) ls = append(ls, (*s)[:n]...) *s = ls }  $ go run rotate.go [3 4 5 6 7 8 0 1 2]  Ex 4.5 Write an in-place function to eliminate adjacent duplicates in a []string slice.\npackage main import ( \u0026quot;fmt\u0026quot; ) func main() { s1 := []string{\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;, \u0026quot;d\u0026quot;, \u0026quot;d\u0026quot;} s11 := s1 dup(\u0026amp;s1) dup1(\u0026amp;s11) fmt.Println(s1, s11) s2 := []string{\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;} s21 := s2 dup(\u0026amp;s2) dup(\u0026amp;s21) fmt.Println(s2, s21) } func dup(s *[]string) { var ls []string ls = append(ls, (*s)[0]) for i := 0; i \u0026lt; len(*s)-1; i++ { if (*s)[i] != (*s)[i+1] { ls = append(ls, (*s)[i+1]) } } *s = ls } func dup1(s *[]string) { j := 0 var temp string for i := range *s { (*s)[j] = (*s)[i] j++ if i \u0026gt; 0 \u0026amp;\u0026amp; temp == (*s)[i] { j-- } temp = (*s)[i] } *s = (*s)[:j] }  $ go run dup.go [a b c d] [a b c d] [a b c] [a b c]  Ex 4.6 Write an in-place function that squashes each run of adjacent Unicode spac (see unicode.IsSpace) in a UTF-8-encoded []byte slice into a single ASCII space.\npackage main import ( \u0026quot;fmt\u0026quot; \u0026quot;unicode\u0026quot; \u0026quot;unicode/utf8\u0026quot; ) func main() { str := \u0026quot;\\t世界a \\na\\r\\t\\vb \u0026quot; s1 := []byte(str) s2 := []byte(str) //s1 := []byte{'a', 'b', ' ', '\t', '\\n', 'c', ' '} fmt.Printf(\u0026quot;before:%d %[1]v %[1]s\\n\u0026quot;, s1) utf8space(\u0026amp;s1) fmt.Printf(\u0026quot;after:%d %[1]v %[1]s\\n\u0026quot;, s1) //s2 := []byte{'1', '2', ' ', '\t', '\\n', '3', ' ', '\\t'} fmt.Printf(\u0026quot;before:%d %[1]v %[1]s\\n\u0026quot;, s2) utf8space2(\u0026amp;s2) fmt.Printf(\u0026quot;after:%d %[1]v %[1]s\\n\u0026quot;, s2) } func utf8space(s *[]byte) { var ls []byte runes := []rune(string(*s)) spaceInd := false for _, r := range runes { if !unicode.IsSpace(r) { spaceInd = false ls = append(ls, []byte(string(r))...) } else if unicode.IsSpace(r) \u0026amp;\u0026amp; !spaceInd { spaceInd = true ls = append(ls, byte(32)) } } *s = ls } func utf8space2(s *[]byte) { str := string(*s) spaceInd := false j := 0 for i, r := range str { bytelen := utf8.RuneLen(r) if !unicode.IsSpace(r) { spaceInd = false copy((*s)[j:], (*s)[i:i+bytelen]) j += bytelen } else if unicode.IsSpace(r) \u0026amp;\u0026amp; !spaceInd { spaceInd = true bytelen = 1 copy((*s)[j:], \u0026quot; \u0026quot;) j += bytelen } } *s = (*s)[:j] }  $ go run utf8space.go before:[9 228 184 150 231 149 140 97 32 10 97 13 9 11 98 32 32 32] [9 228 184 150 231 149 140 97 32 10 97 13 9 11 98 32 32 32] 世界a a b after:[32 228 184 150 231 149 140 97 32 97 32 98 32] [32 228 184 150 231 149 140 97 32 97 32 98 32] 世界a a b before:[9 228 184 150 231 149 140 97 32 10 97 13 9 11 98 32 32 32] [9 228 184 150 231 149 140 97 32 10 97 13 9 11 98 32 32 32] 世界a a b after:[32 228 184 150 231 149 140 97 32 97 32 98 32] [32 228 184 150 231 149 140 97 32 97 32 98 32] 世界a a b  for range遍历字符串的时候，i为当前字符开始的位置，v为当前字符。换句话说，字符串包含多字节utf8字符时，i不连续，因为遍历的单位不是byte，而是rune（unicode）。\nEx 4.7 Modify reverse to reverse the characters of a []byte slice that represents a UTF-8-encoded string, in place. Can you do it without allocating new memory?\npackage main import ( \u0026quot;fmt\u0026quot; \u0026quot;unicode\u0026quot; ) func main() { str := \u0026quot;\\U00000080world,世界,hello,你好\u0026quot; s1 := []byte(str) //每个元素根据utf8的格式，确定utf8表达字符的字节数，或为单字节或为多字节 s2 := []rune(str) //一个元素就是一个unicode fmt.Printf(\u0026quot;% x \\n % x\\n\u0026quot;, s1, s2) fmt.Println(Reverse(str)) reverse(s2) fmt.Println(string(s2)) } // Reverse reverses the input while respecting UTF8 encoding and combined characters func Reverse(text string) string { textRunes := []rune(text) textRunesLength := len(textRunes) if textRunesLength \u0026lt;= 1 { return text } i, j := 0, 0 for i \u0026lt; textRunesLength \u0026amp;\u0026amp; j \u0026lt; textRunesLength { j = i + 1 for j \u0026lt; textRunesLength \u0026amp;\u0026amp; isMark(textRunes[j]) { j++ } if isMark(textRunes[j-1]) { // Reverses Combined Characters reverse(textRunes[i:j]) } i = j } // Reverses the entire array reverse(textRunes) return string(textRunes) } func reverse(runes []rune) { for i, j := 0, len(runes)-1; i \u0026lt; j; i, j = i+1, j-1 { runes[i], runes[j] = runes[j], runes[i] } } // isMark determines whether the rune is a marker func isMark(r rune) bool { return unicode.Is(unicode.Mn, r) || unicode.Is(unicode.Me, r) || unicode.Is(unicode.Mc, r) }  $ go run utf8reverse.go c2 80 77 6f 72 6c 64 2c e4 b8 96 e7 95 8c 2c 68 65 6c 6c 6f 2c e4 bd a0 e5 a5 bd [ 80 77 6f 72 6c 64 2c 4e16 754c 2c 68 65 6c 6c 6f 2c 4f60 597d] 好你,olleh,界世,dlrow 好你,olleh,界世,dlrow  Reverse：确保了组合字符（多个unicode组合成一个字符）翻转的正确性\nreverse：不考虑组合字符，翻转正确\n","date":1514055600,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1543733643,"objectID":"8f4b6fb7bfd979893d4c32440e61df2e","permalink":"https://mooncaker816.github.io/2017/12/23/the-go-programming-language-ex4/","publishdate":"2017-12-23T19:00:00Z","relpermalink":"/2017/12/23/the-go-programming-language-ex4/","section":"post","summary":"Ex 4.1 Write a function that counts the number of bits that are different in two SHA256 hashes. (See PopCount from Section 2.6.2.)\n","tags":["The Go Programming Language Ex","Go slice"],"title":"The Go Programming Language Ex（4）","type":"post"},{"authors":null,"categories":["Golang"],"content":"Ex 3.10 Write a non-recursive version of comma, using bytes.Buffer instead of str concatenation.\npackage main import ( \u0026quot;bytes\u0026quot; \u0026quot;fmt\u0026quot; \u0026quot;log\u0026quot; \u0026quot;os\u0026quot; ) func main() { for _, v := range os.Args[1:] { s := []byte(v) var buf bytes.Buffer for i, j := len(s)-1, 0; i \u0026gt;= 0; i-- { err := buf.WriteByte(s[i]) if err != nil { log.Fatal(\u0026quot;write buf failed\u0026quot;) } if j++; j != len(s) \u0026amp;\u0026amp; j%3 == 0 { err = buf.WriteByte(',') } } fmt.Println(Reverse(buf.String())) } } func Reverse(s string) string { r := []rune(s) for i, j := len(r)-1, 0; i \u0026gt; j; i, j = i-1, j+1 { r[i], r[j] = r[j], r[i] } return string(r) }  $ ./ex3.10 12345678 829356934592162 23 7777 333 12,345,678 829,356,934,592,162 23 7,777 333  Ex 3.11 Enhance comma so that it deals correctly with ﬂoating-point numbers and an optional sign.\npackage main import ( \u0026quot;bytes\u0026quot; \u0026quot;fmt\u0026quot; \u0026quot;log\u0026quot; \u0026quot;os\u0026quot; ) func main() { for _, v := range os.Args[1:] { var lbuf, rbuf bytes.Buffer var lstr, rstr, sign string if v[0] == '+' || v[0] == '-' { sign = string(v[0]) v = v[1:] } chars := bytes.SplitAfterN([]byte(v), []byte(\u0026quot;.\u0026quot;), 2) for ix, pc := range chars { if ix == 0 { if pc[len(pc)-1] == '.' { pc = pc[:len(pc)-1] err := lbuf.WriteByte('.') if err != nil { log.Fatal(\u0026quot;write '.' in buf failed\u0026quot;) } } if len(pc) \u0026gt; 0 { for i, j := len(pc)-1, 0; i \u0026gt;= 0; i-- { err := lbuf.WriteByte(pc[i]) if err != nil { log.Fatal(\u0026quot;write int part in buf failed\u0026quot;) } if j++; j != len(pc) \u0026amp;\u0026amp; j%3 == 0 { err = lbuf.WriteByte(',') } } lstr = Reverse(lbuf.String()) } } if ix == 1 { if len(pc) \u0026gt; 0 { for i, j := 0, 0; i \u0026lt; len(pc); i++ { err := rbuf.WriteByte(pc[i]) if err != nil { log.Fatal(\u0026quot;write float part in buf failed\u0026quot;) } if j++; j != len(pc) \u0026amp;\u0026amp; j%3 == 0 { err = rbuf.WriteByte(',') } } rstr = rbuf.String() } else { rstr = \u0026quot;0\u0026quot; } } } fmt.Println(sign + lstr + rstr) } } func Reverse(s string) string { r := []rune(s) for i, j := len(r)-1, 0; i \u0026gt; j; i, j = i-1, j+1 { r[i], r[j] = r[j], r[i] } return string(r) }  $ go run comma.go +123456.4563 -2342335352234.234 234235235211 +1243535353434 24533. 454545.345354456 +123,456.456,3 -2,342,335,352,234.234 234,235,235,211 +1,243,535,353,434 24,533.0 454,545.345,354,456  Ex 3.12 Write a function that reports whether two strings are anagrams of each other, that is, they contain the same letters in a different order.\npackage main import ( \u0026quot;fmt\u0026quot; \u0026quot;os\u0026quot; \u0026quot;sort\u0026quot; ) func main() { s1 := []rune(os.Args[1]) s2 := []rune(os.Args[2]) var ss1 = make([]string, len(s1)) var ss2 = make([]string, len(s2)) for i, v := range s1 { ss1[i] = string(v) } for i, v := range s2 { ss2[i] = string(v) } sort.Strings(ss1) sort.Strings(ss2) if len(ss1) != len(ss2) { fmt.Println(\u0026quot;they are NOT anagrams strings\u0026quot;) return } for i := 0; i \u0026lt; len(ss1); i++ { if ss1[i] != ss2[i] { fmt.Println(\u0026quot;they are NOT anagrams strings\u0026quot;) return } } fmt.Println(\u0026quot;they are anagrams strings\u0026quot;) }  $ go run anagrams.go abcdefg acdefgb they are anagrams strings $ go run anagrams.go aabbccdd dcbadcba they are anagrams strings $ go run anagrams.go abcde dbca they are NOT anagrams strings $ go run anagrams.go abcde dbcaf they are NOT anagrams strings  Ex 3.13 Write const declarations for KB, MB, up through YB as compactly as you can.\npackage main import ( \u0026quot;fmt\u0026quot; ) const ( _ = int64(1) \u0026lt;\u0026lt; (10 * iota) KiB // 1024 2e1 MiB // 1048576 2e20 GiB // 1073741824 2e30 TiB // 1099511627776 PiB // 1125899906842624 EiB // 1152921504606846976 //ZiB // 1180591620717411303424 overflow //YiB // 1208925819614629174706176 overflow KB = int64(1000) MB = 1000 * KB GB = 1000 * MB TB = 1000 * GB PB = 1000 * TB EB = 1000 * PB ) func main() { fmt.Println(KiB, MiB, GiB, TiB, PiB, EiB) fmt.Println(KB, MB, GB, TB, PB, EB) }  $ go run const.go 1024 1048576 1073741824 1099511627776 1125899906842624 1152921504606846976 1000 1000000 1000000000 1000000000000 1000000000000000 1000000000000000000 ","date":1513962000,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1543733643,"objectID":"d6511ebaf475cc560fbe8e2f1ee75fcc","permalink":"https://mooncaker816.github.io/2017/12/22/the-go-programming-language-ex3/","publishdate":"2017-12-22T17:00:00Z","relpermalink":"/2017/12/22/the-go-programming-language-ex3/","section":"post","summary":"Ex 3.10 Write a non-recursive version of comma, using bytes.Buffer instead of str concatenation.\n","tags":["The Go Programming Language Ex"],"title":"The Go Programming Language Ex（3）","type":"post"},{"authors":null,"categories":["Golang"],"content":"Ex 2.1 Add types, constants, and functions to tempconv for processing temperatures in the Kelvin scale, where zero Kelvin is −273.15°C and a difference of 1K has the same magnitude as 1°C.\npackage tempconv import \u0026quot;fmt\u0026quot; type Celsius float64 type Fahrenheit float64 type Kelvin float64 const ( AbsoluteZeroC Celsius = -273.15 FreezingC Celsius = 0 BoilingC Celsius = 100 ) func (c Celsius) String() string { return fmt.Sprintf(\u0026quot;%g°C\u0026quot;, c) } func (f Fahrenheit) String() string { return fmt.Sprintf(\u0026quot;%g°F\u0026quot;, f) } func (k Kelvin) String() string { return fmt.Sprintf(\u0026quot;%g°K\u0026quot;, k) }  package tempconv // CToF converts a Celsius temperature to Fahrenheit. func CToF(c Celsius) Fahrenheit { return Fahrenheit(c*9/5 + 32) } // FToC converts a Fahrenheit temperature to Celsius. func FToC(f Fahrenheit) Celsius { return Celsius((f - 32) * 5 / 9) } //CToK converts a Celsius temperature to Kelvin. func CToK(c Celsius) Kelvin { return Kelvin(c + 273.15) } //KToC converts a Kelvin temperature to Celsius. func KToC(k Kelvin) Celsius { return Celsius(k - 273.15) } //FToK converts a Fahrenheit temperature to Kelvin. func FToK(f Fahrenheit) Kelvin { return Kelvin((f-32)*5/9 + 273.15) } // KToF converts a Kelvin temperature to Fahrenheit. func KToF(k Kelvin) Fahrenheit { return Fahrenheit((k-273.15)*9/5 + 32) }  package main import ( \u0026quot;fmt\u0026quot; \u0026quot;The_Go_Programming_Language_Exercises/CH2/ex2.1/tempconv\u0026quot; ) func main() { fmt.Println(tempconv.CToK(tempconv.BoilingC)) k1 := tempconv.Kelvin(273) fmt.Println(tempconv.KToC(k1)) fmt.Println(tempconv.KToF(k1)) }  $ go run main.go 373.15°K -0.14999999999997726°C 31.73000000000004°F  Ex 2.2 package main import ( \u0026quot;bufio\u0026quot; \u0026quot;fmt\u0026quot; \u0026quot;io\u0026quot; \u0026quot;os\u0026quot; \u0026quot;strconv\u0026quot; \u0026quot;strings\u0026quot; \u0026quot;The_Go_Programming_Language_Exercises/CH2/ex2.2/unitconv\u0026quot; ) func main() { var s []string if len(os.Args) \u0026gt; 1 { s = os.Args[1:] } else { input, err := os.Open(\u0026quot;a\u0026quot;) if err != nil { fmt.Println(\u0026quot;happend a error when opening\u0026quot;, err) } defer input.Close() buf := bufio.NewReader(input) for { line, err := buf.ReadString('\\n') line = strings.TrimSpace(line) s = append(s, line) if err != nil { if err == io.EOF { break } fmt.Fprintf(os.Stderr, \u0026quot;reading error %v\\n\u0026quot;, err) os.Exit(1) } } } for _, arg := range s { t, err := strconv.ParseFloat(arg, 64) if err != nil { fmt.Fprintf(os.Stderr, \u0026quot;invalid input: %v\\n\u0026quot;, err) os.Exit(1) } f := unitconv.Fahrenheit(t) c := unitconv.Celsius(t) p := unitconv.Pounds(t) kg := unitconv.Kilograms(t) fe := unitconv.Feet(t) m := unitconv.Meter(t) fmt.Printf(\u0026quot;%s = %s, %s = %s\\n\u0026quot;, f, unitconv.FToC(f), c, unitconv.CToF(c)) fmt.Printf(\u0026quot;%s = %s, %s = %s\\n\u0026quot;, p, unitconv.PToKg(p), kg, unitconv.KgToP(kg)) fmt.Printf(\u0026quot;%s = %s, %s = %s\\n\u0026quot;, fe, unitconv.FeToM(fe), m, unitconv.MToFe(m)) } }  //file a 11 22 33  $ ./ex2.2 11°F = -11.666666666666666°C, 11°C = 51.8°F 11 pounds = 4.9895160700000005 kilograms, 11 kilograms = 24.2508488403368 pounds 11 feets = 3.3528000000000002 meters, 11 meters = 36.08913 feets 22°F = -5.555555555555555°C, 22°C = 71.6°F 22 pounds = 9.979032140000001 kilograms, 22 kilograms = 48.5016976806736 pounds 22 feets = 6.7056000000000004 meters, 22 meters = 72.17826 feets 33°F = 0.5555555555555556°C, 33°C = 91.4°F 33 pounds = 14.968548210000002 kilograms, 33 kilograms = 72.7525465210104 pounds 33 feets = 10.0584 meters, 33 meters = 108.26738999999999 feets $ ./ex2.2 11 22 33 44.5 11°F = -11.666666666666666°C, 11°C = 51.8°F 11 pounds = 4.9895160700000005 kilograms, 11 kilograms = 24.2508488403368 pounds 11 feets = 3.3528000000000002 meters, 11 meters = 36.08913 feets 22°F = -5.555555555555555°C, 22°C = 71.6°F 22 pounds = 9.979032140000001 kilograms, 22 kilograms = 48.5016976806736 pounds 22 feets = 6.7056000000000004 meters, 22 meters = 72.17826 feets 33°F = 0.5555555555555556°C, 33°C = 91.4°F 33 pounds = 14.968548210000002 kilograms, 33 kilograms = 72.7525465210104 pounds 33 feets = 10.0584 meters, 33 meters = 108.26738999999999 feets 44.5°F = 6.944444444444445°C, 44.5°C = 112.1°F 44.5 pounds = 20.184860465 kilograms, 44.5 kilograms = 98.10570667227161 pounds 44.5 feets = 13.563600000000001 meters, 44.5 meters = 145.996935 feets  Ex 2.3 2.4 2.5 Rewrite PopCount to use a loop instead of a single expression. Compare the performance of the two versions. (Section 11.4 shows how to compare the performance of different implementations systematically.)\nWrite a version of PopCount that counts bits by shifting its argument through 64 bit positions, testing the rightmost bit each time. Compare its performance to the tablelookup version.\nThe expression x\u0026amp;(x-1) clears the rightmost non-zero bit of x. Write a version of PopCount that counts bits by using this fact, and assess its performance.\npackage popcount_test import ( \u0026quot;fmt\u0026quot; \u0026quot;io/ioutil\u0026quot; \u0026quot;testing\u0026quot; ) func init() { for i := range pc { pc[i] = pc[i/2] + byte(i\u0026amp;1) } for i := 0; i \u0026lt; 256; i++ { n[i] = i } } var pc [256]byte var n = make([]int, 256) //通过v\u0026amp;(v-1)，将v对应的二进制中最右的非零位置零，直到v=0为止，此时置零的次数即为popcount的值 func BenchmarkPopCount1(b *testing.B) { for i := 0; i \u0026lt; b.N; i++ { for _, v := range n { var count int for v != 0 { count++ v \u0026amp;= v - 1 } fmt.Fprintln(ioutil.Discard, count) //fmt.Fprintln(os.Stdout, count) } } } //把64位平均分为8份，每份对应一个字节，读出该字节的数值，去预先准备好的单字节(8位)所能存储的所有数值对应的popcount的表中查询出每份的popcount，再相加8份的popcount func BenchmarkPopCount2(b *testing.B) { for i := 0; i \u0026lt; b.N; i++ { for _, x := range n { count := int(pc[byte(x\u0026gt;\u0026gt;(0*8))] + pc[byte(x\u0026gt;\u0026gt;(1*8))] + pc[byte(x\u0026gt;\u0026gt;(2*8))] + pc[byte(x\u0026gt;\u0026gt;(3*8))] + pc[byte(x\u0026gt;\u0026gt;(4*8))] + pc[byte(x\u0026gt;\u0026gt;(5*8))] + pc[byte(x\u0026gt;\u0026gt;(6*8))] + pc[byte(x\u0026gt;\u0026gt;(7*8))]) fmt.Fprintln(ioutil.Discard, count) //fmt.Fprintln(os.Stdout, count) } } } //从最右开始一位一位检查是否为1 func BenchmarkPopCount3(b *testing.B) { for i := 0; i \u0026lt; b.N; i++ { for _, v := range n { var count int for ; v != 0; v \u0026gt;\u0026gt;= 1 { count += v \u0026amp; 1 } fmt.Fprintln(ioutil.Discard, count) //fmt.Fprintln(os.Stdout, count) } } }  $ go test -v -run=\u0026quot;none\u0026quot; -bench=. -benchtime=\u0026quot;3s\u0026quot; -benchmem BenchmarkPopCount1-4 200000\t23154 ns/op\t2048 B/op\t256 allocs/op BenchmarkPopCount2-4 200000\t21941 ns/op\t2048 B/op\t256 allocs/op BenchmarkPopCount3-4 200000\t24450 ns/op\t2048 B/op\t256 allocs/op PASS ok The_Go_Programming_Language_Exercises/CH2/ex2.3\t14.646s  n\u0026amp;(n-1) ：将n的二进制最右边的非零位置零\n平均来说，此3种方法中查表最快，n\u0026amp;(n-1)居中，一位一位数最慢\n","date":1513875600,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1543733643,"objectID":"8eef815d849dcaa8357915c02791518f","permalink":"https://mooncaker816.github.io/2017/12/21/the-go-programming-language-ex2/","publishdate":"2017-12-21T17:00:00Z","relpermalink":"/2017/12/21/the-go-programming-language-ex2/","section":"post","summary":"Ex 2.1 Add types, constants, and functions to tempconv for processing temperatures in the Kelvin scale, where zero Kelvin is −273.15°C and a difference of 1K has the same magnitude as 1°C.\n","tags":["The Go Programming Language Ex"],"title":"The Go Programming Language Ex（2）","type":"post"},{"authors":null,"categories":["Golang"],"content":"Ex 1.1 Modify the echo program to also print os.Args[0], the name of the command that invoked it.\n//Modify the echo program to also print os.Args[0], the name of the command that invoked it. package main import ( \u0026quot;fmt\u0026quot; \u0026quot;os\u0026quot; \u0026quot;strings\u0026quot; ) func main() { fmt.Println(\u0026quot;打印命令+所有参数\u0026quot;) fmt.Println(strings.Join(os.Args[:], \u0026quot; \u0026quot;)) fmt.Println(\u0026quot;打印所有参数\u0026quot;) fmt.Println(strings.Join(os.Args[1:], \u0026quot; \u0026quot;)) }  $ go run main.go a b c d 打印命令+所有参数 /var/folders/d8/pcxm4kx97flf9vfs3m7j_qlm0000gn/T/go-build129101527/command-line-arguments/_obj/exe/main a b c d 打印所有参数 a b c d  Ex 1.2 Modify the echo program to print the index and value of each of its arguments, one per line.\npackage main import ( \u0026quot;fmt\u0026quot; \u0026quot;os\u0026quot; ) func main() { for i, v := range os.Args[1:] { fmt.Printf(\u0026quot;第%d个参数为：%s\\n\u0026quot;, i+1, v) } }  $ go run main.go a b c d 第1个参数为：a 第2个参数为：b 第3个参数为：c 第4个参数为：d  Ex 1.3 Experiment to measure the difference in running time between our po inefﬁcient versions and the one that uses strings.Join. (Section 1.6 illustrates part of the time package, and Section 11.4 shows how to write benchmark tests for systematic performance evaluation.)\n//比较不同版本的性能 package echo_test import ( \u0026quot;strings\u0026quot; \u0026quot;testing\u0026quot; ) func BenchmarkEcho1(b *testing.B) { s1 := []string{\u0026quot;1\u0026quot;, \u0026quot;2\u0026quot;, \u0026quot;3\u0026quot;, \u0026quot;4\u0026quot;, \u0026quot;5\u0026quot;} b.ResetTimer() for i := 0; i \u0026lt; b.N; i++ { s, sep := \u0026quot;\u0026quot;, \u0026quot;\u0026quot; for _, arg := range s1 { s += sep + arg sep = \u0026quot; \u0026quot; } //fmt.Println(s) } } func BenchmarkEcho2(b *testing.B) { s2 := []string{\u0026quot;1\u0026quot;, \u0026quot;2\u0026quot;, \u0026quot;3\u0026quot;, \u0026quot;4\u0026quot;, \u0026quot;5\u0026quot;} b.ResetTimer() for i := 0; i \u0026lt; b.N; i++ { strings.Join(s2, \u0026quot; \u0026quot;) //fmt.Println(strings.Join(s2, \u0026quot; \u0026quot;)) } }  $ go test -v -run=\u0026quot;none\u0026quot; -bench=. -benchtime=\u0026quot;3s\u0026quot; -benchmem BenchmarkEcho1-4 30000000\t172 ns/op\t32 B/op\t4 allocs/op BenchmarkEcho2-4 50000000\t86.2 ns/op\t32 B/op\t2 allocs/op PASS ok The_Go_Programming_Language_Exercises/CH1/ex1.3\t9.768s  由此可见，strings.Join比s += sep + arg高效\nEx 1.4 Modify dup2 to print the names of all ﬁles in which each duplicated line occurs\npackage main import ( \u0026quot;bufio\u0026quot; \u0026quot;fmt\u0026quot; \u0026quot;os\u0026quot; ) func main() { m := make(map[string]map[string]int) files := os.Args[1:] //fmt.Println(os.Args[1:]) if len(files) == 0 { countLines(os.Stdin, m[\u0026quot;Stdin\u0026quot;]) } else { for _, arg := range files { f, err := os.Open(arg) if err != nil { fmt.Fprintf(os.Stderr, \u0026quot;dup2: %v\\n\u0026quot;, err) continue } m[arg] = map[string]int{\u0026quot;\u0026quot;: 0} countLines(f, m[arg]) f.Close() } } for filename, mv := range m { for line, counts := range mv { if counts \u0026gt; 1 { fmt.Printf(\u0026quot;There are %d lines (\\\u0026quot;%s\\\u0026quot;) in file \\\u0026quot;%s\\\u0026quot;\\n\u0026quot;, counts, line, filename) } } } } func countLines(f *os.File, m2 map[string]int) { input := bufio.NewScanner(f) for input.Scan() { //fmt.Println(input.Text()) m2[input.Text()]++ } // NOTE: ignoring potential errors from input.Err() }  //file a a1 a2 a3 a4 a1 a2 //file b b1 b2 b3 b3 b3 b4 b4 b4 b5 b5 b5 b5  $ go run main.go a b There are 2 lines (\u0026quot;a1\u0026quot;) in file \u0026quot;a\u0026quot; There are 2 lines (\u0026quot;a2\u0026quot;) in file \u0026quot;a\u0026quot; There are 3 lines (\u0026quot;b3\u0026quot;) in file \u0026quot;b\u0026quot; There are 3 lines (\u0026quot;b4\u0026quot;) in file \u0026quot;b\u0026quot; There are 4 lines (\u0026quot;b5\u0026quot;) in file \u0026quot;b\u0026quot;  Ex 1.5 Change the Lissajous program’s color palette to green on black, for a authenticity. To create the web color #RRGGBB, use color.RGBA{0xRR, 0xGG, 0xBB, 0xff}, where each pair of hexadecimal digits represents the intensity of the red, green, or blue component of the pixel.\npackage main import ( \u0026quot;image\u0026quot; \u0026quot;image/color\u0026quot; \u0026quot;image/gif\u0026quot; \u0026quot;io\u0026quot; \u0026quot;math\u0026quot; \u0026quot;math/rand\u0026quot; \u0026quot;os\u0026quot; ) //!-main // Packages not needed by version in book. import ( \u0026quot;log\u0026quot; \u0026quot;net/http\u0026quot; \u0026quot;time\u0026quot; ) //!+main //var palette = []color.Color{color.White, color.Black} var palette = []color.Color{color.White, color.RGBA{0, 255, 100, 1}}//替换成绿色 const ( whiteIndex = 0 // first color in palette blackIndex = 1 // next color in palette ) func main() { //!-main // The sequence of images is deterministic unless we seed // the pseudo-random number generator using the current time. // Thanks to Randall McPherson for pointing out the omission. rand.Seed(time.Now().UTC().UnixNano()) if len(os.Args) \u0026gt; 1 \u0026amp;\u0026amp; os.Args[1] == \u0026quot;web\u0026quot; { //!+http handler := func(w http.ResponseWriter, r *http.Request) { lissajous(w) } http.HandleFunc(\u0026quot;/\u0026quot;, handler) //!-http log.Fatal(http.ListenAndServe(\u0026quot;localhost:8000\u0026quot;, nil)) return } //!+main lissajous(os.Stdout) } func lissajous(out io.Writer) { const ( cycles = 5 // number of complete x oscillator revolutions res = 0.001 // angular resolution size = 100 // image canvas covers [-size..+size] nframes = 64 // number of animation frames delay = 8 // delay between frames in 10ms units ) freq := rand.Float64() * 3.0 // relative frequency of y oscillator anim := gif.GIF{LoopCount: nframes} phase := 0.0 // phase difference for i := 0; i \u0026lt; nframes; i++ { rect := image.Rect(0, 0, 2*size+1, 2*size+1) img := image.NewPaletted(rect, palette) for t := 0.0; t \u0026lt; cycles*2*math.Pi; t += res { x := math.Sin(t) y := math.Sin(t*freq + phase) img.SetColorIndex(size+int(x*size+0.5), size+int(y*size+0.5), blackIndex) } phase += 0.1 anim.Delay = append(anim.Delay, delay) anim.Image = append(anim.Image, img) } gif.EncodeAll(out, \u0026amp;anim) // NOTE: ignoring encoding errors } //!-main  Ex 1.6 Modify the Lissajous program to produce images in multiple colors by adding more values to palette and then displaying them by changing the third argument of SetColorIndex in some interesting way.\n// Copyright © 2016 Alan A. A. Donovan \u0026amp; Brian W. Kernighan. // License: https://creativecommons.org/licenses/by-nc-sa/4.0/ // Run with \u0026quot;web\u0026quot; command-line argument for web server. // See page 13. //!+main // Lissajous generates GIF animations of random Lissajous figures. package main import ( \u0026quot;image\u0026quot; \u0026quot;image/color\u0026quot; \u0026quot;image/gif\u0026quot; \u0026quot;io\u0026quot; \u0026quot;log\u0026quot; \u0026quot;math\u0026quot; \u0026quot;math/rand\u0026quot; \u0026quot;net/http\u0026quot; \u0026quot;os\u0026quot; \u0026quot;time\u0026quot; ) //!-main // Packages not needed by version in book. //!+main //var palette = []color.Color{color.White, color.Black} var palette = []color.Color{color.White, color.Black, color.RGBA{0, 255, 100, 1}, color.RGBA{255, 0, 0, 1}, color.RGBA{0, 0, 255, 1}} const ( whiteIndex = 0 // first color in palette blackIndex = 1 // next color in palette ) func main() { //!-main // The sequence of images is deterministic unless we seed // the pseudo-random number generator using the current time. // Thanks to Randall McPherson for pointing out the omission. rand.Seed(time.Now().UTC().UnixNano()) if len(os.Args) \u0026gt; 1 \u0026amp;\u0026amp; os.Args[1] == \u0026quot;web\u0026quot; { //!+http handler := func(w http.ResponseWriter, r *http.Request) { lissajous(w) } http.HandleFunc(\u0026quot;/\u0026quot;, handler) //!-http log.Fatal(http.ListenAndServe(\u0026quot;localhost:8000\u0026quot;, nil)) return } //!+main lissajous(os.Stdout) } func lissajous(out io.Writer) { const ( cycles = 5 // number of complete x oscillator revolutions res = 0.001 // angular resolution size = 100 // image canvas covers [-size..+size] nframes = 64 // number of animation frames delay = 8 // delay between frames in 10ms units ) freq := rand.Float64() * 3.0 // relative frequency of y oscillator anim := gif.GIF{LoopCount: nframes} phase := 0.0 // phase difference for i := 0; i \u0026lt; nframes; i++ { colorIndex := uint8(i % 5) rect := image.Rect(0, 0, 2*size+1, 2*size+1) img := image.NewPaletted(rect, palette) for t := 0.0; t \u0026lt; cycles*2*math.Pi; t += res { x := math.Sin(t) y := math.Sin(t*freq + phase) img.SetColorIndex(size+int(x*size+0.5), size+int(y*size+0.5), colorIndex) } phase += 0.1 anim.Delay = append(anim.Delay, delay) anim.Image = append(anim.Image, img) } gif.EncodeAll(out, \u0026amp;anim) // NOTE: ignoring encoding errors } //!-main  Ex 1.7 The function call io.Copy(dst, src) reads from src and writes to dst. Use it instead of ioutil.ReadAll to copy the response body to os.Stdout without requiring a buffer large enough to hold the entire stream. Be sure to check the error result of io.Copy.\n// Fetch prints the content found at a URL. package main import ( \u0026quot;fmt\u0026quot; \u0026quot;io\u0026quot; \u0026quot;net/http\u0026quot; \u0026quot;os\u0026quot; ) func main() { for _, url := range os.Args[1:] { resp, err := http.Get(url) if err != nil { fmt.Fprintf(os.Stderr, \u0026quot;fetch: %v\\n\u0026quot;, err) os.Exit(1) } //b, err := ioutil.ReadAll(resp.Body) _, err = io.Copy(os.Stdout, resp.Body) resp.Body.Close() if err != nil { fmt.Fprintf(os.Stderr, \u0026quot;fetch: reading %s: %v\\n\u0026quot;, url, err) os.Exit(1) } //fmt.Printf(\u0026quot;%s\u0026quot;, b) } }  Ex 1.8 Modify fetch to add the preﬁx http:// to each argument URL if it is missing. You might want to use strings.HasPrefix.\n// Fetch prints the content found at a URL. package main import ( \u0026quot;fmt\u0026quot; \u0026quot;io\u0026quot; \u0026quot;net/http\u0026quot; \u0026quot;os\u0026quot; \u0026quot;strings\u0026quot; ) func main() { for _, url := range os.Args[1:] { if !strings.HasPrefix(url, \u0026quot;http://\u0026quot;) { url = \u0026quot;http://\u0026quot; + url } resp, err := http.Get(url) if err != nil { fmt.Fprintf(os.Stderr, \u0026quot;fetch: %v\\n\u0026quot;, err) os.Exit(1) } //b, err := ioutil.ReadAll(resp.Body) _, err = io.Copy(os.Stdout, resp.Body) resp.Body.Close() if err != nil { fmt.Fprintf(os.Stderr, \u0026quot;fetch: reading %s: %v\\n\u0026quot;, url, err) os.Exit(1) } //fmt.Printf(\u0026quot;%s\u0026quot;, b) } }  Ex 1.9 Modify fetch to also print the HTTP status code, found in resp.Status.\n// Fetch prints the content found at a URL. package main import ( \u0026quot;fmt\u0026quot; \u0026quot;io\u0026quot; \u0026quot;net/http\u0026quot; \u0026quot;os\u0026quot; \u0026quot;strings\u0026quot; ) func main() { for _, url := range os.Args[1:] { if !strings.HasPrefix(url, \u0026quot;http://\u0026quot;) { url = \u0026quot;http://\u0026quot; + url } resp, err := http.Get(url) if err != nil { fmt.Fprintf(os.Stderr, \u0026quot;fetch: %v\\n\u0026quot;, err) os.Exit(1) } //b, err := ioutil.ReadAll(resp.Body) _, err = io.Copy(os.Stdout, resp.Body) fmt.Println(\u0026quot;Status:\u0026quot;, resp.Status)//Status: 200 OK resp.Body.Close() if err != nil { fmt.Fprintf(os.Stderr, \u0026quot;fetch: reading %s: %v\\n\u0026quot;, url, err) os.Exit(1) } //fmt.Printf(\u0026quot;%s\u0026quot;, b) } }  Ex 1.10 Exercise 1.10: Find a web site that produces a large amount of data. Investigate caching by running fetchall twice in succession to see whether the reported time changes much. Do you get the same content each time? Modify fetchall to print its output to a ﬁle so it can be examined.\n// Copyright © 2016 Alan A. A. Donovan \u0026amp; Brian W. Kernighan. // License: https://creativecommons.org/licenses/by-nc-sa/4.0/ // See page 17. //!+ // Fetchall fetches URLs in parallel and reports their times and sizes. package main import ( \u0026quot;fmt\u0026quot; \u0026quot;io\u0026quot; \u0026quot;net/http\u0026quot; \u0026quot;os\u0026quot; \u0026quot;strconv\u0026quot; \u0026quot;time\u0026quot; ) func main() { start := time.Now() ch := make(chan string) for ix, url := range os.Args[1:] { go fetch(strconv.FormatInt(int64(ix), 10), url, ch) // start a goroutine } for range os.Args[1:] { fmt.Println(\u0026lt;-ch) // receive from channel ch } fmt.Printf(\u0026quot;%.2fs elapsed\\n\u0026quot;, time.Since(start).Seconds()) } func fetch(fileName, url string, ch chan\u0026lt;- string) { start := time.Now() resp, err := http.Get(url) if err != nil { ch \u0026lt;- fmt.Sprint(err) // send to channel ch return } dst, err := os.OpenFile(fileName, os.O_WRONLY|os.O_CREATE, 0644) if err != nil { fmt.Println(\u0026quot;happend a error when opening\u0026quot;, err) } defer dst.Close() nbytes, err := io.Copy(dst, resp.Body) resp.Body.Close() // don't leak resources if err != nil { ch \u0026lt;- fmt.Sprintf(\u0026quot;while reading %s: %v\u0026quot;, url, err) return } secs := time.Since(start).Seconds() ch \u0026lt;- fmt.Sprintf(\u0026quot;%.2fs %7d %s\u0026quot;, secs, nbytes, url) } //!-  $ go run main.go http://www.baidu.com http://www.taobao.com http://www.360buy.com 0.09s 112255 http://www.baidu.com file 0 0.51s 126963 http://www.360buy.com file 2 0.51s 128027 http://www.taobao.com file 1 0.51s elapsed  Ex 1.11 TBC\nEx 1.12 TBC\n","date":1513702800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1543733643,"objectID":"ab329ec6f9a6995794cec641d0df35a2","permalink":"https://mooncaker816.github.io/2017/12/19/the-go-programming-language-ex1/","publishdate":"2017-12-19T17:00:00Z","relpermalink":"/2017/12/19/the-go-programming-language-ex1/","section":"post","summary":"Ex 1.1 Modify the echo program to also print os.Args[0], the name of the command that invoked it.\n","tags":["The Go Programming Language Ex"],"title":"The Go Programming Language Ex（1）","type":"post"},{"authors":null,"categories":["Golang"],"content":"用户类型  所谓用户类型，就是由一个或多个基本类型或用户类型组合而成的一个新的结构类型。  //多个基本类型组合而成 type user struct { name string email string ext int privileged bool } //一个基本类型，亦可称为别称 type Duration int64   定义，初始化  //定义一个类型为user,初始值为零值的结构变量bill var bill user //定义一个类型为user,且有初始值的结构变量bill bill := user{\u0026quot;Lisa\u0026quot;, \u0026quot;lisa@email.com\u0026quot;, 123, true} bill := user{ name :\t\u0026quot;Lisa\u0026quot;, email :\t\u0026quot;lisa@email.com\u0026quot;, ext :\t123, privileged :\ttrue, }   别称和他的基础类型不能直接赋值，因为Go认为他们不是同一类型  方法  函数是没有接收者的，不属于任何用户类型或基本类型  //没有接收者 func add(a int, b int) int{ return a + b }   方法是有接收者（用户类型）的函数  type score struct { math\tint english\tint chinese\tint } //有接收者 func (s score) sum() int{ return s.math + s.english + s.chinese }   方法的调用者和接收者之间的关系\n 当调用者和接收者同类型时，正常调用 当调用者为值，接收者为指针时，Go会自动取调用者的地址再调用方法，如(\u0026amp;a).func 当调用者为指针，接收者为值时，Go会自动对调用者解引用再调用方法，如(*a).func  开发者无需过多的考虑，调用者和接收者是否匹配的问题，Go会自动处理\n  type user struct { name\tstring email\tstring } // notify 使用值接收者实现了一个方法 func (u user) notify(){ fmt.Printf(\u0026quot;Sending User Email To %s\u0026lt;%s\u0026gt;\\n\u0026quot;,u.name,u.email) } // changeEmail 使用指针接收者实现了一个方法 func (u *user) changeEmail(email string) { u.email = email } //初始化user类型的值bill bill := user{\u0026quot;Bill\u0026quot;, \u0026quot;bill@email.com\u0026quot;} //初始化指向user类型的指针lisa lisa := \u0026amp;user{\u0026quot;Lisa\u0026quot;, \u0026quot;lisa@email.com\u0026quot;} //值bill调用值为接收者的方法notify bill.notify() //Sending User Email To Bill\u0026lt;bill@email.com\u0026gt; //值bill调用指针为接收者的方法changeEmail bill.changeEmail(\u0026quot;bill@newdomain.com\u0026quot;) // success bill.notify() //Sending User Email To Bill\u0026lt;bill@newdomain.com\u0026gt; //指针lisa调用值为接收者的方法notify() lisa.notify() //Sending User Email To Lisa\u0026lt;lisa@email.com\u0026gt; //指针lisa调用指针为接收者的方法changeEmail lisa.changeEmail(\u0026quot;lisa@newdomain.com\u0026quot;) // success lisa.notify() //Sending User Email To Lisa\u0026lt;lisa@newdomain.com\u0026gt;   方法定义的接收者究竟应该是指针还是值，需按该方法的需求决定。  接口  接口是一种抽象的类型，没有具体实现，是一组方法的集合\n 多态是指代码可以根据类型的具体实现采取不同行为的能力。如果一个类型实现了某个接口，所有使用这个接口的地方，都可以支持这种类型的值。换句话说，如果用户定义的类型实现了某个接口类型声明的一组方法，那么这个用户定 义的类型的值就可以赋给这个接口类型的值。这个赋值会把用户定义的类型的值存入接口类型 的值。\n 接口的内部实现\n  接口值是一个两个字长度的数据结构，第一个字包含一个指向内部表的指针。这个内部表叫作 iTable，包含了所存储的值的类型信息。iTable包含了已存储的值的类型信息以及与这个值相关联的一组方法。第二个字是一个指向所存储值的指针。\n 方法集\n 方法集定义了一组关联到给定类型的值或者指针的方法 T 类型的值的方法集只包含值接收者声明的方法，指向 T 类型的指针的方法集既包含值接收者声明的方法，也包含指针接收者声明的方法 如果使用指针接收者来实现一个接口，那么只有指向那个类型的指针才能够实现对应的接口 如果使用值接收者来实现一个接口，那么那个类型的值和指针都能够实现对应的接口      Values Methods Receivers     T (t T)   *T (t T) and (t *T)       Methods Receivers Values     (t T) T and *T   (t *T) *T    因为不是总能获取一个值的地址，所以值的方法集只包括了使用值接收者实现的方法。\n 结论：  实体类型以值接收者实现接口的时候，不管是实体类型的值，还是实体类型值的指针，都实现了该接口。\ntype notifier interface { notify() } type user struct { name string email string } func (u user) notify() { fmt.Printf(\u0026quot;Sending user email to %s\u0026lt;%s\u0026gt;\\n\u0026quot;,u.name,u.email) } //接收一个实现notifier接口的值 func sendNotification(n notifier) { n.notify() } func main() { bill := user{\u0026quot;Bill\u0026quot;, \u0026quot;bill@email.com\u0026quot;} lisa := user{\u0026quot;Lisa\u0026quot;, \u0026quot;lisa@email.com\u0026quot;} sendNotification(bill)// Sending User Email To Bill\u0026lt;bill@email.com\u0026gt; sendNotification(\u0026amp;lisa)// Sending User Email To Lisa\u0026lt;lisa@email.com\u0026gt; }  实体类型以指针接收者实现接口的时候，只有指向这个类型的指针才被认为实现了该接口\ntype notifier interface { notify() } type user struct { name string email string } func (u *user) notify() { fmt.Printf(\u0026quot;Sending user email to %s\u0026lt;%s\u0026gt;\\n\u0026quot;,u.name,u.email) } //接收一个实现notifier接口的值 func sendNotification(n notifier) { n.notify() } func main() { bill := user{\u0026quot;Bill\u0026quot;, \u0026quot;bill@email.com\u0026quot;} lisa := user{\u0026quot;Lisa\u0026quot;, \u0026quot;lisa@email.com\u0026quot;} sendNotification(bill)// ERROR sendNotification(\u0026amp;lisa)// Sending User Email To Lisa\u0026lt;lisa@email.com\u0026gt; }  ​\n","date":1513244347,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1513244347,"objectID":"ffe446398a7dfee814e6c7af9701162e","permalink":"https://mooncaker816.github.io/2017/12/14/go-in-action-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E5%9B%9B/","publishdate":"2017-12-14T09:39:07Z","relpermalink":"/2017/12/14/go-in-action-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E5%9B%9B/","section":"post","summary":"用户类型","tags":["Go In Action","Go type","Go method","Go interface"],"title":"Go In Action 读书笔记（四）","type":"post"},{"authors":null,"categories":["Golang"],"content":"映射  映射用于存储一系列无序的键值对，能快速检索数据，键就像索引一样，指向与该键关联的值\n 键通过散列函数得到散列值，该散列值低位用于确定该键值对所在子集的位置，高位用于确认该键值对在该子集中所在的位置\n  {% asset_img 1.png 映射散列表%}\n 创建，初始化  // 创建一个映射，键的类型是 string，值的类型是 int dict := make(map[string]int) // 创建一个映射，键和值的类型都是 string // 使用两个键值对初始化映射 dict := map[string]string{\u0026quot;Red\u0026quot;: \u0026quot;#da1337\u0026quot;, \u0026quot;Orange\u0026quot;: \u0026quot;#e95a22\u0026quot;} // 空map dict := map[string]int{} // nil map，无法直接赋值，需先进行初始化分配空间 var dict map[string]int   映射的键必须可以进行==运算，切片、函数以及包含切片的结构类型这些类型由于具有引用语义， 不能作为映射的键，使用这些类型会造成编译错误\n 赋值\n  // 创建一个空映射，用来存储颜色以及颜色对应的十六进制代码 colors := map[string]string{} // 将 Red 的代码加入到映射 colors[\u0026quot;Red\u0026quot;] = \u0026quot;#da1337\u0026quot;   判断键值是否存在  // 获取键 Blue 对应的值 value, exists := colors[\u0026quot;Blue\u0026quot;] // 这个键存在吗？ if exists { fmt.Println(value) }   迭代映射，由于映射是无序的，所以单纯的for range迭代得到的结果也是无序的，若需要按顺序迭代，需先按key进行排序，再根据key来取map中对应的值  // 显示映射里的所有颜色(无序) for key, value := range colors { fmt.Printf(\u0026quot;Key: %s Value: %s\\n\u0026quot;, key, value) } // 有序迭代 s1 := []string for key := range colors{ s1 = append(s1,key) } sort.Strings(s1) for _,v := range s1{ fmt.Printf(\u0026quot;Key: %s Value: %s\\n\u0026quot;, v, colors[v]) }   删除  // 删除键为 Coral 的键值对 delete(colors, \u0026quot;Coral\u0026quot;)   函数间的传递 - 表现特点与切片类似，传输成本很小，不会复制底层数据结构  ​\n","date":1513049617,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1513049617,"objectID":"a69f9cd3bd7bac4b4c3de67cfdbe4418","permalink":"https://mooncaker816.github.io/2017/12/12/go-in-action-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%89/","publishdate":"2017-12-12T11:33:37+08:00","relpermalink":"/2017/12/12/go-in-action-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%89/","section":"post","summary":"映射","tags":["Go In Action","Go map"],"title":"Go In Action 读书笔记（三）","type":"post"},{"authors":null,"categories":["Golang"],"content":"数组和切片 数组  Go中数组是一个长度固定的数据类型，用于存储一段具有相同的类型的元素的连续块。 由于元素类型相同，又是连续分配，是一种高效的数据结构 声明\u0026amp;初始化 go // 声明一个包含 5 个元素的整型数组,此时该数组元素为对应的零值 var array [5]int  go // 字面量声明初始化 // 声明一个包含 5 个元素的整型数组 // 用具体值初始化每个元素 array := [5]int{10, 20, 30, 40, 50}   // 声明一个整型数组 // 用具体值初始化每个元素 // 容量由初始化值的数量决定 array := [...]int{10, 20, 30, 40, 50}  // 声明一个有 5 个元素的数组 // 用具体值初始化索引为 1 和 2 的元素 // 其余元素保持零值 array := [5]int{1: 10, 2: 20}   数组赋值给另一个数组时，必须确保长度和元素类型都相同才可行\n 多维数组可以按维度赋值\n Go的数组和C相同，索引从0开始\n 给指针数组赋值时，需注意元素是否已经分配内存，若没分配会引发panic\n  // 声明一个有 5 个元素的指针数组，1,3两个元素分配了内存，其他均为nil array := [5]*int{1:new(int),3:new(int)} // 若要对0元素赋值，需先分配内存 array[0] = new(int) *array[0] = 1 // 下标为1的元素可以直接赋值 *array[1] = 2   函数之间直接传递数组为值拷贝，函数体内对该数组的修改不会影响原始数组 函数之间传递数组的指针，也是值传递，只不过这个值是指向该数组的地址，所以函数体内对该数组的修改会影响原始数组 区分指针数组和数组的指针\n//指针数组，元素为指针 var array [5]*int //数组的指针，是一个地址，指向数组的指针 func f(a *[5]int)  切片 切片可以理解为动态的数组，其底层为数组\n 切片的三要素：指向底层数组的指针，长度，容量，容量\u0026gt;=长度\n 声明\u0026amp;初始化\n  //创建一个字符串切片 //其长度和容量都是5 slice := make([]string, 5)  //创建一个整型切片 //其长度为3，容量为5 slice := make([]int, 3, 5)  //字面量定义切片 slice := []string{\u0026quot;Red\u0026quot;, \u0026quot;Blue\u0026quot;, \u0026quot;Green\u0026quot;, \u0026quot;Yellow\u0026quot;, \u0026quot;Pink\u0026quot;} slice := []int{10, 20, 30}  //创建字符串切片 //使用空字符串初始化第100个元素 slice := []string{99: \u0026quot;\u0026quot;}   nil和空切片  //创建 nil 整型切片 //三要素：指针为nil，长度和容量均为0 var slice []int  // 使用 make 创建空的整型切片 slice := make([]int, 0) // 使用切片字面量创建空的整型切片 slice := []int{} //三要素：指针不为空，长度和容量均为0，但是底层数组包含0个元素，实际也未分配内存   赋值  //原始切片，长度为5，容量为5 slice := []int{1,2,3,4,5} //包含两个元素2,3，长度为2，容量为4 newSlice := slice[1:3] //通用公式,slice容量为k //newSlice容量为k-i //newSlice长度为j-i newSlice := slice[i:j] //还有一种用来控制新切片的容量，范围[i,j),容量k-i，k小于原始容量 newSlice := slice[i:j:k]   修改切片，由于实际修改的是底层数组，所以对所有引用该底层数组的切片都有影响  slice := []int{1,2,3,4,5} newSlice := slice[1:3] newSlice[1] = 9 //newSlice的元素为，2，9 //slice的元素为，1，2，9，4，5   切片只能访问到其长度内的元素。试图访问超出其长度的元素将会导致语言运行时异常，如上述newSlice[3]。与切片的容量相关联的元素只能用于增长切片。在使用这部分元素前，必须将其合并到切片的长度里\n append\n 若切片容量有余，则返回切片仅增加长度，容量不变，即相当于修改底层数组所对应的元素，会影响所有相关切片\n 若切片容量已满，则会新建一个底层数组（小于1000时，容量翻倍），返回的切片以该数组为底层数组，修改该数组对应的元素，不会影响原底层数组对应的其他切片\n append可以增加单个元素，也可以增加多个元素，还可以增加slice\n  slice := []int{1,2,3,4,5} newSlice1 := append(slice,6) newSlice2 := append(slice,6,7,8) newSlice3 := append(slice,newSlice1,newSlice2)  切片迭代\n for range  for i,v := range slice{ fmt.Printf(\u0026quot;Index: %d Value: %d Address: %X\\n\u0026quot;, i, v, \u0026amp;slice[i]) }  i 为元素索引，v为元素的一个副本\n for 循环  for i := 2; i \u0026lt; len(slice); i++ { fmt.Printf(\u0026quot;Index: %d Value: %d\\n\u0026quot;, i, slice[i]) }   可以用占位符忽略返回值  内置函数 len，cap\n  len(slice) - 切片的长度\ncap(slice) - 切片的容量\n 切片的传递  切片是一个由三个字段构成的结构体，每个字段各占8个字节，所以在函数间传递 24 字节的数据会非常快速、简单。这也就是说传递的是一个副本切片，共用同一底层函数。\n 切片与切片不能直接用==比较，唯一能与切片比较的是nil ","date":1512752400,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1512752400,"objectID":"1c60b1970e21c939b0e125b3c90e14dc","permalink":"https://mooncaker816.github.io/2017/12/08/go-in-action-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%BA%8C/","publishdate":"2017-12-08T17:00:00Z","relpermalink":"/2017/12/08/go-in-action-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%BA%8C/","section":"post","summary":"数组和切片","tags":["Go In Action","Go array","Go slice"],"title":"Go In Action 读书笔记（二）","type":"post"},{"authors":null,"categories":null,"content":" Page of Example-2-1 ","date":1512230400,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1543733643,"objectID":"8dafd922ccfc7d9bc1f38e6650b2900d","permalink":"https://mooncaker816.github.io/example/example-2-1/","publishdate":"2017-12-03T00:00:00+08:00","relpermalink":"/example/example-2-1/","section":"example","summary":" Page of Example-2-1 ","tags":null,"title":"Example-2-1","type":"example"},{"authors":null,"categories":["Golang"],"content":"包  目录即为包 同一目录下各个.go文件所属包名必须相同 包名可与目录名不同，但习惯保持一致（main包例外） 同一项目下，main包，main()函数，必须存在且唯一 go build编译后的可执行程序名为main包代码所在目录的目录名 导入包，编译器会按GOROOT,GOPATH的顺序搜索包名依次导入，找到即会停止搜索，找不到就报错\nimport ( \u0026quot;fmt\u0026quot; \u0026quot;os\u0026quot; )  远程导入，支持直接从github，bitbucket等网站直接导入 事实上， 这个导入路径代表一个 URL，指向 GitHub 上的代码库。如果路径包含 URL，可以使用 Go 工具链从 DVCS 获取包，并把包的源代码保存在 GOPATH 指向的路径里与 URL 匹配的目录里。这个获取过程 使用 go get 命令完成。go get 将获取任意指定的 URL 的包，或者一个已经导入的包所依赖的其 他包。由于go get的这种递归特性，这个命令会扫描某个包的源码树，获取能找到的所有依赖包。\n 命名导入，当包名冲突时，可重定义包名以示区别，使用当中只需使用重命名后当包名即可\npackage main import ( \u0026quot;fmt\u0026quot; myfmt \u0026quot;mylib/fmt\u0026quot; )  当重命名名称为下划线时,导入的包只执行init初始化函数，如为数据库注册驱动\n  package main import ( \u0026quot;database/sql\u0026quot; _ \u0026quot;github.com/goinaction/code/chapter3/dbdriver/postgres\u0026quot; ) func main() { sql.Open(\u0026quot;postgres\u0026quot;, \u0026quot;mydb\u0026quot;) }   导入的包必须被使用到，否则编译会报错 ","date":1506358800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1506358800,"objectID":"869ed9cb3070c605991214deb345bfb0","permalink":"https://mooncaker816.github.io/2017/09/25/go-in-action-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%80/","publishdate":"2017-09-25T17:00:00Z","relpermalink":"/2017/09/25/go-in-action-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%80/","section":"post","summary":"包","tags":["Go In Action","Go package"],"title":"Go In Action 读书笔记（一）","type":"post"},{"authors":null,"categories":["Linux"],"content":" npm - Node Package Manager npm 淘宝源\n 搜索地址：http://npm.taobao.org/ （淘宝NPM使用说明） registry地址：http://registry.npm.taobao.org/  持久更换\n$ npm config set registry https://registry.npm.taobao.org  临时更换并安装程序\n$ npm --registry https://registry.npm.taobao.org install express  ","date":1502740200,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1502740200,"objectID":"8a593185b3c6e8c8e31f8ca4f35dd056","permalink":"https://mooncaker816.github.io/2017/08/14/npm%E6%8D%A2%E6%BA%90/","publishdate":"2017-08-14T19:50:00Z","relpermalink":"/2017/08/14/npm%E6%8D%A2%E6%BA%90/","section":"post","summary":"npm - Node Package Manager npm 淘宝源 搜索地址：http://npm.taobao.org/ （淘宝NPM使用说明） registry地址：http://regis","tags":["npm"],"title":"npm换源","type":"post"},{"authors":null,"categories":null,"content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick Start Create a new post $ hexo new \u0026quot;My New Post\u0026quot;  More info: Writing\nRun server $ hexo server  More info: Server\nGenerate static files $ hexo generate  More info: Generating\nDeploy to remote sites $ hexo deploy  More info: Deployment\n","date":1502737200,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1543733643,"objectID":"149146edb9d37107f2905b865ce6ae17","permalink":"https://mooncaker816.github.io/2017/08/14/hello-world/","publishdate":"2017-08-14T19:00:00Z","relpermalink":"/2017/08/14/hello-world/","section":"post","summary":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\n","tags":null,"title":"Hello World","type":"post"},{"authors":null,"categories":null,"content":" Example 首页 ","date":1461081600,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1543733643,"objectID":"4870f26c8ceab84e13d7755aa5d855f2","permalink":"https://mooncaker816.github.io/example/","publishdate":"2016-04-20T00:00:00+08:00","relpermalink":"/example/","section":"example","summary":"Example 首页","tags":null,"title":"Example-0","type":"example"},{"authors":null,"categories":null,"content":" Page of Example-1-1 ","date":1461081600,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1543733643,"objectID":"e71d46747f2d5bd92bf67c10c74b0c30","permalink":"https://mooncaker816.github.io/example/example-1-1/","publishdate":"2016-04-20T00:00:00+08:00","relpermalink":"/example/example-1-1/","section":"example","summary":" Page of Example-1-1 ","tags":null,"title":"Example-1-1","type":"example"},{"authors":null,"categories":null,"content":" Page of Example-1-2 ","date":1461081600,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1543733643,"objectID":"f923ecc67faef362c686dbf330916bd9","permalink":"https://mooncaker816.github.io/example/example-1-2/","publishdate":"2016-04-20T00:00:00+08:00","relpermalink":"/example/example-1-2/","section":"example","summary":" Page of Example-1-2 ","tags":null,"title":"Example-1-2","type":"example"},{"authors":null,"categories":null,"content":" Example-3 ","date":1461081600,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1543733643,"objectID":"0e3e0197ed1007ff1f37aaaa65890012","permalink":"https://mooncaker816.github.io/example/example-3/","publishdate":"2016-04-20T00:00:00+08:00","relpermalink":"/example/example-3/","section":"example","summary":" Example-3 ","tags":null,"title":"Example-3","type":"example"},{"authors":null,"categories":null,"content":" Page of Example-2-2 ","date":1460908800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1543733643,"objectID":"c7ea93063aca530807e9da77687cb265","permalink":"https://mooncaker816.github.io/example/example-2-2/","publishdate":"2016-04-18T00:00:00+08:00","relpermalink":"/example/example-2-2/","section":"example","summary":" Page of Example-2-2 ","tags":null,"title":"Example-2-2","type":"example"},{"authors":null,"categories":["Development","GoLang"],"content":"这是使用Hugo创建的站点中的第一篇文章。\npackage main import ( \u0026quot;bufio\u0026quot; \u0026quot;fmt\u0026quot; \u0026quot;os\u0026quot; \u0026quot;strconv\u0026quot; ) func main() { fmt.Printf(\u0026quot;%b\u0026quot;, 5) r := bufio.NewReader(os.Stdin) f, _ := strconv.ParseFloat(readline(r), 64) p1, _ := strconv.Atoi(readline(r)) p2, _ := strconv.Atoi(readline(r)) total := int(f * (1 + float64(p1+p2)/100)) fmt.Printf(\u0026quot;The total meal cost is %d dollars.\\n\u0026quot;, total) } func readline(r *bufio.Reader) (s string) { for { line, prefix, _ := r.ReadLine() s = s + string(line) if !prefix { break } } return }  #!/bin/bash ###### CONFIG ACCEPTED_HOSTS=\u0026quot;/root/.hag_accepted.conf\u0026quot; BE_VERBOSE=false if [ \u0026quot;$UID\u0026quot; -ne 0 ] then echo \u0026quot;Superuser rights required\u0026quot; exit 2 fi genApacheConf(){ echo -e \u0026quot;# Host ${HOME_DIR}$1/$2 :\u0026quot; } ","date":1442997037,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1543733643,"objectID":"c37907f82482fd5612d3e60689e56628","permalink":"https://mooncaker816.github.io/2015/09/23/%E4%BD%A0%E5%A5%BDhugo/","publishdate":"2015-09-23T16:30:37+08:00","relpermalink":"/2015/09/23/%E4%BD%A0%E5%A5%BDhugo/","section":"post","summary":"这是使用Hugo创建的站点中的第一篇文章。\n","tags":["Development","golang"],"title":"你好，Hugo","type":"post"}]