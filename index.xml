<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Mooncaker816 on Mooncaker816</title>
    <link>https://mooncaker816.github.io/</link>
    <description>Recent content in Mooncaker816 on Mooncaker816</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <copyright>&amp;copy; 2018-Present</copyright>
    <lastBuildDate>Wed, 20 Apr 2016 00:00:00 +0800</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>单向散列函数</title>
      <link>https://mooncaker816.github.io/2018/07/19/%E5%8D%95%E5%90%91%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0/</link>
      <pubDate>Thu, 19 Jul 2018 19:29:32 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/07/19/%E5%8D%95%E5%90%91%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0/</guid>
      <description>&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;1-概念&#34;&gt;1 概念&lt;/h1&gt;

&lt;p&gt;　　单向散列函数，又称单向Hash函数、杂凑函数，就是把任意长的输入消息串变化成固定长的输出串且由输出串难以得到输入串的一种函数。这个输出串称为该消息的散列值。一般用于产生消息摘要，密钥加密，常见的如 MD5，SHAx，HMAC 等。&lt;br /&gt;
　　具体来说，单向散列函数有一个输入，一个输出，其中输入称为消息，输出称为散列值。这里的消息可以是任何类型的数据，对于散列函数来说，它们只不过是一大串比特流。&lt;br /&gt;
　　散列值的长度与消息的长度无关，其值由选择的散列函数决定。下表是常见散列函数对应的散列值长度。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;散列类型&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;最大消息长度&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;散列值长度&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;分块大小&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;块内分组&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;单值字节序&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;MD5&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;无限制&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;16 bytes(128 bits)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;64 bytes(512 bits)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;16 * uint32&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;littleEndian&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;SHA1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;2^64-1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;20 bytes(160 bits)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;64 bytes(512 bits)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;16 * uint32&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;bigEndian&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;SHA-224&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;2^64-1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;28 bytes(224 bits)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;64 bytes(512 bits)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;(16 + 48) * uint32&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;bigEndian&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;SHA-256&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;2^64-1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32 bytes(256 bits)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;64 bytes(512 bits)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;(16 + 48) * uint32&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;bigEndian&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;SHA-384&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;2^128-1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;48 bytes(384 bits)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;128 bytes(1024 bits)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;(16 + 64) * uint64&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;bigEndian&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;SHA-512&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;2^128-1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;64 bytes(512 bits)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;128 bytes(1024 bits)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;(16 + 64) * uint64&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;bigEndian&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;SHA-&lt;sup&gt;512&lt;/sup&gt;&amp;frasl;&lt;sub&gt;224&lt;/sub&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;2^128-1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;28 bytes(224 bits)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;128 bytes(1024 bits)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;(16 + 64) * uint64&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;bigEndian&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;SHA-&lt;sup&gt;512&lt;/sup&gt;&amp;frasl;&lt;sub&gt;256&lt;/sub&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;2^128-1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32 bytes(256 bits)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;128 bytes(1024 bits)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;(16 + 64) * uint64&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;bigEndian&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;SHA3-224&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;无限制&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;28 bytes(224 bits)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;144 bytes(1152 bits)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;SHA3-256&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;无限制&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32 bytes(256 bits)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;136 bytes(1088 bits)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;SHA3-384&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;无限制&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;48 bytes(384 bits)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;104 bytes(832 bits)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;SHA3-512&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;无限制&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;64 bytes(512 bits)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;72 bytes(576 bits)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;SHAKE128&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;无限制&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;变长&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;168 bytes(1344 bits)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;SHAKE256&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;无限制&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;变长&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;136 bytes(1088 bits)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;注：对于 MD5 来说，如果根据最后一个分块末尾用来记录源数据字节长度的空间大小（8个字节）来看，其最大输入长度应该为2^64 - 1，但是在 MD5 的算法中，指明了此处的值是对 2^64 取余,所以 MD5 的输入没有限制。（但是 Go 中并没有取余）&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The remaining bits are filled up with 64 bits representing the length of the original message, modulo 264.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;2-md5&#34;&gt;2 MD5&lt;/h1&gt;

&lt;h2 id=&#34;2-1-预备函数&#34;&gt;2.1 预备函数&lt;/h2&gt;

&lt;p&gt;\begin{align}
F(B,C,D) &amp;amp;= (B \land C) | (\lnot B \land D) \\[2ex]
G(B,C,D) &amp;amp;= (B \land D) | (C \land \lnot D) \\[2ex]
H(B,C,D) &amp;amp;= B \oplus C \oplus D \\[2ex]
I(B,C,D) &amp;amp;= C \oplus (B \lor \lnot D)
\end{align}&lt;/p&gt;

&lt;p&gt;F,G 更高效的表达：
\begin{align}
F(B,C,D) &amp;amp;= D \oplus (B \land (C \oplus D)) \\[2ex]
G(B,C,D) &amp;amp;= C \oplus (D \land (B \oplus C))
\end{align}&lt;/p&gt;

&lt;p&gt;\begin{align}
FF(a,b,c,d,Mj,s,ti) 表示&amp;amp;a=b+((a+F(b,c,d)+Mj+ti)\lll s) \\[2ex]
GG(a,b,c,d,Mj,s,ti) 表示&amp;amp;a=b+((a+G(b,c,d)+Mj+ti)\lll s) \\[2ex]
HH(a,b,c,d,Mj,s,ti) 表示&amp;amp;a=b+((a+H(b,c,d)+Mj+ti)\lll s) \\[2ex]
II(a,b,c,d,Mj,s,ti) 表示&amp;amp;a=b+((a+I(b,c,d)+Mj+ti)\lll s)
\end{align}&lt;/p&gt;

&lt;h2 id=&#34;2-2-具体实现&#34;&gt;2.2 具体实现&lt;/h2&gt;

&lt;p&gt;　　假设我们有一串消息 data，长度位 n 个字节，以下是获取其 MD5 信息摘要的步骤：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;以64字节为单位，对 n 个字节进行分块，$$n = k*64 + r, k = 0,1,2&amp;hellip;,r \in [0,64) $$&lt;/li&gt;
&lt;li&gt;对这 k 个分块中的数据依次调用 MD5 HASH 函数，计算出这 k 个分块对应的散列值&lt;/li&gt;
&lt;li&gt;对剩下的 r 个字节进行填充，&lt;br /&gt;
如果 r &amp;gt;= 56，先填充至64个字节，第一位填充1，后续填充0，即填满一个分块&lt;br /&gt;
如果 r &amp;lt; 56，先填充至56个字节，第一位填充1，后续填充0，再将原始数据对应的字节长度信息以 uint64 为类型，按小字节序填入该分块的最末尾8个字节&lt;/li&gt;
&lt;li&gt;处理填充分块，可能只有一个填充分块，也可能有两个&lt;/li&gt;
&lt;li&gt;块内按小字节序将64字节数据分为16组uint32，对这16组数据进行共计4轮64次循环计算&lt;/li&gt;
&lt;li&gt;整合最终散列值&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2-3-go-源码分析&#34;&gt;2.3 Go 源码分析&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:generate go run gen.go -full -output md5block.go

// Package md5 implements the MD5 hash algorithm as defined in RFC 1321.
//
// MD5 is cryptographically broken and should not be used for secure
// applications.
package md5

import (
	&amp;quot;crypto&amp;quot;
	&amp;quot;errors&amp;quot;
	&amp;quot;hash&amp;quot;
)

func init() {
	crypto.RegisterHash(crypto.MD5, New)
}

// The size of an MD5 checksum in bytes.
// [Min] MD5 消息摘要的字节数，16 字节，128 bits
const Size = 16

// The blocksize of MD5 in bytes.
// [Min] 分块的大小 64 字节
const BlockSize = 64

const (
	chunk = 64         // [Min] 一个分块的字节长度，64 字节，512 位
	init0 = 0x67452301 // [Min] 初始摘要中0-3字节的值
	init1 = 0xEFCDAB89 // [Min] 初始摘要中4-7字节的值
	init2 = 0x98BADCFE // [Min] 初始摘要中8-11字节的值
	init3 = 0x10325476 // [Min] 初始摘要中12-15字节的值
)

/* [Min]
1. 先将源数据以64字节为单位分块，留出不够一个分块的部分 B ，其余部分 A 为64字节的整数倍
2. 将 A 中的数据依次按分块处理
3. 对 B 进行以下填充，使得 B % 64 = 56， 单位为字节
如果 B 不满 56 字节（448位），第一位填充1，后续填充 0 至448位即可，等待最终长度的填充
如果 B &amp;gt;= 56 字节，则需填充 (64 - B)*8 + 448 位，第一位为1，后续为0，
并且此时会形成一个满的分块，对此分块处理，剩余 448 位等待最终长度填充后达到512位后一起处理
4. 最后将源数据和所有填充数据的长度以 uint64 的类型填充到上述 448 位后，形成最后一个分块
对此分块进行处理
*/
// digest represents the partial evaluation of a checksum.
// [Min] 消息摘要
type digest struct {
	s   [4]uint32   // [Min] 存储摘要的实际载体
	x   [chunk]byte // [Min] 填充分块
	nx  int         // [Min] 当前填充分块中未处理数据的字节长度
	len uint64      // [Min] 源消息的长度
}

// [Min] 重置摘要，将载体中的值按初始值初始化
func (d *digest) Reset() {
	d.s[0] = init0
	d.s[1] = init1
	d.s[2] = init2
	d.s[3] = init3
	d.nx = 0
	d.len = 0
}

const (
	magic = &amp;quot;md5\x01&amp;quot;
	// [Min] MarshalBinary 返回的字节长度 ：
	// [Min] magic 头长度 + 16 字节消息摘要长度 + 64 字节最后一个分块长度 + 8 字节源消息大小的长度
	marshaledSize = len(magic) + 4*4 + chunk + 8
)

// [Min] 调用 Write 方法后，将当前 d 中数据格式化，用于反应 hash 过程中的状态
func (d *digest) MarshalBinary() ([]byte, error) {
	b := make([]byte, 0, marshaledSize)
	// [Min] 头
	b = append(b, magic...)
	// [Min] 当前已处理分块的消息摘要
	b = appendUint32(b, d.s[0])
	b = appendUint32(b, d.s[1])
	b = appendUint32(b, d.s[2])
	b = appendUint32(b, d.s[3])
	// [Min] 将填充分块中的还在等待填充的数据写入 b
	b = append(b, d.x[:d.nx]...)
	// [Min] 撑满一个分块的大小
	b = b[:len(b)+len(d.x)-int(d.nx)] // already zero
	// [Min] 当前已处理的数据的长度（可能包括填充数据）写入 b
	b = appendUint64(b, d.len)
	return b, nil
}

// [Min] 根据 digest 的状态（marshal 后的字节流），还原 digest
func (d *digest) UnmarshalBinary(b []byte) error {
	// [Min] 必须有 magic 头
	if len(b) &amp;lt; len(magic) || string(b[:len(magic)]) != magic {
		return errors.New(&amp;quot;crypto/md5: invalid hash state identifier&amp;quot;)
	}
	// [Min] b 的长度是固定的 marshaledSize
	if len(b) != marshaledSize {
		return errors.New(&amp;quot;crypto/md5: invalid hash state size&amp;quot;)
	}
	b = b[len(magic):]
	// [Min] 还原当前的消息摘要
	b, d.s[0] = consumeUint32(b)
	b, d.s[1] = consumeUint32(b)
	b, d.s[2] = consumeUint32(b)
	b, d.s[3] = consumeUint32(b)
	// [Min] 还原填充分块数据
	b = b[copy(d.x[:], b):]
	// [Min] 还原已处理数据（可能包括填充数据）长度
	b, d.len = consumeUint64(b)
	// [Min] 还原填充分块中待填充的数据的长度
	d.nx = int(d.len) % chunk
	return nil
}

// [Min] 将 x 对应的8个字节由高到低依次存入 b 中
func appendUint64(b []byte, x uint64) []byte {
	a := [8]byte{
		byte(x &amp;gt;&amp;gt; 56),
		byte(x &amp;gt;&amp;gt; 48),
		byte(x &amp;gt;&amp;gt; 40),
		byte(x &amp;gt;&amp;gt; 32),
		byte(x &amp;gt;&amp;gt; 24),
		byte(x &amp;gt;&amp;gt; 16),
		byte(x &amp;gt;&amp;gt; 8),
		byte(x),
	}
	return append(b, a[:]...)
}

// [Min] 将 x 对应的4个字节由高到低依次存入 b 中
func appendUint32(b []byte, x uint32) []byte {
	a := [4]byte{
		byte(x &amp;gt;&amp;gt; 24),
		byte(x &amp;gt;&amp;gt; 16),
		byte(x &amp;gt;&amp;gt; 8),
		byte(x),
	}
	return append(b, a[:]...)
}

// [Min] 将 b 中前8个字节当成一个 uint64 数值，返回剩余部分和该数值
func consumeUint64(b []byte) ([]byte, uint64) {
	_ = b[7]
	x := uint64(b[7]) | uint64(b[6])&amp;lt;&amp;lt;8 | uint64(b[5])&amp;lt;&amp;lt;16 | uint64(b[4])&amp;lt;&amp;lt;24 |
		uint64(b[3])&amp;lt;&amp;lt;32 | uint64(b[2])&amp;lt;&amp;lt;40 | uint64(b[1])&amp;lt;&amp;lt;48 | uint64(b[0])&amp;lt;&amp;lt;56
	return b[8:], x
}

// [Min] 将 b 中前4个字节当成一个 uint32 数值，返回剩余部分和该数值
func consumeUint32(b []byte) ([]byte, uint32) {
	_ = b[3]
	x := uint32(b[3]) | uint32(b[2])&amp;lt;&amp;lt;8 | uint32(b[1])&amp;lt;&amp;lt;16 | uint32(b[0])&amp;lt;&amp;lt;24
	return b[4:], x
}

// New returns a new hash.Hash computing the MD5 checksum. The Hash also
// implements encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to
// marshal and unmarshal the internal state of the hash.
// [Min] 构造一个 MD5 类型的 hash 载体
func New() hash.Hash {
	d := new(digest)
	d.Reset()
	return d
}

// [Min] 返回 MD5 摘要的字节长度16
func (d *digest) Size() int { return Size }

// [Min] 返回 MD5 的 BlockSize 64
func (d *digest) BlockSize() int { return BlockSize }

func (d *digest) Write(p []byte) (nn int, err error) {
	nn = len(p)
	d.len += uint64(nn)
	// [Min] 如果 d.nx &amp;gt;0, 说明 d.x 中含有遗留的未处理的尾部源数据（不够一个分块的部分）
	// [Min] 此时 p 中的数据为填充数据，
	// [Min] 如果填满了一个分块，就进行处理
	// [Min] 如果没满，说明还在等待最后的长度填充（届时一定能恰好填满一个分块）
	if d.nx &amp;gt; 0 {
		n := copy(d.x[d.nx:], p)
		d.nx += n
		if d.nx == chunk {
			block(d, d.x[:])
			d.nx = 0
		}
		p = p[n:]
	}
	// [Min] 源数据超过一个分块的大小，此处的 p 为源数据
	if len(p) &amp;gt;= chunk {
		// [Min] 计算出 p 中最大整数倍分块大小的字节长度 n，
		// [Min] 对这 n 个字节先处理，剩余部分比分块大小小，存入 p 中
		n := len(p) &amp;amp;^ (chunk - 1)
		block(d, p[:n])
		p = p[n:]
	}
	// [Min] p 中数据不够一个分块，存入 d.x 中，待后续调用 Write 时再处理
	if len(p) &amp;gt; 0 {
		d.nx = copy(d.x[:], p)
	}
	return
}

func (d0 *digest) Sum(in []byte) []byte {
	// Make a copy of d0 so that caller can keep writing and summing.
	d := *d0
	hash := d.checkSum()
	return append(in, hash[:]...)
}

func (d *digest) checkSum() [Size]byte {
	// Padding. Add a 1 bit and 0 bits until 56 bytes mod 64.
	// [Min] 获得填充前的源消息字节长度
	len := d.len
	var tmp [64]byte
	// [Min] 填充信息，最高位为1，后续全为0
	tmp[0] = 0x80
	// [Min] 如果不满56字节（448位），填充至56字节即可
	// [Min] 如果超过或等于56字节，需填满一个分块64字节，再填56字节
	if len%64 &amp;lt; 56 {
		d.Write(tmp[0 : 56-len%64])
	} else {
		d.Write(tmp[0 : 64+56-len%64])
	}

	// Length in bits.
	// [Min] 将字节长度转为 bit 位长，再将其存入8个字节中，代表一个 uint64 值
	// [Min] 再将这8个字节填入剩余部分，构成最后一个分块（小字节序）
	len &amp;lt;&amp;lt;= 3
	for i := uint(0); i &amp;lt; 8; i++ {
		tmp[i] = byte(len &amp;gt;&amp;gt; (8 * i))
	}
	d.Write(tmp[0:8])

	// [Min] 此时 d.nx 必须为0， 代表 d.x 中的分块已处理
	if d.nx != 0 {
		panic(&amp;quot;d.nx != 0&amp;quot;)
	}

	// [Min] 所有分块都处理完后，将最终128位摘要信息按小字节序写入对应的16个字节的变量返回
	var digest [Size]byte
	for i, s := range d.s {
		digest[i*4] = byte(s)
		digest[i*4+1] = byte(s &amp;gt;&amp;gt; 8)
		digest[i*4+2] = byte(s &amp;gt;&amp;gt; 16)
		digest[i*4+3] = byte(s &amp;gt;&amp;gt; 24)
	}

	return digest
}

// Sum returns the MD5 checksum of the data.
// [Min] 计算 data 的 MD5 摘要信息
func Sum(data []byte) [Size]byte {
	var d digest
	d.Reset()
	// [Min] 先把能构成分块的数据处理，留下剩余不够分块的数据待处理
	d.Write(data)
	// [Min] 填充分块，处理数据，最后返回消息摘要
	return d.checkSum()
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Copyright 2013 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// DO NOT EDIT.
// Generate with: go run gen.go -full -output md5block.go

package md5

import (
	&amp;quot;runtime&amp;quot;
	&amp;quot;unsafe&amp;quot;
)

const x86 = runtime.GOARCH == &amp;quot;amd64&amp;quot; || runtime.GOARCH == &amp;quot;386&amp;quot;

var littleEndian bool

// [Min] 判断当前系统的字节序
func init() {
	x := uint32(0x04030201)
	y := [4]byte{0x1, 0x2, 0x3, 0x4}
	littleEndian = *(*[4]byte)(unsafe.Pointer(&amp;amp;x)) == y
}

// [Min] 消息摘要处理函数
func blockGeneric(dig *digest, p []byte) {
	a := dig.s[0]
	b := dig.s[1]
	c := dig.s[2]
	d := dig.s[3]
	var X *[16]uint32
	var xbuf [16]uint32
	// [Min] 这里 p 一定是分块大小的整数倍
	for len(p) &amp;gt;= chunk {
		// [Min] 备份未处理当前分块前的值
		aa, bb, cc, dd := a, b, c, d

		// [Min] 首先根据系统，都按小字节序从 p 中获取一个分块的数据（64字节512位）存入 X
		// [Min] 分成16个小组，每个小组32位
		// This is a constant condition - it is not evaluated on each iteration.
		if x86 {
			// MD5 was designed so that x86 processors can just iterate
			// over the block data directly as uint32s, and we generate
			// less code and run 1.3x faster if we take advantage of that.
			// My apologies.
			X = (*[16]uint32)(unsafe.Pointer(&amp;amp;p[0]))
		} else if littleEndian &amp;amp;&amp;amp; uintptr(unsafe.Pointer(&amp;amp;p[0]))&amp;amp;(unsafe.Alignof(uint32(0))-1) == 0 {
			X = (*[16]uint32)(unsafe.Pointer(&amp;amp;p[0]))
		} else {
			X = &amp;amp;xbuf
			j := 0
			for i := 0; i &amp;lt; 16; i++ {
				X[i&amp;amp;15] = uint32(p[j]) | uint32(p[j+1])&amp;lt;&amp;lt;8 | uint32(p[j+2])&amp;lt;&amp;lt;16 | uint32(p[j+3])&amp;lt;&amp;lt;24
				j += 4
			}
        }
            
        // [Min] F(X,Y,Z)=(X&amp;amp;Y)|((~X)&amp;amp;Z) &amp;lt;=&amp;gt;  Z xor (X and (Y xor Z)) 后者更高效
        // [Min] G(X,Y,Z)=(X&amp;amp;Z)|(Y&amp;amp;(~Z)) &amp;lt;=&amp;gt;  Y xor (Z and (X xor Y)) 后者更高效
        // [Min] H(X,Y,Z)=X^Y^Z
        // [Min] I(X,Y,Z)=Y^(X|(~Z))

		// [Min] 设Mj表示消息的第j个子分组（从0到15），&amp;lt;&amp;lt;&amp;lt;s表示循环左移s位，则四种操作为：
		// [Min] FF(a,b,c,d,Mj,s,ti)表示a=b+((a+F(b,c,d)+Mj+ti)&amp;lt;&amp;lt;&amp;lt;s)
		// [Min] GG(a,b,c,d,Mj,s,ti)表示a=b+((a+G(b,c,d)+Mj+ti)&amp;lt;&amp;lt;&amp;lt;s)
		// [Min] HH(a,b,c,d,Mj,s,ti)表示a=b+((a+H(b,c,d)+Mj+ti)&amp;lt;&amp;lt;&amp;lt;s)
		// [Min] II(a,b,c,d,Mj,s,ti)表示a=b+((a+I(b,c,d)+Mj+ti)&amp;lt;&amp;lt;&amp;lt;s)
        
		// [Min] 对每一个分块进行以下4轮计算，每一轮中会对每一小组进行处理
		// Round 1.

		// [Min] FF(a ,b ,c ,d,M0 ,7 ,0xd76aa478 )
		a += (((c ^ d) &amp;amp; b) ^ d) + X[0] + 3614090360
		a = a&amp;lt;&amp;lt;7 | a&amp;gt;&amp;gt;(32-7) + b

		// [Min] FF(d ,a ,b ,c,M1 ,12 ,0xe8c7b756 )
		d += (((b ^ c) &amp;amp; a) ^ c) + X[1] + 3905402710
		d = d&amp;lt;&amp;lt;12 | d&amp;gt;&amp;gt;(32-12) + a

		// [Min] FF(c ,d ,a ,b,M2 ,17 ,0x242070db )
		c += (((a ^ b) &amp;amp; d) ^ b) + X[2] + 606105819
		c = c&amp;lt;&amp;lt;17 | c&amp;gt;&amp;gt;(32-17) + d

		// [Min] FF(b ,c ,d ,a,M3 ,22 ,0xc1bdceee )
		b += (((d ^ a) &amp;amp; c) ^ a) + X[3] + 3250441966
		b = b&amp;lt;&amp;lt;22 | b&amp;gt;&amp;gt;(32-22) + c

		// [Min] FF(a ,b ,c ,d,M4 ,7 ,0xf57c0faf )
		a += (((c ^ d) &amp;amp; b) ^ d) + X[4] + 4118548399
		a = a&amp;lt;&amp;lt;7 | a&amp;gt;&amp;gt;(32-7) + b

		// [Min] b=FF(d,a,b,c,M5,12,0x4787c62a)
		d += (((b ^ c) &amp;amp; a) ^ c) + X[5] + 1200080426
		d = d&amp;lt;&amp;lt;12 | d&amp;gt;&amp;gt;(32-12) + a

		// [Min] c=FF(c,d,a,b,M6,17,0xa8304613)
		c += (((a ^ b) &amp;amp; d) ^ b) + X[6] + 2821735955
		c = c&amp;lt;&amp;lt;17 | c&amp;gt;&amp;gt;(32-17) + d

		// [Min] d=FF(b,c,d,a,M7,22,0xfd469501)
		b += (((d ^ a) &amp;amp; c) ^ a) + X[7] + 4249261313
		b = b&amp;lt;&amp;lt;22 | b&amp;gt;&amp;gt;(32-22) + c

		// [Min] a=FF(a,b,c,d,M8,7,0x698098d8)
		a += (((c ^ d) &amp;amp; b) ^ d) + X[8] + 1770035416
		a = a&amp;lt;&amp;lt;7 | a&amp;gt;&amp;gt;(32-7) + b

		// [Min] b=FF(d,a,b,c,M9,12,0x8b44f7af)
		d += (((b ^ c) &amp;amp; a) ^ c) + X[9] + 2336552879
		d = d&amp;lt;&amp;lt;12 | d&amp;gt;&amp;gt;(32-12) + a

		// [Min] c=FF(c,d,a,b,M10,17,0xffff5bb1)
		c += (((a ^ b) &amp;amp; d) ^ b) + X[10] + 4294925233
		c = c&amp;lt;&amp;lt;17 | c&amp;gt;&amp;gt;(32-17) + d

		// [Min] d=FF(b,c,d,a,M11,22,0x895cd7be)
		b += (((d ^ a) &amp;amp; c) ^ a) + X[11] + 2304563134
		b = b&amp;lt;&amp;lt;22 | b&amp;gt;&amp;gt;(32-22) + c

		// [Min] a=FF(a,b,c,d,M12,7,0x6b901122)
		a += (((c ^ d) &amp;amp; b) ^ d) + X[12] + 1804603682
		a = a&amp;lt;&amp;lt;7 | a&amp;gt;&amp;gt;(32-7) + b

		// [Min] b=FF(d,a,b,c,M13,12,0xfd987193)
		d += (((b ^ c) &amp;amp; a) ^ c) + X[13] + 4254626195
		d = d&amp;lt;&amp;lt;12 | d&amp;gt;&amp;gt;(32-12) + a

		// [Min] c=FF(c,d,a,b,M14,17,0xa679438e)
		c += (((a ^ b) &amp;amp; d) ^ b) + X[14] + 2792965006
		c = c&amp;lt;&amp;lt;17 | c&amp;gt;&amp;gt;(32-17) + d

		// [Min] d=FF(b,c,d,a,M15,22,0x49b40821)
		b += (((d ^ a) &amp;amp; c) ^ a) + X[15] + 1236535329
		b = b&amp;lt;&amp;lt;22 | b&amp;gt;&amp;gt;(32-22) + c

		// Round 2.
		// [Min] a=GG(a,b,c,d,M1,5,0xf61e2562)
		a += (((b ^ c) &amp;amp; d) ^ c) + X[(1+5*0)&amp;amp;15] + 4129170786
		a = a&amp;lt;&amp;lt;5 | a&amp;gt;&amp;gt;(32-5) + b

		// [Min] b=GG(d,a,b,c,M6,9,0xc040b340)
		d += (((a ^ b) &amp;amp; c) ^ b) + X[(1+5*1)&amp;amp;15] + 3225465664
		d = d&amp;lt;&amp;lt;9 | d&amp;gt;&amp;gt;(32-9) + a

		// [Min] c=GG(c,d,a,b,M11,14,0x265e5a51)
		c += (((d ^ a) &amp;amp; b) ^ a) + X[(1+5*2)&amp;amp;15] + 643717713
		c = c&amp;lt;&amp;lt;14 | c&amp;gt;&amp;gt;(32-14) + d

		// [Min] d=GG(b,c,d,a,M0,20,0xe9b6c7aa)
		b += (((c ^ d) &amp;amp; a) ^ d) + X[(1+5*3)&amp;amp;15] + 3921069994
		b = b&amp;lt;&amp;lt;20 | b&amp;gt;&amp;gt;(32-20) + c

		// [Min] a=GG(a,b,c,d,M5,5,0xd62f105d)
		a += (((b ^ c) &amp;amp; d) ^ c) + X[(1+5*4)&amp;amp;15] + 3593408605
		a = a&amp;lt;&amp;lt;5 | a&amp;gt;&amp;gt;(32-5) + b

		// [Min] b=GG(d,a,b,c,M10,9,0x02441453)
		d += (((a ^ b) &amp;amp; c) ^ b) + X[(1+5*5)&amp;amp;15] + 38016083
		d = d&amp;lt;&amp;lt;9 | d&amp;gt;&amp;gt;(32-9) + a

		// [Min] c=GG(c,d,a,b,M15,14,0xd8a1e681)
		c += (((d ^ a) &amp;amp; b) ^ a) + X[(1+5*6)&amp;amp;15] + 3634488961
		c = c&amp;lt;&amp;lt;14 | c&amp;gt;&amp;gt;(32-14) + d

		// [Min] d=GG(b,c,d,a,M4,20,0xe7d3fbc8)
		b += (((c ^ d) &amp;amp; a) ^ d) + X[(1+5*7)&amp;amp;15] + 3889429448
		b = b&amp;lt;&amp;lt;20 | b&amp;gt;&amp;gt;(32-20) + c

		// [Min] a=GG(a,b,c,d,M9,5,0x21e1cde6)
		a += (((b ^ c) &amp;amp; d) ^ c) + X[(1+5*8)&amp;amp;15] + 568446438
		a = a&amp;lt;&amp;lt;5 | a&amp;gt;&amp;gt;(32-5) + b

		// [Min] b=GG(d,a,b,c,M14,9,0xc33707d6)
		d += (((a ^ b) &amp;amp; c) ^ b) + X[(1+5*9)&amp;amp;15] + 3275163606
		d = d&amp;lt;&amp;lt;9 | d&amp;gt;&amp;gt;(32-9) + a

		// [Min] c=GG(c,d,a,b,M3,14,0xf4d50d87)
		c += (((d ^ a) &amp;amp; b) ^ a) + X[(1+5*10)&amp;amp;15] + 4107603335
		c = c&amp;lt;&amp;lt;14 | c&amp;gt;&amp;gt;(32-14) + d

		// [Min] d=GG(b,c,d,a,M8,20,0x455a14ed)
		b += (((c ^ d) &amp;amp; a) ^ d) + X[(1+5*11)&amp;amp;15] + 1163531501
		b = b&amp;lt;&amp;lt;20 | b&amp;gt;&amp;gt;(32-20) + c

		// [Min] a=GG(a,b,c,d,M13,5,0xa9e3e905)
		a += (((b ^ c) &amp;amp; d) ^ c) + X[(1+5*12)&amp;amp;15] + 2850285829
		a = a&amp;lt;&amp;lt;5 | a&amp;gt;&amp;gt;(32-5) + b

		// [Min] b=GG(d,a,b,c,M2,9,0xfcefa3f8)
		d += (((a ^ b) &amp;amp; c) ^ b) + X[(1+5*13)&amp;amp;15] + 4243563512
		d = d&amp;lt;&amp;lt;9 | d&amp;gt;&amp;gt;(32-9) + a

		// [Min] c=GG(c,d,a,b,M7,14,0x676f02d9)
		c += (((d ^ a) &amp;amp; b) ^ a) + X[(1+5*14)&amp;amp;15] + 1735328473
		c = c&amp;lt;&amp;lt;14 | c&amp;gt;&amp;gt;(32-14) + d

		// [Min] d=GG(b,c,d,a,M12,20,0x8d2a4c8a)
		b += (((c ^ d) &amp;amp; a) ^ d) + X[(1+5*15)&amp;amp;15] + 2368359562
		b = b&amp;lt;&amp;lt;20 | b&amp;gt;&amp;gt;(32-20) + c

		// Round 3.
		// [Min] a=HH(a,b,c,d,M5,4,0xfffa3942)
		a += (b ^ c ^ d) + X[(5+3*0)&amp;amp;15] + 4294588738
		a = a&amp;lt;&amp;lt;4 | a&amp;gt;&amp;gt;(32-4) + b

		// [Min] b=HH(d,a,b,c,M8,11,0x8771f681)
		d += (a ^ b ^ c) + X[(5+3*1)&amp;amp;15] + 2272392833
		d = d&amp;lt;&amp;lt;11 | d&amp;gt;&amp;gt;(32-11) + a

		// [Min] c=HH(c,d,a,b,M11,16,0x6d9d6122)
		c += (d ^ a ^ b) + X[(5+3*2)&amp;amp;15] + 1839030562
		c = c&amp;lt;&amp;lt;16 | c&amp;gt;&amp;gt;(32-16) + d

		// [Min] d=HH(b,c,d,a,M14,23,0xfde5380c)
		b += (c ^ d ^ a) + X[(5+3*3)&amp;amp;15] + 4259657740
		b = b&amp;lt;&amp;lt;23 | b&amp;gt;&amp;gt;(32-23) + c

		// [Min] a=HH(a,b,c,d,M1,4,0xa4beea44)
		a += (b ^ c ^ d) + X[(5+3*4)&amp;amp;15] + 2763975236
		a = a&amp;lt;&amp;lt;4 | a&amp;gt;&amp;gt;(32-4) + b

		// [Min] b=HH(d,a,b,c,M4,11,0x4bdecfa9)
		d += (a ^ b ^ c) + X[(5+3*5)&amp;amp;15] + 1272893353
		d = d&amp;lt;&amp;lt;11 | d&amp;gt;&amp;gt;(32-11) + a

		// [Min] c=HH(c,d,a,b,M7,16,0xf6bb4b60)
		c += (d ^ a ^ b) + X[(5+3*6)&amp;amp;15] + 4139469664
		c = c&amp;lt;&amp;lt;16 | c&amp;gt;&amp;gt;(32-16) + d

		// [Min] d=HH(b,c,d,a,M10,23,0xbebfbc70)
		b += (c ^ d ^ a) + X[(5+3*7)&amp;amp;15] + 3200236656
		b = b&amp;lt;&amp;lt;23 | b&amp;gt;&amp;gt;(32-23) + c

		// [Min] a=HH(a,b,c,d,M13,4,0x289b7ec6)
		a += (b ^ c ^ d) + X[(5+3*8)&amp;amp;15] + 681279174
		a = a&amp;lt;&amp;lt;4 | a&amp;gt;&amp;gt;(32-4) + b

		// [Min] b=HH(d,a,b,c,M0,11,0xeaa127fa)
		d += (a ^ b ^ c) + X[(5+3*9)&amp;amp;15] + 3936430074
		d = d&amp;lt;&amp;lt;11 | d&amp;gt;&amp;gt;(32-11) + a

		// [Min] c=HH(c,d,a,b,M3,16,0xd4ef3085)
		c += (d ^ a ^ b) + X[(5+3*10)&amp;amp;15] + 3572445317
		c = c&amp;lt;&amp;lt;16 | c&amp;gt;&amp;gt;(32-16) + d

		// [Min] d=HH(b,c,d,a,M6,23,0x04881d05)
		b += (c ^ d ^ a) + X[(5+3*11)&amp;amp;15] + 76029189
		b = b&amp;lt;&amp;lt;23 | b&amp;gt;&amp;gt;(32-23) + c

		// [Min] a=HH(a,b,c,d,M9,4,0xd9d4d039)
		a += (b ^ c ^ d) + X[(5+3*12)&amp;amp;15] + 3654602809
		a = a&amp;lt;&amp;lt;4 | a&amp;gt;&amp;gt;(32-4) + b

		// [Min] b=HH(d,a,b,c,M12,11,0xe6db99e5)
		d += (a ^ b ^ c) + X[(5+3*13)&amp;amp;15] + 3873151461
		d = d&amp;lt;&amp;lt;11 | d&amp;gt;&amp;gt;(32-11) + a

		// [Min] c=HH(c,d,a,b,M15,16,0x1fa27cf8)
		c += (d ^ a ^ b) + X[(5+3*14)&amp;amp;15] + 530742520
		c = c&amp;lt;&amp;lt;16 | c&amp;gt;&amp;gt;(32-16) + d

		// [Min] d=HH(b,c,d,a,M2,23,0xc4ac5665)
		b += (c ^ d ^ a) + X[(5+3*15)&amp;amp;15] + 3299628645
		b = b&amp;lt;&amp;lt;23 | b&amp;gt;&amp;gt;(32-23) + c

		// Round 4.

		// [Min] a=II(a,b,c,d,M0,6,0xf4292244)

		a += (c ^ (b | ^d)) + X[(7*0)&amp;amp;15] + 4096336452
		a = a&amp;lt;&amp;lt;6 | a&amp;gt;&amp;gt;(32-6) + b

		// [Min] b=II(d,a,b,c,M7,10,0x432aff97)
		d += (b ^ (a | ^c)) + X[(7*1)&amp;amp;15] + 1126891415
		d = d&amp;lt;&amp;lt;10 | d&amp;gt;&amp;gt;(32-10) + a

		// [Min] c=II(c,d,a,b,M14,15,0xab9423a7)
		c += (a ^ (d | ^b)) + X[(7*2)&amp;amp;15] + 2878612391
		c = c&amp;lt;&amp;lt;15 | c&amp;gt;&amp;gt;(32-15) + d

		// [Min] d=II(b,c,d,a,M5,21,0xfc93a039)
		b += (d ^ (c | ^a)) + X[(7*3)&amp;amp;15] + 4237533241
		b = b&amp;lt;&amp;lt;21 | b&amp;gt;&amp;gt;(32-21) + c

		// [Min] a=II(a,b,c,d,M12,6,0x655b59c3)
		a += (c ^ (b | ^d)) + X[(7*4)&amp;amp;15] + 1700485571
		a = a&amp;lt;&amp;lt;6 | a&amp;gt;&amp;gt;(32-6) + b

		// [Min] b=II(d,a,b,c,M3,10,0x8f0ccc92)
		d += (b ^ (a | ^c)) + X[(7*5)&amp;amp;15] + 2399980690
		d = d&amp;lt;&amp;lt;10 | d&amp;gt;&amp;gt;(32-10) + a

		// [Min] c=II(c,d,a,b,M10,15,0xffeff47d)
		c += (a ^ (d | ^b)) + X[(7*6)&amp;amp;15] + 4293915773
		c = c&amp;lt;&amp;lt;15 | c&amp;gt;&amp;gt;(32-15) + d

		// [Min] d=II(b,c,d,a,M1,21,0x85845dd1)
		b += (d ^ (c | ^a)) + X[(7*7)&amp;amp;15] + 2240044497
		b = b&amp;lt;&amp;lt;21 | b&amp;gt;&amp;gt;(32-21) + c

		// [Min] a=II(a,b,c,d,M8,6,0x6fa87e4f)
		a += (c ^ (b | ^d)) + X[(7*8)&amp;amp;15] + 1873313359
		a = a&amp;lt;&amp;lt;6 | a&amp;gt;&amp;gt;(32-6) + b

		// [Min] b=II(d,a,b,c,M15,10,0xfe2ce6e0)
		d += (b ^ (a | ^c)) + X[(7*9)&amp;amp;15] + 4264355552
		d = d&amp;lt;&amp;lt;10 | d&amp;gt;&amp;gt;(32-10) + a

		// [Min] c=II(c,d,a,b,M6,15,0xa3014314)
		c += (a ^ (d | ^b)) + X[(7*10)&amp;amp;15] + 2734768916
		c = c&amp;lt;&amp;lt;15 | c&amp;gt;&amp;gt;(32-15) + d

		// [Min] d=II(b,c,d,a,M13,21,0x4e0811a1)
		b += (d ^ (c | ^a)) + X[(7*11)&amp;amp;15] + 1309151649
		b = b&amp;lt;&amp;lt;21 | b&amp;gt;&amp;gt;(32-21) + c

		// [Min] a=II(a,b,c,d,M4,6,0xf7537e82)
		a += (c ^ (b | ^d)) + X[(7*12)&amp;amp;15] + 4149444226
		a = a&amp;lt;&amp;lt;6 | a&amp;gt;&amp;gt;(32-6) + b

		// [Min] b=II(d,a,b,c,M11,10,0xbd3af235)
		d += (b ^ (a | ^c)) + X[(7*13)&amp;amp;15] + 3174756917
		d = d&amp;lt;&amp;lt;10 | d&amp;gt;&amp;gt;(32-10) + a

		// [Min] c=II(c,d,a,b,M2,15,0x2ad7d2bb)
		c += (a ^ (d | ^b)) + X[(7*14)&amp;amp;15] + 718787259
		c = c&amp;lt;&amp;lt;15 | c&amp;gt;&amp;gt;(32-15) + d

		// [Min] d=II(b,c,d,a,M9,21,0xeb86d391)
		b += (d ^ (c | ^a)) + X[(7*15)&amp;amp;15] + 3951481745
		b = b&amp;lt;&amp;lt;21 | b&amp;gt;&amp;gt;(32-21) + c

		// [Min] 在原来的基础上加上经过4轮计算后的值
		a += aa
		b += bb
		c += cc
		d += dd

		// [Min] 处理下一分块
		p = p[chunk:]
	}

	// [Min] 设置最终摘要
	dig.s[0] = a
	dig.s[1] = b
	dig.s[2] = c
	dig.s[3] = d
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;3-sha1&#34;&gt;3. SHA1&lt;/h1&gt;

&lt;h2 id=&#34;3-1-与-md5-的比较&#34;&gt;3.1 与 MD5 的比较&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;SHA1 摘要长度为20字节160位长&lt;/li&gt;
&lt;li&gt;SHA1 与 MD5 相反，采用大字节序存储数值&lt;/li&gt;
&lt;li&gt;SHA1 采用与 MD5 完全一致的分块方式&lt;/li&gt;
&lt;li&gt;SHA1 块内按大字节序分为16组 uint32，再进行共计80次循环计算&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;3-2-sha1-分块处理算法&#34;&gt;3.2 SHA1 分块处理算法&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/SHA-1&#34; target=&#34;_blank&#34;&gt;https://en.wikipedia.org/wiki/SHA-1&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;3-3-go源码分析&#34;&gt;3.3 Go源码分析&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;a href=&#34;https://github.com/mooncaker816/LearningGoStandardLib/blob/master/crypto/sha1/sha1.go&#34; target=&#34;_blank&#34;&gt;sha1.go&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;a href=&#34;https://github.com/mooncaker816/LearningGoStandardLib/blob/master/crypto/sha1/sha1block.go&#34; target=&#34;_blank&#34;&gt;sha1block.go&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&#34;4-sha2&#34;&gt;4. SHA2&lt;/h1&gt;

&lt;p&gt;　　1. SHA2 是 SHA256，SHA224，SHA512，SHA384，SHA512-256，SHA512-224 的统称&lt;/p&gt;

&lt;p&gt;　　2. SHA224 可以看成是以不同初始摘要计算的 SHA256 的截取&lt;/p&gt;

&lt;p&gt;　　3. 同样，SHA384，SHA512-256，SHA512-224 可以看成是以不同初始摘要计算的 SHA512 的截取　&lt;/p&gt;

&lt;h2 id=&#34;4-1-sha256-sha224&#34;&gt;4.1 SHA256，SHA224&lt;/h2&gt;

&lt;h3 id=&#34;4-1-1-与-md5-的比较&#34;&gt;4.1.1 与 MD5 的比较&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;SHA256 摘要长度为32字节256位长&lt;/li&gt;
&lt;li&gt;SHA256 与 MD5 相反，采用大字节序存储数值&lt;/li&gt;
&lt;li&gt;SHA256 采用与 MD5 完全一致的分块方式&lt;/li&gt;
&lt;li&gt;SHA256 块内按大字节序分为16组 uint32，再以这16组数据为基础，按一定算法扩充至64组，最后再进行共计64次循环计算&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;4-1-2-sha256-分块处理算法&#34;&gt;4.1.2 SHA256 分块处理算法&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/SHA-2&#34; target=&#34;_blank&#34;&gt;https://en.wikipedia.org/wiki/SHA-2&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;4-1-3-go源码分析&#34;&gt;4.1.3 Go源码分析&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;a href=&#34;https://github.com/mooncaker816/LearningGoStandardLib/blob/master/crypto/sha256/sha256.go&#34; target=&#34;_blank&#34;&gt;sha256.go&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;a href=&#34;https://github.com/mooncaker816/LearningGoStandardLib/blob/master/crypto/sha256/sha256block.go&#34; target=&#34;_blank&#34;&gt;sha256block.go&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;4-2-sha512-sha384-sha512-256-sha512-224&#34;&gt;4.2 SHA512，SHA384，SHA512-256，SHA512-224&lt;/h2&gt;

&lt;h3 id=&#34;4-2-1-与-md5-的比较&#34;&gt;4.2.1 与 MD5 的比较&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;SHA512 摘要长度为64字节512位长&lt;/li&gt;
&lt;li&gt;SHA512 与 MD5 相反，采用大字节序存储数值&lt;/li&gt;
&lt;li&gt;SHA512 采用与 MD5 基本一致的分块方式，分块大小略有调整
分块大小由64字节512位变为128字节1024位，
最后一个分块末尾用来记录源数据字节长度的部分由8字节改为16字节
因为分块的长度改成了128字节，所以填充临界点位128-16=112字节&lt;/li&gt;
&lt;li&gt;SHA512 块内按大字节序分为16组 uint64，再以这16组数据为基础，按一定算法扩充至80组，最后再进行共计80次循环计算&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;4-2-2-sha512-分块处理算法&#34;&gt;4.2.2 SHA512 分块处理算法&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/SHA-2&#34; target=&#34;_blank&#34;&gt;https://en.wikipedia.org/wiki/SHA-2&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;4-2-3-go源码分析&#34;&gt;4.2.3 Go源码分析&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;a href=&#34;https://github.com/mooncaker816/LearningGoStandardLib/blob/master/crypto/sha512/sha512.go&#34; target=&#34;_blank&#34;&gt;sha512.go&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;a href=&#34;https://github.com/mooncaker816/LearningGoStandardLib/blob/master/crypto/sha512/sha512block.go&#34; target=&#34;_blank&#34;&gt;sha512block.go&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</description>
    </item>
    
    <item>
      <title>Filepath</title>
      <link>https://mooncaker816.github.io/2018/06/26/filepath/</link>
      <pubDate>Tue, 26 Jun 2018 15:39:18 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/06/26/filepath/</guid>
      <description>&lt;h1 id=&#34;1-filepath包概要&#34;&gt;1. Filepath包概要&lt;/h1&gt;

&lt;h2 id=&#34;1-1-概述&#34;&gt;1.1 概述&lt;/h2&gt;

&lt;p&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Package filepath implements utility routines for manipulating filename paths
in a way compatible with the target operating system-defined file paths.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　&lt;code&gt;filepath&lt;/code&gt;包实现了对不同操作系统的文件路径的统一操作&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The filepath package uses either forward slashes or backslashes,
depending on the operating system. To process paths such as URLs
that always use forward slashes regardless of the operating
system, see the path package.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　根据不同的操作系统，该包既可以处理以正斜杠&lt;code&gt;/&lt;/code&gt;为分隔的路径，也可以处理以反斜杠&lt;code&gt;\&lt;/code&gt;为分隔的路径。对于 URL 的处理，总是使用正斜杠&lt;code&gt;/&lt;/code&gt;，无关操作系统。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&#34;1-2-包结构&#34;&gt;1.2 包结构&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;├── example_test.go
├── example_unix_test.go
├── export_test.go
├── export_windows_test.go
├── match.go
├── match_test.go
├── path.go
├── path_plan9.go
├── path_test.go
├── path_unix.go
├── path_windows.go
├── path_windows_test.go
├── symlink.go
├── symlink_unix.go
└── symlink_windows.go
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;2-深入-filepath-包&#34;&gt;2. 深入&lt;code&gt;filepath&lt;/code&gt;包&lt;/h1&gt;

&lt;h2 id=&#34;2-1-path-go-path-test-go&#34;&gt;2.1 &lt;code&gt;path.go&lt;/code&gt; &amp;amp; &lt;code&gt;path_test.go&lt;/code&gt;&lt;/h2&gt;

&lt;h3 id=&#34;2-1-1-clean&#34;&gt;2.1.1 &lt;code&gt;Clean&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;签名：&lt;code&gt;func Clean(path string) string&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;用途：对路径进行格式化，与&lt;code&gt;path.Clean&lt;/code&gt;基本一致，windows 系统的根目录为&lt;code&gt;C:\&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;示例：&lt;a href=&#34;https://play.golang.org/p/UZqq84JBFet&#34; target=&#34;_blank&#34;&gt;https://play.golang.org/p/UZqq84JBFet&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;	// Already clean
	{&amp;quot;abc&amp;quot; =&amp;gt; &amp;quot;abc&amp;quot;},
	{&amp;quot;abc/def&amp;quot; =&amp;gt; &amp;quot;abc/def&amp;quot;},
	{&amp;quot;a/b/c&amp;quot; =&amp;gt; &amp;quot;a/b/c&amp;quot;},
	{&amp;quot;.&amp;quot; =&amp;gt; &amp;quot;.&amp;quot;},
	{&amp;quot;..&amp;quot; =&amp;gt; &amp;quot;..&amp;quot;},
	{&amp;quot;../..&amp;quot; =&amp;gt; &amp;quot;../..&amp;quot;},
	{&amp;quot;../../abc&amp;quot; =&amp;gt; &amp;quot;../../abc&amp;quot;},
	{&amp;quot;/abc&amp;quot; =&amp;gt; &amp;quot;/abc&amp;quot;},
	{&amp;quot;/&amp;quot; =&amp;gt; &amp;quot;/&amp;quot;},

	// Empty is current dir
	{&amp;quot;&amp;quot; =&amp;gt; &amp;quot;.&amp;quot;},

	// Remove trailing slash
	{&amp;quot;abc/&amp;quot; =&amp;gt; &amp;quot;abc&amp;quot;},
	{&amp;quot;abc/def/&amp;quot; =&amp;gt; &amp;quot;abc/def&amp;quot;},
	{&amp;quot;a/b/c/&amp;quot; =&amp;gt; &amp;quot;a/b/c&amp;quot;},
	{&amp;quot;./&amp;quot; =&amp;gt; &amp;quot;.&amp;quot;},
	{&amp;quot;../&amp;quot; =&amp;gt; &amp;quot;..&amp;quot;},
	{&amp;quot;../../&amp;quot; =&amp;gt; &amp;quot;../..&amp;quot;},
	{&amp;quot;/abc/&amp;quot; =&amp;gt; &amp;quot;/abc&amp;quot;},

	// Remove doubled slash
	{&amp;quot;abc//def//ghi&amp;quot; =&amp;gt; &amp;quot;abc/def/ghi&amp;quot;},
	{&amp;quot;//abc&amp;quot; =&amp;gt; &amp;quot;/abc&amp;quot;},
	{&amp;quot;///abc&amp;quot; =&amp;gt; &amp;quot;/abc&amp;quot;},
	{&amp;quot;//abc//&amp;quot; =&amp;gt; &amp;quot;/abc&amp;quot;},
	{&amp;quot;abc//&amp;quot; =&amp;gt; &amp;quot;abc&amp;quot;},

	// Remove . elements
	{&amp;quot;abc/./def&amp;quot; =&amp;gt; &amp;quot;abc/def&amp;quot;},
	{&amp;quot;/./abc/def&amp;quot; =&amp;gt; &amp;quot;/abc/def&amp;quot;},
	{&amp;quot;abc/.&amp;quot; =&amp;gt; &amp;quot;abc&amp;quot;},

	// Remove .. elements
	{&amp;quot;abc/def/ghi/../jkl&amp;quot; =&amp;gt; &amp;quot;abc/def/jkl&amp;quot;},
	{&amp;quot;abc/def/../ghi/../jkl&amp;quot; =&amp;gt; &amp;quot;abc/jkl&amp;quot;},
	{&amp;quot;abc/def/..&amp;quot; =&amp;gt; &amp;quot;abc&amp;quot;},
	{&amp;quot;abc/def/../..&amp;quot; =&amp;gt; &amp;quot;.&amp;quot;},
	{&amp;quot;/abc/def/../..&amp;quot; =&amp;gt; &amp;quot;/&amp;quot;},
	{&amp;quot;abc/def/../../..&amp;quot; =&amp;gt; &amp;quot;..&amp;quot;},
	{&amp;quot;/abc/def/../../..&amp;quot; =&amp;gt; &amp;quot;/&amp;quot;},
	{&amp;quot;abc/def/../../../ghi/jkl/../../../mno&amp;quot; =&amp;gt; &amp;quot;../../mno&amp;quot;},
	{&amp;quot;/../abc&amp;quot; =&amp;gt; &amp;quot;/abc&amp;quot;},

	// Combinations
	{&amp;quot;abc/./../def&amp;quot; =&amp;gt; &amp;quot;def&amp;quot;},
	{&amp;quot;abc//./../def&amp;quot; =&amp;gt; &amp;quot;def&amp;quot;},
	{&amp;quot;abc/../../././../def&amp;quot; =&amp;gt; &amp;quot;../../def&amp;quot;},

	{`c:` =&amp;gt; `c:.`},
	{`c:\` =&amp;gt; `c:\`},
	{`c:\abc` =&amp;gt; `c:\abc`},
	{`c:abc\..\..\.\.\..\def` =&amp;gt; `c:..\..\def`},
	{`c:\abc\def\..\..` =&amp;gt; `c:\`},
	{`c:\..\abc` =&amp;gt; `c:\abc`},
	{`c:..\abc` =&amp;gt; `c:..\abc`},
	{`\` =&amp;gt; `\`},
	{`/` =&amp;gt; `\`},
	{`\\i\..\c$` =&amp;gt; `\c$`},
	{`\\i\..\i\c$` =&amp;gt; `\i\c$`},
	{`\\i\..\I\c$` =&amp;gt; `\I\c$`},
	{`\\host\share\foo\..\bar` =&amp;gt; `\\host\share\bar`},
	{`//host/share/foo/../baz` =&amp;gt; `\\host\share\baz`},
	{`\\a\b\..\c` =&amp;gt; `\\a\b\c`},
	{`\\a\b` =&amp;gt; `\\a\b`},
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-1-2-toslash-fromslash&#34;&gt;2.1.2 &lt;code&gt;ToSlash&lt;/code&gt; &amp;amp; &lt;code&gt;FromSlash&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;签名：&lt;code&gt;func ToSlash(path string) string&lt;/code&gt; &amp;amp; &lt;code&gt;func FromSlash(path string) string&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;用途：将路径中的分隔符替换为&lt;code&gt;/&lt;/code&gt; &amp;amp; 将路径中的&lt;code&gt;/&lt;/code&gt;分隔符替换为系统对应的分隔符&lt;/p&gt;

&lt;p&gt;示例：&lt;a href=&#34;https://play.golang.org/p/FB-HZSqbuSd&#34; target=&#34;_blank&#34;&gt;https://play.golang.org/p/FB-HZSqbuSd&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;	{&amp;quot;&amp;quot;, &amp;quot;&amp;quot;},
	{&amp;quot;/&amp;quot;, string(sep)},
	{&amp;quot;/a/b&amp;quot;, string([]byte{sep, &#39;a&#39;, sep, &#39;b&#39;})},
	{&amp;quot;a//b&amp;quot;, string([]byte{&#39;a&#39;, sep, sep, &#39;b&#39;})},
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-1-3-splitlist&#34;&gt;2.1.3 &lt;code&gt;SplitList&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;签名：&lt;code&gt;func SplitList(path string) []string&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;用途：根据系统的 List分隔符（如环境变量&lt;code&gt;PATH&lt;/code&gt;中包含的多个路径之间的&lt;code&gt;:&lt;/code&gt; &lt;code&gt;;&lt;/code&gt;）,将List路径拆分成单个路径组成的 slice，若List路径为空，则返回空 slice&lt;/p&gt;

&lt;p&gt;示例：&lt;a href=&#34;https://play.golang.org/p/bQOhCR4kvFq&#34; target=&#34;_blank&#34;&gt;https://play.golang.org/p/bQOhCR4kvFq&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;	{&amp;quot;&amp;quot;, []string{}},
	{string([]byte{&#39;a&#39;, lsep, &#39;b&#39;}), []string{&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;}},
	{string([]byte{lsep, &#39;a&#39;, lsep, &#39;b&#39;}), []string{&amp;quot;&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;}},
    
	// quoted
	{`&amp;quot;a&amp;quot;`, []string{`a`}},

	// semicolon
	{`&amp;quot;;&amp;quot;`, []string{`;`}},
	{`&amp;quot;a;b&amp;quot;`, []string{`a;b`}},
	{`&amp;quot;;&amp;quot;;`, []string{`;`, ``}},
	{`;&amp;quot;;&amp;quot;`, []string{``, `;`}},

	// partially quoted
	{`a&amp;quot;;&amp;quot;b`, []string{`a;b`}},
	{`a; &amp;quot;&amp;quot;b`, []string{`a`, ` b`}},
	{`&amp;quot;a;b`, []string{`a;b`}},
	{`&amp;quot;&amp;quot;a;b`, []string{`a`, `b`}},
	{`&amp;quot;&amp;quot;&amp;quot;a;b`, []string{`a;b`}},
	{`&amp;quot;&amp;quot;&amp;quot;&amp;quot;a;b`, []string{`a`, `b`}},
	{`a&amp;quot;;b`, []string{`a;b`}},
	{`a;b&amp;quot;;c`, []string{`a`, `b;c`}},
	{`&amp;quot;a&amp;quot;;b&amp;quot;;c`, []string{`a`, `b;c`}},
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-1-4-split&#34;&gt;2.1.4 &lt;code&gt;Split&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;签名：&lt;code&gt;func Split(path string) (dir, file string)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;用途：拆分路径为目录+文件名&lt;/p&gt;

&lt;p&gt;示例：&lt;a href=&#34;https://play.golang.org/p/ABl-Ph464rW&#34; target=&#34;_blank&#34;&gt;https://play.golang.org/p/ABl-Ph464rW&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;	{&amp;quot;a/b&amp;quot;, &amp;quot;a/&amp;quot;, &amp;quot;b&amp;quot;},
	{&amp;quot;a/b/&amp;quot;, &amp;quot;a/b/&amp;quot;, &amp;quot;&amp;quot;},
	{&amp;quot;a/&amp;quot;, &amp;quot;a/&amp;quot;, &amp;quot;&amp;quot;},
	{&amp;quot;a&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;a&amp;quot;},
	{&amp;quot;/&amp;quot;, &amp;quot;/&amp;quot;, &amp;quot;&amp;quot;},

	{`c:`, `c:`, ``},
	{`c:/`, `c:/`, ``},
	{`c:/foo`, `c:/`, `foo`},
	{`c:/foo/bar`, `c:/foo/`, `bar`},
	{`//host/share`, `//host/share`, ``},
	{`//host/share/`, `//host/share/`, ``},
	{`//host/share/foo`, `//host/share/`, `foo`},
	{`\\host\share`, `\\host\share`, ``},
	{`\\host\share\`, `\\host\share\`, ``},
	{`\\host\share\foo`, `\\host\share\`, `foo`},
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-1-5-join&#34;&gt;2.1.5 &lt;code&gt;Join&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;签名：&lt;code&gt;func Join(elem ...string) string&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;用途：拼接路径&lt;/p&gt;

&lt;p&gt;示例：&lt;a href=&#34;https://play.golang.org/p/RRhT3gH_SCJ&#34; target=&#34;_blank&#34;&gt;https://play.golang.org/p/RRhT3gH_SCJ&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;	// zero parameters
	{[]string{}, &amp;quot;&amp;quot;},

	// one parameter
	{[]string{&amp;quot;&amp;quot;}, &amp;quot;&amp;quot;},
	{[]string{&amp;quot;/&amp;quot;}, &amp;quot;/&amp;quot;},
	{[]string{&amp;quot;a&amp;quot;}, &amp;quot;a&amp;quot;},

	// two parameters
	{[]string{&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;}, &amp;quot;a/b&amp;quot;},
	{[]string{&amp;quot;a&amp;quot;, &amp;quot;&amp;quot;}, &amp;quot;a&amp;quot;},
	{[]string{&amp;quot;&amp;quot;, &amp;quot;b&amp;quot;}, &amp;quot;b&amp;quot;},
	{[]string{&amp;quot;/&amp;quot;, &amp;quot;a&amp;quot;}, &amp;quot;/a&amp;quot;},
	{[]string{&amp;quot;/&amp;quot;, &amp;quot;a/b&amp;quot;}, &amp;quot;/a/b&amp;quot;},
	{[]string{&amp;quot;/&amp;quot;, &amp;quot;&amp;quot;}, &amp;quot;/&amp;quot;},
	{[]string{&amp;quot;//&amp;quot;, &amp;quot;a&amp;quot;}, &amp;quot;/a&amp;quot;},
	{[]string{&amp;quot;/a&amp;quot;, &amp;quot;b&amp;quot;}, &amp;quot;/a/b&amp;quot;},
	{[]string{&amp;quot;a/&amp;quot;, &amp;quot;b&amp;quot;}, &amp;quot;a/b&amp;quot;},
	{[]string{&amp;quot;a/&amp;quot;, &amp;quot;&amp;quot;}, &amp;quot;a&amp;quot;},
	{[]string{&amp;quot;&amp;quot;, &amp;quot;&amp;quot;}, &amp;quot;&amp;quot;},

	// three parameters
	{[]string{&amp;quot;/&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;}, &amp;quot;/a/b&amp;quot;},

	{[]string{`directory`, `file`}, `directory\file`},
	{[]string{`C:\Windows\`, `System32`}, `C:\Windows\System32`},
	{[]string{`C:\Windows\`, ``}, `C:\Windows`},
	{[]string{`C:\`, `Windows`}, `C:\Windows`},
	{[]string{`C:`, `a`}, `C:a`},
	{[]string{`C:`, `a\b`}, `C:a\b`},
	{[]string{`C:`, `a`, `b`}, `C:a\b`},
	{[]string{`C:.`, `a`}, `C:a`},
	{[]string{`C:a`, `b`}, `C:a\b`},
	{[]string{`C:a`, `b`, `d`}, `C:a\b\d`},
	{[]string{`\\host\share`, `foo`}, `\\host\share\foo`},
	{[]string{`\\host\share\foo`}, `\\host\share\foo`},
	{[]string{`//host/share`, `foo/bar`}, `\\host\share\foo\bar`},
	{[]string{`\`}, `\`},
	{[]string{`\`, ``}, `\`},
	{[]string{`\`, `a`}, `\a`},
	{[]string{`\\`, `a`}, `\a`},
	{[]string{`\`, `a`, `b`}, `\a\b`},
	{[]string{`\\`, `a`, `b`}, `\a\b`},
	{[]string{`\`, `\\a\b`, `c`}, `\a\b\c`},
	{[]string{`\\a`, `b`, `c`}, `\a\b\c`},
	{[]string{`\\a\`, `b`, `c`}, `\a\b\c`},
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-1-6-ext&#34;&gt;2.1.6 &lt;code&gt;Ext&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;签名：&lt;code&gt;func Ext(path string) string&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;用途：根据最后一个元素中的最后一个&lt;code&gt;.&lt;/code&gt;，返回路径中文件的扩展名，若没有&lt;code&gt;.&lt;/code&gt;，返回空&lt;/p&gt;

&lt;p&gt;示例：&lt;a href=&#34;https://play.golang.org/p/K5TZl6W-ByS&#34; target=&#34;_blank&#34;&gt;https://play.golang.org/p/K5TZl6W-ByS&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;	{&amp;quot;path.go&amp;quot;, &amp;quot;.go&amp;quot;},
	{&amp;quot;path.pb.go&amp;quot;, &amp;quot;.go&amp;quot;},
	{&amp;quot;a.dir/b&amp;quot;, &amp;quot;&amp;quot;},
	{&amp;quot;a.dir/b.go&amp;quot;, &amp;quot;.go&amp;quot;},
	{&amp;quot;a.dir/&amp;quot;, &amp;quot;&amp;quot;},
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-1-7-evalsymlinks&#34;&gt;2.1.7 &lt;code&gt;EvalSymlinks&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;签名：&lt;code&gt;func EvalSymlinks(path string) (string, error)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;用途：对symlink文件解引用，并对结果路径格式化&lt;/p&gt;

&lt;p&gt;示例：&lt;a href=&#34;https://play.golang.org/p/3RwUZ9tfHos&#34; target=&#34;_blank&#34;&gt;https://play.golang.org/p/3RwUZ9tfHos&lt;/a&gt; (run local)&lt;/p&gt;

&lt;h3 id=&#34;2-1-8-abs&#34;&gt;2.1.8 &lt;code&gt;Abs&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;签名：&lt;code&gt;func Abs(path string) (string, error)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;用途：返回绝对路径并格式化，如果给定的路径不是绝对路径，则会加上当前目录形成绝对路径&lt;/p&gt;

&lt;p&gt;示例：&lt;a href=&#34;https://play.golang.org/p/UMr9_z4AsWR&#34; target=&#34;_blank&#34;&gt;https://play.golang.org/p/UMr9_z4AsWR&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;2-1-9-rel&#34;&gt;2.1.9 &lt;code&gt;Rel&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;签名：&lt;code&gt;func Rel(basepath, targpath string) (string, error)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;用途：根据 basepath 将 targpath 以相对路径的方式返回，并格式化&lt;/p&gt;

&lt;p&gt;示例：&lt;a href=&#34;https://play.golang.org/p/KFoNtsbW68D&#34; target=&#34;_blank&#34;&gt;https://play.golang.org/p/KFoNtsbW68D&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;	{&amp;quot;a/b&amp;quot;, &amp;quot;a/b&amp;quot;, &amp;quot;.&amp;quot;},
	{&amp;quot;a/b/.&amp;quot;, &amp;quot;a/b&amp;quot;, &amp;quot;.&amp;quot;},
	{&amp;quot;a/b&amp;quot;, &amp;quot;a/b/.&amp;quot;, &amp;quot;.&amp;quot;},
	{&amp;quot;./a/b&amp;quot;, &amp;quot;a/b&amp;quot;, &amp;quot;.&amp;quot;},
	{&amp;quot;a/b&amp;quot;, &amp;quot;./a/b&amp;quot;, &amp;quot;.&amp;quot;},
	{&amp;quot;ab/cd&amp;quot;, &amp;quot;ab/cde&amp;quot;, &amp;quot;../cde&amp;quot;},
	{&amp;quot;ab/cd&amp;quot;, &amp;quot;ab/c&amp;quot;, &amp;quot;../c&amp;quot;},
	{&amp;quot;a/b&amp;quot;, &amp;quot;a/b/c/d&amp;quot;, &amp;quot;c/d&amp;quot;},
	{&amp;quot;a/b&amp;quot;, &amp;quot;a/b/../c&amp;quot;, &amp;quot;../c&amp;quot;},
	{&amp;quot;a/b/../c&amp;quot;, &amp;quot;a/b&amp;quot;, &amp;quot;../b&amp;quot;},
	{&amp;quot;a/b/c&amp;quot;, &amp;quot;a/c/d&amp;quot;, &amp;quot;../../c/d&amp;quot;},
	{&amp;quot;a/b&amp;quot;, &amp;quot;c/d&amp;quot;, &amp;quot;../../c/d&amp;quot;},
	{&amp;quot;a/b/c/d&amp;quot;, &amp;quot;a/b&amp;quot;, &amp;quot;../..&amp;quot;},
	{&amp;quot;a/b/c/d&amp;quot;, &amp;quot;a/b/&amp;quot;, &amp;quot;../..&amp;quot;},
	{&amp;quot;a/b/c/d/&amp;quot;, &amp;quot;a/b&amp;quot;, &amp;quot;../..&amp;quot;},
	{&amp;quot;a/b/c/d/&amp;quot;, &amp;quot;a/b/&amp;quot;, &amp;quot;../..&amp;quot;},
	{&amp;quot;../../a/b&amp;quot;, &amp;quot;../../a/b/c/d&amp;quot;, &amp;quot;c/d&amp;quot;},
	{&amp;quot;/a/b&amp;quot;, &amp;quot;/a/b&amp;quot;, &amp;quot;.&amp;quot;},
	{&amp;quot;/a/b/.&amp;quot;, &amp;quot;/a/b&amp;quot;, &amp;quot;.&amp;quot;},
	{&amp;quot;/a/b&amp;quot;, &amp;quot;/a/b/.&amp;quot;, &amp;quot;.&amp;quot;},
	{&amp;quot;/ab/cd&amp;quot;, &amp;quot;/ab/cde&amp;quot;, &amp;quot;../cde&amp;quot;},
	{&amp;quot;/ab/cd&amp;quot;, &amp;quot;/ab/c&amp;quot;, &amp;quot;../c&amp;quot;},
	{&amp;quot;/a/b&amp;quot;, &amp;quot;/a/b/c/d&amp;quot;, &amp;quot;c/d&amp;quot;},
	{&amp;quot;/a/b&amp;quot;, &amp;quot;/a/b/../c&amp;quot;, &amp;quot;../c&amp;quot;},
	{&amp;quot;/a/b/../c&amp;quot;, &amp;quot;/a/b&amp;quot;, &amp;quot;../b&amp;quot;},
	{&amp;quot;/a/b/c&amp;quot;, &amp;quot;/a/c/d&amp;quot;, &amp;quot;../../c/d&amp;quot;},
	{&amp;quot;/a/b&amp;quot;, &amp;quot;/c/d&amp;quot;, &amp;quot;../../c/d&amp;quot;},
	{&amp;quot;/a/b/c/d&amp;quot;, &amp;quot;/a/b&amp;quot;, &amp;quot;../..&amp;quot;},
	{&amp;quot;/a/b/c/d&amp;quot;, &amp;quot;/a/b/&amp;quot;, &amp;quot;../..&amp;quot;},
	{&amp;quot;/a/b/c/d/&amp;quot;, &amp;quot;/a/b&amp;quot;, &amp;quot;../..&amp;quot;},
	{&amp;quot;/a/b/c/d/&amp;quot;, &amp;quot;/a/b/&amp;quot;, &amp;quot;../..&amp;quot;},
	{&amp;quot;/../../a/b&amp;quot;, &amp;quot;/../../a/b/c/d&amp;quot;, &amp;quot;c/d&amp;quot;},
	{&amp;quot;.&amp;quot;, &amp;quot;a/b&amp;quot;, &amp;quot;a/b&amp;quot;},
	{&amp;quot;.&amp;quot;, &amp;quot;..&amp;quot;, &amp;quot;..&amp;quot;},

	// can&#39;t do purely lexically
	{&amp;quot;..&amp;quot;, &amp;quot;.&amp;quot;, &amp;quot;err&amp;quot;},
	{&amp;quot;..&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;err&amp;quot;},
	{&amp;quot;../..&amp;quot;, &amp;quot;..&amp;quot;, &amp;quot;err&amp;quot;},
	{&amp;quot;a&amp;quot;, &amp;quot;/a&amp;quot;, &amp;quot;err&amp;quot;},
	{&amp;quot;/a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;err&amp;quot;},

	{`C:a\b\c`, `C:a/b/d`, `..\d`},
	{`C:\`, `D:\`, `err`},
	{`C:`, `D:`, `err`},
	{`C:\Projects`, `c:\projects\src`, `src`},
	{`C:\Projects`, `c:\projects`, `.`},
	{`C:\Projects\a\..`, `c:\projects`, `.`},
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-1-10-walk&#34;&gt;2.1.10 &lt;code&gt;Walk&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;签名：&lt;code&gt;func Walk(root string, walkFn WalkFunc) error&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;用途：用于遍历目录树&lt;/p&gt;

&lt;p&gt;示例：&lt;a href=&#34;https://play.golang.org/p/1fYRtezNBX-&#34; target=&#34;_blank&#34;&gt;https://play.golang.org/p/1fYRtezNBX-&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;type WalkFunc func(path string, info os.FileInfo, err error) error&lt;/code&gt;
&lt;code&gt;WalkFunc&lt;/code&gt; 函数一般是一个闭包，用于处理目录树中的每个文件/目录，如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;	errors := make([]error, 0, 10)
	clear := true
	markFn := func(path string, info os.FileInfo, err error) error {
		return mark(info, err, &amp;amp;errors, clear)
	}
	// Expect no errors.
	err := filepath.Walk(tree.name, markFn)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-1-11-base&#34;&gt;2.1.11 &lt;code&gt;Base&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;签名：&lt;code&gt;func Base(path string) string&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;用途：返回最后一个元素，如果路径为空，则返回&lt;code&gt;.&lt;/code&gt;，如果路径全是分隔符，则返回单个分隔符&lt;/p&gt;

&lt;p&gt;示例：&lt;a href=&#34;https://play.golang.org/p/0F6PSQjwOTX&#34; target=&#34;_blank&#34;&gt;https://play.golang.org/p/0F6PSQjwOTX&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;	{&amp;quot;&amp;quot;, &amp;quot;.&amp;quot;},
	{&amp;quot;.&amp;quot;, &amp;quot;.&amp;quot;},
	{&amp;quot;/.&amp;quot;, &amp;quot;.&amp;quot;},
	{&amp;quot;/&amp;quot;, &amp;quot;/&amp;quot;},
	{&amp;quot;////&amp;quot;, &amp;quot;/&amp;quot;},
	{&amp;quot;x/&amp;quot;, &amp;quot;x&amp;quot;},
	{&amp;quot;abc&amp;quot;, &amp;quot;abc&amp;quot;},
	{&amp;quot;abc/def&amp;quot;, &amp;quot;def&amp;quot;},
	{&amp;quot;a/b/.x&amp;quot;, &amp;quot;.x&amp;quot;},
	{&amp;quot;a/b/c.&amp;quot;, &amp;quot;c.&amp;quot;},
	{&amp;quot;a/b/c.x&amp;quot;, &amp;quot;c.x&amp;quot;},

	{`c:\`, `\`},
	{`c:.`, `.`},
	{`c:\a\b`, `b`},
	{`c:a\b`, `b`},
	{`c:a\b\c`, `c`},
	{`\\host\share\`, `\`},
	{`\\host\share\a`, `a`},
	{`\\host\share\a\b`, `b`},
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-1-12-dir&#34;&gt;2.1.12 &lt;code&gt;Dir&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;签名：&lt;code&gt;func Dir(path string) string&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;用途：返回除去最后一个元素的路径，并格式化。如果路径为空，返回.，如果路径全是分隔符，返回单个分隔符，返回的路径不以分隔符结尾，除非该路径为根目录&lt;/p&gt;

&lt;p&gt;示例：&lt;a href=&#34;https://play.golang.org/p/-6CrUtV9_CO&#34; target=&#34;_blank&#34;&gt;https://play.golang.org/p/-6CrUtV9_CO&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;	{&amp;quot;&amp;quot;, &amp;quot;.&amp;quot;},
	{&amp;quot;.&amp;quot;, &amp;quot;.&amp;quot;},
	{&amp;quot;/.&amp;quot;, &amp;quot;/&amp;quot;},
	{&amp;quot;/&amp;quot;, &amp;quot;/&amp;quot;},
	{&amp;quot;////&amp;quot;, &amp;quot;/&amp;quot;},
	{&amp;quot;/foo&amp;quot;, &amp;quot;/&amp;quot;},
	{&amp;quot;x/&amp;quot;, &amp;quot;x&amp;quot;},
	{&amp;quot;abc&amp;quot;, &amp;quot;.&amp;quot;},
	{&amp;quot;abc/def&amp;quot;, &amp;quot;abc&amp;quot;},
	{&amp;quot;a/b/.x&amp;quot;, &amp;quot;a/b&amp;quot;},
	{&amp;quot;a/b/c.&amp;quot;, &amp;quot;a/b&amp;quot;},
	{&amp;quot;a/b/c.x&amp;quot;, &amp;quot;a/b&amp;quot;},

	{`c:\`, `c:\`},
	{`c:.`, `c:.`},
	{`c:\a\b`, `c:\a`},
	{`c:a\b`, `c:a`},
	{`c:a\b\c`, `c:a\b`},
	{`\\host\share`, `\\host\share`},
	{`\\host\share\`, `\\host\share\`},
	{`\\host\share\a`, `\\host\share\`},
	{`\\host\share\a\b`, `\\host\share\a`},
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-1-13-volumename&#34;&gt;2.1.13 &lt;code&gt;VolumeName&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;签名：&lt;code&gt;func VolumeName(path string) string&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;用途：Windows系统返回卷名，其他系统返回空&lt;/p&gt;

&lt;p&gt;示例：&lt;a href=&#34;https://play.golang.org/p/uxvpRgAy9Lg&#34; target=&#34;_blank&#34;&gt;https://play.golang.org/p/uxvpRgAy9Lg&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;    	{`c:/foo/bar`, `c:`},
    	{`c:`, `c:`},
    	{`2:`, ``},
    	{``, ``},
    	{`\\\host`, ``},
    	{`\\\host\`, ``},
    	{`\\\host\share`, ``},
    	{`\\\host\\share`, ``},
    	{`\\host`, ``},
    	{`//host`, ``},
        {`\\host\`, ``},
        {`//host/`, ``},
        {`\\host\share`, `\\host\share`},
        {`//host/share`, `//host/share`},
        {`\\host\share\`, `\\host\share`},
        {`//host/share/`, `//host/share`},
        {`\\host\share\foo`, `\\host\share`},
        {`//host/share/foo`, `//host/share`},
        {`\\host\share\\foo\\\bar\\\\baz`, `\\host\share`},
        {`//host/share//foo///bar////baz`, `//host/share`},
        {`\\host\share\foo\..\bar`, `\\host\share`},
        {`//host/share/foo/../bar`, `//host/share`},
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-1-14-isabs&#34;&gt;2.1.14 &lt;code&gt;IsAbs&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;签名：&lt;code&gt;func IsAbs(path string) bool&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;用途：判断是否为绝对路径，在 Unix 中，以&lt;code&gt;/&lt;/code&gt;开始；在 Windows 中以某个盘符开始&lt;/p&gt;

&lt;p&gt;示例：&lt;a href=&#34;https://play.golang.org/p/JV2dVvYUaYP&#34; target=&#34;_blank&#34;&gt;https://play.golang.org/p/JV2dVvYUaYP&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;	{&amp;quot;&amp;quot;, false},
	{&amp;quot;/&amp;quot;, true},
	{&amp;quot;/usr/bin/gcc&amp;quot;, true},
	{&amp;quot;..&amp;quot;, false},
	{&amp;quot;/a/../bb&amp;quot;, true},
	{&amp;quot;.&amp;quot;, false},
	{&amp;quot;./&amp;quot;, false},
	{&amp;quot;lala&amp;quot;, false},
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2-2-match-go-match-test-go&#34;&gt;2.2 &lt;code&gt;match.go&lt;/code&gt; &amp;amp; &lt;code&gt;match_test.go&lt;/code&gt;&lt;/h2&gt;

&lt;h3 id=&#34;2-2-1-match&#34;&gt;2.2.1 &lt;code&gt;Match&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;签名：&lt;code&gt;func Match(pattern, name string) (matched bool, err error)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;用途：同&lt;code&gt;path.Match&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;示例：&lt;a href=&#34;https://play.golang.org/p/N5knl-o3yWM&#34; target=&#34;_blank&#34;&gt;https://play.golang.org/p/N5knl-o3yWM&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;	{&amp;quot;abc&amp;quot;, &amp;quot;abc&amp;quot;, true, nil},
	{&amp;quot;*&amp;quot;, &amp;quot;abc&amp;quot;, true, nil},
	{&amp;quot;*c&amp;quot;, &amp;quot;abc&amp;quot;, true, nil},
	{&amp;quot;a*&amp;quot;, &amp;quot;a&amp;quot;, true, nil},
	{&amp;quot;a*&amp;quot;, &amp;quot;abc&amp;quot;, true, nil},
	{&amp;quot;a*&amp;quot;, &amp;quot;ab/c&amp;quot;, false, nil},
	{&amp;quot;a*/b&amp;quot;, &amp;quot;abc/b&amp;quot;, true, nil},
	{&amp;quot;a*/b&amp;quot;, &amp;quot;a/c/b&amp;quot;, false, nil},
	{&amp;quot;a*b*c*d*e*/f&amp;quot;, &amp;quot;axbxcxdxe/f&amp;quot;, true, nil},
	{&amp;quot;a*b*c*d*e*/f&amp;quot;, &amp;quot;axbxcxdxexxx/f&amp;quot;, true, nil},
	{&amp;quot;a*b*c*d*e*/f&amp;quot;, &amp;quot;axbxcxdxe/xxx/f&amp;quot;, false, nil},
	{&amp;quot;a*b*c*d*e*/f&amp;quot;, &amp;quot;axbxcxdxexxx/fff&amp;quot;, false, nil},
	{&amp;quot;a*b?c*x&amp;quot;, &amp;quot;abxbbxdbxebxczzx&amp;quot;, true, nil},
	{&amp;quot;a*b?c*x&amp;quot;, &amp;quot;abxbbxdbxebxczzy&amp;quot;, false, nil},
	{&amp;quot;ab[c]&amp;quot;, &amp;quot;abc&amp;quot;, true, nil},
	{&amp;quot;ab[b-d]&amp;quot;, &amp;quot;abc&amp;quot;, true, nil},
	{&amp;quot;ab[e-g]&amp;quot;, &amp;quot;abc&amp;quot;, false, nil},
	{&amp;quot;ab[^c]&amp;quot;, &amp;quot;abc&amp;quot;, false, nil},
	{&amp;quot;ab[^b-d]&amp;quot;, &amp;quot;abc&amp;quot;, false, nil},
	{&amp;quot;ab[^e-g]&amp;quot;, &amp;quot;abc&amp;quot;, true, nil},
	{&amp;quot;a\\*b&amp;quot;, &amp;quot;a*b&amp;quot;, true, nil},
	{&amp;quot;a\\*b&amp;quot;, &amp;quot;ab&amp;quot;, false, nil},
	{&amp;quot;a?b&amp;quot;, &amp;quot;a☺b&amp;quot;, true, nil},
	{&amp;quot;a[^a]b&amp;quot;, &amp;quot;a☺b&amp;quot;, true, nil},
	{&amp;quot;a???b&amp;quot;, &amp;quot;a☺b&amp;quot;, false, nil},
	{&amp;quot;a[^a][^a][^a]b&amp;quot;, &amp;quot;a☺b&amp;quot;, false, nil},
	{&amp;quot;[a-ζ]*&amp;quot;, &amp;quot;α&amp;quot;, true, nil},
	{&amp;quot;*[a-ζ]&amp;quot;, &amp;quot;A&amp;quot;, false, nil},
	{&amp;quot;a?b&amp;quot;, &amp;quot;a/b&amp;quot;, false, nil},
	{&amp;quot;a*b&amp;quot;, &amp;quot;a/b&amp;quot;, false, nil},
	{&amp;quot;[\\]a]&amp;quot;, &amp;quot;]&amp;quot;, true, nil},
	{&amp;quot;[\\-]&amp;quot;, &amp;quot;-&amp;quot;, true, nil},
	{&amp;quot;[x\\-]&amp;quot;, &amp;quot;x&amp;quot;, true, nil},
	{&amp;quot;[x\\-]&amp;quot;, &amp;quot;-&amp;quot;, true, nil},
	{&amp;quot;[x\\-]&amp;quot;, &amp;quot;z&amp;quot;, false, nil},
	{&amp;quot;[\\-x]&amp;quot;, &amp;quot;x&amp;quot;, true, nil},
	{&amp;quot;[\\-x]&amp;quot;, &amp;quot;-&amp;quot;, true, nil},
	{&amp;quot;[\\-x]&amp;quot;, &amp;quot;a&amp;quot;, false, nil},
	{&amp;quot;[]a]&amp;quot;, &amp;quot;]&amp;quot;, false, ErrBadPattern},
	{&amp;quot;[-]&amp;quot;, &amp;quot;-&amp;quot;, false, ErrBadPattern},
	{&amp;quot;[x-]&amp;quot;, &amp;quot;x&amp;quot;, false, ErrBadPattern},
	{&amp;quot;[x-]&amp;quot;, &amp;quot;-&amp;quot;, false, ErrBadPattern},
	{&amp;quot;[x-]&amp;quot;, &amp;quot;z&amp;quot;, false, ErrBadPattern},
	{&amp;quot;[-x]&amp;quot;, &amp;quot;x&amp;quot;, false, ErrBadPattern},
	{&amp;quot;[-x]&amp;quot;, &amp;quot;-&amp;quot;, false, ErrBadPattern},
	{&amp;quot;[-x]&amp;quot;, &amp;quot;a&amp;quot;, false, ErrBadPattern},
	{&amp;quot;\\&amp;quot;, &amp;quot;a&amp;quot;, false, ErrBadPattern},
	{&amp;quot;[a-b-c]&amp;quot;, &amp;quot;a&amp;quot;, false, ErrBadPattern},
	{&amp;quot;[&amp;quot;, &amp;quot;a&amp;quot;, false, ErrBadPattern},
	{&amp;quot;[^&amp;quot;, &amp;quot;a&amp;quot;, false, ErrBadPattern},
	{&amp;quot;[^bc&amp;quot;, &amp;quot;a&amp;quot;, false, ErrBadPattern},
	{&amp;quot;a[&amp;quot;, &amp;quot;a&amp;quot;, false, nil},
	{&amp;quot;a[&amp;quot;, &amp;quot;ab&amp;quot;, false, ErrBadPattern},
	{&amp;quot;*x&amp;quot;, &amp;quot;xxx&amp;quot;, true, nil},
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-2-2-glob&#34;&gt;2.2.2 &lt;code&gt;Glob&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;签名：&lt;code&gt;func Glob(pattern string) (matches []string, err error)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;用途：列出与指定的模式 pattern 完全匹配的文件或目录（匹配原则同&lt;code&gt;Match&lt;/code&gt;）&lt;/p&gt;

&lt;p&gt;示例：&lt;a href=&#34;https://play.golang.org/p/GxqJkYQp_xm&#34; target=&#34;_blank&#34;&gt;https://play.golang.org/p/GxqJkYQp_xm&lt;/a&gt; (run local)&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Path</title>
      <link>https://mooncaker816.github.io/2018/06/26/path/</link>
      <pubDate>Tue, 26 Jun 2018 12:45:39 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/06/26/path/</guid>
      <description>&lt;h1 id=&#34;1-path包概要&#34;&gt;1. Path包概要&lt;/h1&gt;

&lt;h2 id=&#34;1-1-概述&#34;&gt;1.1 概述&lt;/h2&gt;

&lt;p&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Package path implements utility routines for manipulating slash-separated paths.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　&lt;code&gt;path&lt;/code&gt; 包实现了对以&lt;code&gt;/&lt;/code&gt;为分隔的路径的操作&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The path package should only be used for paths separated by forward
slashes, such as the paths in URLs. This package does not deal with
Windows paths with drive letters or backslashes; to manipulate
operating system paths, use the path/filepath package.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　该包只能用于对以正斜杠&lt;code&gt;/&lt;/code&gt;为分隔的路径的处理，比如 URL，而不能处理带有windows中的盘符或者反斜杠&lt;code&gt;\&lt;/code&gt;的路径，对于这类路径的处理需要使用 &lt;code&gt;path/filepath&lt;/code&gt; 包&lt;/p&gt;

&lt;h2 id=&#34;1-2-包结构&#34;&gt;1.2 包结构&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;├── example_test.go
├── match.go
├── match_test.go
├── path.go
└── path_test.go
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;2-深入-path-包&#34;&gt;2. 深入&lt;code&gt;path&lt;/code&gt;包&lt;/h1&gt;

&lt;h2 id=&#34;2-1-path-go-path-test-go&#34;&gt;2.1 &lt;code&gt;path.go&lt;/code&gt; &amp;amp; &lt;code&gt;path_test.go&lt;/code&gt;&lt;/h2&gt;

&lt;h3 id=&#34;2-1-1-clean&#34;&gt;2.1.1 &lt;code&gt;Clean&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;签名：&lt;code&gt;func Clean(path string) string&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;用途：&lt;code&gt;Clean&lt;/code&gt;函数主要是对给定路径进行以下格式化：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;替换多个斜杠&lt;code&gt;//&lt;/code&gt;为单个斜杠&lt;code&gt;/&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;消除&lt;code&gt;.&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;消除&lt;code&gt;..&lt;/code&gt;当且仅当前一个元素不是&lt;code&gt;..&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;替换绝对路径开头的&lt;code&gt;/..&lt;/code&gt;为&lt;code&gt;/&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;格式化后的路径不以&lt;code&gt;/&lt;/code&gt;结尾，除非该路径就是根路径&lt;code&gt;/&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;若格式化后路径为空，则返回&lt;code&gt;.&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;示例：&lt;a href=&#34;https://play.golang.org/p/Ya85iuk0uMU&#34; target=&#34;_blank&#34;&gt;https://play.golang.org/p/Ya85iuk0uMU&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;    // Already clean
	&amp;quot;&amp;quot; =&amp;gt; &amp;quot;.&amp;quot;
	&amp;quot;abc&amp;quot; =&amp;gt; &amp;quot;abc&amp;quot;
	&amp;quot;abc/def&amp;quot; =&amp;gt; &amp;quot;abc/def&amp;quot;
	&amp;quot;a/b/c&amp;quot; =&amp;gt; &amp;quot;a/b/c&amp;quot;
	&amp;quot;.&amp;quot; =&amp;gt; &amp;quot;.&amp;quot;
	&amp;quot;..&amp;quot; =&amp;gt; &amp;quot;..&amp;quot;
	&amp;quot;../..&amp;quot; =&amp;gt; &amp;quot;../..&amp;quot;
	&amp;quot;../../abc&amp;quot; =&amp;gt; &amp;quot;../../abc&amp;quot;
	&amp;quot;/abc&amp;quot; =&amp;gt; &amp;quot;/abc&amp;quot;
	&amp;quot;/&amp;quot; =&amp;gt; &amp;quot;/&amp;quot;

    // Remove trailing slash
	&amp;quot;abc/&amp;quot; =&amp;gt; &amp;quot;abc&amp;quot;
	&amp;quot;abc/def/&amp;quot; =&amp;gt; &amp;quot;abc/def&amp;quot;
	&amp;quot;a/b/c/&amp;quot; =&amp;gt; &amp;quot;a/b/c&amp;quot;
	&amp;quot;./&amp;quot; =&amp;gt; &amp;quot;.&amp;quot;
	&amp;quot;../&amp;quot; =&amp;gt; &amp;quot;..&amp;quot;
	&amp;quot;../../&amp;quot; =&amp;gt; &amp;quot;../..&amp;quot;
	&amp;quot;/abc/&amp;quot; =&amp;gt; &amp;quot;/abc&amp;quot;

    // Remove doubled slash
	&amp;quot;abc//def//ghi&amp;quot; =&amp;gt; &amp;quot;abc/def/ghi&amp;quot;
	&amp;quot;//abc&amp;quot; =&amp;gt; &amp;quot;/abc&amp;quot;
	&amp;quot;///abc&amp;quot; =&amp;gt; &amp;quot;/abc&amp;quot;
	&amp;quot;//abc//&amp;quot; =&amp;gt; &amp;quot;/abc&amp;quot;
	&amp;quot;abc//&amp;quot; =&amp;gt; &amp;quot;abc&amp;quot;

	&amp;quot;abc/./def&amp;quot; =&amp;gt; &amp;quot;abc/def&amp;quot;
	&amp;quot;/./abc/def&amp;quot; =&amp;gt; &amp;quot;/abc/def&amp;quot;
	&amp;quot;abc/.&amp;quot; =&amp;gt; &amp;quot;abc&amp;quot;

    // Remove .. elements
	&amp;quot;abc/def/ghi/../jkl&amp;quot; =&amp;gt; &amp;quot;abc/def/jkl&amp;quot;
	&amp;quot;abc/def/../ghi/../jkl&amp;quot; =&amp;gt; &amp;quot;abc/jkl&amp;quot;
	&amp;quot;abc/def/..&amp;quot; =&amp;gt; &amp;quot;abc&amp;quot;
	&amp;quot;abc/def/../..&amp;quot; =&amp;gt; &amp;quot;.&amp;quot;
	&amp;quot;/abc/def/../..&amp;quot; =&amp;gt; &amp;quot;/&amp;quot;
	&amp;quot;abc/def/../../..&amp;quot; =&amp;gt; &amp;quot;..&amp;quot;
	&amp;quot;/abc/def/../../..&amp;quot; =&amp;gt; &amp;quot;/&amp;quot;
	&amp;quot;abc/def/../../../ghi/jkl/../../../mno&amp;quot; =&amp;gt; &amp;quot;../../mno&amp;quot;

    // Combinations
	&amp;quot;abc/./../def&amp;quot; =&amp;gt; &amp;quot;def&amp;quot;
	&amp;quot;abc//./../def&amp;quot; =&amp;gt; &amp;quot;def&amp;quot;
	&amp;quot;abc/../../././../def&amp;quot; =&amp;gt; &amp;quot;../../def&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-1-2-split&#34;&gt;2.1.2 &lt;code&gt;Split&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;签名：&lt;code&gt;func Split(path string) (dir, file string)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;用途：拆分路径为目录+文件，目录保留&lt;code&gt;/&lt;/code&gt;，若路径中没有&lt;code&gt;/&lt;/code&gt;，则目录为空&lt;/p&gt;

&lt;p&gt;示例：&lt;a href=&#34;https://play.golang.org/p/DG8QjjWdkuq&#34; target=&#34;_blank&#34;&gt;https://play.golang.org/p/DG8QjjWdkuq&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;	&amp;quot;a/b&amp;quot; =&amp;gt; &amp;quot;a/&amp;quot; + &amp;quot;b&amp;quot;
	&amp;quot;a/b/&amp;quot; =&amp;gt; &amp;quot;a/b/&amp;quot; + &amp;quot;&amp;quot;
	&amp;quot;a/&amp;quot; =&amp;gt; &amp;quot;a/&amp;quot; + &amp;quot;&amp;quot;
	&amp;quot;a&amp;quot; =&amp;gt; &amp;quot;&amp;quot; + &amp;quot;a&amp;quot;
	&amp;quot;/&amp;quot; =&amp;gt; &amp;quot;/&amp;quot; + &amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-1-3-join&#34;&gt;2.1.3 &lt;code&gt;Join&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;签名：&lt;code&gt;Join(elem ...string) string&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;用途：把所有元素按顺序拼接为路径，并对路径格式化&lt;/p&gt;

&lt;p&gt;示例：&lt;a href=&#34;https://play.golang.org/p/jxcwt_fgUpt&#34; target=&#34;_blank&#34;&gt;https://play.golang.org/p/jxcwt_fgUpt&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;	// zero parameters
	{[]string{} =&amp;gt; &amp;quot;&amp;quot;},

	// one parameter
	{[]string{&amp;quot;&amp;quot;} =&amp;gt; &amp;quot;&amp;quot;},
	{[]string{&amp;quot;a&amp;quot;} =&amp;gt; &amp;quot;a&amp;quot;},

	// two parameters
	{[]string{&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;} =&amp;gt; &amp;quot;a/b&amp;quot;},
	{[]string{&amp;quot;a&amp;quot;, &amp;quot;&amp;quot;} =&amp;gt; &amp;quot;a&amp;quot;},
	{[]string{&amp;quot;&amp;quot;, &amp;quot;b&amp;quot;} =&amp;gt; &amp;quot;b&amp;quot;},
	{[]string{&amp;quot;/&amp;quot;, &amp;quot;a&amp;quot;} =&amp;gt; &amp;quot;/a&amp;quot;},
	{[]string{&amp;quot;/&amp;quot;, &amp;quot;&amp;quot;} =&amp;gt; &amp;quot;/&amp;quot;},
	{[]string{&amp;quot;a/&amp;quot;, &amp;quot;b&amp;quot;} =&amp;gt; &amp;quot;a/b&amp;quot;},
	{[]string{&amp;quot;a/&amp;quot;, &amp;quot;&amp;quot;} =&amp;gt; &amp;quot;a&amp;quot;},
	{[]string{&amp;quot;&amp;quot;, &amp;quot;&amp;quot;} =&amp;gt; &amp;quot;&amp;quot;},
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-1-4-ext&#34;&gt;2.1.4 &lt;code&gt;Ext&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;签名：&lt;code&gt;Ext(path string) string&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;用途：根据&lt;code&gt;.&lt;/code&gt;返回路径中文件的扩展名，若没有&lt;code&gt;.&lt;/code&gt;则返回空&lt;/p&gt;

&lt;p&gt;示例：&lt;a href=&#34;https://play.golang.org/p/VxIO_oewphL&#34; target=&#34;_blank&#34;&gt;https://play.golang.org/p/VxIO_oewphL&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;	{&amp;quot;path.go&amp;quot; =&amp;gt; &amp;quot;.go&amp;quot;},
	{&amp;quot;path.pb.go&amp;quot; =&amp;gt; &amp;quot;.go&amp;quot;},
	{&amp;quot;a.dir/b&amp;quot; =&amp;gt; &amp;quot;&amp;quot;},
	{&amp;quot;a.dir/b.go&amp;quot; =&amp;gt; &amp;quot;.go&amp;quot;},
	{&amp;quot;a.dir/&amp;quot; =&amp;gt; &amp;quot;&amp;quot;},
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-1-5-base&#34;&gt;2.1.5 &lt;code&gt;Base&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;签名：&lt;code&gt;Base(path string) string&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;用途：先清除路径末尾的&lt;code&gt;/&lt;/code&gt;（如果有的话），再根据最后一个&lt;code&gt;/&lt;/code&gt;，返回该元素，若没有&lt;code&gt;/&lt;/code&gt;，则返回&lt;code&gt;.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;示例：&lt;a href=&#34;https://play.golang.org/p/bW-KYszq1fE&#34; target=&#34;_blank&#34;&gt;https://play.golang.org/p/bW-KYszq1fE&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;	{&amp;quot;&amp;quot; =&amp;gt; &amp;quot;.&amp;quot;},
	{&amp;quot;.&amp;quot; =&amp;gt; &amp;quot;.&amp;quot;},
	{&amp;quot;/.&amp;quot; =&amp;gt; &amp;quot;.&amp;quot;},
	{&amp;quot;/&amp;quot; =&amp;gt; &amp;quot;/&amp;quot;},
	{&amp;quot;////&amp;quot; =&amp;gt; &amp;quot;/&amp;quot;},
	{&amp;quot;x/&amp;quot; =&amp;gt; &amp;quot;x&amp;quot;},
	{&amp;quot;abc&amp;quot; =&amp;gt; &amp;quot;abc&amp;quot;},
	{&amp;quot;abc/def&amp;quot; =&amp;gt; &amp;quot;def&amp;quot;},
	{&amp;quot;a/b/.x&amp;quot; =&amp;gt; &amp;quot;.x&amp;quot;},
	{&amp;quot;a/b/c.&amp;quot; =&amp;gt; &amp;quot;c.&amp;quot;},
	{&amp;quot;a/b/c.x&amp;quot; =&amp;gt; &amp;quot;c.x&amp;quot;},
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-1-6-isabs&#34;&gt;2.1.6 &lt;code&gt;IsAbs&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;签名：&lt;code&gt;IsAbs(path string) bool&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;用途：判断路径是否为绝对路径，即以&lt;code&gt;/&lt;/code&gt;开头&lt;/p&gt;

&lt;p&gt;示例：&lt;a href=&#34;https://play.golang.org/p/MWv0m9Q8I-J&#34; target=&#34;_blank&#34;&gt;https://play.golang.org/p/MWv0m9Q8I-J&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;	{&amp;quot;&amp;quot; =&amp;gt; false},
	{&amp;quot;/&amp;quot; =&amp;gt; true},
	{&amp;quot;/usr/bin/gcc&amp;quot; =&amp;gt; true},
	{&amp;quot;..&amp;quot; =&amp;gt; false},
	{&amp;quot;/a/../bb&amp;quot; =&amp;gt; true},
	{&amp;quot;.&amp;quot; =&amp;gt; false},
	{&amp;quot;./&amp;quot; =&amp;gt; false},
	{&amp;quot;lala&amp;quot; =&amp;gt; false},
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-1-7-dir&#34;&gt;2.1.7 &lt;code&gt;Dir&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;签名：&lt;code&gt;Dir(path string) string&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;用途：返回去除最后一项后的目录路径,并格式化&lt;/p&gt;

&lt;p&gt;示例：&lt;a href=&#34;https://play.golang.org/p/DBULKf343C6&#34; target=&#34;_blank&#34;&gt;https://play.golang.org/p/DBULKf343C6&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;	{&amp;quot;&amp;quot; =&amp;gt; &amp;quot;.&amp;quot;},
	{&amp;quot;.&amp;quot; =&amp;gt; &amp;quot;.&amp;quot;},
	{&amp;quot;/.&amp;quot; =&amp;gt; &amp;quot;/&amp;quot;},
	{&amp;quot;/&amp;quot; =&amp;gt; &amp;quot;/&amp;quot;},
	{&amp;quot;////&amp;quot; =&amp;gt; &amp;quot;/&amp;quot;},
	{&amp;quot;/foo&amp;quot; =&amp;gt; &amp;quot;/&amp;quot;},
	{&amp;quot;x/&amp;quot; =&amp;gt; &amp;quot;x&amp;quot;},
	{&amp;quot;abc&amp;quot; =&amp;gt; &amp;quot;.&amp;quot;},
	{&amp;quot;abc/def&amp;quot; =&amp;gt; &amp;quot;abc&amp;quot;},
	{&amp;quot;abc////def&amp;quot; =&amp;gt; &amp;quot;abc&amp;quot;},
	{&amp;quot;a/b/.x&amp;quot; =&amp;gt; &amp;quot;a/b&amp;quot;},
	{&amp;quot;a/b/c.&amp;quot; =&amp;gt; &amp;quot;a/b&amp;quot;},
	{&amp;quot;a/b/c.x&amp;quot; =&amp;gt; &amp;quot;a/b&amp;quot;},
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2-2-match-go-match-test-go&#34;&gt;2.2 &lt;code&gt;match.go&lt;/code&gt; &amp;amp; &lt;code&gt;match_test.go&lt;/code&gt;&lt;/h2&gt;

&lt;h3 id=&#34;2-2-1-match&#34;&gt;2.2.1 &lt;code&gt;Match&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;签名：&lt;code&gt;func Match(pattern, name string) (matched bool, err error)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;用途：根据给定的模式对路径进行匹配，模式如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;	pattern:
		{ term }
	term:
		&#39;*&#39;         matches any sequence of non-/ characters 匹配任意数量的所有非/字符
		&#39;?&#39;         matches any single non-/ character 匹配所有单个非/字符
		&#39;[&#39; [ &#39;^&#39; ] { character-range } &#39;]&#39; 区间匹配，^表示除了该区间，匹配不能为空，至少需要一个
		            character class (must be non-empty)
		c           matches character c (c != &#39;*&#39;, &#39;?&#39;, &#39;\\&#39;, &#39;[&#39;) 匹配单个确定字符，除&#39;*&#39;, &#39;?&#39;, &#39;\\&#39;, &#39;[&#39;
		&#39;\\&#39; c      matches character c 可以看作转义匹配&#39;*&#39;, &#39;?&#39;, &#39;\\&#39;, &#39;[&#39;

	character-range:
		c           matches character c (c != &#39;\\&#39;, &#39;-&#39;, &#39;]&#39;) 在区间匹配中匹配单个确定字符，除&#39;\\&#39;, &#39;-&#39;, &#39;]&#39;
		&#39;\\&#39; c      matches character c 可以看作在区间匹配中转义匹配&#39;\\&#39;, &#39;-&#39;, &#39;]&#39;
		lo &#39;-&#39; hi   matches character c for lo &amp;lt;= c &amp;lt;= hi 区间范围
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;示例：&lt;a href=&#34;https://play.golang.org/p/yhfME8jBmn1&#34; target=&#34;_blank&#34;&gt;https://play.golang.org/p/yhfME8jBmn1&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;	{&amp;quot;abc&amp;quot;, &amp;quot;abc&amp;quot;, true, nil},
	{&amp;quot;*&amp;quot;, &amp;quot;abc&amp;quot;, true, nil},
	{&amp;quot;*c&amp;quot;, &amp;quot;abc&amp;quot;, true, nil},
	{&amp;quot;a*&amp;quot;, &amp;quot;a&amp;quot;, true, nil},
	{&amp;quot;a*&amp;quot;, &amp;quot;abc&amp;quot;, true, nil},
	{&amp;quot;a*&amp;quot;, &amp;quot;ab/c&amp;quot;, false, nil},
	{&amp;quot;a*/b&amp;quot;, &amp;quot;abc/b&amp;quot;, true, nil},
	{&amp;quot;a*/b&amp;quot;, &amp;quot;a/c/b&amp;quot;, false, nil},
	{&amp;quot;a*b*c*d*e*/f&amp;quot;, &amp;quot;axbxcxdxe/f&amp;quot;, true, nil},
	{&amp;quot;a*b*c*d*e*/f&amp;quot;, &amp;quot;axbxcxdxexxx/f&amp;quot;, true, nil},
	{&amp;quot;a*b*c*d*e*/f&amp;quot;, &amp;quot;axbxcxdxe/xxx/f&amp;quot;, false, nil},
	{&amp;quot;a*b*c*d*e*/f&amp;quot;, &amp;quot;axbxcxdxexxx/fff&amp;quot;, false, nil},
	{&amp;quot;a*b?c*x&amp;quot;, &amp;quot;abxbbxdbxebxczzx&amp;quot;, true, nil},
	{&amp;quot;a*b?c*x&amp;quot;, &amp;quot;abxbbxdbxebxczzy&amp;quot;, false, nil},
	{&amp;quot;ab[c]&amp;quot;, &amp;quot;abc&amp;quot;, true, nil},
	{&amp;quot;ab[b-d]&amp;quot;, &amp;quot;abc&amp;quot;, true, nil},
	{&amp;quot;ab[e-g]&amp;quot;, &amp;quot;abc&amp;quot;, false, nil},
	{&amp;quot;ab[^c]&amp;quot;, &amp;quot;abc&amp;quot;, false, nil},
	{&amp;quot;ab[^b-d]&amp;quot;, &amp;quot;abc&amp;quot;, false, nil},
	{&amp;quot;ab[^e-g]&amp;quot;, &amp;quot;abc&amp;quot;, true, nil},
	{&amp;quot;a\\*b&amp;quot;, &amp;quot;a*b&amp;quot;, true, nil},
	{&amp;quot;a\\*b&amp;quot;, &amp;quot;ab&amp;quot;, false, nil},
	{&amp;quot;a?b&amp;quot;, &amp;quot;a☺b&amp;quot;, true, nil},
	{&amp;quot;a[^a]b&amp;quot;, &amp;quot;a☺b&amp;quot;, true, nil},
	{&amp;quot;a???b&amp;quot;, &amp;quot;a☺b&amp;quot;, false, nil},
	{&amp;quot;a[^a][^a][^a]b&amp;quot;, &amp;quot;a☺b&amp;quot;, false, nil},
	{&amp;quot;[a-ζ]*&amp;quot;, &amp;quot;α&amp;quot;, true, nil},
	{&amp;quot;*[a-ζ]&amp;quot;, &amp;quot;A&amp;quot;, false, nil},
	{&amp;quot;a?b&amp;quot;, &amp;quot;a/b&amp;quot;, false, nil},
	{&amp;quot;a*b&amp;quot;, &amp;quot;a/b&amp;quot;, false, nil},
	{&amp;quot;[\\]a]&amp;quot;, &amp;quot;]&amp;quot;, true, nil},
	{&amp;quot;[\\-]&amp;quot;, &amp;quot;-&amp;quot;, true, nil},
	{&amp;quot;[x\\-]&amp;quot;, &amp;quot;x&amp;quot;, true, nil},
	{&amp;quot;[x\\-]&amp;quot;, &amp;quot;-&amp;quot;, true, nil},
	{&amp;quot;[x\\-]&amp;quot;, &amp;quot;z&amp;quot;, false, nil},
	{&amp;quot;[\\-x]&amp;quot;, &amp;quot;x&amp;quot;, true, nil},
	{&amp;quot;[\\-x]&amp;quot;, &amp;quot;-&amp;quot;, true, nil},
	{&amp;quot;[\\-x]&amp;quot;, &amp;quot;a&amp;quot;, false, nil},
	{&amp;quot;[]a]&amp;quot;, &amp;quot;]&amp;quot;, false, ErrBadPattern},
	{&amp;quot;[-]&amp;quot;, &amp;quot;-&amp;quot;, false, ErrBadPattern},
	{&amp;quot;[x-]&amp;quot;, &amp;quot;x&amp;quot;, false, ErrBadPattern},
	{&amp;quot;[x-]&amp;quot;, &amp;quot;-&amp;quot;, false, ErrBadPattern},
	{&amp;quot;[x-]&amp;quot;, &amp;quot;z&amp;quot;, false, ErrBadPattern},
	{&amp;quot;[-x]&amp;quot;, &amp;quot;x&amp;quot;, false, ErrBadPattern},
	{&amp;quot;[-x]&amp;quot;, &amp;quot;-&amp;quot;, false, ErrBadPattern},
	{&amp;quot;[-x]&amp;quot;, &amp;quot;a&amp;quot;, false, ErrBadPattern},
	{&amp;quot;\\&amp;quot;, &amp;quot;a&amp;quot;, false, ErrBadPattern},
	{&amp;quot;[a-b-c]&amp;quot;, &amp;quot;a&amp;quot;, false, ErrBadPattern},
	{&amp;quot;[&amp;quot;, &amp;quot;a&amp;quot;, false, ErrBadPattern},
	{&amp;quot;[^&amp;quot;, &amp;quot;a&amp;quot;, false, ErrBadPattern},
	{&amp;quot;[^bc&amp;quot;, &amp;quot;a&amp;quot;, false, ErrBadPattern},
	{&amp;quot;a[&amp;quot;, &amp;quot;a&amp;quot;, false, nil},
	{&amp;quot;a[&amp;quot;, &amp;quot;ab&amp;quot;, false, ErrBadPattern},
	{&amp;quot;*x&amp;quot;, &amp;quot;xxx&amp;quot;, true, nil},
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Go并发模式1</title>
      <link>https://mooncaker816.github.io/2018/06/13/go%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F1/</link>
      <pubDate>Wed, 13 Jun 2018 15:02:12 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/06/13/go%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F1/</guid>
      <description>&lt;h1 id=&#34;or-channel&#34;&gt;Or-Channel&lt;/h1&gt;

&lt;p&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;使用场景：&lt;br /&gt;
当你需要同时监测多个信号时，只要接收到其中任一个信号，就认为信号接收成功，需要进行下一步处理&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func or(channels ...&amp;lt;-chan interface{}) &amp;lt;-chan interface{} {
    switch len(channels) {
    case 0:
        return nil
    case 1:
        return channels[0]
    }
    orDone := make(chan interface{})
    go func() {
        defer close(orDone)
        switch len(channels) {
        case 2:
            select {
            case &amp;lt;-channels[0]:
            case &amp;lt;-channels[1]:
            }
        default:
            select {
            case &amp;lt;-channels[0]:
            case &amp;lt;-channels[1]:
            case &amp;lt;-channels[2]:
            case &amp;lt;-or(append(channels[3:], orDone)...):
            }
        }
    }()
    return orDone
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;测试：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func TestOr(t *testing.T) {
    st := time.Now()
    r := rand.New(rand.NewSource(time.Now().Unix()))
    &amp;lt;-or(
        randSig(r),
        randSig(r),
        randSig(r),
        randSig(r),
        randSig(r),
    )
    fmt.Printf(&amp;quot;closed after %v!\n&amp;quot;, time.Since(st))
}

func randSig(r *rand.Rand) &amp;lt;-chan interface{} {
    ch := make(chan interface{})
    go func() {
        defer close(ch)
        sec := time.Duration(r.Int63n(10)+3) * time.Second
        fmt.Printf(&amp;quot;closing after %v!\n&amp;quot;, sec)
        time.Sleep(sec)
    }()
    return ch
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;closing after 4s!
closing after 10s!
closing after 3s!
closing after 9s!
closing after 11s!
closed after 3.001062582s!
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>天文算法27</title>
      <link>https://mooncaker816.github.io/2018/05/28/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9527/</link>
      <pubDate>Mon, 28 May 2018 10:35:29 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/05/28/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9527/</guid>
      <description>&lt;h1 id=&#34;第二十九章-ephemeris-for-physical-observations-of-the-sun&#34;&gt;第二十九章 Ephemeris for Physical Observations of the Sun&lt;/h1&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-日面计算&#34;&gt;1. 日面计算&lt;/h2&gt;

&lt;p&gt;$P$ 为日轴方位角，自日面北点量起的太阳自转轴北端的方位角，向东为正&lt;br /&gt;
$B_0$ 为日面中心的日面纬度&lt;br /&gt;
$L_0$ 为日面中心的日面经度&lt;/p&gt;

&lt;p&gt;根据之前章节的算法，先计算太阳视黄经$λ$(包含光行差修正)，$λ&amp;rsquo;$为$λ$的黄经章动修正值，$ε$为真黄赤交角&lt;br /&gt;
再计算
\begin{cases}
θ = (JD - 2398220)\frac {360°}{25.38}\\[2ex]
I = 7°.25,(太阳赤道与黄道的倾角)\\[2ex]
K = 73°.6667 + 1°.3958333\frac {JD - 2396758}{36525},(太阳赤道与黄道的升交点的黄经)\\[2ex]
\tan x = -\cos λ&amp;rsquo;\tan ε\\[2ex]
\tan y = -\cos (λ - K)\tan I
\end{cases}
那么
\begin{cases}
P = x+y\\[2ex]
\sin B_0 = \sin(λ - K)\sin I\\[2ex]
\tan η = \frac {-\sin(λ - K)\cos I}{-\cos (λ - K)}\\[2ex]
L_0 = η-θ
\end{cases}&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Ephemeris returns the apparent orientation of the sun at the given jd.
// 计算日面参数
//
// Results:
//	P:  Position angle of the solar north pole.
//	B0: Heliographic latitude of the center of the solar disk.
//	L0: Heliographic longitude of the center of the solar disk.
func Ephemeris(jd float64, e *pp.V87Planet) (P, B0, L0 unit.Angle) {
	θ := unit.Angle((jd - 2398220) * 2 * math.Pi / 25.38)
	I := unit.AngleFromDeg(7.25)
	K := unit.AngleFromDeg(73.6667) +
		unit.AngleFromDeg(1.3958333).Mul((jd-2396758)/base.JulianCentury)

	L, _, R := solar.TrueVSOP87(e, jd)
	Δψ, Δε := nutation.Nutation(jd)
	ε0 := nutation.MeanObliquity(jd)
	ε := ε0 + Δε
	λ := L - unit.AngleFromSec(20.4898).Div(R)
	λp := λ + Δψ

	sλK, cλK := (λ - K).Sincos()
	sI, cI := I.Sincos()

	tx := -(λp.Cos() * ε.Tan())
	ty := -(cλK * I.Tan())
	P = unit.Angle(math.Atan(tx) + math.Atan(ty))
	B0 = unit.Angle(math.Asin(sλK * sI))
	η := unit.Angle(math.Atan2(-sλK*cI, -cλK))
	L0 = (η - θ).Mod1()
	return
}

// Cycle returns the jd of the start of the given synodic rotation.
//
// Argument c is the &amp;quot;Carrington&amp;quot; cycle number.
//
// Result is a dynamical time (not UT).
func Cycle(c int) (jde float64) {
	cf := float64(c)
	jde = 2398140.227 + 27.2752316*cf
	m := 281.96*math.Pi/180 + 26.882476*math.Pi/180*cf
	s2m, c2m := math.Sincos(2 * m)
	return jde + .1454*math.Sin(m) - .0085*s2m - .0141*c2m
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>天文算法26</title>
      <link>https://mooncaker816.github.io/2018/05/28/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9526/</link>
      <pubDate>Mon, 28 May 2018 09:25:36 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/05/28/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9526/</guid>
      <description>&lt;h1 id=&#34;第二十八章-equation-of-time-均时差&#34;&gt;第二十八章 Equation of Time 均时差&lt;/h1&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-均时差的概念&#34;&gt;1. 均时差的概念&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%9D%87%E6%99%82%E5%B7%AE&#34; target=&#34;_blank&#34;&gt;均时差&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;2-计算时差&#34;&gt;2. 计算时差&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;VSOP87理论计算&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;$$E = L_0 - 0°.0057183 - α + Δψ·\cos ε$$
其中$α$为太阳地心视赤经，$Δψ$为赤经章动，$ε$为真黄赤交角，$L_0$为太阳平黄经
$$L_0 = 280.4664567 + 360007.6982779τ + 0.03032028τ^2 + τ^3 /49931 - τ^4 /15300 - τ^5 /2000000$$
$τ$为儒略日千年数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// E computes the &amp;quot;equation of time&amp;quot; for the given JDE.
// 计算时差
//
// Parameter e must be a planetposition.V87Planet object for Earth obtained
// with planetposition.LoadPlanet.
//
// Result is equation of time as an hour angle.
func E(jde float64, e *pp.V87Planet) unit.HourAngle {
	τ := base.J2000Century(jde) * .1 // J2000儒略日千年数
	L0 := l0(τ)
	// code duplicated from solar.ApparentEquatorialVSOP87 so that
	// we can keep Δψ and cε
	s, β, R := solar.TrueVSOP87(e, jde) // 真太阳黄经
	Δψ, Δε := nutation.Nutation(jde)
	a := unit.AngleFromSec(-20.4898).Div(R) //光行差
	λ := s + Δψ + a                         //视黄经
	ε := nutation.MeanObliquity(jde) + Δε   // 真黄赤交角
	sε, cε := ε.Sincos()
	α, _ := coord.EclToEq(λ, β, sε, cε) // 视赤经
	// (28.1) p. 183
	E := L0 - unit.AngleFromDeg(.0057183) - unit.Angle(α) + Δψ.Mul(cε)
	return unit.HourAngle((E + math.Pi).Mod1() - math.Pi)
}

// (28.2) p. 183
// 太阳平黄经
func l0(τ float64) unit.Angle {
	return unit.AngleFromDeg(base.Horner(τ,
		280.4664567, 360007.6982779, .03032028,
		1./49931, -1./15300, -1./2000000))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;低精度时差计算&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;$$E = y\sin 2L_0 - 2e\sin M + 4ey\sin M \cos 2L_0 - \frac 12y^2\sin 4L_0 - \frac 54 e^2\sin 2M$$
其中$y = \tan^2(ε/2)，ε是平黄赤交角,L_0为太阳平黄经，e为地球轨道离心率，M为太阳平近点角$&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// ESmart computes the &amp;quot;equation of time&amp;quot; for the given JDE.
// 低精度计算时差
//
// Result is equation of time as an hour angle.
//
// Result is less accurate that E() but the function has the advantage
// of not requiring the V87Planet object.
func ESmart(jde float64) unit.HourAngle {
	ε := nutation.MeanObliquity(jde) // 平黄赤交角
	t := ε.Mul(.5).Tan()
	y := t * t
	T := base.J2000Century(jde)
	L0 := l0(T * .1)
	e := solar.Eccentricity(T) //地球轨道离心率
	M := solar.MeanAnomaly(T)  // 太阳平近点角
	s2L0, c2L0 := L0.Mul(2).Sincos()
	sM := M.Sin()
	// (28.3) p. 185, with double angle identity
	return unit.HourAngle(y*s2L0 - 2*e*sM + 4*e*y*sM*c2L0 -
		y*y*s2L0*c2L0 - 1.25*e*e*M.Mul(2).Sin())
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>天文算法25</title>
      <link>https://mooncaker816.github.io/2018/05/26/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9525/</link>
      <pubDate>Sat, 26 May 2018 08:58:00 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/05/26/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9525/</guid>
      <description>&lt;h1 id=&#34;第二十七章-分点和至点-equinoxes-and-solstices&#34;&gt;第二十七章 分点和至点 Equinoxes and Solstices&lt;/h1&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;分点（英语：equinox，或称二分点）是想像中天球赤道在天球上的位置，是每年太阳穿过天球赤道和黄道在天球上交点的天文事件[1]，这造成地球上各地的白天和夜晚几乎等长。&lt;/p&gt;

&lt;p&gt;二至点（亦称至点）可以是太阳在一年之中离地球赤道最远的两个事件中的任何一个，英文的字源（solstice） 来自拉丁文的太阳（sol）和保持直立（sistere），因为在至点时太阳直射的地球纬度是他能抵达的最南或最北的极值，而至点所在之日是一年之中日夜长短差异最大的一天。&lt;/p&gt;

&lt;p&gt;分点和至点时刻是指：太阳的地心视黄经(含光行差和章动)为90的整数倍时对应的时刻。因太阳黄纬不是真正为零的，所以在分点时刻太阳赤纬也不是真正为零的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://garyborjesson.files.wordpress.com/2013/03/equ-schem.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-近似时刻计算-最大误差1分钟&#34;&gt;1. 近似时刻计算(最大误差1分钟)&lt;/h2&gt;

&lt;p&gt;先找到平分点或平至点$JDE_0$&lt;br /&gt;
当$year \in [-1000,1000)$时，
\begin{cases}
Y = \frac {year}{1000}\\[2ex]
春分点：JDE_0 = 1721139.29189 + 365242.13740Y + 0.06134Y^2 + 0.00111Y^3 - 0.00071Y^4\\[2ex]
夏至点：JDE_0 = 1721233.25401 + 365241.72562Y - 0.05323Y^2 + 0.00907Y^3 + 0.00025Y^4\\[2ex]
秋分点：JDE_0 = 1721325.70455 + 365242.49558Y - 0.11677Y^2 - 0.00297Y^3 + 0.00074Y^4\\[2ex]
冬至点：JDE_0 = 1721414.39987 + 365242.88257Y - 0.00769Y^2 - 0.00933Y^3 - 0.00006Y^4\\[2ex]
\end{cases}
当$year \in [1000,3000]$时，
\begin{cases}
Y = \frac {year-2000}{1000}\\[2ex]
春分点：JDE_0 = 2451623.80984 + 365242.37404Y + 0.05169Y^2 - 0.00411Y^3 - 0.00057Y^4\\[2ex]
夏至点：JDE_0 = 2451716.56767 + 365241.62603Y + 0.00325Y^2 + 0.00888Y^3 - 0.00030Y^4\\[2ex]
秋分点：JDE_0 = 2451810.21715 + 365242.01767Y - 0.11575Y^2 + 0.00337Y^3 + 0.00078Y^4\\[2ex]
冬至点：JDE_0 = 2451900.05952 + 365242.74049Y - 0.06223Y^2 - 0.00823Y^3 + 0.00032Y^4\\[2ex]
\end{cases}
再计算
\begin{cases}
T &amp;amp;= \frac {JDE_0 - 2451545.0}{36525}\\[2ex]
W &amp;amp;= 35999°.373T - 2°.47\\[2ex]
Δλ &amp;amp;= 1 + 0.0334\cos W + 0.0007\cos (2W)\\[2ex]
S &amp;amp;= \sum A\cos(B+CT)
\end{cases}
其中$A,B,C$分别为下表中的系数项&lt;img src=&#34;https://mooncaker816.github.io/img/分至点.png&#34; alt=&#34;&#34; /&gt;
那么$$JDE = JDE_0 + \frac {0.00001S}{Δλ} days$$
注意此时得到的力学时DT，可以按需再转为UT&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var (
	mc0 = []float64{1721139.29189, 365242.13740, .06134, .00111, -.00071}
	jc0 = []float64{1721233.25401, 365241.72562, -.05232, .00907, .00025}
	sc0 = []float64{1721325.70455, 365242.49558, -.11677, -.00297, .00074}
	dc0 = []float64{1721414.39987, 365242.88257, -.00769, -.00933, -.00006}

	mc2 = []float64{2451623.80984, 365242.37404, .05169, -.00411, -.00057}
	jc2 = []float64{2451716.56767, 365241.62603, .00325, .00888, -.00030}
	sc2 = []float64{2451810.21715, 365242.01767, -.11575, .00337, .00078}
	dc2 = []float64{2451900.05952, 365242.74049, -.06223, -.00823, .00032}
)

type term struct {
	a, b, c float64
}

var terms = []term{
	{485, 324.96, 1934.136},
	{203, 337.23, 32964.467},
	{199, 342.08, 20.186},
	{182, 27.85, 445267.112},
	{156, 73.14, 45036.886},
	{136, 171.52, 22518.443},
	{77, 222.54, 65928.934},
	{74, 296.72, 3034.906},
	{70, 243.58, 9037.513},
	{58, 119.81, 33718.147},
	{52, 297.17, 150.678},
	{50, 21.02, 2281.226},

	{45, 247.54, 29929.562},
	{44, 325.15, 31555.956},
	{29, 60.93, 4443.417},
	{18, 155.12, 67555.328},
	{17, 288.79, 4562.452},
	{16, 198.04, 62894.029},
	{14, 199.76, 31436.921},
	{12, 95.39, 14577.848},
	{12, 287.11, 31931.756},
	{12, 320.81, 34777.259},
	{9, 227.73, 1222.114},
	{8, 15.45, 16859.074},
}

// March returns the JDE of the March equinox for the given year.
// 计算y年春分点力学时，y∈[-1000,3000]
//
// Results are valid for the years -1000 to +3000.
//
// Accuracy is within one minute of time for the years 1951-2050.
func March(y int) float64 {
	if y &amp;lt; 1000 {
		return eq(y, mc0)
	}
	return eq(y-2000, mc2)
}

// June returns the JDE of the June solstice for the given year.
// 计算y年夏至点力学时，y∈[-1000,3000]
//
// Results are valid for the years -1000 to +3000.
//
// Accuracy is within one minute of time for the years 1951-2050.
func June(y int) float64 {
	if y &amp;lt; 1000 {
		return eq(y, jc0)
	}
	return eq(y-2000, jc2)
}

// September returns the JDE of the September equinox for the given year.
// 计算y年秋分点力学时，y∈[-1000,3000]
//
// Results are valid for the years -1000 to +3000.
//
// Accuracy is within one minute of time for the years 1951-2050.
func September(y int) float64 {
	if y &amp;lt; 1000 {
		return eq(y, sc0)
	}
	return eq(y-2000, sc2)
}

// December returns the JDE of the December solstice for a given year.
// 计算y年冬至点力学时，y∈[-1000,3000]
//
// Results are valid for the years -1000 to +3000.
//
// Accuracy is within one minute of time for the years 1951-2050.
func December(y int) float64 {
	if y &amp;lt; 1000 {
		return eq(y, dc0)
	}
	return eq(y-2000, dc2)
}

func eq(y int, c []float64) float64 {
	J0 := base.Horner(float64(y)*.001, c...)
	T := base.J2000Century(J0)
	W := 35999.373*math.Pi/180*T - 2.47*math.Pi/180
	Δλ := 1 + .0334*math.Cos(W) + .0007*math.Cos(2*W)
	S := 0.
	for i := len(terms) - 1; i &amp;gt;= 0; i-- {
		t := &amp;amp;terms[i]
		S += t.a * math.Cos((t.b+t.c*T)*math.Pi/180)
	}
	return J0 + .00001*S/Δλ
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2-高精度分至点时刻计算&#34;&gt;2. 高精度分至点时刻计算&lt;/h2&gt;

&lt;p&gt;　　先用低精度方法算出近似时刻，再采用VSOP87理论计算出该时刻的太阳视黄经$λ$，&lt;br /&gt;
　　再根据各个分至点的几何度数按以下公式求该近似时刻的修正量，循环迭代，直至满足要求。
　　$$+58\sin (k90° - λ)$$
　　其中k=0,1,2,3分别对应春夏秋冬四个分至点&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// March2 returns a more accurate JDE of the March equinox.
// 高精度计算春分点力学时
//
// Result is accurate to one second of time.
//
// Parameter e must be a V87Planet object representing Earth, obtained with
// the package planetposition and code similar to
//
//	e, err := planetposition.LoadPlanet(planetposition.Earth, &amp;quot;&amp;quot;)
//	    if err != nil {
//	        ....
//
// See example under June2.
func March2(y int, e *pp.V87Planet) float64 {
	if y &amp;lt; 1000 {
		return eq2(y, e, 0, mc0)
	}
	return eq2(y-2000, e, 0, mc2)
}

// June2 returns a more accurate JDE of the June solstice.
// 高精度计算夏至点力学时
//
// Result is accurate to one second of time.
//
// Parameter e must be a V87Planet object representing Earth, obtained with
// the package planetposition.
func June2(y int, e *pp.V87Planet) float64 {
	if y &amp;lt; 1000 {
		return eq2(y, e, math.Pi/2, jc0)
	}
	return eq2(y-2000, e, math.Pi/2, jc2)
}

// September2 returns a more accurate JDE of the September equinox.
// 高精度计算秋分点力学时
//
// Result is accurate to one second of time.
//
// Parameter e must be a V87Planet object representing Earth, obtained with
// the package planetposition and code similar to
//
//	e, err := planetposition.LoadPlanet(planetposition.Earth, &amp;quot;&amp;quot;)
//	    if err != nil {
//	        ....
//
// See example under June2.
func September2(y int, e *pp.V87Planet) float64 {
	if y &amp;lt; 1000 {
		return eq2(y, e, math.Pi, sc0)
	}
	return eq2(y-2000, e, math.Pi, sc2)
}

// December2 returns a more accurate JDE of the December solstice.
// 高精度计算冬至点力学时
//
// Result is accurate to one second of time.
//
// Parameter e must be a V87Planet object representing Earth, obtained with
// the package planetposition and code similar to
//
//	e, err := planetposition.LoadPlanet(planetposition.Earth, &amp;quot;&amp;quot;)
//	    if err != nil {
//	        ....
//
// See example under June2.
func December2(y int, e *pp.V87Planet) float64 {
	if y &amp;lt; 1000 {
		return eq2(y, e, math.Pi*3/2, dc0)
	}
	return eq2(y-2000, e, math.Pi*3/2, dc2)
}

//先用低精度方法算出近似时刻，再采用VSOP87理论计算出该时刻的太阳视黄经λ，
//再根据各个分至点的几何度数求该近似时刻的修正量，循环迭代，直至满足要求。
func eq2(y int, e *pp.V87Planet, q unit.Angle, c []float64) float64 {
	J0 := base.Horner(float64(y)*.001, c...)
	for {
		λ, _, _ := solar.ApparentVSOP87(e, J0)
		c := 58 * (q - λ).Sin() // (27.1) p. 180
		J0 += c
		if math.Abs(c) &amp;lt; .000005 {
			break
		}
	}
	return J0
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>天文算法24</title>
      <link>https://mooncaker816.github.io/2018/05/25/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9524/</link>
      <pubDate>Fri, 25 May 2018 13:59:39 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/05/25/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9524/</guid>
      <description>&lt;h1 id=&#34;第二十六章-太阳直角坐标-rectangular-coordinates-of-the-sun&#34;&gt;第二十六章 太阳直角坐标 Rectangular Coordinates of the Sun&lt;/h1&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;　　太阳的地心赤道直角坐标$X,Y,Z$。原点在地心。$X$轴的方向指向春分点（经度为0），$Y$轴平放在赤道面上， 经度是90°，$Z$轴方向是北极。&lt;/p&gt;

&lt;h2 id=&#34;1-date-平分点参考系&#34;&gt;1. Date 平分点参考系&lt;/h2&gt;

&lt;p&gt;\begin{cases}
X &amp;amp;= R\cos β\cos ☉\\[2ex]
Y &amp;amp;= R(\cos β\sin ☉\cos ε - \sin β\sin ε)\\[2ex]
Z &amp;amp;= R(\cos β\sin ☉\sin ε + \sin β\cos ε)
\end{cases}
其中$☉,β,R$是太阳的地心几何黄经,黄纬,日地距离（可由&lt;code&gt;solar.TrueVSOP87&lt;/code&gt;求出），$ε$是平黄赤交角。&lt;br /&gt;
因为 Date 黄道坐标中，太阳的纬度不超过 1.2 角秒， 所以可以看成$\cos β=1$&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Position returns rectangular coordinates referenced to the mean equinox
// of date.
// Date 平分点太阳地心直角坐标
func Position(e *pp.V87Planet, jde float64) (x, y, z float64) {
	// (26.1) p. 171
	s, β, R := solar.TrueVSOP87(e, jde)
	sε, cε := nutation.MeanObliquity(jde).Sincos()
	ss, cs := s.Sincos()
	sβ := β.Sin()
	x = R * cs
	y = R * (ss*cε - sβ*sε)
	z = R * (ss*sε + sβ*cε)
	return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2-j2000标准分点参考系和b1950平分点参考系&#34;&gt;2. J2000标准分点参考系和B1950平分点参考系&lt;/h2&gt;

&lt;p&gt;通过VSOP87计算给定时刻地球的相对于 J2000.0 分点的日心黄经$L$和黄纬$B$，及距离$R$
$$☉ = L + 180°， β = -B$$
计算
\begin{cases}
X &amp;amp;= R\cos β*cos ☉\\[2ex]
Y &amp;amp;= R\cos β*sin ☉\\[2ex]
Z &amp;amp;= R\sin β
\end{cases}&lt;/p&gt;

&lt;p&gt;上述坐标仍是黄道坐标，J2000参考系的赤道坐标为：
\begin{cases}
X_0 &amp;amp;= 1.000000000000X+0.000000440360Y-0.000000190919Z\\[2ex]
Y_0 &amp;amp;= -0.000000479966X+0.917482137087Y-0.397776982902Z\\[2ex]
Z_0 &amp;amp;= 0.000000000000X+0.397776982902Y+0.917482137087Z
\end{cases}&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// PositionJ2000 returns rectangular coordinates referenced to equinox J2000.
// J2000太阳直角坐标
func PositionJ2000(e *pp.V87Planet, jde float64) (x, y, z float64) {
	x, y, z = xyz(e, jde)
	// (26.3) p. 174
	return x + .00000044036*y - .000000190919*z,
		-.000000479966*x + .917482137087*y - .397776982902*z,
		.397776982902*y + .917482137087*z
}

func xyz(e *pp.V87Planet, jde float64) (x, y, z float64) {
	l, b, r := e.Position2000(jde)
	s := l + math.Pi
	β := -b
	ss, cs := s.Sincos()
	sβ, cβ := β.Sincos()
	// (26.2) p. 172
	x = r * cβ * cs
	y = r * cβ * ss
	z = r * sβ
	return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;B1950平分点参考系坐标：
\begin{cases}
X_0 &amp;amp;=0.999925702634X+0.012189716217Y+0.000011134016Z\\[2ex]
Y_0 &amp;amp;=-0.011179418036X+0.917413998946Y-0.397777041885Z\\[2ex]
Z_0 &amp;amp;=-0.004859003787X+0.397747363646Y+0.917482111428Z
\end{cases}&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// PositionB1950 returns rectangular coordinates referenced to B1950.
// B1950 平分点参考系太阳直角坐标
//
// Results are referenced to the mean equator and equinox of the epoch B1950
// in the FK5 system, not FK4.
func PositionB1950(e *pp.V87Planet, jde float64) (x, y, z float64) {
	x, y, z = xyz(e, jde)
	return .999925702634*x + .012189716217*y + .000011134016*z,
		-.011179418036*x + .917413998946*y - .397777041885*z,
		-.004859003787*x + .397747363646*y + .917482111428*z
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;3-任意其它平分点参考系&#34;&gt;3. 任意其它平分点参考系&lt;/h2&gt;

&lt;p&gt;　　先计算出J2000标准分点标准$X_0,Y_0,Z_0$&lt;br /&gt;
　　然后按岁差计算中的方法计算出$ζ,z,θ$,&lt;br /&gt;
\begin{cases}
X_x &amp;amp;= \cos ζ\cos z\cos θ - \sin ζ\sin z\\[2ex]
X_y &amp;amp;= \sin ζ\cos z + \cos ζ\sin z\cos θ\\[2ex]
X_z &amp;amp;= \cos ζ\sin θ\\[2ex]
\end{cases}
\begin{cases}
Y_x &amp;amp;= -\cos ζ\sin z - \sin ζ\cos z\cos θ\\[2ex]
Y_y &amp;amp;= \cos ζ\cos z - \sin ζ\sin z\cos θ\\[2ex]
Y_z &amp;amp;= -\sin ζ\sin θ\\[2ex]
\end{cases}
\begin{cases}
Z_x &amp;amp;= -\cos z\sin θ\\[2ex]
Z_y &amp;amp;= -\sin z\sin θ\\[2ex]
Z_z &amp;amp;= \cos θ
\end{cases}
　　那么
\begin{cases}
X′ &amp;amp;= X_xX_0 + Y_xY_0 + Z_xZ_0\\[2ex]
Y′ &amp;amp;= X_yX_0 + Y_yY_0 + Z_yZ_0\\[2ex]
Z′ &amp;amp;= X_zX_0 + Y_zY_0 + Z_zZ_0
\end{cases}&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// PositionEquinox returns rectangular coordinates referenced to an arbitrary epoch.
// 任意其它平分点参考系太阳直角坐标
//
// Position will be computed for given Julian day &amp;quot;jde&amp;quot; but referenced to mean
// equinox &amp;quot;epoch&amp;quot; (year).
func PositionEquinox(e *pp.V87Planet, jde, epoch float64) (xp, yp, zp float64) {
	x0, y0, z0 := PositionJ2000(e, jde)
	t := (epoch - 2000) * .01
	ζ := base.Horner(t, ζt...) * t * math.Pi / 180 / 3600
	z := base.Horner(t, zt...) * t * math.Pi / 180 / 3600
	θ := base.Horner(t, θt...) * t * math.Pi / 180 / 3600
	sζ, cζ := math.Sincos(ζ)
	sz, cz := math.Sincos(z)
	sθ, cθ := math.Sincos(θ)
	xx := cζ*cz*cθ - sζ*sz
	xy := sζ*cz + cζ*sz*cθ
	xz := cζ * sθ
	yx := -cζ*sz - sζ*cz*cθ
	yy := cζ*cz - sζ*sz*cθ
	yz := -sζ * sθ
	zx := -cz * sθ
	zy := -sz * sθ
	zz := cθ
	return xx*x0 + yx*y0 + zx*z0,
		xy*x0 + yy*y0 + zy*z0,
		xz*x0 + yz*y0 + zz*z0
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>天文算法23</title>
      <link>https://mooncaker816.github.io/2018/05/25/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9523/</link>
      <pubDate>Fri, 25 May 2018 08:06:54 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/05/25/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9523/</guid>
      <description>&lt;h1 id=&#34;第二十五章-太阳坐标-solar-coordinates&#34;&gt;第二十五章 太阳坐标 Solar Coordinates&lt;/h1&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-低精度太阳黄经&#34;&gt;1. 低精度太阳黄经&lt;/h2&gt;

&lt;p&gt;当计算精度要求为0.01度，计算太阳位置时可假设地球运动是一个纯椭圆，也就说忽略月球及行星摄动。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;太阳真黄经&lt;/p&gt;

&lt;p&gt;$T$为J2000起算的儒略世纪数&lt;br /&gt;
\begin{align}
太阳几何平黄经：L_0 &amp;amp;= 280°.46646 + 36000°.76983T + 0°.0003032T^2\\[2ex]
太阳平近点角： M &amp;amp;= 357°.52911 + 35999°.05029T - 0°.0001537T^2\\[2ex]
地球轨道离心率： e &amp;amp;= 0.016708634 - 0.000042037T - 0.0000001267T^2\\[2ex]
太阳中心方程 ： C &amp;amp;= +(1°.914602 - 0°.004817T - 0°.000014T^2)\sin M\\[2ex]
&amp;amp;+(0°.019993 - 0°.000101T)\sin 2M\\[2ex]
&amp;amp;+ 0°.000289\sin 3M
\end{align}
那么，太阳的真黄经是：$☉ = L_0 + C$ 真近点角是：$ν = M + C$&lt;br /&gt;
日地距离(AU)为：$R =\frac {1.000001018(1-e^2)}{1+e\cos ν}$&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// True returns true geometric longitude and anomaly of the sun referenced to the mean equinox of date.
// 计算太阳真黄经s，真近点角ν
//
// Argument T is the number of Julian centuries since J2000.
// See base.J2000Century.
//
// Results:
//  s = true geometric longitude, ☉
//  ν = true anomaly
func True(T float64) (s, ν unit.Angle) {
    // (25.2) p. 163
    L0 := unit.AngleFromDeg(base.Horner(T, 280.46646, 36000.76983, 0.0003032))
    M := MeanAnomaly(T)
    C := unit.AngleFromDeg(base.Horner(T, 1.914602, -0.004817, -.000014)*
        M.Sin() +
        (0.019993-.000101*T)*M.Mul(2).Sin() +
        0.000289*M.Mul(3).Sin())
    return (L0 + C).Mod1(), (M + C).Mod1()
}

// MeanAnomaly returns the mean anomaly of Earth at the given T.
// 太阳平近点角
//
// Argument T is the number of Julian centuries since J2000.
// See base.J2000Century.
//
// Result is not normalized to the range 0..2π.
func MeanAnomaly(T float64) unit.Angle {
    // (25.3) p. 163
    return unit.AngleFromDeg(base.Horner(T, 357.52911, 35999.05029, -0.0001537))
}

// Eccentricity returns eccentricity of the Earth&#39;s orbit around the sun.
// 地球轨道离心率
//
// Argument T is the number of Julian centuries since J2000.
// See base.J2000Century.
func Eccentricity(T float64) float64 {
    // (25.4) p. 163
    return base.Horner(T, 0.016708634, -0.000042037, -0.0000001267)
}

// Radius returns the Sun-Earth distance in AU.
// 日地距离，单位为 AU
//
// Argument T is the number of Julian centuries since J2000.
// See base.J2000Century.
func Radius(T float64) float64 {
    _, ν := True(T)
    e := Eccentricity(T)
    // (25.5) p. 164
    return 1.000001018 * (1 - e*e) / (1 + e*ν.Cos())
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;太阳视黄经&lt;/p&gt;

&lt;p&gt;太阳视黄经$λ$ = 太阳真黄经$☉$ + 章动修正 + 光行差修正&lt;/p&gt;

&lt;p&gt;如果精度要求不高，可以采用以下公式：
\begin{cases}
Ω &amp;amp;= 125°.04 - 1934°.136T\\[2ex]
λ &amp;amp;= ☉ - 0°.00569 -0°.00478\sin Ω
\end{cases}&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// ApparentLongitude returns apparent longitude of the Sun referenced
// to the true equinox of date.
// 太阳视黄经，考虑了章动和光行差
//
// Argument T is the number of Julian centuries since J2000.
// See base.J2000Century.
//
// Result includes correction for nutation and aberration.
func ApparentLongitude(T float64) unit.Angle {
    Ω := node(T)
    s, _ := True(T)
    return s - unit.AngleFromDeg(.00569) -
        unit.AngleFromDeg(.00478).Mul(Ω.Sin())
}

func node(T float64) unit.Angle {
    return unit.AngleFromDeg(125.04 - 1934.136*T)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;J2000的太阳真黄经$☉_2000 = ☉ - 0°.01397(year-2000), 1900\leq year \leq 2100$&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// True2000 returns true geometric longitude and anomaly of the sun referenced to equinox J2000.
//
// Argument T is the number of Julian centuries since J2000.
// See base.J2000Century.
//
// Results are accurate to .01 degree for years 1900 to 2100.
//
// Results:
//  s = true geometric longitude, ☉
//  ν = true anomaly
// J2000的太阳真黄经，真近点角
func True2000(T float64) (s, ν unit.Angle) {
    s, ν = True(T)
    s -= unit.AngleFromDeg(.01397).Mul(T * 100)
    return
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;太阳地心赤经$α$，地心赤纬$δ$&lt;/p&gt;

&lt;p&gt;\begin{cases}
\tan α = \frac {\cos ε\sin ☉}{\cos ☉}\\[2ex]
\sin δ = \sin ε\sin ☉
\end{cases}&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// TrueEquatorial returns the true geometric position of the Sun as equatorial coordinates.
// 太阳真赤经，真赤纬
func TrueEquatorial(jde float64) (α unit.RA, δ unit.Angle) {
    s, _ := True(base.J2000Century(jde))
    ε := nutation.MeanObliquity(jde)
    ss, cs := s.Sincos()
    sε, cε := ε.Sincos()
    // (25.6, 25.7) p. 165
    α = unit.RAFromRad(math.Atan2(cε*ss, cs))
    δ = unit.Angle(math.Asin(sε * ss))
    return
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;太阳地心视赤经，视赤纬&lt;/p&gt;

&lt;p&gt;$☉$补上黄经章动及光行差得到太阳视黄经$λ$，$ε$补上交角章动$+0.00256\cos Ω$
\begin{cases}
\tan α = \frac {\cos ε\sin λ}{\cos λ}\\[2ex]
\sin δ = \sin ε\sin λ
\end{cases}&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// ApparentEquatorial returns the apparent position of the Sun as equatorial coordinates.
// 太阳视赤经，视赤纬
//
//  α: right ascension in radians
//  δ: declination in radians
func ApparentEquatorial(jde float64) (α unit.RA, δ unit.Angle) {
    T := base.J2000Century(jde)
    λ := ApparentLongitude(T)
    ε := nutation.MeanObliquity(jde)
    sλ, cλ := λ.Sincos()
    // (25.8) p. 165
    ε += unit.AngleFromDeg(.00256).Mul(node(T).Cos())
    sε, cε := ε.Sincos()
    α = unit.RAFromRad(math.Atan2(cε*sλ, cλ))
    δ = unit.Angle(math.Asin(sε * sλ))
    return
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2-高精度太阳黄经&#34;&gt;2. 高精度太阳黄经&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;太阳地心黄经，地心黄纬
先采用VSOP87理论计算地球位置得到地球的日心黄经$L$，黄纬$β$，日地距离$R$
再计算地心黄经$☉ = L + 180°$,黄纬$β=-B$&lt;br /&gt;
令$λ′ = ☉ - 1°.397T - 0°.00031T^2$&lt;br /&gt;
那么
\begin{cases}
Δ☉ = -0&amp;rdquo;.09033\\[2ex]
Δβ = +0&amp;rdquo;.03916(\cos(λ′) - \sin(λ′))
\end{cases}&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// TrueVSOP87 returns the true geometric position of the sun as ecliptic coordinates.
// 根据VSOP87理论计算太阳真黄经，真黄纬，日地距离
//
// Result computed by full VSOP87 theory.  Result is at equator and equinox
// of date in the FK5 frame.  It does not include nutation or aberration.
//
//  s: ecliptic longitude
//  β: ecliptic latitude
//  R: range in AU
func TrueVSOP87(e *pp.V87Planet, jde float64) (s, β unit.Angle, R float64) {
    l, b, r := e.Position(jde) //VSOP87算出的地球的日心黄经，黄纬，日地距离
    s = l + math.Pi
    // FK5 correction.
    λp := base.Horner(base.J2000Century(jde),
        s.Rad(), -1.397*math.Pi/180, -.00031*math.Pi/180)
    sλp, cλp := math.Sincos(λp)
    Δβ := unit.AngleFromSec(.03916).Mul(cλp - sλp)
    // (25.9) p. 166
    s -= unit.AngleFromSec(.09033)
    return s.Mod1(), Δβ - b, r
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;太阳地心视黄经&lt;/p&gt;

&lt;p&gt;与日心视黄经一样，对日心黄经进行章动和光行差修正
章动可以由章动公式求得，光行差可以由以下公式求得$$-20&amp;rdquo;.4898/R$$&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// ApparentVSOP87 returns the apparent position of the sun as ecliptic coordinates.
// 根据VSOP87理论计算太阳视黄经，视黄纬，日地距离，考虑了章动和光行差
// 即真黄经+黄经章动+光行差，真黄纬，日地距离不变
//
// Result computed by VSOP87, at equator and equinox of date in the FK5 frame,
// and includes effects of nutation and aberration.
//
//  λ: ecliptic longitude
//  β: ecliptic latitude
//  R: range in AU
func ApparentVSOP87(e *pp.V87Planet, jde float64) (λ, β unit.Angle, R float64) {
    // note: see duplicated code in ApparentEquatorialVSOP87.
    s, β, R := TrueVSOP87(e, jde)
    Δψ, _ := nutation.Nutation(jde)
    a := aberration(R)
    return s + Δψ + a, β, R
}

// Low precision formula.  The high precision formula is not implemented
// because the low precision formula already gives position results to the
// accuracy given on p. 165.  The high precision formula the represents lots
// of typing with associated chance of typos, and no way to test the result.
// 低精度光行差修正项
func aberration(R float64) unit.Angle {
    // (25.10) p. 167
    return unit.AngleFromSec(-20.4898).Div(R)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;太阳地心视赤经，视赤纬&lt;/p&gt;

&lt;p&gt;算法同低精度太阳地心视赤经，视赤纬一致&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// ApparentEquatorialVSOP87 returns the apparent position of the sun as equatorial coordinates.
// 根据VSOP87理论计算太阳视赤经，视赤纬，日地距离，考虑了章动和光行差
// 即先计算视黄经，视黄纬，此时考虑交角章动，用真黄赤交角转为赤道坐标
//
// Result computed by VSOP87, at equator and equinox of date in the FK5 frame,
// and includes effects of nutation and aberration.
//
//  α: right ascension
//  δ: declination
//  R: range in AU
func ApparentEquatorialVSOP87(e *pp.V87Planet, jde float64) (α unit.RA, δ unit.Angle, R float64) {
    // note: duplicate code from ApparentVSOP87 so we can keep Δε.
    // see also duplicate code in time.E().
    s, β, R := TrueVSOP87(e, jde)
    Δψ, Δε := nutation.Nutation(jde)
    a := aberration(R)
    λ := s + Δψ + a
    ε := nutation.MeanObliquity(jde) + Δε
    sε, cε := ε.Sincos()
    α, δ = coord.EclToEq(λ, β, sε, cε)
    return
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>天文算法22</title>
      <link>https://mooncaker816.github.io/2018/05/25/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9522/</link>
      <pubDate>Fri, 25 May 2018 08:04:20 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/05/25/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9522/</guid>
      <description>&lt;h1 id=&#34;第二十四章-reduction-of-ecliptical-elements-from-one-equinox-to-another-one&#34;&gt;第二十四章 Reduction of Ecliptical Elements from one Equinox to another one&lt;/h1&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;略&#34;&gt;略&lt;/h2&gt;</description>
    </item>
    
    <item>
      <title>天文算法21</title>
      <link>https://mooncaker816.github.io/2018/05/24/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9521/</link>
      <pubDate>Thu, 24 May 2018 20:01:23 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/05/24/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9521/</guid>
      <description>&lt;h1 id=&#34;第二十三章-apparent-place-of-a-star&#34;&gt;第二十三章 Apparent Place of a Star&lt;/h1&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-平-视位置&#34;&gt;1. 平，视位置&lt;/h2&gt;

&lt;p&gt;任意时刻恒星的平位置是：当观测者站在不动的太阳上（严格的说是太阳系的质心）看到它在天球上的视位置，并且，它的位置坐标涉及 Date 黄道平分点（或 Date 赤道平分点）。&lt;/p&gt;

&lt;p&gt;任意时刻恒星的视位置是：当观测者站在移动着的地心看到它在天球上的位置，其视坐标涉及瞬时赤道、黄道及分点&lt;/p&gt;

&lt;h2 id=&#34;2-平转视的影响因素&#34;&gt;2. 平转视的影响因素&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;恒星的自行运动&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第二十一章已经给出计算方法&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;岁差&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第二十一章已经给出计算方法&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;章动&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;赤经章动和赤纬章动&lt;/p&gt;

&lt;p&gt;\begin{cases}
Δα_1=(\cos ε+\sin ε\sin α\tan δ)Δψ-\cos α\tan δΔε\\[2ex]
Δδ_1 = \sin ε\cos αΔψ + \sin αΔε
\end{cases}
其中$Δψ,Δε$可以使用章动章节给出的方法计算，$ε$是平黄赤交角&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Nutation returns corrections due to nutation for equatorial coordinates
// of an object.
//
// Results are invalid for objects very near the celestial poles.
// 章动导致的赤道坐标修正
func Nutation(α unit.RA, δ unit.Angle, jd float64) (Δα1 unit.HourAngle, Δδ1 unit.Angle) {
	ε := nutation.MeanObliquity(jd)
	sε, cε := ε.Sincos()
	Δψ, Δε := nutation.Nutation(jd)
	sα, cα := α.Sincos()
	tδ := δ.Tan()
	// (23.1) p. 151
	Δα1 = unit.HourAngle((cε+sε*sα*tδ)*Δψ.Rad() - cα*tδ*Δε.Rad())
	Δδ1 = Δψ.Mul(sε*cα) + Δε.Mul(sα)
	return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;周年光行差&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;黄道周年光行差：&lt;br /&gt;
$λ,β$是恒星的黄经和黄纬，$K$是光行差常数（20&amp;rdquo;.49552），$Θ$是太阳真黄经(也叫几何黄经)，$e$是地球 轨道的离心率，$π$轨道近日点经度&lt;br /&gt;
\begin{cases}
Θ 可使用后续章节的方法计算\\[2ex]
e = 0.016708617 - 0.000042037T - 0.0000001236T^2\\[2ex]
π = 102°.93735 + 1°.71953T + 0°.00046T^2
\end{cases}
$T$是J2000.0起算的儒略世纪数
则
\begin{cases}
Δλ &amp;amp;= \frac {-K\cos (Θ-λ)+eK\cos (π-λ)}{\cos β}\\[2ex]
Δβ &amp;amp;= -K\sin β(\sin (Θ-λ)-e\sin (π-λ))
\end{cases}&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// κ is the constnt of aberration in radians.
var κ = unit.AngleFromSec(20.49552)

// longitude of perihelian of Earth&#39;s orbit.
// 近日点经度
func perihelion(T float64) unit.Angle {
	return unit.AngleFromDeg(base.Horner(T, 102.93735, 1.71946, .00046))
}
// EclipticAberration returns corrections due to aberration for ecliptic
// coordinates of an object.
// 光行差导致的黄道坐标的修正
func EclipticAberration(λ, β unit.Angle, jd float64) (Δλ, Δβ unit.Angle) {
	T := base.J2000Century(jd)
	s, _ := solar.True(T)      //太阳真黄经
	e := solar.Eccentricity(T) //地球轨道离心率
	π := perihelion(T)         //地球近日点经度
	sβ, cβ := β.Sincos()
	ssλ, csλ := (s - λ).Sincos()
	sπλ, cπλ := (π - λ).Sincos()
	// (23.2) p. 151
	Δλ = κ.Mul((e*cπλ - csλ) / cβ)
	Δβ = -κ.Mul(sβ * (ssλ - e*sπλ))
	return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;赤道周年光行差：
\begin{cases}
Δα_2 &amp;amp;= -K\frac {\cos α\cos Θ\cos ε + \sin α\sin Θ}{\cos δ} + eK\frac {\cos α\cos π\cos ε + \sin α\sin π}{\cos δ}\\[2ex]
Δδ_2 &amp;amp;= -K(\cos Θ\cos ε(\tan ε\cos δ - \sin α\sin δ)+\cos α\sin δ\sin Θ)\\[2ex]
&amp;amp;+eK(\cos π\cos ε(\tan ε\cos δ - \sin α\sin δ)+\cos α\sin δ\sin π)
\end{cases}&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Aberration returns corrections due to aberration for equatorial
// coordinates of an object.
// 光行差导致的赤道坐标的修正
func Aberration(α unit.RA, δ unit.Angle, jd float64) (Δα2 unit.HourAngle, Δδ2 unit.Angle) {
	ε := nutation.MeanObliquity(jd)
	T := base.J2000Century(jd)
	s, _ := solar.True(T)
	e := solar.Eccentricity(T)
	π := perihelion(T)
	sα, cα := α.Sincos()
	sδ, cδ := δ.Sincos()
	ss, cs := s.Sincos()
	sπ, cπ := π.Sincos()
	cε := ε.Cos()
	tε := ε.Tan()
	q1 := cα * cε
	// (23.3) p. 152
	Δα2 = unit.HourAngle(κ.Rad() * (e*(q1*cπ+sα*sπ) - (q1*cs + sα*ss)) / cδ)
	q2 := cε * (tε*cδ - sα*sδ)
	q3 := cα * sδ
	Δδ2 = κ.Mul(e*(cπ*q2+sπ*q3) - (cs*q2 + ss*q3))
	return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ron_Vondrak法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// AberrationRonVondrak uses the Ron-Vondrák expression to compute corrections
// due to aberration for equatorial coordinates of an object.
// RonVondrak方法计算光行差引起的赤道坐标的修正
func AberrationRonVondrak(α unit.RA, δ unit.Angle, jd float64) (Δα unit.HourAngle, Δδ unit.Angle) {
	T := base.J2000Century(jd)
	r := &amp;amp;rv{
		T:  T,
		L2: 3.1761467 + 1021.3285546*T,
		L3: 1.7534703 + 628.3075849*T,
		L4: 6.2034809 + 334.0612431*T,
		L5: 0.5995465 + 52.9690965*T,
		L6: 0.8740168 + 21.3299095*T,
		L7: 5.4812939 + 7.4781599*T,
		L8: 5.3118863 + 3.8133036*T,
		Lp: 3.8103444 + 8399.6847337*T,
		D:  5.1984667 + 7771.3771486*T,
		Mp: 2.3555559 + 8328.6914289*T,
		F:  1.6279052 + 8433.4661601*T,
	}
	var Xp, Yp, Zp float64
	// sum smaller terms first
	for i := 35; i &amp;gt;= 0; i-- {
		x, y, z := rvTerm[i](r)
		Xp += x
		Yp += y
		Zp += z
	}
	sα, cα := α.Sincos()
	sδ, cδ := δ.Sincos()
	// (23.4) p. 156
	Δα = unit.HourAngle((Yp*cα - Xp*sα) / (c * cδ))
	Δδ = unit.Angle(-((Xp*cα+Yp*sα)*sδ - Zp*cδ) / c)
	return
}

const c = 17314463350 // unit is 1e-8 AU / day

type rv struct {
	T, L2, L3, L4, L5, L6, L7, L8, Lp, D, Mp, F float64
}

type rvFunc func(*rv) (x, y, z float64)

var rvTerm = [36]rvFunc{
	func(r *rv) (x, y, z float64) { // 1
		sA, cA := math.Sincos(r.L3)
		return (-1719914-2*r.T)*sA - 25*cA,
			(25-13*r.T)*sA + (1578089+156*r.T)*cA,
			(10+32*r.T)*sA + (684185-358*r.T)*cA
	},
	func(r *rv) (x, y, z float64) { // 2
		sA, cA := math.Sincos(2 * r.L3)
		return (6434+141*r.T)*sA + (28007-107*r.T)*cA,
			(25697-95*r.T)*sA + (-5904-130*r.T)*cA,
			(11141-48*r.T)*sA + (-2559-55*r.T)*cA
	},
	func(r *rv) (x, y, z float64) { // 3
		sA, cA := math.Sincos(r.L5)
		return 715 * sA, 6*sA - 657*cA, -15*sA - 282*cA
	},
	func(r *rv) (x, y, z float64) { // 4
		sA, cA := math.Sincos(r.Lp)
		return 715 * sA, -656 * cA, -285 * cA
	},
	func(r *rv) (x, y, z float64) { // 5
		sA, cA := math.Sincos(3 * r.L3)
		return (486-5*r.T)*sA + (-236-4*r.T)*cA,
			(-216-4*r.T)*sA + (-446+5*r.T)*cA,
			-94*sA - 193*cA
	},
	func(r *rv) (x, y, z float64) { // 6
		sA, cA := math.Sincos(r.L6)
		return 159 * sA, 2*sA - 147*cA, -6*sA - 61*cA
	},
	func(r *rv) (x, y, z float64) { // 7
		cA := math.Cos(r.F)
		return 0, 26 * cA, -59 * cA
	},
	func(r *rv) (x, y, z float64) { // 8
		sA, cA := math.Sincos(r.Lp + r.Mp)
		return 39 * sA, -36 * cA, -16 * cA
	},
	func(r *rv) (x, y, z float64) { // 9
		sA, cA := math.Sincos(2 * r.L5)
		return 33*sA - 10*cA, -9*sA - 30*cA, -5*sA - 13*cA
	},
	func(r *rv) (x, y, z float64) { // 10
		sA, cA := math.Sincos(2*r.L3 - r.L5)
		return 31*sA + cA, sA - 28*cA, -12 * cA
	},
	func(r *rv) (x, y, z float64) { // 11
		sA, cA := math.Sincos(3*r.L3 - 8*r.L4 + 3*r.L5)
		return 8*sA - 28*cA, 25*sA + 8*cA, 11*sA + 3*cA
	},
	func(r *rv) (x, y, z float64) { // 12
		sA, cA := math.Sincos(5*r.L3 - 8*r.L4 + 3*r.L5)
		return 8*sA - 28*cA, -25*sA - 8*cA, -11*sA + -3*cA
	},
	func(r *rv) (x, y, z float64) { // 13
		sA, cA := math.Sincos(2*r.L2 - r.L3)
		return 21 * sA, -19 * cA, -8 * cA
	},
	func(r *rv) (x, y, z float64) { // 14
		sA, cA := math.Sincos(r.L2)
		return -19 * sA, 17 * cA, 8 * cA
	},
	func(r *rv) (x, y, z float64) { // 15
		sA, cA := math.Sincos(r.L7)
		return 17 * sA, -16 * cA, -7 * cA
	},
	func(r *rv) (x, y, z float64) { // 16
		sA, cA := math.Sincos(r.L3 - 2*r.L5)
		return 16 * sA, 15 * cA, sA + 7*cA
	},
	func(r *rv) (x, y, z float64) { // 17
		sA, cA := math.Sincos(r.L8)
		return 16 * sA, sA - 15*cA, -3*sA - 6*cA
	},
	func(r *rv) (x, y, z float64) { // 18
		sA, cA := math.Sincos(r.L3 + r.L5)
		return 11*sA - cA, -sA - 10*cA, -sA - 5*cA
	},
	func(r *rv) (x, y, z float64) { // 19
		sA, cA := math.Sincos(2*r.L2 - 2*r.L3)
		return -11 * cA, -10 * sA, -4 * sA
	},
	func(r *rv) (x, y, z float64) { // 20
		sA, cA := math.Sincos(r.L3 - r.L5)
		return -11*sA - 2*cA, -2*sA + 9*cA, -sA + 4*cA
	},
	func(r *rv) (x, y, z float64) { // 21
		sA, cA := math.Sincos(4 * r.L3)
		return -7*sA - 8*cA, -8*sA + 6*cA, -3*sA + 3*cA
	},
	func(r *rv) (x, y, z float64) { // 22
		sA, cA := math.Sincos(3*r.L3 - 2*r.L5)
		return -10 * sA, 9 * cA, 4 * cA
	},
	func(r *rv) (x, y, z float64) { // 23
		sA, cA := math.Sincos(r.L2 - 2*r.L3)
		return -9 * sA, -9 * cA, -4 * cA
	},
	func(r *rv) (x, y, z float64) { // 24
		sA, cA := math.Sincos(2*r.L2 - 3*r.L3)
		return -9 * sA, -8 * cA, -4 * cA
	},
	func(r *rv) (x, y, z float64) { // 25
		sA, cA := math.Sincos(2 * r.L6)
		return -9 * cA, -8 * sA, -3 * sA
	},
	func(r *rv) (x, y, z float64) { // 26
		sA, cA := math.Sincos(2*r.L2 - 4*r.L3)
		return -9 * cA, 8 * sA, 3 * sA
	},
	func(r *rv) (x, y, z float64) { // 27
		sA, cA := math.Sincos(3*r.L3 - 2*r.L4)
		return 8 * sA, -8 * cA, -3 * cA
	},
	func(r *rv) (x, y, z float64) { // 28
		sA, cA := math.Sincos(r.Lp + 2*r.D - r.Mp)
		return 8 * sA, -7 * cA, -3 * cA
	},
	func(r *rv) (x, y, z float64) { // 29
		sA, cA := math.Sincos(8*r.L2 - 12*r.L3)
		return -4*sA - 7*cA, -6*sA + 4*cA, -3*sA + 2*cA
	},
	func(r *rv) (x, y, z float64) { // 30
		sA, cA := math.Sincos(8*r.L2 - 14*r.L3)
		return -4*sA - 7*cA, 6*sA - 4*cA, 3*sA - 2*cA
	},
	func(r *rv) (x, y, z float64) { // 31
		sA, cA := math.Sincos(2 * r.L4)
		return -6*sA - 5*cA, -4*sA + 5*cA, -2*sA + 2*cA
	},
	func(r *rv) (x, y, z float64) { // 32
		sA, cA := math.Sincos(3*r.L2 - 4*r.L3)
		return -sA - cA, -2*sA - 7*cA, sA - 4*cA
	},
	func(r *rv) (x, y, z float64) { // 33
		sA, cA := math.Sincos(2*r.L3 - 2*r.L5)
		return 4*sA - 6*cA, -5*sA - 4*cA, -2*sA - 2*cA
	},
	func(r *rv) (x, y, z float64) { // 34
		sA, cA := math.Sincos(3*r.L2 - 3*r.L3)
		return -7 * cA, -6 * sA, -3 * sA
	},
	func(r *rv) (x, y, z float64) { // 35
		sA, cA := math.Sincos(2*r.L3 - 2*r.L4)
		return 5*sA - 5*cA, -4*sA - 5*cA, -2*sA - 2*cA
	},
	func(r *rv) (x, y, z float64) { // 36
		sA, cA := math.Sincos(r.Lp - 2*r.D)
		return 5 * sA, -5 * cA, -2 * cA
	},
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;周年视差&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;该算法忽略&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>天文算法20</title>
      <link>https://mooncaker816.github.io/2018/05/23/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9520/</link>
      <pubDate>Wed, 23 May 2018 16:58:54 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/05/23/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9520/</guid>
      <description>&lt;h1 id=&#34;第二十二章-章动和黄赤交角-nutation-and-the-obliquity-of-the-ecliptic&#34;&gt;第二十二章 章动和黄赤交角 Nutation and the Obliquity of the Ecliptic&lt;/h1&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-名词解释&#34;&gt;1. 名词解释&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E7%AB%A0%E5%8B%95&#34; target=&#34;_blank&#34;&gt;章动&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;2-章动的分量&#34;&gt;2. 章动的分量&lt;/h2&gt;

&lt;p&gt;　　章动可以很容易的分解为黄道的水平分量和的垂直分量。黄道上的分量记为$Δψ$，称为黄经章动；它影响了天球上所有天体的经度。黄道的垂直分量记为$Δε$，称为交角章动，它影响了黄赤交角。&lt;/p&gt;

&lt;h2 id=&#34;3-较精确计算章动&#34;&gt;3. 较精确计算章动&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Nutation returns nutation in longitude (Δψ) and nutation in obliquity (Δε)
// for a given JDE.
//
// JDE = UT + ΔT, see package deltat.
//
// Computation is by 1980 IAU theory, with terms &amp;lt; .0003″ neglected.
// 计算 jde 对应的章动
func Nutation(jde float64) (Δψ, Δε unit.Angle) {
	T := base.J2000Century(jde)
	D := base.Horner(T,
		297.85036, 445267.11148, -0.0019142, 1./189474) * math.Pi / 180
	M := base.Horner(T,
		357.52772, 35999.050340, -0.0001603, -1./300000) * math.Pi / 180
	N := base.Horner(T,
		134.96298, 477198.867398, 0.0086972, 1./56250) * math.Pi / 180
	F := base.Horner(T,
		93.27191, 483202.017538, -0.0036825, 1./327270) * math.Pi / 180
	Ω := base.Horner(T,
		125.04452, -1934.136261, 0.0020708, 1./450000) * math.Pi / 180
	// sum in reverse order to accumulate smaller terms first
	var Δψs, Δεs float64
	for i := len(table22A) - 1; i &amp;gt;= 0; i-- {
		row := table22A[i]
		arg := row.d*D + row.m*M + row.n*N + row.f*F + row.ω*Ω
		s, c := math.Sincos(arg)
		Δψs += s * (row.s0 + row.s1*T)
		Δεs += c * (row.c0 + row.c1*T)
	}
	Δψ = unit.AngleFromSec(Δψs * .0001)
	Δε = unit.AngleFromSec(Δεs * .0001)
	return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;4-粗略计算章动&#34;&gt;4. 粗略计算章动&lt;/h2&gt;

&lt;p&gt;Δψ精度为0.5″,Δε精度为0.1″&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// ApproxNutation returns a fast approximation of nutation in longitude (Δψ)
// and nutation in obliquity (Δε) for a given JDE.
//
// Accuracy is 0.5″ in Δψ, 0.1″ in Δε.
// 精度要求为0.5″ in Δψ, 0.1″ in Δε
func ApproxNutation(jde float64) (Δψ, Δε unit.Angle) {
	T := (jde - base.J2000) / 36525
	Ω := (125.04452 - 1934.136261*T) * math.Pi / 180
	L := (280.4665 + 36000.7698*T) * math.Pi / 180
	N := (218.3165 + 481267.8813*T) * math.Pi / 180
	sΩ, cΩ := math.Sincos(Ω)
	s2L, c2L := math.Sincos(2 * L)
	s2N, c2N := math.Sincos(2 * N)
	s2Ω, c2Ω := math.Sincos(2 * Ω)
	Δψ = unit.AngleFromSec(-17.2*sΩ - 1.32*s2L - 0.23*s2N + 0.21*s2Ω)
	Δε = unit.AngleFromSec(9.2*cΩ + 0.57*c2L + 0.1*c2N - 0.09*c2Ω)
	return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;5-黄赤交角&#34;&gt;5. 黄赤交角&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;平黄赤交角$ε_0$：黄道与平赤道的夹角&lt;/p&gt;

&lt;p&gt;$$ε_0 = 23°26&amp;rsquo;21&amp;rdquo;.448 - 46&amp;rdquo;.8150T - 0&amp;rdquo;.00059T^2 + 0&amp;rdquo;.001813T^3$$&lt;/p&gt;

&lt;p&gt;T是J2000.0起算的儒略世纪数&lt;/p&gt;

&lt;p&gt;　　当时间范围很长，上述公式的精度并不令人满意：2000年误差1&amp;rdquo;，4000误差为10&amp;rdquo;。Laskar提供了以下改良的的公式，式中U是J2000.0起算的儒略万年数，即U=T/100：
\begin{align}
ε_0 =&amp;amp; 23°26&amp;rsquo;21&amp;rdquo;.448 - 4680&amp;rdquo;.93U - 1.55U^2 + 1999.25U^3 - 51.38U^4 - 249.67U^5 \\[2ex]
&amp;amp;-39.05U^6 + 7.12U^7 + 27.87U^8 + 5.79U^9 + 2.45U^{10}
\end{align}
　　该表达式的精度是：1000年后误差0&amp;rdquo;.01(公元 1000 到 3000)，10000年后误差数个角秒。&lt;br /&gt;
　　&lt;strong&gt;该表达式适用于|U|&amp;lt;1，即 J2000.0 起算前后各 10000 年的范围内。&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// MeanObliquity returns mean obliquity (ε₀) following the IAU 1980
// polynomial.
//
// Accuracy is 1″ over the range 1000 to 3000 years and 10″ over the range
// 0 to 4000 years.
// 平黄赤交角 - 精度一般，2000年误差 1&amp;quot;，4000年误差为 10&amp;quot;
func MeanObliquity(jde float64) unit.Angle {
    // (22.2) p. 147
    return unit.AngleFromSec(base.Horner(base.J2000Century(jde),
        unit.FromSexaSec(&#39; &#39;, 23, 26, 21.448),
        -46.815,
        -0.00059,
        0.001813))
}

// MeanObliquityLaskar returns mean obliquity (ε₀) following the Laskar
// 1986 polynomial.
//
// Accuracy over the range 1000 to 3000 years is .01″.
//
// Accuracy over the valid date range of -8000 to +12000 years is
// &amp;quot;a few seconds.&amp;quot;
// 平黄赤交角 - 精度较好，1000年后误差0&amp;quot;.01(公元 1000 到 3000)，10000年后误差数个角秒
// 适用范围：J2000.0 起算前后各10000年的范围内。
func MeanObliquityLaskar(jde float64) unit.Angle {
    // (22.3) p. 147
    return unit.AngleFromSec(base.Horner(base.J2000Century(jde)*.01,
        unit.FromSexaSec(&#39; &#39;, 23, 26, 21.448),
        -4680.93,
        -1.55,
        1999.25,
        -51.38,
        -249.67,
        -39.05,
        7.12,
        27.87,
        5.79,
        2.45))
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;真黄赤交角：黄道与真赤道的夹角&lt;/p&gt;

&lt;p&gt;$$ε = ε_0 + Δε$$&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>天文算法19</title>
      <link>https://mooncaker816.github.io/2018/05/23/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9519/</link>
      <pubDate>Wed, 23 May 2018 14:36:29 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/05/23/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9519/</guid>
      <description>&lt;h1 id=&#34;第二十一章-岁差&#34;&gt;第二十一章 岁差&lt;/h1&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-名词解释&#34;&gt;1. 名词解释&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E9%80%B2%E5%8B%95&#34; target=&#34;_blank&#34;&gt;Precession&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;2-赤道坐标岁差的近似计算&#34;&gt;2. 赤道坐标岁差的近似计算&lt;/h2&gt;

&lt;p&gt;　　当两个历元相差不远，并且如果星体没有太靠近天极，下面的公式可以用来计算在这两个历元之间的，相对于起始历元的截至历元的年度平均岁差：$$Δα = m + n\sin α\tan δ$$
其中$m = 3s.07496 + 0s.00186T, n = 1s.33621 - 0s.00057T$
$$Δδ = n*cos(α)$$
其中$n = 20&amp;rdquo;.0431 - 0&amp;rdquo;.0085T$&lt;br /&gt;
T是J2000.0起算的儒略世纪数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// ApproxAnnualPrecession returns approximate annual precision in right
// ascension and declination.
//
// The two epochs should be within a few hundred years.
// The declinations should not be too close to the poles.
// 近似计算截至历元相对于起始历元的年度平均岁差，俩历元不能相差太远，且天体不能靠近天极
func ApproxAnnualPrecession(eq *coord.Equatorial, epochFrom, epochTo float64) (Δα unit.HourAngle, Δδ unit.Angle) {
	m, nα, nδ := mn(epochFrom, epochTo)
	sα, cα := eq.RA.Sincos()
	// (21.1) p. 132
	Δα = m + nα.Mul(sα*eq.Dec.Tan())
	Δδ = nδ.Mul(cα)
	return
}

// mn as separate function for testing purposes
// 计算截至历元相对于起始历元的平均年度岁差要用的变量 m,n
func mn(epochFrom, epochTo float64) (m, nα unit.HourAngle, nδ unit.Angle) {
	T := (epochTo - epochFrom) * .01
	m = unit.HourAngleFromSec(3.07496 + 0.00186*T)
	nα = unit.HourAngleFromSec(1.33621 - 0.00057*T)
	nδ = unit.AngleFromSec(20.0431 - 0.0085*T)
	return
}

// ApproxPosition uses ApproxAnnualPrecession to compute a simple and quick
// precession while still considering proper motion.
//
// Both eqFrom and eqTo must be non-nil, although they may point to the same
// struct.  EqTo is returned for convenience.
// 两历元之间坐标的换算，考虑岁差和自行运动（mα，mδ）
func ApproxPosition(eqFrom, eqTo *coord.Equatorial, epochFrom, epochTo float64, mα unit.HourAngle, mδ unit.Angle) *coord.Equatorial {
	Δα, Δδ := ApproxAnnualPrecession(eqFrom, epochFrom, epochTo)
	dy := epochTo - epochFrom
	eqTo.RA = eqFrom.RA.Add((Δα + mα).Mul(dy))
	eqTo.Dec = eqFrom.Dec + (Δδ + mδ).Mul(dy)
	return eqTo
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;3-赤道坐标岁差的精确计算&#34;&gt;3. 赤道坐标岁差的精确计算&lt;/h2&gt;

&lt;p&gt;设T是J2000.0起算的儒略世纪数，t是某一起始历元到终止历元之间的时间差，单位也是儒略世纪数。
\begin{cases}
ζ = ( 2306&amp;rdquo;.2181 + 1&amp;rdquo;.39656T - 0&amp;rdquo;.000139T^2)t + (0&amp;rdquo;.30188 - 0&amp;rdquo;.000344T)t^2 + 0&amp;rdquo;.017998t^3\\[2ex]
z = ( 2306&amp;rdquo;.2181 + 1&amp;rdquo;.39656T - 0&amp;rdquo;.000139T^2)t + (1&amp;rdquo;.09468 + 0&amp;rdquo;.000066T)t^2 + 0&amp;rdquo;.018203t^3\\[2ex]
θ = ( 2004&amp;rdquo;.3109 - 0&amp;rdquo;.85330T - 0&amp;rdquo;.000217T^2)t - (0&amp;rdquo;.42665 + 0&amp;rdquo;.000217T)t^2 - 0&amp;rdquo;.041833t^3
\end{cases}
当T=0时，即起始历元正好就是J2000.0,
\begin{cases}
ζ = 2306&amp;rdquo;.2181t + 0&amp;rdquo;.30188t^2 + 0&amp;rdquo;.017998t^3\\[2ex]
z = 2306&amp;rdquo;.2181t + 1&amp;rdquo;.09468t^2 + 0&amp;rdquo;.018203t^3\\[2ex]
θ = 2004&amp;rdquo;.3109t - 0&amp;rdquo;.42665t^2 - 0&amp;rdquo;.041833t^3
\end{cases}
再计算
\begin{cases}
A &amp;amp;= \cos δ_0\sin(α_0 + ζ)\\[2ex]
B &amp;amp;= \cos θ\cos δ_0\cos(α_0 +ζ) - \sin θ\sin δ_0\\[2ex]
C &amp;amp;= \sin θ\cos δ_0\cos(α_0 +ζ) + \cos θ\sin δ_0
\end{cases}
则$$\tan(α-z) = A/B,\sin δ = C$$
如果星体接近天极，使用$\cos δ = \sqrt {A^2+B^2}$代替$\sin δ = C$&lt;br /&gt;
$α,δ$即为经过岁差转换后的赤道坐标&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Precessor represents precession from one epoch to another.
//
// Construct with NewPrecessor, then call method Precess.
// After construction, Precess may be called multiple times to precess
// different coordinates with the same initial and final epochs.
// 计算赤道坐标精确岁差要用到的变量
type Precessor struct {
	ζ      unit.RA
	z      unit.Angle
	sθ, cθ float64
}

const d = math.Pi / 180
const s = d / 3600

// Package variables allow these slices to be reused.  (As composite
// literals inside of NewPrecessor they would be reallocated on every
// function call.)
var (
	// coefficients from (21.2) p. 134
	ζT = []float64{2306.2181 * s, 1.39656 * s, -0.000139 * s}
	zT = []float64{2306.2181 * s, 1.39656 * s, -0.000139 * s}
	θT = []float64{2004.3109 * s, -0.8533 * s, -0.000217 * s}

	// coefficients from (21.3) p. 134
	ζt = []float64{2306.2181 * s, 0.30188 * s, 0.017998 * s}
	zt = []float64{2306.2181 * s, 1.09468 * s, 0.018203 * s}
	θt = []float64{2004.3109 * s, -0.42665 * s, -0.041833 * s}
)

// NewPrecessor constructs a Precessor object and initializes it to precess
// coordinates from epochFrom to epochTo.
// 构造赤道坐标岁差计算要素
func NewPrecessor(epochFrom, epochTo float64) *Precessor {
	// (21.2) p. 134
	ζCoeff := ζt
	zCoeff := zt
	θCoeff := θt
	if epochFrom != 2000 {
		T := (epochFrom - 2000) * .01
		ζCoeff = []float64{
			base.Horner(T, ζT...),
			0.30188*s - 0.000344*s*T,
			0.017998 * s}
		zCoeff = []float64{
			base.Horner(T, zT...),
			1.09468*s + 0.000066*s*T,
			0.018203 * s}
		θCoeff = []float64{
			base.Horner(T, θT...),
			-0.42665*s - 0.000217*s*T,
			-0.041833 * s}
	}
	t := (epochTo - epochFrom) * .01
	p := &amp;amp;Precessor{
		ζ: unit.RA(base.Horner(t, ζCoeff...) * t),
		z: unit.Angle(base.Horner(t, zCoeff...) * t),
	}
	θ := base.Horner(t, θCoeff...) * t
	p.sθ, p.cθ = math.Sincos(θ)
	return p
}

// Precess precesses coordinates eqFrom, leaving result in eqTo.
//
// The same struct may be used for eqFrom and eqTo.
// EqTo is returned for convenience.
// 赤道坐标的岁差转换计算
func (p *Precessor) Precess(eqFrom, eqTo *coord.Equatorial) *coord.Equatorial {
	// (21.4) p. 134
	sδ, cδ := eqFrom.Dec.Sincos()
	sαζ, cαζ := (eqFrom.RA + p.ζ).Sincos()
	A := cδ * sαζ
	B := p.cθ*cδ*cαζ - p.sθ*sδ
	C := p.sθ*cδ*cαζ + p.cθ*sδ
	eqTo.RA = unit.RAFromRad(math.Atan2(A, B) + p.z.Rad())
	if math.Abs(C) &amp;lt; base.CosSmallAngle {
		eqTo.Dec = unit.Angle(math.Asin(C))
	} else {
		eqTo.Dec = unit.Angle(math.Acos(math.Hypot(A, B))) // near pole
		if C &amp;lt; 0 {
			eqTo.Dec = -eqTo.Dec
		}
	}
	return eqTo
}

// Position precesses equatorial coordinates from one epoch to another,
// including proper motions.
//
// If proper motions are not to be considered or are not applicable, pass 0, 0
// for mα, mδ
//
// Both eqFrom and eqTo must be non-nil, although they may point to the same
// struct.  EqTo is returned for convenience.
// 考虑自行运动的赤道坐标的转换
func Position(eqFrom, eqTo *coord.Equatorial, epochFrom, epochTo float64, mα unit.HourAngle, mδ unit.Angle) *coord.Equatorial {
	p := NewPrecessor(epochFrom, epochTo)
	t := epochTo - epochFrom
	eqTo.RA = unit.RAFromRad(eqFrom.RA.Rad() + mα.Rad()*t)
	eqTo.Dec = eqFrom.Dec + mδ*unit.Angle(t)
	return p.Precess(eqTo, eqTo)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;4-黄道坐标岁差的精确计算&#34;&gt;4. 黄道坐标岁差的精确计算&lt;/h2&gt;

&lt;p&gt;同上，我们先计算
\begin{cases}
η = (47&amp;rdquo;.0029 - 0&amp;rdquo;.06603T + 0&amp;rdquo;.000598T^2)t + (-0&amp;rdquo;.03302 + 0&amp;rdquo;.000598T)t^2 +0&amp;rdquo;.000060t^3\\[2ex]
П = 174°.876384 + 3289&amp;rdquo;.4789T + 0&amp;rdquo;.60622T^2 (869&amp;rdquo;.8089 + 0&amp;rdquo;.50491T)t + 0&amp;rdquo;.03536t^2\\[2ex]
p = (5029&amp;rdquo;.0966 + 2&amp;rdquo;.22226T - 0&amp;rdquo;.000042T^2)t + (1&amp;rdquo;.11113 - 0&amp;rdquo;.000042T)t^2 -0&amp;rdquo;.000006t^3
\end{cases}
当$T=0$时，
\begin{cases}
η = 47&amp;rdquo;.0029t -0&amp;rdquo;.03302t^2 +0&amp;rdquo;.000060t^3\\[2ex]
П = 174°.876384 -869&amp;rdquo;.8089t +0&amp;rdquo;.03536t^2\\[2ex]
p = 5029&amp;rdquo;.0966t +1&amp;rdquo;.11113t^2 -0&amp;rdquo;.000006t^3
\end{cases}
再计算
\begin{cases}
A′ &amp;amp;= \cos η\cos β_0\sin(П-λ_0) - \sin η\sin β_0\\[2ex]
B′ &amp;amp;= \cos β_0\cos(П-λ_0)\\[2ex]
C′ &amp;amp;= \cos η\sin β_0 + \sin η\cos β_0\sin(П-λ_0)
\end{cases}
则$$\tan(p +П-λ) = A′/B′,\sin β = C′$$
如果星体接近天极，使用$\cos β = \sqrt {A′^2+B′^2}$代替$\sin β = C′$&lt;br /&gt;
$λ,β$即为经过岁差转换后的黄道坐标&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// EclipticPrecessor represents precession from one epoch to another.
//
// Construct with NewEclipticPrecessor, then call method Precess.
// After construction, Precess may be called multiple times to precess
// different coordinates with the same initial and final epochs.
// 计算黄道坐标精确岁差要用到的变量
type EclipticPrecessor struct {
	sη, cη float64
	π, p   unit.Angle
}

var (
	// coefficients from (21.5) p. 136, scaled to radians
	ηT = []float64{47.0029 * s, -0.06603 * s, 0.000598 * s}
	πT = []float64{174.876384 * d, 3289.4789 * s, 0.60622 * s}
	pT = []float64{5029.0966 * s, 2.22226 * s, -0.000042 * s}

	// coefficients from (21.6) p. 136, scaled to radians
	ηt = []float64{47.0029 * s, -0.03302 * s, 0.000060 * s}
	πt = []float64{174.876384 * d, -869.8089 * s, 0.03536 * s}
	pt = []float64{5029.0966 * s, 1.11113 * s, -0.000006 * s}
)

// NewEclipticPrecessor constructs an EclipticPrecessor object and initializes
// it to precess coordinates from epochFrom to epochTo.
// 构造黄道坐标岁差计算要素
func NewEclipticPrecessor(epochFrom, epochTo float64) *EclipticPrecessor {
	// (21.5) p. 136
	ηCoeff := ηt
	πCoeff := πt
	pCoeff := pt
	if epochFrom != 2000 {
		T := (epochFrom - 2000) * .01
		ηCoeff = []float64{
			base.Horner(T, ηT...),
			-0.03302*s + 0.000598*s*T,
			0.000060 * s}
		πCoeff = []float64{
			base.Horner(T, πT...),
			-869.8089*s - 0.50491*s*T,
			0.03536 * s}
		pCoeff = []float64{
			base.Horner(T, pT...),
			1.11113*s - 0.000042*s*T,
			-0.000006 * s}
	}
	t := (epochTo - epochFrom) * .01
	p := &amp;amp;EclipticPrecessor{
		π: unit.Angle(base.Horner(t, πCoeff...)),
		p: unit.Angle(base.Horner(t, pCoeff...) * t),
	}
	η := unit.Angle(base.Horner(t, ηCoeff...) * t)
	p.sη, p.cη = η.Sincos()
	return p
}

// EclipticPrecess precesses coordinates eclFrom, leaving result in eclTo.
//
// The same struct may be used for eclFrom and eclTo.
// EclTo is returned for convenience.
// 黄道坐标的岁差转换
func (p *EclipticPrecessor) Precess(eclFrom, eclTo *coord.Ecliptic) *coord.Ecliptic {
	// (21.7) p. 137
	sβ, cβ := eclFrom.Lat.Sincos()
	sd, cd := (p.π - eclFrom.Lon).Sincos()
	A := p.cη*cβ*sd - p.sη*sβ
	B := cβ * cd
	C := p.cη*sβ + p.sη*cβ*sd
	eclTo.Lon = p.p + p.π - unit.Angle(math.Atan2(A, B))
	if math.Abs(C) &amp;lt; base.CosSmallAngle {
		eclTo.Lat = unit.Angle(math.Asin(C))
	} else {
		eclTo.Lat = unit.Angle(math.Acos(math.Hypot(A, B))) // near pole
		if C &amp;lt; 0 {
			eclTo.Lat = -eclTo.Lat
		}
	}
	return eclTo
}

// ReduceElements reduces orbital elements of a solar system body from one
// equinox to another.
//
// This function is described in chapter 24, but is located in this
// package so it can be a method of EclipticPrecessor.
func (p *EclipticPrecessor) ReduceElements(eFrom, eTo *elementequinox.Elements) *elementequinox.Elements {
	ψ := p.π + p.p
	si, ci := eFrom.Inc.Sincos()
	snp, cnp := (eFrom.Node - p.π).Sincos()
	// (24.1) p. 159
	eTo.Inc = unit.Angle(math.Acos(ci*p.cη + si*p.sη*cnp))
	// (24.2) p. 159
	eTo.Node = ψ +
		unit.Angle(math.Atan2(si*snp, p.cη*si*cnp-p.sη*ci))
	// (24.3) p. 160
	eTo.Peri = eFrom.Peri +
		unit.Angle(math.Atan2(-p.sη*snp, si*p.cη-ci*p.sη*cnp))
	return eTo
}

// EclipticPosition precesses ecliptic coordinates from one epoch to another,
// including proper motions.
//
// While eclFrom is given as ecliptic coordinates, proper motions mα, mδ are
// still expected to be equatorial.  If proper motions are not to be considered
// or are not applicable, pass 0, 0.
//
// Both eclFrom and eclTo must be non-nil, although they may point to the same
// struct.  EclTo is returned for convenience.
// 考虑自行运动的黄道坐标的转换，
// 注意此处的mα，mδ是赤道坐标系中的数值，要先转换为黄道坐标mλ, mβ
func EclipticPosition(eclFrom, eclTo *coord.Ecliptic, epochFrom, epochTo float64, mα unit.HourAngle, mδ unit.Angle) *coord.Ecliptic {
	p := NewEclipticPrecessor(epochFrom, epochTo)
	*eclTo = *eclFrom
	if mα != 0 || mδ != 0 {
		mλ, mβ := eqProperMotionToEcl(mα, mδ, epochFrom, eclFrom)
		t := epochTo - epochFrom
		eclTo.Lon += mλ.Mul(t)
		eclTo.Lat += mβ.Mul(t)
	}
	return p.Precess(eclTo, eclTo)
}

// 将自行运动由赤道坐标转黄道坐标
func eqProperMotionToEcl(mα unit.HourAngle, mδ unit.Angle, epoch float64, pos *coord.Ecliptic) (mλ, mβ unit.Angle) {
	ε := nutation.MeanObliquity(base.JulianYearToJDE(epoch))
	sε, cε := ε.Sincos()
	α, δ := coord.EclToEq(pos.Lon, pos.Lat, sε, cε)
	sα, cα := α.Sincos()
	sδ, cδ := δ.Sincos()
	cβ := pos.Lat.Cos()
	mλ = (mδ.Mul(sε*cα) + unit.Angle(mα).Mul(cδ*(cε*cδ+sε*sδ*sα))).Div(cβ * cβ)
	mβ = (mδ.Mul(cε*cδ+sε*sδ*sα) - unit.Angle(mα).Mul(sε*cα*cδ)).Div(cβ)
	return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;5-天体自行运动导致的坐标的转换&#34;&gt;5. 天体自行运动导致的坐标的转换&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// ProperMotion3D takes the 3D equatorial coordinates of an object
// at one epoch and computes its coordinates at a new epoch, considering
// proper motion and radial velocity.
//
// Radial distance (r) must be in parsecs, radial velocitiy (mr) in
// parsecs per year.
//
// Both eqFrom and eqTo must be non-nil, although they may point to the same
// struct.  EqTo is returned for convenience.
// 自行运动导致的赤道坐标变化的精确计算(不在当成常量乘以时间间隔)
func ProperMotion3D(eqFrom, eqTo *coord.Equatorial, epochFrom, epochTo, r, mr float64, mα unit.HourAngle, mδ unit.Angle) *coord.Equatorial {
	sα, cα := eqFrom.RA.Sincos()
	sδ, cδ := eqFrom.Dec.Sincos()
	x := r * cδ * cα
	y := r * cδ * sα
	z := r * sδ
	mrr := mr / r
	zmδ := z * mδ.Rad()
	mx := x*mrr - zmδ*cα - y*mα.Rad()
	my := y*mrr - zmδ*sα + x*mα.Rad()
	mz := z*mrr + r*mδ.Rad()*cδ
	t := epochTo - epochFrom
	xp := x + t*mx
	yp := y + t*my
	zp := z + t*mz
	eqTo.RA = unit.RAFromRad(math.Atan2(yp, xp))
	eqTo.Dec = unit.Angle(math.Atan2(zp, math.Hypot(xp, yp)))
	return eqTo
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>天文算法18</title>
      <link>https://mooncaker816.github.io/2018/05/23/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9518/</link>
      <pubDate>Wed, 23 May 2018 09:01:52 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/05/23/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9518/</guid>
      <description>&lt;h1 id=&#34;第二十章-smallest-circle-containing-three-celestial-bodies&#34;&gt;第二十章 Smallest Circle containing three Celestial Bodies&lt;/h1&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-问题&#34;&gt;1. 问题&lt;/h2&gt;

&lt;p&gt;设三点为A,B,C,对应三边为a,b,c,其中a为最长边，&lt;br /&gt;
当$a&amp;gt;\sqrt {b^2+c^2}$,则包含这三点的最小圆直径为a，&lt;br /&gt;
当$a&amp;lt;\sqrt {b^2+c^2}$,则包含这三点的最小圆直径为$$\frac {2abc}{\sqrt {(a+b+c)(a+b-c)(b+c-a)(a+c-b)}}$$&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://baike.baidu.com/item/外接圆半径公式/14818938?fr=aladdin&#34; target=&#34;_blank&#34;&gt;证明&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;给定三个天体的坐标，求最小圆直径。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Smallest finds the smallest circle containing three points.
//
// Arguments should represent coordinates in right ascension and declination
// or longitude and latitude.  Result Δ is the diameter of the circle, typeI
// is true if solution is of type I.
//
//	type I   Two points on circle, one interior.
//	type II  All three points on circle.
// 根据三点坐标，求最小圆直径
func Smallest(r1, d1, r2, d2, r3, d3 unit.Angle) (Δ unit.Angle, typeI bool) {
	// Using haversine formula, but reimplementing SepHav here to reuse
	// the computed cosines.
	cd1 := d1.Cos()
	cd2 := d2.Cos()
	cd3 := d3.Cos()
	a := 2 * math.Asin(math.Sqrt(base.Hav(d2-d1)+cd1*cd2*base.Hav(r2-r1)))
	b := 2 * math.Asin(math.Sqrt(base.Hav(d3-d2)+cd2*cd3*base.Hav(r3-r2)))
	c := 2 * math.Asin(math.Sqrt(base.Hav(d1-d3)+cd3*cd1*base.Hav(r1-r3)))
	if b &amp;gt; a {
		a, b = b, a
	}
	if c &amp;gt; a {
		a, c = c, a
	}
	if a*a &amp;gt;= b*b+c*c {
		return unit.Angle(a), true
	}
	// (20.1) p. 128
	return unit.Angle(2 * a * b * c /
		math.Sqrt((a+b+c)*(a+b-c)*(b+c-a)*(a+c-b))), false
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>天文算法17</title>
      <link>https://mooncaker816.github.io/2018/05/22/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9517/</link>
      <pubDate>Tue, 22 May 2018 10:15:11 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/05/22/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9517/</guid>
      <description>&lt;h1 id=&#34;第十九章-bodies-in-straight-line&#34;&gt;第十九章 Bodies in Straight Line&lt;/h1&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-定义&#34;&gt;1. 定义&lt;/h2&gt;

&lt;p&gt;　　当天体位于同一个天球大圆时，我们称之为天体处在同一&amp;rdquo;直线&amp;rdquo;上。&lt;br /&gt;
　　假设有三个天体,赤道系坐标分别为$(α_1,δ_1),(α_2,δ_2),(α_3,δ_3)$，当它们&amp;rdquo;共线&amp;rdquo;时，有：$$\tan δ_1\sin (α_2-α_3)+\tan δ_2\sin (α_3-α_1)+\tan δ_3\sin (α_1-α_2)=0$$
　　上述公式对黄道坐标系同样适用。&lt;/p&gt;

&lt;p&gt;　　利用该公式，我们就可以插值求得共线的时间点&lt;/p&gt;

&lt;h2 id=&#34;2-计算行星与两个恒星共线的时间点&#34;&gt;2. 计算行星与两个恒星共线的时间点&lt;/h2&gt;

&lt;p&gt;　　对于恒星，我们可以认为在一定观测时间范围内是静止的。所以在进行插值计算时，应该当做常数。如$(α_1,δ_1),(α_2,δ_2)$为恒星坐标，则插值时保持不变。&lt;br /&gt;
　　对于运动的行星，考虑一段时间范围内的坐标，进行插值并求零点。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Time computes the time at which a moving body is on a straight line (great
// circle) between two fixed points, such as stars.
//
// Coordinates may be right ascensions and declinations or longitudes and
// latitudes.  Fixed points are r1, d1, r2, d2.  Moving body is an ephemeris
// of 5 rows, r3, d3, starting at time t1 and ending at time t5.  Time scale
// is arbitrary.
//
// Result is time of alignment.
// 计算一个运动的天体和另外两个在观测时间内默认为不动的天体在一条直线上的时间点
func Time(r1, d1, r2, d2 unit.Angle, r3, d3 []unit.Angle, t1, t5 float64) (float64, error) {
	if len(r3) != 5 || len(d3) != 5 {
		return 0, errors.New(&amp;quot;r3, d3 must be length 5&amp;quot;)
	}
	gc := make([]float64, 5)
	for i, r3i := range r3 {
		// (19.1) p. 121
		gc[i] = d1.Tan()*(r2-r3i).Sin() +
			d2.Tan()*(r3i-r1).Sin() +
			d3[i].Tan()*(r1-r2).Sin()
	}
	l5, err := interp.NewLen5(t1, t5, gc)
	if err != nil {
		return 0, err
	}
	return l5.Zero(false)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;3-计算3点-近似共线-时的球面角和离共线大圆的角距离&#34;&gt;3. 计算3点&amp;rdquo;近似共线&amp;rdquo;时的球面角和离共线大圆的角距离&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://mooncaker816.github.io/img/line.png&#34; alt=&#34;&#34; /&gt;
　　如上图，$S_1,S_2,S_3$为三个天体，此时它们几乎&amp;rdquo;共线&amp;rdquo;,$C_1$为球面角$\angle PS_2S_1$，$C_2$为球面角$\angle PS_2S_3$，我们所求的就是球面角$\angle S_1S_2S_3$以及$S_2$与经过$S_1,S_3$的大圆之间的角距离（可以看作离共线还差多少度）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Meeus 计算三天体球面角$\angle S_1S_2S_3$&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;\begin{cases}
\tan C_1 &amp;amp;= \frac {\sin (α_2-α_1)}{\cos δ_2\tan δ_1-\sin δ_2\cos (α_2-α_1)}\\[2ex]
\tan C_2 &amp;amp;= \frac {\sin (α_3-α_2)}{\cos δ_2\tan δ_3-\sin δ_2\cos (α_3-α_2)}
\end{cases}
　　$C_1 + C_2$即为所求&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Angle returns the angle between great circles defined by three points.
//
// Coordinates may be right ascensions and declinations or longitudes and
// latitudes.  If r1, d1, r2, d2 defines one line and r2, d2, r3, d3 defines
// another, the result is the angle between the two lines.
//
// Algorithm by Meeus.
// 计算第一点第二点经过的大圆和第二点第三点经过的大圆之间的角度
func Angle(r1, d1, r2, d2, r3, d3 unit.Angle) unit.Angle {
	sd2, cd2 := d2.Sincos()
	sr21, cr21 := (r2 - r1).Sincos()
	sr32, cr32 := (r3 - r2).Sincos()
	C1 := math.Atan2(sr21, cd2*d1.Tan()-sd2*cr21)
	C2 := math.Atan2(sr32, cd2*d3.Tan()-sd2*cr32)
	return unit.Angle(C1 + C2)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Meeus 计算$S_2$与经过$S_1,S_3$的大圆之间的角距离&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　先计算：
\begin{cases}
X_1 &amp;amp;= \cos δ_1\cos α_1\\[2ex]
Y_1 &amp;amp;= \cos δ_1\sin α_1\\[2ex]
Z_1 &amp;amp;= \sin δ_1
\end{cases}
\begin{cases}
X_2 &amp;amp;= \cos δ_2\cos α_2\\[2ex]
Y_2 &amp;amp;= \cos δ_2\sin α_2\\[2ex]
Z_2 &amp;amp;= \sin δ_2
\end{cases}
\begin{cases}
A &amp;amp;= Y_1Z_2-Z_1Y_2\\[2ex]
B &amp;amp;= Z_1X_2-X_1Z_2\\[2ex]
C &amp;amp;= X_1Y_2-Y_1X_2
\end{cases}
$$m = \tan α_0, n = \frac {\tan δ_0}{\cos α_0}$$
　　则，$$\sin ω = \frac {A+Bm+Cn}{\sqrt {A^2+B^2+C^2}\sqrt{1+m^2+n^2}}$$
　　ω即为所求&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Error returns an error angle of three nearly co-linear points.
//
// For the line defined by r1, d1, r2, d2, the result is the anglular distance
// between that line and r0, d0.
//
// Algorithm by Meeus.
// 计算一点到由另外两点组成的大圆之间的角距离
func Error(r1, d1, r2, d2, r0, d0 unit.Angle) unit.Angle {
	sr1, cr1 := r1.Sincos()
	sd1, cd1 := d1.Sincos()
	sr2, cr2 := r2.Sincos()
	sd2, cd2 := d2.Sincos()
	X1 := cd1 * cr1
	X2 := cd2 * cr2
	Y1 := cd1 * sr1
	Y2 := cd2 * sr2
	Z1 := sd1
	Z2 := sd2
	A := Y1*Z2 - Z1*Y2
	B := Z1*X2 - X1*Z2
	C := X1*Y2 - Y1*X2
	m := r0.Tan()
	n := d0.Tan() / r0.Cos()
	return unit.Angle(math.Asin((A + B*m + C*n) /
		(math.Sqrt(A*A+B*B+C*C) * math.Sqrt(1+m*m+n*n))))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Pessens 同时计算上述两个量&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;\begin{cases}
a_1 &amp;amp;= \cos δ_1\cos α_1\\[2ex]
a_2 &amp;amp;= \cos δ_2\cos α_2\\[2ex]
a_3 &amp;amp;= \cos δ_3\cos α_3\\[2ex]
\end{cases}
\begin{cases}
b_1 &amp;amp;= \cos δ_1\sin α_1\\[2ex]
b_2 &amp;amp;= \cos δ_2\sin α_2\\[2ex]
b_3 &amp;amp;= \cos δ_3\sin α_3\\[2ex]
\end{cases}
\begin{cases}
c_1 &amp;amp;= \sin δ_1\\[2ex]
c_2 &amp;amp;= \sin δ_2\\[2ex]
c_3 &amp;amp;= \sin δ_3\\[2ex]
\end{cases}
\begin{cases}
l_1 &amp;amp;= b_1c_2-b_2c_1\\[2ex]
l_2 &amp;amp;= b_2c_3-b_3c_2\\[2ex]
l_3 &amp;amp;= b_1c_3-b_3c_1\\[2ex]
\end{cases}
\begin{cases}
m_1 &amp;amp;= c_1a_2-c_2a_1\\[2ex]
m_2 &amp;amp;= c_2a_3-c_3a_2\\[2ex]
m_3 &amp;amp;= c_1a_3-c_3a_1\\[2ex]
\end{cases}
\begin{cases}
n_1 &amp;amp;= a_1b_2-a_2b_1\\[2ex]
n_2 &amp;amp;= a_2b_3-a_3b_2\\[2ex]
n_3 &amp;amp;= a_1b_3-a_3b_1\\[2ex]
\end{cases}
　　则有：
\begin{cases}
\cos ψ &amp;amp;= \frac {l_1l_2+m_1m_2+n_1n_2}{\sqrt {l_1^2+m_1^2+n_1^2}\sqrt{l_2^2+m_2^2+n_2^2}}\\[2ex]
\sin ω &amp;amp;= \frac {a_2l_3+b_2m_3+c_2n_3}{\sqrt {a_2^2+b_2^2+c_2^2}\sqrt {l_3^2+m_3^2+n_3^2}}
\end{cases}
　　ψ，ω即为所求。ψ可能与 Meeus 方法求解的值互余180°。（平面的夹角有两个，互余180°）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// AngleError returns both an angle as in the function Angle, and an error
// as in the function Error.
//
// The algorithm is by B. Pessens.
// Angle和 Error 的合体版
// Angle 的值可能和之前 Angle 中计算的值互余180°（想象一下两个面的夹角）
func AngleError(r1, d1, r2, d2, r3, d3 unit.Angle) (ψ, ω unit.Angle) {
	sr1, cr1 := r1.Sincos()
	sd1, cd1 := d1.Sincos()
	sr2, cr2 := r2.Sincos()
	sd2, cd2 := d2.Sincos()
	sr3, cr3 := r3.Sincos()
	sd3, cd3 := d3.Sincos()
	a1 := cd1 * cr1
	a2 := cd2 * cr2
	a3 := cd3 * cr3
	b1 := cd1 * sr1
	b2 := cd2 * sr2
	b3 := cd3 * sr3
	c1 := sd1
	c2 := sd2
	c3 := sd3
	l1 := b1*c2 - b2*c1
	l2 := b2*c3 - b3*c2
	l3 := b1*c3 - b3*c1
	m1 := c1*a2 - c2*a1
	m2 := c2*a3 - c3*a2
	m3 := c1*a3 - c3*a1
	n1 := a1*b2 - a2*b1
	n2 := a2*b3 - a3*b2
	n3 := a1*b3 - a3*b1
	ψ = unit.Angle(math.Acos((l1*l2 + m1*m2 + n1*n2) /
		(math.Sqrt(l1*l1+m1*m1+n1*n1) * math.Sqrt(l2*l2+m2*m2+n2*n2))))
	ω = unit.Angle(math.Asin((a2*l3 + b2*m3 + c2*n3) /
		(math.Sqrt(a2*a2+b2*b2+c2*c2) * math.Sqrt(l3*l3+m3*m3+n3*n3))))
	return
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
  </channel>
</rss>
