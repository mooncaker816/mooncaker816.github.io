<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Mooncaker816 on Mooncaker816</title>
    <link>https://mooncaker816.github.io/</link>
    <description>Recent content in Mooncaker816 on Mooncaker816</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <copyright>&amp;copy; 2018-Present</copyright>
    <lastBuildDate>Wed, 20 Apr 2016 00:00:00 +0800</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Linux Centos 命令之 cp,rm,mv</title>
      <link>https://mooncaker816.github.io/2018/04/21/linux-centos-%E5%91%BD%E4%BB%A4%E4%B9%8B-cprmmv/</link>
      <pubDate>Sat, 21 Apr 2018 13:50:00 +0000</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/04/21/linux-centos-%E5%91%BD%E4%BB%A4%E4%B9%8B-cprmmv/</guid>
      <description>&lt;h2 id=&#34;cp-copy-拷贝目录-文件&#34;&gt;cp - copy 拷贝目录，文件&lt;/h2&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;usage&#34;&gt;Usage：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Usage: cp [OPTION]... [-T] SOURCE DEST
  or:  cp [OPTION]... SOURCE... DIRECTORY
  or:  cp [OPTION]... -t DIRECTORY SOURCE...
Copy SOURCE to DEST, or multiple SOURCE(s) to DIRECTORY.

Mandatory arguments to long options are mandatory for short options too.
  -a, --archive                same as -dR --preserve=all
      --attributes-only        don&#39;t copy the file data, just the attributes
      --backup[=CONTROL]       make a backup of each existing destination file
  -b                           like --backup but does not accept an argument
      --copy-contents          copy contents of special files when recursive
  -d                           same as --no-dereference --preserve=links
  -f, --force                  if an existing destination file cannot be
                                 opened, remove it and try again (this option
                                 is ignored when the -n option is also used)
  -i, --interactive            prompt before overwrite (overrides a previous -n
                                  option)
  -H                           follow command-line symbolic links in SOURCE
  -l, --link                   hard link files instead of copying
  -L, --dereference            always follow symbolic links in SOURCE
  -n, --no-clobber             do not overwrite an existing file (overrides
                                 a previous -i option)
  -P, --no-dereference         never follow symbolic links in SOURCE
  -p                           same as --preserve=mode,ownership,timestamps
      --preserve[=ATTR_LIST]   preserve the specified attributes (default:
                                 mode,ownership,timestamps), if possible
                                 additional attributes: context, links, xattr,
                                 all
  -c                           deprecated, same as --preserve=context
      --no-preserve=ATTR_LIST  don&#39;t preserve the specified attributes
      --parents                use full source file name under DIRECTORY
  -R, -r, --recursive          copy directories recursively
      --reflink[=WHEN]         control clone/CoW copies. See below
      --remove-destination     remove each existing destination file before
                                 attempting to open it (contrast with --force)
      --sparse=WHEN            control creation of sparse files. See below
      --strip-trailing-slashes  remove any trailing slashes from each SOURCE
                                 argument
  -s, --symbolic-link          make symbolic links instead of copying
  -S, --suffix=SUFFIX          override the usual backup suffix
  -t, --target-directory=DIRECTORY  copy all SOURCE arguments into DIRECTORY
  -T, --no-target-directory    treat DEST as a normal file
  -u, --update                 copy only when the SOURCE file is newer
                                 than the destination file or when the
                                 destination file is missing
  -v, --verbose                explain what is being done
  -x, --one-file-system        stay on this file system
  -Z                           set SELinux security context of destination
                                 file to default type
      --context[=CTX]          like -Z, or if CTX is specified then set the
                                 SELinux or SMACK security context to CTX
      --help     display this help and exit
      --version  output version information and exit

By default, sparse SOURCE files are detected by a crude heuristic and the
corresponding DEST file is made sparse as well.  That is the behavior
selected by --sparse=auto.  Specify --sparse=always to create a sparse DEST
file whenever the SOURCE file contains a long enough sequence of zero bytes.
Use --sparse=never to inhibit creation of sparse files.

When --reflink[=always] is specified, perform a lightweight copy, where the
data blocks are copied only when modified.  If this is not possible the copy
fails, or if --reflink=auto is specified, fall back to a standard copy.

The backup suffix is &#39;~&#39;, unless set with --suffix or SIMPLE_BACKUP_SUFFIX.
The version control method may be selected via the --backup option or through
the VERSION_CONTROL environment variable.  Here are the values:

  none, off       never make backups (even if --backup is given)
  numbered, t     make numbered backups
  existing, nil   numbered if numbered backups exist, simple otherwise
  simple, never   always make simple backups

As a special case, cp makes a backup of SOURCE when the force and backup
options are given and SOURCE and DEST are the same name for an existing,
regular file.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;常用选项&#34;&gt;常用选项：&lt;/h3&gt;

&lt;p&gt;-a / -p：连同文件属性一起复制（用户组属性受 id 权限限制）&lt;/p&gt;

&lt;p&gt;-i（interactive）：覆盖询问&lt;/p&gt;

&lt;p&gt;-r（recursive）： 用于目录的递归复制&lt;/p&gt;

&lt;p&gt;-u （update）：source 比 destination 新才复制&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;覆盖询问&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@78063f0fe2e8 ~]# cp ~/.bashrc /tmp/bashrc
[root@78063f0fe2e8 ~]# cp -i ~/.bashrc /tmp/bashrc
cp: overwrite ‘/tmp/bashrc’? y
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;连同文件属性一起复制&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@78063f0fe2e8 ~]# cd /tmp
[root@78063f0fe2e8 tmp]# cp /var/log/wtmp .
[root@78063f0fe2e8 tmp]# ls -l /var/log/wtmp wtmp
-rw-rw-r-- 1 root utmp 0 Apr  2 18:38 /var/log/wtmp
-rw-r--r-- 1 root root 0 Apr 21 06:23 wtmp
[root@78063f0fe2e8 tmp]# cp -a /var/log/wtmp wtmp2
[root@78063f0fe2e8 tmp]# ls -l /var/log/wtmp wtmp2
-rw-rw-r-- 1 root utmp 0 Apr  2 18:38 /var/log/wtmp
-rw-rw-r-- 1 root utmp 0 Apr  2 18:38 wtmp2
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;用于目录的递归复制&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@78063f0fe2e8 tmp]# cp /etc /tmp
cp: omitting directory ‘/etc’
[root@78063f0fe2e8 tmp]# cp -r /etc /tmp
&lt;/code&gt;&lt;/pre&gt;

&lt;asciinema-player src=&#34;https://mooncaker816.github.io/asciinema/177529&#34; cols=&#34;80&#34; rows=&#34;24&#34;&gt;&lt;/asciinema-player&gt;

&lt;h2 id=&#34;rm-remove-删除目录或文件&#34;&gt;rm - remove 删除目录或文件&lt;/h2&gt;

&lt;h3 id=&#34;usage-1&#34;&gt;Usage：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Usage: rm [OPTION]... FILE...
Remove (unlink) the FILE(s).

  -f, --force           ignore nonexistent files and arguments, never prompt
  -i                    prompt before every removal
  -I                    prompt once before removing more than three files, or
                          when removing recursively; less intrusive than -i,
                          while still giving protection against most mistakes
      --interactive[=WHEN]  prompt according to WHEN: never, once (-I), or
                          always (-i); without WHEN, prompt always
      --one-file-system  when removing a hierarchy recursively, skip any
                          directory that is on a file system different from
                          that of the corresponding command line argument
      --no-preserve-root  do not treat &#39;/&#39; specially
      --preserve-root   do not remove &#39;/&#39; (default)
  -r, -R, --recursive   remove directories and their contents recursively
  -d, --dir             remove empty directories
  -v, --verbose         explain what is being done
      --help     display this help and exit
      --version  output version information and exit

By default, rm does not remove directories.  Use the --recursive (-r or -R)
option to remove each listed directory, too, along with all of its contents.

To remove a file whose name starts with a &#39;-&#39;, for example &#39;-foo&#39;,
use one of these commands:
  rm -- -foo

  rm ./-foo

Note that if you use rm to remove a file, it might be possible to recover
some of its contents, given sufficient expertise and/or time.  For greater
assurance that the contents are truly unrecoverable, consider using shred.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;常用选项-1&#34;&gt;常用选项：&lt;/h3&gt;

&lt;p&gt;-f（force）：忽略不存在的文件&lt;/p&gt;

&lt;p&gt;-i（interactive）：询问删除&lt;/p&gt;

&lt;p&gt;-r（recursive）：递归删除&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sh-4.2# cd /tmp
sh-4.2# ls
bashrc		  mingle1  tmpxq2sylvo-ascii.cast  wtmp2
ks-script-hE5IPf  test1    wtmp			   yum.log
sh-4.2# rm -i bashrc
rm: remove regular file ‘bashrc’? y
sh-4.2# ls
ks-script-hE5IPf  mingle1  test1  tmpxq2sylvo-ascii.cast  wtmp	wtmp2  yum.log
sh-4.2# rmdir mingle1
sh-4.2# rmdir test1
rmdir: failed to remove ‘test1’: Directory not empty
sh-4.2# rm -rf test1
sh-4.2# ls
ks-script-hE5IPf  tmpxq2sylvo-ascii.cast  wtmp	wtmp2  yum.log
sh-4.2# touch ./-aaa-
sh-4.2# ls
-aaa-  ks-script-hE5IPf  tmpxq2sylvo-ascii.cast  wtmp  wtmp2  yum.log
sh-4.2# rm -f -aaa-
rm: invalid option -- &#39;a&#39;
Try &#39;rm ./-aaa-&#39; to remove the file ‘-aaa-’.
Try &#39;rm --help&#39; for more information.
sh-4.2# rm -f ./-aaa-
sh-4.2# ls
ks-script-hE5IPf  tmpxq2sylvo-ascii.cast  wtmp	wtmp2  yum.log
sh-4.2# rm -rf wtmp*
sh-4.2# ls
ks-script-hE5IPf  tmpxq2sylvo-ascii.cast  yum.log
&lt;/code&gt;&lt;/pre&gt;

&lt;asciinema-player src=&#34;https://mooncaker816.github.io/asciinema/177530&#34; cols=&#34;80&#34; rows=&#34;24&#34;&gt;&lt;/asciinema-player&gt;

&lt;h2 id=&#34;mv-move-移动文件或目录-更名&#34;&gt;mv - move 移动文件或目录，更名&lt;/h2&gt;

&lt;h3 id=&#34;usage-2&#34;&gt;Usage：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Usage: mv [OPTION]... [-T] SOURCE DEST
  or:  mv [OPTION]... SOURCE... DIRECTORY
  or:  mv [OPTION]... -t DIRECTORY SOURCE...
Rename SOURCE to DEST, or move SOURCE(s) to DIRECTORY.

Mandatory arguments to long options are mandatory for short options too.
      --backup[=CONTROL]       make a backup of each existing destination file
  -b                           like --backup but does not accept an argument
  -f, --force                  do not prompt before overwriting
  -i, --interactive            prompt before overwrite
  -n, --no-clobber             do not overwrite an existing file
If you specify more than one of -i, -f, -n, only the final one takes effect.
      --strip-trailing-slashes  remove any trailing slashes from each SOURCE
                                 argument
  -S, --suffix=SUFFIX          override the usual backup suffix
  -t, --target-directory=DIRECTORY  move all SOURCE arguments into DIRECTORY
  -T, --no-target-directory    treat DEST as a normal file
  -u, --update                 move only when the SOURCE file is newer
                                 than the destination file or when the
                                 destination file is missing
  -v, --verbose                explain what is being done
  -Z, --context                set SELinux security context of destination
                                 file to default type
      --help     display this help and exit
      --version  output version information and exit

The backup suffix is &#39;~&#39;, unless set with --suffix or SIMPLE_BACKUP_SUFFIX.
The version control method may be selected via the --backup option or through
the VERSION_CONTROL environment variable.  Here are the values:

  none, off       never make backups (even if --backup is given)
  numbered, t     make numbered backups
  existing, nil   numbered if numbered backups exist, simple otherwise
  simple, never   always make simple backups
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;常用选项-2&#34;&gt;常用选项：&lt;/h3&gt;

&lt;p&gt;-f（force）：不询问直接覆盖&lt;/p&gt;

&lt;p&gt;-i（ interactive）： 询问覆盖&lt;/p&gt;

&lt;p&gt;-u（update）：source 新于 destination 才会 move&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;普通移动&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sh-4.2# cd /tmp
sh-4.2# cp ~/.bashrc bashrc1
sh-4.2# cp ~/.bashrc bashrc2
sh-4.2# ls
bashrc1  bashrc2  ks-script-hE5IPf  tmp8u627nsx-ascii.cast  yum.log
sh-4.2# mkdir mvtest
sh-4.2# ls
bashrc1  bashrc2  ks-script-hE5IPf  mvtest  tmp8u627nsx-ascii.cast  yum.log
sh-4.2# mv bashrc1 bashrc2 mvtest
sh-4.2# ls
ks-script-hE5IPf  mvtest  tmp8u627nsx-ascii.cast  yum.log
sh-4.2# cd mvtest
sh-4.2# ls
bashrc1  bashrc2
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;重命名&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sh-4.2# cd ..
sh-4.2# ls
ks-script-hE5IPf  mvtest  tmp8u627nsx-ascii.cast  yum.log
sh-4.2# mv mvtest mvtest2
sh-4.2# ls
ks-script-hE5IPf  mvtest2  tmp8u627nsx-ascii.cast  yum.log
&lt;/code&gt;&lt;/pre&gt;

&lt;asciinema-player src=&#34;https://mooncaker816.github.io/asciinema/177531&#34; cols=&#34;80&#34; rows=&#34;24&#34;&gt;&lt;/asciinema-player&gt;</description>
    </item>
    
    <item>
      <title>Linux Centos 命令之 touch,cat,tac,more,less</title>
      <link>https://mooncaker816.github.io/2018/04/21/linux-centos-%E5%91%BD%E4%BB%A4%E4%B9%8B-touchcattacmoreless/</link>
      <pubDate>Sat, 21 Apr 2018 13:50:00 +0000</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/04/21/linux-centos-%E5%91%BD%E4%BB%A4%E4%B9%8B-touchcattacmoreless/</guid>
      <description>&lt;h2 id=&#34;touch-创建空文件-修改时间&#34;&gt;touch -  创建空文件，修改时间&lt;/h2&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;usage&#34;&gt;Usage：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Usage: touch [OPTION]... FILE...
Update the access and modification times of each FILE to the current time.

A FILE argument that does not exist is created empty, unless -c or -h
is supplied.

A FILE argument string of - is handled specially and causes touch to
change the times of the file associated with standard output.

Mandatory arguments to long options are mandatory for short options too.
  -a                     change only the access time
  -c, --no-create        do not create any files
  -d, --date=STRING      parse STRING and use it instead of current time
  -f                     (ignored)
  -h, --no-dereference   affect each symbolic link instead of any referenced
                         file (useful only on systems that can change the
                         timestamps of a symlink)
  -m                     change only the modification time
  -r, --reference=FILE   use this file&#39;s times instead of current time
  -t STAMP               use [[CC]YY]MMDDhhmm[.ss] instead of current time
      --time=WORD        change the specified time:
                           WORD is access, atime, or use: equivalent to -a
                           WORD is modify or mtime: equivalent to -m
      --help     display this help and exit
      --version  output version information and exit

Note that the -d and -t options accept different time-date formats.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mtime ：modification time （默认）&lt;/p&gt;

&lt;p&gt;文件的内容被修改时会更新&lt;/p&gt;

&lt;p&gt;ctime ：status time&lt;/p&gt;

&lt;p&gt;文件的属性或权限被修改时会更新&lt;/p&gt;

&lt;p&gt;atime ： access time&lt;/p&gt;

&lt;p&gt;文件的内容被读取时会更新&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@78063f0fe2e8 etc]# ls -l login.defs
-rw-r--r-- 1 root root 2028 Nov  4  2016 login.defs
[root@78063f0fe2e8 etc]# ls -l login.defs --time=atime
-rw-r--r-- 1 root root 2028 Nov  4  2016 login.defs
[root@78063f0fe2e8 etc]# ls -l login.defs --time=ctime
-rw-r--r-- 1 root root 2028 Apr 20 14:19 login.defs
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;常用选项&#34;&gt;常用选项：&lt;/h3&gt;

&lt;p&gt;-a（access） ：仅修改访问时间&lt;/p&gt;

&lt;p&gt;-c（）：仅修改文件时间，若文件不存在则&lt;strong&gt;不&lt;/strong&gt;创建新文件&lt;/p&gt;

&lt;p&gt;-m（modification）： 仅修改 mtime&lt;/p&gt;

&lt;p&gt;-t （time）：想要修改的时间[YYMMDDhhmm]&lt;/p&gt;

&lt;p&gt;-d（date）：修改的日期&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;新建空文件&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sh-4.2# cd /tmp
sh-4.2# touch testtouch
sh-4.2# ls -l testtouch
-rw-r--r-- 1 root root 0 Apr 21 07:52 testtouch
sh-4.2# ls -l testtouch --time=atime
-rw-r--r-- 1 root root 0 Apr 21 07:52 testtouch
sh-4.2# ls -l testtouch --time=ctime
-rw-r--r-- 1 root root 0 Apr 21 07:52 testtouch
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;修改时间&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sh-4.2# cp -a ~/.bashrc bashrc
sh-4.2# ls -l bashrc
-rw-r--r-- 1 root root 176 Dec 29  2013 bashrc
sh-4.2# ls -l bashrc --time=atime
-rw-r--r-- 1 root root 176 Dec 29  2013 bashrc
sh-4.2# ls -l bashrc --time=ctime
-rw-r--r-- 1 root root 176 Apr 21 07:53 bashrc
sh-4.2# touch -d &amp;quot;2 days ago&amp;quot; bashrc
sh-4.2# ls -l bashrc
-rw-r--r-- 1 root root 176 Apr 19 07:55 bashrc
sh-4.2# ls -l bashrc --time=atime
-rw-r--r-- 1 root root 176 Apr 19 07:55 bashrc
sh-4.2# ls -l bashrc --time=ctime
-rw-r--r-- 1 root root 176 Apr 21 07:55 bashrc
sh-4.2# touch -t 1801011000 bashrc
sh-4.2# ls -l bashrc
-rw-r--r-- 1 root root 176 Jan  1 10:00 bashrc
sh-4.2# ls -l bashrc --time=ctime
-rw-r--r-- 1 root root 176 Apr 21 07:57 bashrc
sh-4.2# ls -l bashrc --time=atime
-rw-r--r-- 1 root root 176 Jan  1 10:00 bashrc
&lt;/code&gt;&lt;/pre&gt;

&lt;asciinema-player src=&#34;https://mooncaker816.github.io/asciinema/177538&#34; cols=&#34;80&#34; rows=&#34;24&#34;&gt;&lt;/asciinema-player&gt;

&lt;h2 id=&#34;cat-concatenate-浏览文件&#34;&gt;cat - concatenate 浏览文件&lt;/h2&gt;

&lt;h3 id=&#34;usage-1&#34;&gt;Usage：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Usage: cat [OPTION]... [FILE]...
Concatenate FILE(s), or standard input, to standard output.

  -A, --show-all           equivalent to -vET
  -b, --number-nonblank    number nonempty output lines, overrides -n
  -e                       equivalent to -vE
  -E, --show-ends          display $ at end of each line
  -n, --number             number all output lines
  -s, --squeeze-blank      suppress repeated empty output lines
  -t                       equivalent to -vT
  -T, --show-tabs          display TAB characters as ^I
  -u                       (ignored)
  -v, --show-nonprinting   use ^ and M- notation, except for LFD and TAB
      --help     display this help and exit
      --version  output version information and exit

With no FILE, or when FILE is -, read standard input.

Examples:
  cat f - g  Output f&#39;s contents, then standard input, then g&#39;s contents.
  cat        Copy standard input to standard output.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;常用选项-1&#34;&gt;常用选项：&lt;/h3&gt;

&lt;p&gt;-A（All）：显示所有，包括特殊字符，等价于-vET&lt;/p&gt;

&lt;p&gt;-v（verbose）：列出看不出来的特殊字符&lt;/p&gt;

&lt;p&gt;-T（Tab）：将 Tab 按键以^I 显示出来&lt;/p&gt;

&lt;p&gt;-b（blank）：列出行号，空白行不标号&lt;/p&gt;

&lt;p&gt;-n（number）：列出行号，空白行也有&lt;/p&gt;

&lt;p&gt;-E（End）：将结尾的断行字符$显示出来&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sh-4.2# cat /etc/issue
\S
Kernel \r on an \m

sh-4.2# cat -n /etc/issue
     1	\S
     2	Kernel \r on an \m
     3
sh-4.2# cat -b /etc/issue
     1	\S
     2	Kernel \r on an \m

sh-4.2# cd /tmp
sh-4.2# ls
bashrc		  mvtest2    testtouch		     yum.log
ks-script-hE5IPf  test.conf  tmpk3saal44-ascii.cast
sh-4.2# cat -A test.conf
^Ihello$
this is a test file only...$
sh-4.2# cat -An test.conf
     1	^Ihello$
     2	this is a test file only...$
&lt;/code&gt;&lt;/pre&gt;

&lt;asciinema-player src=&#34;https://mooncaker816.github.io/asciinema/177541&#34; cols=&#34;80&#34; rows=&#34;24&#34;&gt;&lt;/asciinema-player&gt;

&lt;h2 id=&#34;tac-反向-cat&#34;&gt;tac - 反向 cat&lt;/h2&gt;

&lt;h3 id=&#34;usage-2&#34;&gt;Usage：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Usage: tac [OPTION]... [FILE]...
Write each FILE to standard output, last line first.
With no FILE, or when FILE is -, read standard input.

Mandatory arguments to long options are mandatory for short options too.
  -b, --before             attach the separator before instead of after
  -r, --regex              interpret the separator as a regular expression
  -s, --separator=STRING   use STRING as the separator instead of newline
      --help     display this help and exit
      --version  output version information and exit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;tac 没有 -n 选项&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@78063f0fe2e8 ~]# tac /etc/issue

Kernel \r on an \m
\S
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;nl-添加行号显示文件&#34;&gt;nl - 添加行号显示文件&lt;/h2&gt;

&lt;h3 id=&#34;usage-3&#34;&gt;Usage：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Usage: nl [OPTION]... [FILE]...
Write each FILE to standard output, with line numbers added.
With no FILE, or when FILE is -, read standard input.

Mandatory arguments to long options are mandatory for short options too.
  -b, --body-numbering=STYLE      use STYLE for numbering body lines
  -d, --section-delimiter=CC      use CC for separating logical pages
  -f, --footer-numbering=STYLE    use STYLE for numbering footer lines
  -h, --header-numbering=STYLE    use STYLE for numbering header lines
  -i, --line-increment=NUMBER     line number increment at each line
  -l, --join-blank-lines=NUMBER   group of NUMBER empty lines counted as one
  -n, --number-format=FORMAT      insert line numbers according to FORMAT
  -p, --no-renumber               do not reset line numbers at logical pages
  -s, --number-separator=STRING   add STRING after (possible) line number
  -v, --starting-line-number=NUMBER  first line number on each logical page
  -w, --number-width=NUMBER       use NUMBER columns for line numbers
      --help     display this help and exit
      --version  output version information and exit

By default, selects -v1 -i1 -l1 -sTAB -w6 -nrn -hn -bt -fn.  CC are
two delimiter characters for separating logical pages, a missing
second character implies :.  Type \\ for \.  STYLE is one of:

  a         number all lines
  t         number only nonempty lines
  n         number no lines
  pBRE      number only lines that contain a match for the basic regular
            expression, BRE

FORMAT is one of:

  ln   left justified, no leading zeros
  rn   right justified, no leading zeros
  rz   right justified, leading zeros
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@78063f0fe2e8 ~]# nl /etc/issue
     1	\S
     2	Kernel \r on an \m

[root@78063f0fe2e8 ~]# nl /etc/issue -b a
     1	\S
     2	Kernel \r on an \m
     3
[root@78063f0fe2e8 ~]# nl /etc/issue -b a -n rz
000001	\S
000002	Kernel \r on an \m
000003
[root@78063f0fe2e8 ~]# nl /etc/issue -b a -n ln
1     	\S
2     	Kernel \r on an \m
3
[root@78063f0fe2e8 ~]# nl /etc/issue -b a -n rn
     1	\S
     2	Kernel \r on an \m
     3
[root@78063f0fe2e8 ~]# nl /etc/issue -b a -n rn -w 3
  1	\S
  2	Kernel \r on an \m
  3
[root@78063f0fe2e8 ~]# nl /etc/issue -b a -n rz -w 3
001	\S
002	Kernel \r on an \m
003
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;more-一页一页显示文件内容&#34;&gt;more - 一页一页显示文件内容&lt;/h2&gt;

&lt;h3 id=&#34;usage-4&#34;&gt;Usage：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;more: unknown option -help
Usage: more [options] file...

Options:
  -d        display help instead of ring bell
  -f        count logical, rather than screen lines
  -l        suppress pause after form feed
  -p        do not scroll, clean screen and display text
  -c        do not scroll, display text and clean line ends
  -u        suppress underlining
  -s        squeeze multiple blank lines into one
  -NUM      specify the number of lines per screenful
  +NUM      display file beginning from line number NUM
  +/STRING  display file beginning from search string match
  -V        output version information and exit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;空格：向下翻一页&lt;/p&gt;

&lt;p&gt;Enter：向下一行&lt;/p&gt;

&lt;p&gt;/字符串：向下查询字符串&lt;/p&gt;

&lt;p&gt;q：退出查看&lt;/p&gt;

&lt;p&gt;b：往回翻页&lt;/p&gt;

&lt;h2 id=&#34;less-more-的进阶&#34;&gt;less - more 的进阶&lt;/h2&gt;

&lt;p&gt;略&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Linux Centos 命令之 mkdir,rmdir,pwd,cd</title>
      <link>https://mooncaker816.github.io/2018/04/21/linux-centos-%E5%91%BD%E4%BB%A4%E4%B9%8B-mkdirrmdirpwdcd/</link>
      <pubDate>Sat, 21 Apr 2018 12:50:00 +0000</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/04/21/linux-centos-%E5%91%BD%E4%BB%A4%E4%B9%8B-mkdirrmdirpwdcd/</guid>
      <description>&lt;h2 id=&#34;mkdir-make-directory-创建目录&#34;&gt;mkdir - make directory 创建目录&lt;/h2&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;usage&#34;&gt;Usage：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Usage: mkdir [OPTION]... DIRECTORY...
Create the DIRECTORY(ies), if they do not already exist.

Mandatory arguments to long options are mandatory for short options too.
  -m, --mode=MODE   set file mode (as in chmod), not a=rwx - umask
  -p, --parents     no error if existing, make parent directories as needed
  -v, --verbose     print a message for each created directory
  -Z                   set SELinux security context of each created directory
                         to the default type
      --context[=CTX]  like -Z, or if CTX is specified then set the SELinux
                         or SMACK security context to CTX
      --help     display this help and exit
      --version  output version information and exit
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;常用选项&#34;&gt;常用选项：&lt;/h3&gt;

&lt;p&gt;-m（mode）：按指定权限创建目录，若没有该选项则按 umask 的默认设置创建&lt;/p&gt;

&lt;p&gt;-p（parent）：递归创建所有目录&lt;/p&gt;

&lt;p&gt;-v（verbose）： 打印出每个创建的目录&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;递归创建目录&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@78063f0fe2e8 ~]# mkdir -pv /tmp/test1/test2/test3
mkdir: created directory ‘/tmp/test1’
mkdir: created directory ‘/tmp/test1/test2’
mkdir: created directory ‘/tmp/test1/test2/test3’
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;目录的权限由 umask 决定&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@78063f0fe2e8 ~]# umask
0022
[root@78063f0fe2e8 ~]# umask -S
u=rwx,g=rx,o=rx
[root@78063f0fe2e8 ~]# ls /tmp/test1 -l
total 4
drwxr-xr-x 3 root root 4096 Apr 21 05:01 test2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;022是指对应三个组别分别要减去的权限分数，777-022=755=（rwxr-xr-x）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;指定创建权限为711的目录&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@78063f0fe2e8 ~]# mkdir /tmp/mingle -m 711
[root@78063f0fe2e8 ~]# ls /tmp/mingle -ld
drwx--x--x 2 root root 4096 Apr 21 05:10 /tmp/mingle
&lt;/code&gt;&lt;/pre&gt;

&lt;asciinema-player src=&#34;https://mooncaker816.github.io/asciinema/177520&#34; cols=&#34;80&#34; rows=&#34;24&#34;&gt;&lt;/asciinema-player&gt;

&lt;h2 id=&#34;rmdir-remove-empty-directory-删除空目录&#34;&gt;rmdir - remove empty directory 删除空目录&lt;/h2&gt;

&lt;h3 id=&#34;usage-1&#34;&gt;Usage：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Usage: rmdir [OPTION]... DIRECTORY...
Remove the DIRECTORY(ies), if they are empty.

      --ignore-fail-on-non-empty
                  ignore each failure that is solely because a directory
                    is non-empty
  -p, --parents   remove DIRECTORY and its ancestors; e.g., &#39;rmdir -p a/b/c&#39; is
                    similar to &#39;rmdir a/b/c a/b a&#39;
  -v, --verbose   output a diagnostic for every directory processed
      --help     display this help and exit
      --version  output version information and exit
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;常用选项-1&#34;&gt;常用选项：&lt;/h3&gt;

&lt;p&gt;-p（parent）：递归删除空目录&lt;/p&gt;

&lt;p&gt;-v（verbose）：打印出每个删除的目录&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@78063f0fe2e8 ~]# mkdir -p /tmp/test1/test2/test3
[root@78063f0fe2e8 ~]# rmdir -pv /tmp/test1/test2/test3
rmdir: removing directory, ‘/tmp/test1/test2/test3’
rmdir: removing directory, ‘/tmp/test1/test2’
rmdir: removing directory, ‘/tmp/test1’
rmdir: removing directory, ‘/tmp’
rmdir: failed to remove directory ‘/tmp’: Directory not empty
&lt;/code&gt;&lt;/pre&gt;

&lt;asciinema-player src=&#34;https://mooncaker816.github.io/asciinema/177521&#34; cols=&#34;80&#34; rows=&#34;24&#34;&gt;&lt;/asciinema-player&gt;

&lt;h2 id=&#34;pwd-print-working-directory-打印当前路径&#34;&gt;pwd - print working directory 打印当前路径&lt;/h2&gt;

&lt;h3 id=&#34;usage-2&#34;&gt;Usage：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pwd [-LP]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;常用选项-2&#34;&gt;常用选项：&lt;/h3&gt;

&lt;p&gt;-L（link）：若为软链，则显示软链路径(默认)&lt;/p&gt;

&lt;p&gt;-P（）：若为软链，则显示为实际指向路径&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@78063f0fe2e8 mail]# ls -ld /var/mail
lrwxrwxrwx 1 root root 10 Apr  2 18:38 /var/mail -&amp;gt; spool/mail
[root@78063f0fe2e8 mail]# pwd
/var/mail
[root@78063f0fe2e8 mail]# pwd -P
/var/spool/mail
[root@78063f0fe2e8 mail]# pwd -L
/var/mail
&lt;/code&gt;&lt;/pre&gt;

&lt;asciinema-player src=&#34;https://mooncaker816.github.io/asciinema/177522&#34; cols=&#34;80&#34; rows=&#34;24&#34;&gt;&lt;/asciinema-player&gt;

&lt;h2 id=&#34;cd-change-directory-切换当前路径&#34;&gt;cd - change directory 切换当前路径&lt;/h2&gt;

&lt;h3 id=&#34;常用目录&#34;&gt;常用目录：&lt;/h3&gt;

&lt;p&gt;&amp;rdquo;.&amp;rdquo; ： 当前目录&lt;/p&gt;

&lt;p&gt;&amp;rdquo;..&amp;rdquo; ：上级目录&lt;/p&gt;

&lt;p&gt;&amp;rdquo;-&amp;rdquo; ：前一个工作目录&lt;/p&gt;

&lt;p&gt;&amp;ldquo;~&amp;ldquo;,&amp;rdquo; &amp;ldquo; ：当前用户所在的主目录
&amp;ldquo;~account&amp;rdquo; ：account 这个用户所在的主目录&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@78063f0fe2e8 mail]# cd
[root@78063f0fe2e8 ~]#
[root@78063f0fe2e8 ~]# cd /tmp
[root@78063f0fe2e8 tmp]# cd
[root@78063f0fe2e8 ~]# cd ~root
[root@78063f0fe2e8 ~]# cd -
/root
[root@78063f0fe2e8 ~]# cd ..
[root@78063f0fe2e8 /]# cd -
/root
[root@78063f0fe2e8 ~]# cd /var/mail
[root@78063f0fe2e8 mail]#
&lt;/code&gt;&lt;/pre&gt;

&lt;asciinema-player src=&#34;https://mooncaker816.github.io/asciinema/177524&#34; cols=&#34;80&#34; rows=&#34;24&#34;&gt;&lt;/asciinema-player&gt;</description>
    </item>
    
    <item>
      <title>Linux Centos 命令之 ls</title>
      <link>https://mooncaker816.github.io/2018/04/21/linux-centos-%E5%91%BD%E4%BB%A4%E4%B9%8B-ls/</link>
      <pubDate>Sat, 21 Apr 2018 11:50:00 +0000</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/04/21/linux-centos-%E5%91%BD%E4%BB%A4%E4%B9%8B-ls/</guid>
      <description>&lt;h2 id=&#34;ls-list-列出文件与目录&#34;&gt;ls - list 列出文件与目录&lt;/h2&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;usage&#34;&gt;Usage：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Usage: ls [OPTION]... [FILE]...
List information about the FILEs (the current directory by default).
Sort entries alphabetically if none of -cftuvSUX nor --sort is specified.

Mandatory arguments to long options are mandatory for short options too.
  -a, --all                  do not ignore entries starting with .
  -A, --almost-all           do not list implied . and ..
      --author               with -l, print the author of each file
  -b, --escape               print C-style escapes for nongraphic characters
      --block-size=SIZE      scale sizes by SIZE before printing them; e.g.,
                               &#39;--block-size=M&#39; prints sizes in units of
                               1,048,576 bytes; see SIZE format below
  -B, --ignore-backups       do not list implied entries ending with ~
  -c                         with -lt: sort by, and show, ctime (time of last
                               modification of file status information);
                               with -l: show ctime and sort by name;
                               otherwise: sort by ctime, newest first
  -C                         list entries by columns
      --color[=WHEN]         colorize the output; WHEN can be &#39;never&#39;, &#39;auto&#39;,
                               or &#39;always&#39; (the default); more info below
  -d, --directory            list directories themselves, not their contents
  -D, --dired                generate output designed for Emacs&#39; dired mode
  -f                         do not sort, enable -aU, disable -ls --color
  -F, --classify             append indicator (one of */=&amp;gt;@|) to entries
      --file-type            likewise, except do not append &#39;*&#39;
      --format=WORD          across -x, commas -m, horizontal -x, long -l,
                               single-column -1, verbose -l, vertical -C
      --full-time            like -l --time-style=full-iso
  -g                         like -l, but do not list owner
      --group-directories-first
                             group directories before files;
                               can be augmented with a --sort option, but any
                               use of --sort=none (-U) disables grouping
  -G, --no-group             in a long listing, don&#39;t print group names
  -h, --human-readable       with -l, print sizes in human readable format
                               (e.g., 1K 234M 2G)
      --si                   likewise, but use powers of 1000 not 1024
  -H, --dereference-command-line
                             follow symbolic links listed on the command line
      --dereference-command-line-symlink-to-dir
                             follow each command line symbolic link
                               that points to a directory
      --hide=PATTERN         do not list implied entries matching shell PATTERN
                               (overridden by -a or -A)
      --indicator-style=WORD  append indicator with style WORD to entry names:
                               none (default), slash (-p),
                               file-type (--file-type), classify (-F)
  -i, --inode                print the index number of each file
  -I, --ignore=PATTERN       do not list implied entries matching shell PATTERN
  -k, --kibibytes            default to 1024-byte blocks for disk usage
  -l                         use a long listing format
  -L, --dereference          when showing file information for a symbolic
                               link, show information for the file the link
                               references rather than for the link itself
  -m                         fill width with a comma separated list of entries
  -n, --numeric-uid-gid      like -l, but list numeric user and group IDs
  -N, --literal              print raw entry names (don&#39;t treat e.g. control
                               characters specially)
  -o                         like -l, but do not list group information
  -p, --indicator-style=slash
                             append / indicator to directories
  -q, --hide-control-chars   print ? instead of nongraphic characters
      --show-control-chars   show nongraphic characters as-is (the default,
                               unless program is &#39;ls&#39; and output is a terminal)
  -Q, --quote-name           enclose entry names in double quotes
      --quoting-style=WORD   use quoting style WORD for entry names:
                               literal, locale, shell, shell-always, c, escape
  -r, --reverse              reverse order while sorting
  -R, --recursive            list subdirectories recursively
  -s, --size                 print the allocated size of each file, in blocks
  -S                         sort by file size
      --sort=WORD            sort by WORD instead of name: none (-U), size (-S),
                               time (-t), version (-v), extension (-X)
      --time=WORD            with -l, show time as WORD instead of default
                               modification time: atime or access or use (-u)
                               ctime or status (-c); also use specified time
                               as sort key if --sort=time
      --time-style=STYLE     with -l, show times using style STYLE:
                               full-iso, long-iso, iso, locale, or +FORMAT;
                               FORMAT is interpreted like in &#39;date&#39;; if FORMAT
                               is FORMAT1&amp;lt;newline&amp;gt;FORMAT2, then FORMAT1 applies
                               to non-recent files and FORMAT2 to recent files;
                               if STYLE is prefixed with &#39;posix-&#39;, STYLE
                               takes effect only outside the POSIX locale
  -t                         sort by modification time, newest first
  -T, --tabsize=COLS         assume tab stops at each COLS instead of 8
  -u                         with -lt: sort by, and show, access time;
                               with -l: show access time and sort by name;
                               otherwise: sort by access time
  -U                         do not sort; list entries in directory order
  -v                         natural sort of (version) numbers within text
  -w, --width=COLS           assume screen width instead of current value
  -x                         list entries by lines instead of by columns
  -X                         sort alphabetically by entry extension
  -1                         list one file per line

SELinux options:

  --lcontext                 Display security context.   Enable -l. Lines
                             will probably be too wide for most displays.
  -Z, --context              Display security context so it fits on most
                             displays.  Displays only mode, user, group,
                             security context and file name.
  --scontext                 Display only security context and file name.
      --help     display this help and exit
      --version  output version information and exit

SIZE is an integer and optional unit (example: 10M is 10*1024*1024).  Units
are K, M, G, T, P, E, Z, Y (powers of 1024) or KB, MB, ... (powers of 1000).

Using color to distinguish file types is disabled both by default and
with --color=never.  With --color=auto, ls emits color codes only when
standard output is connected to a terminal.  The LS_COLORS environment
variable can change the settings.  Use the dircolors command to set it.

Exit status:
 0  if OK,
 1  if minor problems (e.g., cannot access subdirectory),
 2  if serious trouble (e.g., cannot access command-line argument).
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;常用选项&#34;&gt;常用选项：&lt;/h3&gt;

&lt;p&gt;-a：列出所有文件&lt;/p&gt;

&lt;p&gt;-d：列出目录本身，而不是其内容&lt;/p&gt;

&lt;p&gt;-h：以适合人类阅读的格式输出（size 大小转为 K，M，G 等）&lt;/p&gt;

&lt;p&gt;-i：打印出每个文件的 inode编号&lt;/p&gt;

&lt;p&gt;inode 参考：&lt;a href=&#34;http://www.ruanyifeng.com/blog/2011/12/inode.html&#34; target=&#34;_blank&#34;&gt;http://www.ruanyifeng.com/blog/2011/12/inode.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;-l：以长格式显示完整信息&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;drwxr-xr-x   2 root root  4096 Nov  5  2016 srv
dr-xr-xr-x  13 root root     0 Apr 21 03:02 sys
drwxrwxrwt   1 root root  4096 Apr 20 21:17 tmp
drwxr-xr-x   1 root root  4096 Apr  2 18:38 usr
drwxr-xr-x   1 root root  4096 Apr  2 18:38 var
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;drwxr-xr-x:&lt;/p&gt;

&lt;p&gt;常用文件类型：（-普通文件，d 目录，l 软链接文件）&lt;/p&gt;

&lt;p&gt;权限设置：rwxr-xr-x (拥有者权限 rwx，所属组权限r-x，其他权限r-x)&lt;/p&gt;

&lt;asciinema-player src=&#34;https://mooncaker816.github.io/asciinema/177514&#34; cols=&#34;80&#34; rows=&#34;24&#34;&gt;&lt;/asciinema-player&gt;</description>
    </item>
    
    <item>
      <title>Go 标准库学习</title>
      <link>https://mooncaker816.github.io/2018/01/14/go-%E6%A0%87%E5%87%86%E5%BA%93%E5%AD%A6%E4%B9%A0/</link>
      <pubDate>Sun, 14 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/01/14/go-%E6%A0%87%E5%87%86%E5%BA%93%E5%AD%A6%E4%B9%A0/</guid>
      <description>&lt;h3 id=&#34;bytes和strings函数比对&#34;&gt;bytes和strings函数比对&lt;/h3&gt;

&lt;p&gt;&lt;/p&gt;

&lt;table&gt;&lt;tr&gt;&lt;td&gt;bytes&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;strings&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;函数签名&lt;/td&gt;&lt;td&gt;功能&lt;/td&gt;&lt;td&gt;函数签名&lt;/td&gt;&lt;td&gt;功能&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func explode(s []byte, n int) [][]byte&lt;/td&gt;&lt;td&gt;以每个utf8字符为单位，将前n个字符对应的[]byte型组成新的slice返回&lt;/td&gt;&lt;td&gt;func explode(s string, n int) []string&lt;/td&gt;&lt;td&gt;以每个utf8字符为单位，将前n个字符对应的string型组成新的slice返回&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func countGeneric(s, sep []byte) int&lt;/td&gt;&lt;td&gt;返回s中有几个sep，若sep为空，则返回sutf8.RuneCount(s) + 1&lt;/td&gt;&lt;td&gt;func countGeneric(s, substr string) int&lt;/td&gt;&lt;td&gt;返回s中有几个substr，若substr为空，则返回sutf8.RuneCount(s) + 1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func Contains(b, subslice []byte) bool&lt;/td&gt;&lt;td&gt;b中是否含有subslice&lt;/td&gt;&lt;td&gt;func Contains(s, substr string) bool&lt;/td&gt;&lt;td&gt;s中是否含有substr&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func ContainsAny(b []byte, chars string) bool&lt;/td&gt;&lt;td&gt;b中是否含有字符串chars&lt;/td&gt;&lt;td&gt;func ContainsAny(s, chars string) bool&lt;/td&gt;&lt;td&gt;s中是否含有字符串chars中的任意一个unicode字符&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func ContainsRune(b []byte, r rune) bool&lt;/td&gt;&lt;td&gt;b中是否含有rune r&lt;/td&gt;&lt;td&gt;func ContainsRune(s string, r rune) bool&lt;/td&gt;&lt;td&gt;s中是否含有rune r&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func indexBytePortable(s []byte, c byte) int（并没有导出也没有用于内部）&lt;/td&gt;&lt;td&gt;返回s中c的位置，若不含有c，则返回-1&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func LastIndex(s, sep []byte) int&lt;/td&gt;&lt;td&gt;返回s中最后一个sep的位置，若sep为空，返回s的长度，若不含sep，则返回-1&lt;/td&gt;&lt;td&gt;func LastIndex(s, substr string) int&lt;/td&gt;&lt;td&gt;返回s中最后一个substr的位置，若substr为空，返回s的长度，若不含substr，则返回-1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func LastIndexByte(s []byte, c byte) int&lt;/td&gt;&lt;td&gt;返回最后一个c的位置，没有则返回-1&lt;/td&gt;&lt;td&gt;func LastIndexByte(s string, c byte) int&lt;/td&gt;&lt;td&gt;返回最后一个c的位置，没有则返回-1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func IndexRune(s []byte, r rune) int&lt;/td&gt;&lt;td&gt;返回第一个r的位置，如果r无法解码为utf8又不是\uFFFD，认为没找到返回-1&lt;/td&gt;&lt;td&gt;func IndexRune(s string, r rune) int&lt;/td&gt;&lt;td&gt;返回第一个r的位置，如果r无法解码为utf8又不是\uFFFD，认为没找到返回-1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func IndexAny(s []byte, chars string) int&lt;/td&gt;&lt;td&gt;返回chars中任意一个unicode字符在s中第一次出现的位置&lt;/td&gt;&lt;td&gt;func IndexAny(s, chars string) int&lt;/td&gt;&lt;td&gt;返回chars中任意一个unicode字符在s中第一次出现的位置&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func LastIndexAny(s []byte, chars string) int&lt;/td&gt;&lt;td&gt;返回chars中任意一个unicode字符在s中最后一次出现的位置&lt;/td&gt;&lt;td&gt;func LastIndexAny(s, chars string) int&lt;/td&gt;&lt;td&gt;返回chars中任意一个unicode字符在s中最后一次出现的位置&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func genSplit(s, sep []byte, sepSave, n int) [][]byte&lt;/td&gt;&lt;td&gt;按sep划分s，返回前n个组成的slice，每个slice中sep的保留位数有sepSave决定，n小于0时，返回所有划分组成的slice&lt;/td&gt;&lt;td&gt;func genSplit(s, sep string, sepSave, n int) []string&lt;/td&gt;&lt;td&gt;按sep划分s，返回前n个组成的slice，每个slice中sep的保留位数有sepSave决定，n小于0时，返回所有划分组成的slice&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func SplitN(s, sep []byte, n int) [][]byte&lt;/td&gt;&lt;td&gt;按sep划分s，返回前n个划分的slice组成的slice，每个划分的slice不包含sep，n小于0返回所有划分组成的slice&lt;/td&gt;&lt;td&gt;func SplitN(s, sep string, n int) []string&lt;/td&gt;&lt;td&gt;按sep划分s，返回前n个划分的string组成的slice，每个划分的string不包含sep，n小于0返回所有划分组成的slice&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func SplitAfterN(s, sep []byte, n int) [][]byte&lt;/td&gt;&lt;td&gt;按sep划分s，返回前n个划分的slice组成slice，每个划分包含sep&lt;/td&gt;&lt;td&gt;func SplitAfterN(s, sep string, n int) []string&lt;/td&gt;&lt;td&gt;按sep划分s，返回前n个划分的string组成slice，每个划分包含sep&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func Split(s, sep []byte) [][]byte&lt;/td&gt;&lt;td&gt;返回所有的由sep划分的slice组成的slice，每个划分不包含sep&lt;/td&gt;&lt;td&gt;func Split(s, sep string) []string&lt;/td&gt;&lt;td&gt;返回所有的由sep划分的string组成的slice，每个划分不包含sep&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func SplitAfter(s, sep []byte) [][]byte&lt;/td&gt;&lt;td&gt;返回所有的由sep划分的slice组成的slice，每个划分包含sep&lt;/td&gt;&lt;td&gt;func SplitAfter(s, sep string) []string&lt;/td&gt;&lt;td&gt;返回所有的由sep划分的string组成的slice，每个划分包含sep&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func Fields(s []byte) [][]byte&lt;/td&gt;&lt;td&gt;按unicode.IsSpace划分s（所有连续的whitespce当成一个sep），返回所有的划分组成的slice&lt;/td&gt;&lt;td&gt;func Fields(s string) []string&lt;/td&gt;&lt;td&gt;按unicode.IsSpace划分s（所有连续的whitespce当成一个sep），返回所有的划分组成的slice&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func FieldsFunc(s []byte, f func(rune) bool) [][]byte&lt;/td&gt;&lt;td&gt;如果s中对应的一个rune满足f，则这个rune就是s的一个分隔符，返回s中所有分隔符划分的子slice的slice&lt;/td&gt;&lt;td&gt;func FieldsFunc(s string, f func(rune) bool) []string&lt;/td&gt;&lt;td&gt;如果s中对应的一个rune满足f，则这个rune就是s的一个分隔符，返回s中所有分隔符划分的子string的slice&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func Join(s [][]byte, sep []byte) []byte&lt;/td&gt;&lt;td&gt;将s中的元素用sep拼接起来，返回一个新的slice&lt;/td&gt;&lt;td&gt;func Join(a []string, sep string) string &lt;/td&gt;&lt;td&gt;将s中的元素用sep拼接起来，返回一个新的string&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func HasPrefix(s, prefix []byte) bool&lt;/td&gt;&lt;td&gt;判断s是否以prefix开头&lt;/td&gt;&lt;td&gt;func HasPrefix(s, prefix string) bool&lt;/td&gt;&lt;td&gt;判断s是否以prefix开头&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func HasSuffix(s, suffix []byte) bool&lt;/td&gt;&lt;td&gt;判断s是否以suffix结尾&lt;/td&gt;&lt;td&gt;func HasSuffix(s, suffix string) bool&lt;/td&gt;&lt;td&gt;判断s是否以suffix结尾&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func Map(mapping func(r rune) rune, s []byte) []byte&lt;/td&gt;&lt;td&gt;将s中对应的每个rune字符作用映射f得到新的字符，再将这些字符转为utf8存储在一个新的slice中返回&lt;/td&gt;&lt;td&gt;func Map(mapping func(rune) rune, s string) string&lt;/td&gt;&lt;td&gt;将s中对应的每个rune字符作用映射f得到新的字符，再将这些字符存储在一个新的string中返回&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func Repeat(b []byte, count int) []byte&lt;/td&gt;&lt;td&gt;重复b count次，返回新的slice&lt;/td&gt;&lt;td&gt;func Repeat(s string, count int) string&lt;/td&gt;&lt;td&gt;重复s count次，返回新的string&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func ToUpper(s []byte) []byte&lt;/td&gt;&lt;td&gt;转为大写&lt;/td&gt;&lt;td&gt;func ToUpper(s string) string&lt;/td&gt;&lt;td&gt;转为大写&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func ToLower(s []byte) []byte &lt;/td&gt;&lt;td&gt;转为小写&lt;/td&gt;&lt;td&gt;func ToLower(s string) string&lt;/td&gt;&lt;td&gt;转为小写&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func ToTitle(s []byte) []byte&lt;/td&gt;&lt;td&gt;转为Title&lt;/td&gt;&lt;td&gt;func ToTitle(s string) string&lt;/td&gt;&lt;td&gt;转为Title&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func ToUpperSpecial(c unicode.SpecialCase, s []byte) []byte&lt;/td&gt;&lt;td&gt;只将SpecialCase范围里的字符转为大写&lt;/td&gt;&lt;td&gt;func ToUpperSpecial(c unicode.SpecialCase, s string) string&lt;/td&gt;&lt;td&gt;只将SpecialCase范围里的字符转为大写&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func ToLowerSpecial(c unicode.SpecialCase, s []byte) []byte&lt;/td&gt;&lt;td&gt;只将SpecialCase范围里的字符转为小写&lt;/td&gt;&lt;td&gt;func ToLowerSpecial(c unicode.SpecialCase, s string) string&lt;/td&gt;&lt;td&gt;只将SpecialCase范围里的字符转为小写&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func ToTitleSpecial(c unicode.SpecialCase, s []byte) []byte&lt;/td&gt;&lt;td&gt;只将SpecialCase范围里的字符转为Title&lt;/td&gt;&lt;td&gt;func ToTitleSpecial(c unicode.SpecialCase, s string) string&lt;/td&gt;&lt;td&gt;只将SpecialCase范围里的字符转为Title&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func isSeparator(r rune) bool&lt;/td&gt;&lt;td&gt;r是否可以作为一个词（unicode）的分隔符&lt;br&gt;ascii码，数字，字母，下划线不可以&lt;br&gt;非ascii码，unicode的数字，字母不可以，剩下其他认为是unicode的space可以&lt;/td&gt;&lt;td&gt;func isSeparator(r rune) bool&lt;/td&gt;&lt;td&gt;r是否可以作为一个词（unicode）的分隔符&lt;br&gt;ascii码，数字，字母，下划线不可以&lt;br&gt;非ascii码，unicode的数字，字母不可以，剩下其他认为是unicode的space可以&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func Title(s []byte) []byte &lt;/td&gt;&lt;td&gt;调用Map，s中非词分隔符的字符转换为Title&lt;/td&gt;&lt;td&gt;func Title(s string) string&lt;/td&gt;&lt;td&gt;调用Map，s中非词分隔符的字符转换为Title&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func TrimLeftFunc(s []byte, f func(r rune) bool) []byte&lt;/td&gt;&lt;td&gt;以左边起第一个不满足f的rune对应的utf8码开始到s末尾的子slice&lt;/td&gt;&lt;td&gt;func TrimLeftFunc(s string, f func(rune) bool) string&lt;/td&gt;&lt;td&gt;以左边起第一个不满足f的rune对应的utf8码开始到s末尾的子string&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func TrimRightFunc(s []byte, f func(r rune) bool) []byte&lt;/td&gt;&lt;td&gt;以s头开始到从右边起第一个不满足f的rune对应的utf8码为终点的子slice&lt;/td&gt;&lt;td&gt;func TrimRightFunc(s string, f func(rune) bool) string&lt;/td&gt;&lt;td&gt;以s头开始到从右边起第一个不满足f的rune对应的utf8码为终点的子string&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func TrimFunc(s []byte, f func(r rune) bool) []byte &lt;/td&gt;&lt;td&gt;去掉左边和去掉右边的结合体&lt;/td&gt;&lt;td&gt;func TrimFunc(s string, f func(rune) bool) string&lt;/td&gt;&lt;td&gt;去掉左边和去掉右边的结合体&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func TrimPrefix(s, prefix []byte) []byte&lt;/td&gt;&lt;td&gt;去掉prefix后的子slice&lt;/td&gt;&lt;td&gt;func TrimPrefix(s, prefix string) string&lt;/td&gt;&lt;td&gt;去掉prefix后的子string&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func TrimSuffix(s, suffix []byte) []byte&lt;/td&gt;&lt;td&gt;去掉suffix后的子slice&lt;/td&gt;&lt;td&gt;func TrimSuffix(s, suffix string) string&lt;/td&gt;&lt;td&gt;去掉suffix后的子string&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func IndexFunc(s []byte, f func(r rune) bool) int&lt;/td&gt;&lt;td&gt;返回s中第一个满足f的rune字符对应的utf8码的起始位置&lt;/td&gt;&lt;td&gt;func IndexFunc(s string, f func(rune) bool) int&lt;/td&gt;&lt;td&gt;返回s中第一个满足f的rune字符对应的utf8码的起始位置&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func LastIndexFunc(s []byte, f func(r rune) bool) int&lt;/td&gt;&lt;td&gt;返回s中最后一个满足f的rune字符对应的utf8码的起始位置&lt;/td&gt;&lt;td&gt;func LastIndexFunc(s string, f func(rune) bool) int&lt;/td&gt;&lt;td&gt;返回s中最后一个满足f的rune字符对应的utf8码的起始位置&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func indexFunc(s []byte, f func(r rune) bool, truth bool)&lt;/td&gt;&lt;td&gt;返回s中第一个在f作用下得到truth的rune字符对应的utf8码的起始位置&lt;/td&gt;&lt;td&gt;func indexFunc(s string, f func(rune) bool, truth bool) int&lt;/td&gt;&lt;td&gt;返回s中第一个在f作用下得到truth的rune字符对应的utf8码的起始位置&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func lastIndexFunc(s []byte, f func(r rune) bool, truth bool) int&lt;/td&gt;&lt;td&gt;返回s中最后一个在f作用下得到truth的rune字符对应的utf8码的起始位置&lt;/td&gt;&lt;td&gt;func lastIndexFunc(s string, f func(rune) bool, truth bool) int&lt;/td&gt;&lt;td&gt;返回s中最后一个在f作用下得到truth的rune字符对应的utf8码的起始位置&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func makeASCIISet(chars string) (as asciiSet, ok bool)&lt;/td&gt;&lt;td&gt;返回s中碰到非ascii码之前所有ascii码的集合，以及s中是否都是ascii码&lt;br&gt;可以把asciiSet看成是一个32字节长度的值，其中低16字节共计128位表达128个ascii码[0,127]，高16字节用来比对非ascii码&lt;br&gt;具体存储：&lt;br&gt;asciiSet是一个含有8个元素的数组，每个元素有32位，共计256位，&lt;br&gt;其中元素的位置保存了该字符（uint8）对应的高3位（c&gt;&gt;5）的信息，&lt;br&gt;元素的内容保存了每个字符低5位（1 &lt;&lt; uint(c&amp;31)）的信息，5位最大是31（11111），&lt;br&gt;刚好uint32的每一位可以代表在相同高3位的情况下，所有字符的低5位情况，&lt;br&gt;这样就可以用数组的前4个元素完整表达128个ascii了&lt;/td&gt;&lt;td&gt;func makeASCIISet(chars string) (as asciiSet, ok bool)&lt;/td&gt;&lt;td&gt;返回s中碰到非ascii码之前所有ascii码的集合，以及s中是否都是ascii码&lt;br&gt;可以把asciiSet看成是一个32字节长度的值，其中低16字节共计128位表达128个ascii码[0,127]，高16字节用来比对非ascii码&lt;br&gt;具体存储：&lt;br&gt;asciiSet是一个含有8个元素的数组，每个元素有32位，共计256位，&lt;br&gt;其中元素的位置保存了该字符（uint8）对应的高3位（c&gt;&gt;5）的信息，&lt;br&gt;元素的内容保存了每个字符低5位（1 &lt;&lt; uint(c&amp;31)）的信息，5位最大是31（11111），&lt;br&gt;刚好uint32的每一位可以代表在相同高3位的情况下，所有字符的低5位情况，&lt;br&gt;这样就可以用数组的前4个元素完整表达128个ascii了&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func (as *asciiSet) contains(c byte) bool&lt;/td&gt;&lt;td&gt;c是否在as中&lt;/td&gt;&lt;td&gt;func (as *asciiSet) contains(c byte) bool&lt;/td&gt;&lt;td&gt;c是否在as中&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func makeCutsetFunc(cutset string) func(r rune) bool&lt;/td&gt;&lt;td&gt;返回一个判断r是否在cutset字符串中的函数&lt;br&gt;若为单字节字符串，则返回一个直接比较r是否和cutset相同的函数&lt;br&gt;根据cutset创建一个ascii码的集合，&lt;br&gt;如果全是ascii，则返回一个用来判断r是否在上述集合中的函数&lt;br&gt;如果含有非ascii，则返回一个逐一循环cutset中rune字符，判断r是否其中之一的函数&lt;/td&gt;&lt;td&gt;func makeCutsetFunc(cutset string) func(rune) bool&lt;/td&gt;&lt;td&gt;返回一个判断r是否在cutset字符串中的函数&lt;br&gt;若为单字节字符串，则返回一个直接比较r是否和cutset相同的函数&lt;br&gt;根据cutset创建一个ascii码的集合，&lt;br&gt;如果全是ascii，则返回一个用来判断r是否在上述集合中的函数&lt;br&gt;如果含有非ascii，则返回一个逐一循环cutset中rune字符，判断r是否其中之一的函数&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func Trim(s []byte, cutset string) []byte&lt;/td&gt;&lt;td&gt;将s左右两端连续属于cutset的rune字符去除，保留中间的子slice&lt;/td&gt;&lt;td&gt;func Trim(s string, cutset string) string&lt;/td&gt;&lt;td&gt;将s左右两端连续属于cutset的rune字符去除，保留中间的子string&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func TrimLeft(s []byte, cutset string) []byte&lt;/td&gt;&lt;td&gt;将s左边连续属于cutset的rune字符去除，返回剩下的子slice&lt;/td&gt;&lt;td&gt;func TrimLeft(s string, cutset string) string&lt;/td&gt;&lt;td&gt;将s左边连续属于cutset的rune字符去除，返回剩下的子string&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func TrimRight(s []byte, cutset string) []byte&lt;/td&gt;&lt;td&gt;将s右边连续属于cutset的rune字符去除，返回剩下的子slice&lt;/td&gt;&lt;td&gt;func TrimRight(s string, cutset string) string&lt;/td&gt;&lt;td&gt;将s右边连续属于cutset的rune字符去除，返回剩下的子string&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func TrimSpace(s []byte) []byte&lt;/td&gt;&lt;td&gt;去除s左右两端的whitespce，保留剩下的子slice&lt;/td&gt;&lt;td&gt;func TrimSpace(s string) string&lt;/td&gt;&lt;td&gt;去除s左右两端的whitespce，保留剩下的子string&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func Runes(s []byte) []rune&lt;/td&gt;&lt;td&gt;返回s对应的rune类型的slice&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func Replace(s, old, new []byte, n int) []byte&lt;/td&gt;&lt;td&gt;将s中前n个old替换成new，返回一个新的slice，n为负数或者n&gt;old个数时，替换所有old&lt;/td&gt;&lt;td&gt;func Replace(s, old, new string, n int) string&lt;/td&gt;&lt;td&gt;将s中前n个old替换成new，返回一个新的string，n为负数或者n&gt;old个数时，替换所有old&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func EqualFold(s, t []byte) bool&lt;/td&gt;&lt;td&gt;判断s和t在不区分大小写（包括unicode case）的情况下是否相等&lt;/td&gt;&lt;td&gt;func EqualFold(s, t string) bool&lt;/td&gt;&lt;td&gt;判断s和t在不区分大小写（包括unicode case）的情况下是否相等&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func indexRabinKarp(s, sep []byte) int&lt;/td&gt;&lt;td&gt;返回第一个sep在s中的位置&lt;br&gt;Rabin-Karp字符串匹配算法和前面介绍的《朴素字符串匹配算法》类似，也是对应每一个字符进行比较，不同的是Rabin-Karp采用了把字符进行预处理，也就是对每个字符进行对应进制数并取模运算，类似于通过某种函数计算其函数值，比较的是每个字符的函数值。预处理时间O(m)，匹配时间是O((n-m+1)m)。&lt;br&gt;Rabin-Karp算法的思想：&lt;br&gt;假设待匹配字符串的长度为M，目标字符串的长度为N（N&gt;M）；&lt;br&gt;首先计算待匹配字符串的hash值，计算目标字符串前M个字符的hash值；&lt;br&gt;比较前面计算的两个hash值，比较次数N-M+1：&lt;br&gt;若hash值不相等，则继续计算目标字符串的下一个长度为M的字符子串的hash值&lt;br&gt;若hash值相同，则需要使用朴素算法再次判断是否为相同的字串；&lt;/td&gt;&lt;td&gt;func indexRabinKarp(s, substr string) int&lt;/td&gt;&lt;td&gt;返回第一个sep在s中的位置&lt;br&gt;Rabin-Karp字符串匹配算法和前面介绍的《朴素字符串匹配算法》类似，也是对应每一个字符进行比较，不同的是Rabin-Karp采用了把字符进行预处理，也就是对每个字符进行对应进制数并取模运算，类似于通过某种函数计算其函数值，比较的是每个字符的函数值。预处理时间O(m)，匹配时间是O((n-m+1)m)。&lt;br&gt;Rabin-Karp算法的思想：&lt;br&gt;假设待匹配字符串的长度为M，目标字符串的长度为N（N&gt;M）；&lt;br&gt;首先计算待匹配字符串的hash值，计算目标字符串前M个字符的hash值；&lt;br&gt;比较前面计算的两个hash值，比较次数N-M+1：&lt;br&gt;若hash值不相等，则继续计算目标字符串的下一个长度为M的字符子串的hash值&lt;br&gt;若hash值相同，则需要使用朴素算法再次判断是否为相同的字串；&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func hashStr(sep []byte) (uint32, uint32)&lt;/td&gt;&lt;td&gt;计算sep的hash，用于Rabin-Karp算法&lt;/td&gt;&lt;td&gt;func hashStr(sep string) (uint32, uint32)&lt;/td&gt;&lt;td&gt;计算sep的hash，用于Rabin-Karp算法&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;func hashStrRev(sep string) (uint32, uint32)&lt;/td&gt;&lt;td&gt;计算reverse(sep)的hash，用于Rabin-Karp算法&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</description>
    </item>
    
    <item>
      <title>The Go Programming Language Ex（11）</title>
      <link>https://mooncaker816.github.io/2018/01/04/the-go-programming-language-ex11/</link>
      <pubDate>Thu, 04 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/01/04/the-go-programming-language-ex11/</guid>
      <description>&lt;h3 id=&#34;ex-9-1&#34;&gt;Ex 9.1&lt;/h3&gt;

&lt;p&gt;Add a function Withdraw(amount int) bool to the gopl.io/ch9/bank1 program. The result should indicate whether the transaction succeeded or failed due to insufﬁcient funds. The message sent to the monitor goroutine must contain both the amount to withdraw and a new channel over which the monitor goroutine can send the boolean result back to Withdraw.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Copyright © 2016 Alan A. A. Donovan &amp;amp; Brian W. Kernighan.
// License: https://creativecommons.org/licenses/by-nc-sa/4.0/

package bank_test

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;testing&amp;quot;

	&amp;quot;The_Go_Programming_Language_Exercises/CH9/ex9.1&amp;quot;
)

func TestBank(t *testing.T) {
	done := make(chan struct{})

	// Alice
	go func() {
		bank.Deposit(200)
		fmt.Println(&amp;quot;=&amp;quot;, bank.Balance())
		done &amp;lt;- struct{}{}
	}()

	// Bob
	go func() {
		bank.Deposit(100)
		done &amp;lt;- struct{}{}
	}()

	go func() {
		fmt.Println(bank.Withdraw(500))
		done &amp;lt;- struct{}{}
	}()

	// Wait for both transactions.
	&amp;lt;-done
	&amp;lt;-done
	&amp;lt;-done

	if got, want := bank.Balance(), 300; got != want {
		t.Errorf(&amp;quot;Balance = %d, want %d&amp;quot;, got, want)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ex-9-2&#34;&gt;Ex 9.2&lt;/h3&gt;

&lt;p&gt;Rewrite the PopCount example from Section 2.6.2 so that it initializes the l table using sync.Once the ﬁrst time it is needed. (Realistically, the cost of synchronization would be prohibitive for a small and highly optimized function like PopCount.)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Copyright © 2016 Alan A. A. Donovan &amp;amp; Brian W. Kernighan.
// License: https://creativecommons.org/licenses/by-nc-sa/4.0/

// See page 45.

// (Package doc comment intentionally malformed to demonstrate golint.)
//!+
package popcount

import &amp;quot;sync&amp;quot;

// pc[i] is the population count of i.
var pc [256]byte
var loadpcOnce sync.Once

//func init() {
//	for i := range pc {
//		pc[i] = pc[i/2] + byte(i&amp;amp;1)
//	}
//}

// PopCount returns the population count (number of set bits) of x.
func PopCount(x uint64) int {
	loadpcOnce.Do(loadpc)
	return int(pc[byte(x&amp;gt;&amp;gt;(0*8))] +
		pc[byte(x&amp;gt;&amp;gt;(1*8))] +
		pc[byte(x&amp;gt;&amp;gt;(2*8))] +
		pc[byte(x&amp;gt;&amp;gt;(3*8))] +
		pc[byte(x&amp;gt;&amp;gt;(4*8))] +
		pc[byte(x&amp;gt;&amp;gt;(5*8))] +
		pc[byte(x&amp;gt;&amp;gt;(6*8))] +
		pc[byte(x&amp;gt;&amp;gt;(7*8))])
}

func loadpc() {
	for i := range pc {
		pc[i] = pc[i/2] + byte(i&amp;amp;1)
	}
}

//!-

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ex-9-3&#34;&gt;Ex 9.3&lt;/h3&gt;

&lt;p&gt;Extend the Func type and the (*Memo).Get method so that callers may provide an optional done channel through which they can cancel the operation (§8.9). The results of a cancelled Func call should not be cached.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Copyright © 2016 Alan A. A. Donovan &amp;amp; Brian W. Kernighan.
// License: https://creativecommons.org/licenses/by-nc-sa/4.0/

// See page 278.

// Package memo provides a concurrency-safe non-blocking memoization
// of a function.  Requests for different keys proceed in parallel.
// Concurrent requests for the same key block until the first completes.
// This implementation uses a monitor goroutine.
package memo

import &amp;quot;errors&amp;quot;
import &amp;quot;time&amp;quot;

//!+Func

// Func is the type of the function to memoize.
type Func func(key string) (interface{}, error)

// A result is the result of calling a Func.
type result struct {
	value interface{}
	err   error
}

type entry struct {
	res   result
	ready chan struct{} // closed when res is ready
}

//!-Func

//!+get

// A request is a message requesting that the Func be applied to key.
type request struct {
	key      string
	response chan&amp;lt;- result // the client wants a single result
}

type Memo struct{ requests chan request }

// New returns a memoization of f.  Clients must subsequently call Close.
func New(f Func) *Memo {
	memo := &amp;amp;Memo{requests: make(chan request)}
	go memo.server(f)
	return memo
}

func (memo *Memo) Get(key string) (interface{}, error) {
	response := make(chan result)
	memo.requests &amp;lt;- request{key, response}
	res := &amp;lt;-response
	return res.value, res.err
}

func (memo *Memo) Close() { close(memo.requests) }

//!-get

//!+monitor

func (memo *Memo) server(f Func) {
	var done = make(chan struct{})
	// Cancel traversal when input is detected.
	go func() {
		//os.Stdin.Read(make([]byte, 1)) // read a single byte
		time.Sleep(300 * time.Millisecond)
		close(done)
	}()
	cancelled := func() bool {
		select {
		case &amp;lt;-done:
			return true
		default:
			return false
		}
	}
	cache := make(map[string]*entry)
	for req := range memo.requests {
		if cancelled() {
			//close(memo.requests)
			break
		}
		e := cache[req.key]
		if e == nil {
			// This is the first request for this key.
			e = &amp;amp;entry{ready: make(chan struct{})}
			cache[req.key] = e
			go e.call(f, req.key) // call f(key)
			if cancelled() {
				delete(cache, req.key)
			}
		}
		go e.deliver(req.response, done)
	}
}

func (e *entry) call(f Func, key string) {
	// Evaluate the function.
	e.res.value, e.res.err = f(key)
	// Broadcast the ready condition.
	close(e.ready)
}

func (e *entry) deliver(response chan&amp;lt;- result, done &amp;lt;-chan struct{}) {
	// Wait for the ready condition.
	select {
	case &amp;lt;-e.ready:
		response &amp;lt;- e.res
	case &amp;lt;-done:
		response &amp;lt;- result{nil, errors.New(&amp;quot;request cancelled&amp;quot;)}
	}
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>The Go Programming Language Ex（10）</title>
      <link>https://mooncaker816.github.io/2018/01/03/the-go-programming-language-ex10/</link>
      <pubDate>Wed, 03 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/01/03/the-go-programming-language-ex10/</guid>
      <description>&lt;h3 id=&#34;ex-8-6&#34;&gt;Ex 8.6&lt;/h3&gt;

&lt;p&gt;Add depth-limiting to the concurrent crawler. That is, if the user sets -depth=3, then only URLs reachable by at most three links will be fetched.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Copyright © 2016 Alan A. A. Donovan &amp;amp; Brian W. Kernighan.
// License: https://creativecommons.org/licenses/by-nc-sa/4.0/

// See page 241.

// Crawl2 crawls web links starting with the command-line arguments.
//
// This version uses a buffered channel as a counting semaphore
// to limit the number of concurrent calls to links.Extract.
package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;log&amp;quot;
	&amp;quot;os&amp;quot;

	&amp;quot;gopl.io/ch5/links&amp;quot;
)

//!+sema
// tokens is a counting semaphore used to
// enforce a limit of 20 concurrent requests.
var tokens = make(chan struct{}, 20)

func crawl(url string, deepth int, f *os.File) work {
	tokens &amp;lt;- struct{}{} // acquire a token
	list, err := links.Extract(url)
	fmt.Fprintln(f, deepth, &amp;quot; &amp;quot;, url, &amp;quot; &amp;quot;, len(list))
	&amp;lt;-tokens // release the token
	deepth++
	if err != nil {
		log.Print(err)
	}
	return work{list, deepth}
}

//!-sema
type work struct {
	worklist   []string
	workdeepth int
}

const DEEPTH = 2

//!+
func main() {
	wkpool := make(chan work)
	var n int // number of pending sends to worklist
	f, _ := os.Create(&amp;quot;stat&amp;quot;)
	defer f.Close()
	// Start with the command-line arguments.
	n++
	go func() { wkpool &amp;lt;- work{os.Args[1:], 0} }()

	// Crawl the web concurrently.
	seen := make(map[string]bool)
	for ; n &amp;gt; 0; n-- {
		wk := &amp;lt;-wkpool
		if wk.workdeepth &amp;gt; DEEPTH {
			continue
		}
		for _, link := range wk.worklist {
			if !seen[link] {
				seen[link] = true
				n++
				go func(link string, deepth int, f *os.File) {
					wkpool &amp;lt;- crawl(link, deepth, f)
				}(link, wk.workdeepth, f)
			}
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ex-8-8&#34;&gt;Ex 8.8&lt;/h3&gt;

&lt;p&gt;Using a select statement, add a timeout to the echo server from Section 8.3 so that it disconnects any client that shouts nothing within 10 seconds.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//client
package main

import (
	&amp;quot;io&amp;quot;
	&amp;quot;log&amp;quot;
	&amp;quot;net&amp;quot;
	&amp;quot;os&amp;quot;
)

func init() {
	log.SetFlags(log.Ldate | log.Lmicroseconds)
}

//!+
func main() {
	f, err := os.Open(&amp;quot;a&amp;quot;)
	defer f.Close()
	conn, err := net.Dial(&amp;quot;tcp&amp;quot;, &amp;quot;localhost:8000&amp;quot;)
	if err != nil {
		log.Fatal(err)
	}
	log.Println(&amp;quot;connected!&amp;quot;)
	done := make(chan struct{})
	go func() {
		io.Copy(os.Stdout, conn) // NOTE: ignoring errors
		log.Println(&amp;quot;done&amp;quot;)
		done &amp;lt;- struct{}{} // signal the main goroutine
	}()
	go func() {
		mustCopy(conn, os.Stdin)
		//conn.Close()
		err = conn.(*net.TCPConn).CloseWrite() //经实验：必须要关，否则无法通知服务端输入已结束（但不应该是服务端根据EOF来判断吗？）
		log.Println(&amp;quot;write finished in client: &amp;quot;, err)
	}()
	&amp;lt;-done // wait for background goroutine to finish
	log.Printf(&amp;quot;local in server: %#v\n&amp;quot;, conn.LocalAddr())
	log.Printf(&amp;quot;remote in server: %#v\n&amp;quot;, conn.RemoteAddr())
	log.Println(&amp;quot;finish print&amp;quot;)
	//err = conn.(*net.TCPConn).CloseRead()
	//log.Println(&amp;quot;read finished in client: &amp;quot;, err)
	err = conn.Close()
	log.Println(err)
}

//!-

func mustCopy(dst io.Writer, src io.Reader) {
	if _, err := io.Copy(dst, src); err != nil {
		log.Fatal(err)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//server
// Copyright © 2016 Alan A. A. Donovan &amp;amp; Brian W. Kernighan.
// License: https://creativecommons.org/licenses/by-nc-sa/4.0/

// See page 224.

// Reverb2 is a TCP server that simulates an echo.
package main

import (
	&amp;quot;bufio&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;log&amp;quot;
	&amp;quot;net&amp;quot;
	&amp;quot;strings&amp;quot;
	&amp;quot;sync&amp;quot;
	&amp;quot;time&amp;quot;
)

func init() {
	log.SetFlags(log.Ldate | log.Lmicroseconds)
}
func echo(c net.Conn, shout string, delay time.Duration, wg *sync.WaitGroup) {
	defer wg.Done()
	fmt.Fprintln(c, &amp;quot;\t&amp;quot;, strings.ToUpper(shout))
	time.Sleep(delay)
	fmt.Fprintln(c, &amp;quot;\t&amp;quot;, shout)
	time.Sleep(delay)
	fmt.Fprintln(c, &amp;quot;\t&amp;quot;, strings.ToLower(shout))
}

//!+
func handleConn(c net.Conn) {
	msg := make(chan string)
	go func(c net.Conn) {
		//for {
		input := bufio.NewScanner(c)
		for input.Scan() {
			fmt.Println(&amp;quot;getting: &amp;quot;, input.Text())
			msg &amp;lt;- input.Text()
		}
		msg &amp;lt;- &amp;quot;eof&amp;quot;
		//}
	}(c)
	ticker := time.NewTicker(5 * time.Second)
	var wg sync.WaitGroup
label1:
	for {
		select {
		case &amp;lt;-ticker.C:
			ticker.Stop()
			c.Close()
			fmt.Println(&amp;quot;connect closed!!&amp;quot;)
			return
		case s := &amp;lt;-msg:
			if s == &amp;quot;eof&amp;quot; {
				break label1
			}
			ticker.Stop()
			fmt.Println(s)
			wg.Add(1)
			go echo(c, s, 1*time.Second, &amp;amp;wg)
		}
	}
	// NOTE: ignoring potential errors from input.Err()
	//err := c.(*net.TCPConn).CloseRead()
	//log.Println(&amp;quot;read finished in server: &amp;quot;, err)
	log.Println(&amp;quot;finish scan&amp;quot;)
	log.Printf(&amp;quot;local in server: %#v\n&amp;quot;, c.LocalAddr())
	log.Printf(&amp;quot;remote in server: %#v\n&amp;quot;, c.RemoteAddr())
	wg.Wait()
	err := c.(*net.TCPConn).CloseWrite()
	//err := c.Close()
	log.Println(&amp;quot;finished in server: &amp;quot;, err)
}

//!-

func main() {
	l, err := net.Listen(&amp;quot;tcp&amp;quot;, &amp;quot;localhost:8000&amp;quot;)
	if err != nil {
		log.Fatal(err)
	}
	for {
		conn, err := l.Accept()
		if err != nil {
			log.Print(err) // e.g., connection aborted
			continue
		}
		go handleConn(conn)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;//client
$ ./ex8.3
2018/01/03 17:01:15.985187 connected!
2018/01/03 17:01:20.989292 done
2018/01/03 17:01:20.989515 local in server: &amp;amp;net.TCPAddr{IP:net.IP{0x7f, 0x0, 0x0, 0x1}, Port:49954, Zone:&amp;quot;&amp;quot;}
2018/01/03 17:01:20.989576 remote in server: &amp;amp;net.TCPAddr{IP:net.IP{0x7f, 0x0, 0x0, 0x1}, Port:8000, Zone:&amp;quot;&amp;quot;}
2018/01/03 17:01:20.989596 finish print
2018/01/03 17:01:20.989774 &amp;lt;nil&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;//server
./ex8.8
2018/01/03 17:01:20.989248 connect closed!! 127.0.0.1:8000 127.0.0.1:49954
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ex-8-9&#34;&gt;Ex 8.9&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Copyright © 2016 Alan A. A. Donovan &amp;amp; Brian W. Kernighan.
// License: https://creativecommons.org/licenses/by-nc-sa/4.0/

// See page 250.

// The du3 command computes the disk usage of the files in a directory.
package main

// The du3 variant traverses all directories in parallel.
// It uses a concurrency-limiting counting semaphore
// to avoid opening too many files at once.

import (
	&amp;quot;flag&amp;quot;
	&amp;quot;io/ioutil&amp;quot;
	&amp;quot;log&amp;quot;
	&amp;quot;os&amp;quot;
	&amp;quot;path/filepath&amp;quot;
	&amp;quot;sync&amp;quot;
	&amp;quot;time&amp;quot;
)

var vFlag = flag.Bool(&amp;quot;v&amp;quot;, false, &amp;quot;show verbose progress messages&amp;quot;)

func init() {
	log.SetFlags(log.Ldate | log.Lmicroseconds)
}

//!+
func main() {
	// ...determine roots...

	//!-
	flag.Parse()

	// Determine the initial directories.
	roots := flag.Args()
	if len(roots) == 0 {
		roots = []string{&amp;quot;.&amp;quot;}
	}

	//!+
	// Traverse each root of the file tree in parallel.
	//fileSizes := make(chan int64)
	var m sync.WaitGroup
	for _, root := range roots {
		var tick &amp;lt;-chan time.Time
		if *vFlag {
			tick = time.Tick(100 * time.Millisecond)
		}
		var fileSizes chan int64
		var n sync.WaitGroup
		fileSizes = make(chan int64)
		n.Add(1)
		go walkDir(root, &amp;amp;n, fileSizes)
		go func() {
			n.Wait()
			close(fileSizes)
		}()
		m.Add(1)
		go func(root string, tick &amp;lt;-chan time.Time) {
			defer m.Done()
			var nfiles, nbytes int64
		loop:
			for {
				select {
				case size, ok := &amp;lt;-fileSizes:
					if !ok {
						break loop // fileSizes was closed
					}
					nfiles++
					nbytes += size
				case &amp;lt;-tick:
					printDiskUsage(root, nfiles, nbytes)
				}
			}
			printDiskUsage(root, nfiles, nbytes) // final totals
		}(root, tick)
	}
	m.Wait()
}

//!-

func printDiskUsage(root string, nfiles, nbytes int64) {
	log.Printf(&amp;quot;%s: %d files  %.1f GB\n&amp;quot;, root, nfiles, float64(nbytes)/1e9)
}

// walkDir recursively walks the file tree rooted at dir
// and sends the size of each found file on fileSizes.
//!+walkDir
func walkDir(dir string, n *sync.WaitGroup, fileSizes chan&amp;lt;- int64) {
	defer n.Done()
	for _, entry := range dirents(dir) {
		if entry.IsDir() {
			n.Add(1)
			subdir := filepath.Join(dir, entry.Name())
			go walkDir(subdir, n, fileSizes)
		} else {
			fileSizes &amp;lt;- entry.Size()
		}
	}
}

//!-walkDir

//!+sema
// sema is a counting semaphore for limiting concurrency in dirents.
var sema = make(chan struct{}, 20)

// dirents returns the entries of directory dir.
func dirents(dir string) []os.FileInfo {
	sema &amp;lt;- struct{}{}        // acquire token
	defer func() { &amp;lt;-sema }() // release token
	// ...
	//!-sema

	entries, err := ioutil.ReadDir(dir)
	if err != nil {
		//fmt.Fprintf(os.Stderr, &amp;quot;du: %v\n&amp;quot;, err)
		return nil
	}
	return entries
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./ex8.9 -v /etc /usr /bin /var
2018/01/03 20:36:21.368337 /bin: 36 files  0.0 GB
2018/01/03 20:36:21.370797 /etc: 308 files  0.0 GB
2018/01/03 20:36:21.483464 /var: 2270 files  6.1 GB
2018/01/03 20:36:21.483846 /usr: 4322 files  1.9 GB
2018/01/03 20:36:21.571401 /var: 2449 files  6.3 GB
2018/01/03 20:36:21.599092 /usr: 9322 files  2.1 GB
2018/01/03 20:36:21.678850 /usr: 18130 files  2.6 GB
2018/01/03 20:36:21.782177 /usr: 47807 files  3.2 GB
2018/01/03 20:36:21.872339 /usr: 65859 files  3.7 GB
2018/01/03 20:36:21.920744 /usr: 89008 files  3.9 GB
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ex-8-12&#34;&gt;Ex 8.12&lt;/h3&gt;

&lt;p&gt;Make the broadcaster announce the current set of clients to each new arrival. This requires that the clients set and the entering and leaving channels record the client name too.&lt;/p&gt;

&lt;h3 id=&#34;ex-8-13&#34;&gt;Ex 8.13&lt;/h3&gt;

&lt;p&gt;Make the chat server disconnect idle clients, such as those that have sent no messages in the last ﬁve minutes. Hint: calling conn.Close() in another goroutine unblocks active Read calls such as the one done by input.Scan().&lt;/p&gt;

&lt;h3 id=&#34;ex-8-14&#34;&gt;Ex 8.14&lt;/h3&gt;

&lt;p&gt;Change the chat server’s network protocol so that each client provides its name on entering. Use that name instead of the network address when preﬁxing each message with its sender’s identity.&lt;/p&gt;

&lt;p&gt;只需要添加自定义协议，在压包解包的时候按协议进行就行，待做。。。&lt;/p&gt;

&lt;h3 id=&#34;ex-8-15&#34;&gt;Ex 8.15&lt;/h3&gt;

&lt;p&gt;Failure of any client program to read data in a timely manner ultimately causes all clients to get stuck. Modify the broadcaster to skip a message rather than wait if a client writer is not ready to accept it. Alternatively, add buffering to each client’s outgoing message channel so that most messages are not dropped; the broadcaster should use a non-blocking send to this channel.&lt;/p&gt;

&lt;p&gt;将broadcaster中向各个客户端发送消息的部分写入go routine，并将客户端发送通道定义为缓存通道&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Copyright © 2016 Alan A. A. Donovan &amp;amp; Brian W. Kernighan.
// License: https://creativecommons.org/licenses/by-nc-sa/4.0/

// See page 254.
//!+

// Chat is a server that lets clients chat with each other.
package main

import (
	&amp;quot;bufio&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;log&amp;quot;
	&amp;quot;net&amp;quot;
	&amp;quot;time&amp;quot;
)

//!+broadcaster
type client chan&amp;lt;- string // an outgoing message channel

var (
	entering = make(chan client)
	leaving  = make(chan client)
	messages = make(chan string) // all incoming client messages
)

func broadcaster() {
	clients := make(map[client]bool) // all connected clients
	for {
		select {
		case msg := &amp;lt;-messages:
			// Broadcast incoming message to all
			// clients&#39; outgoing message channels.
			for cli := range clients {
				cli &amp;lt;- msg
			}

		case cli := &amp;lt;-entering:
			clients[cli] = true

		case cli := &amp;lt;-leaving:
			delete(clients, cli)
			close(cli)
		}
	}
}

//!-broadcaster

//!+handleConn
func handleConn(conn net.Conn) {
	inittime := time.Now()
	itimestr := &amp;quot;[&amp;quot; + inittime.Format(&amp;quot;2006-01-02 15:04:05&amp;quot;) + &amp;quot;]&amp;quot;
	ch := make(chan string) // outgoing client messages
	go clientWriter(conn, ch)
	lastmsgtime := make(chan time.Time)
	who := conn.RemoteAddr().String()
	go func(t time.Time) {
		for {
			select {
			case t = &amp;lt;-lastmsgtime:
			default:
			}
			if time.Now().After(t.Add(20 * time.Second)) {
				ch &amp;lt;- fmt.Sprintf(&amp;quot;[%s] no msg in last 20 sec since %s, closing connect!&amp;quot;, time.Now().Format(&amp;quot;2006-01-02 15:04:05&amp;quot;), t.Format(&amp;quot;2006-01-02 15:04:05&amp;quot;))
				time.Sleep(1 * time.Second)
				conn.Close()
				//leaving &amp;lt;- ch
				//messages &amp;lt;- who + &amp;quot; has left&amp;quot;
				break
			}
		}
	}(inittime)
	ch &amp;lt;- itimestr + &amp;quot; &amp;quot; + &amp;quot;You are &amp;quot; + who
	messages &amp;lt;- itimestr + &amp;quot; &amp;quot; + who + &amp;quot; has arrived&amp;quot;
	entering &amp;lt;- ch

	input := bufio.NewScanner(conn)
	for input.Scan() {
		messages &amp;lt;- &amp;quot;[&amp;quot; + time.Now().Format(&amp;quot;2006-01-02 15:04:05&amp;quot;) + &amp;quot;]&amp;quot; + &amp;quot; &amp;quot; + who + &amp;quot;: &amp;quot; + input.Text()
		lastmsgtime &amp;lt;- time.Now()
	}
	// NOTE: ignoring potential errors from input.Err()

	leaving &amp;lt;- ch
	messages &amp;lt;- &amp;quot;[&amp;quot; + time.Now().Format(&amp;quot;2006-01-02 15:04:05&amp;quot;) + &amp;quot;]&amp;quot; + &amp;quot; &amp;quot; + who + &amp;quot; has left&amp;quot;
	conn.Close()
}

func clientWriter(conn net.Conn, ch &amp;lt;-chan string) {
	for msg := range ch {
		fmt.Fprintln(conn, msg) // NOTE: ignoring network errors
	}
}

//!-handleConn

//!+main
func main() {
	listener, err := net.Listen(&amp;quot;tcp&amp;quot;, &amp;quot;localhost:8000&amp;quot;)
	if err != nil {
		log.Fatal(err)
	}

	go broadcaster()
	for {
		conn, err := listener.Accept()
		if err != nil {
			log.Print(err)
			continue
		}
		go handleConn(conn)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./netcat1
[2018-01-04 01:09:14] You are 127.0.0.1:55627
[2018-01-04 01:09:18] 127.0.0.1:55630 has arrived
[2018-01-04 01:09:20] 127.0.0.1:55630: sdf
[2018-01-04 01:09:24] 127.0.0.1:55635 has arrived
[2018-01-04 01:09:28] 127.0.0.1:55635: ththth
[2018-01-04 01:09:34] no msg in last 20 sec since 2018-01-04 01:09:14, closing connect!
2018/01/04 01:09:35 done
$ ./netcat2
[2018-01-04 01:09:18] You are 127.0.0.1:55630
sdf
[2018-01-04 01:09:20] 127.0.0.1:55630: sdf
[2018-01-04 01:09:24] 127.0.0.1:55635 has arrived
[2018-01-04 01:09:28] 127.0.0.1:55635: ththth
[2018-01-04 01:09:35] 127.0.0.1:55627 has left
[2018-01-04 01:09:40] no msg in last 20 sec since 2018-01-04 01:09:20, closing connect!
2018/01/04 01:09:41 done
$ ./netcat3
[2018-01-04 01:09:24] You are 127.0.0.1:55635
ththth
[2018-01-04 01:09:28] 127.0.0.1:55635: ththth
[2018-01-04 01:09:35] 127.0.0.1:55627 has left
[2018-01-04 01:09:41] 127.0.0.1:55630 has left
[2018-01-04 01:09:48] no msg in last 20 sec since 2018-01-04 01:09:28, closing connect!
2018/01/04 01:09:49 done
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>The Go Programming Language Ex（9）</title>
      <link>https://mooncaker816.github.io/2018/01/01/the-go-programming-language-ex9/</link>
      <pubDate>Mon, 01 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/01/01/the-go-programming-language-ex9/</guid>
      <description>&lt;h3 id=&#34;ex-8-1&#34;&gt;Ex 8.1&lt;/h3&gt;

&lt;p&gt;Modify clock2 to accept a port number, and write a program, clockwall, that acts as a client of several clock servers at once, reading the times from each one and displaying the results in a table, akin to the wall of clocks seen in some business ofﬁces. If you have access to geographically distributed computers, run instances remotely ; otherwise run local instances on different ports with fake time zones.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;$ TZ=US/Eastern ./clock2 -port 8010 &amp;amp; $ TZ=Asia/Tokyo ./clock2 -port 8020 &amp;amp; $ TZ=Europe/London ./clock2 -port 8030 &amp;amp; $ clockwall NewYork=localhost:8010 London=localhost:8020 Tokyo=localhost:8030&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//clockwall
package main

import (
	&amp;quot;html/template&amp;quot;
	&amp;quot;log&amp;quot;
	&amp;quot;net&amp;quot;
	&amp;quot;net/http&amp;quot;
)

type City struct {
	Name string
	Addr string
	Time string
}

type cities []City

const templ = `
&amp;lt;h1&amp;gt;current times:&amp;lt;/h1&amp;gt;
&amp;lt;table&amp;gt;
&amp;lt;tr style=&#39;text-align: left&#39;&amp;gt;
  &amp;lt;th&amp;gt;City&amp;lt;/th&amp;gt;
  &amp;lt;th&amp;gt;Time&amp;lt;/th&amp;gt;
&amp;lt;/tr&amp;gt;
{{range . }}
&amp;lt;tr&amp;gt;
  &amp;lt;td&amp;gt;{{.Name}}&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;{{.Time}}&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;
{{end}}
&amp;lt;/table&amp;gt;
`

var report = template.Must(template.New(&amp;quot;result&amp;quot;).
	Parse(templ))
var cs = cities{
	{&amp;quot;NewYork&amp;quot;, &amp;quot;localhost:8010&amp;quot;, &amp;quot;&amp;quot;},
	{&amp;quot;Tokyo&amp;quot;, &amp;quot;localhost:8020&amp;quot;, &amp;quot;&amp;quot;},
	{&amp;quot;London&amp;quot;, &amp;quot;localhost:8030&amp;quot;, &amp;quot;&amp;quot;},
}

func main() {
	for i := range cs {
		go func(c *City) {
			conn, err := net.Dial(&amp;quot;tcp&amp;quot;, c.Addr)
			if err != nil {
				log.Fatal(err)
			}
			defer conn.Close()
			buf := make([]byte, 20)
			for {
				n, _ := conn.Read(buf)
				c.Time = string(buf[:n])
			}
		}(&amp;amp;cs[i])
	}
	http.HandleFunc(&amp;quot;/gettime&amp;quot;, cs.gettime)
	log.Fatal(http.ListenAndServe(&amp;quot;localhost:8000&amp;quot;, nil))
}

func (cs cities) gettime(w http.ResponseWriter, req *http.Request) {
	if err := report.Execute(w, cs); err != nil {
		log.Fatal(err)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//clock
package main

import (
	&amp;quot;flag&amp;quot;
	&amp;quot;io&amp;quot;
	&amp;quot;log&amp;quot;
	&amp;quot;net&amp;quot;
	&amp;quot;time&amp;quot;
)

func handleConn(c net.Conn) {
	defer c.Close()
	for {
		_, err := io.WriteString(c, time.Now().Format(&amp;quot;15:04:05\n&amp;quot;))
		if err != nil {
			return // e.g., client disconnected
		}
		time.Sleep(1 * time.Second)
	}
}

func main() {
	port := flag.String(&amp;quot;port&amp;quot;, &amp;quot;8000&amp;quot;, &amp;quot;port num&amp;quot;)
	flag.Parse()
	address := &amp;quot;localhost:&amp;quot; + *port
	listener, err := net.Listen(&amp;quot;tcp&amp;quot;, address)
	if err != nil {
		log.Fatal(err)
	}
	//!+
	for {
		conn, err := listener.Accept()
		if err != nil {
			log.Print(err) // e.g., connection aborted
			continue
		}
		go handleConn(conn) // handle connections concurrently
	}
	//!-
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;//启动服务器
TZ=US/Eastern    ./clock -port 8010 &amp;amp;
TZ=Asia/Tokyo    ./clock -port 8020 &amp;amp;
TZ=Europe/London ./clock -port 8030
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://oumnldfwl.bkt.clouddn.com/clockwall.png?imageView2/0/h/200&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;ex-8-3&#34;&gt;Ex 8.3&lt;/h3&gt;

&lt;p&gt;In netcat3, the interface value conn has the concrete type *net.TCPConn, which represents a TCP connection. A TCP connection consists of two halves that may be closed independently using its CloseRead and CloseWrite methods. Modify the main goroutine of netcat3 to close only the write half of the connection so that the program will continue to print the ﬁnal echoes from the reverb1 server even after the standard input has been closed. (Doing this for the reverb2 server is harder; see Exercise 8.4.)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;io&amp;quot;
	&amp;quot;log&amp;quot;
	&amp;quot;net&amp;quot;
	&amp;quot;os&amp;quot;
)

//!+
func main() {
	conn, err := net.Dial(&amp;quot;tcp&amp;quot;, &amp;quot;localhost:8000&amp;quot;)
	if err != nil {
		log.Fatal(err)
	}
	done := make(chan struct{})
	go func() {
		io.Copy(os.Stdout, conn) // NOTE: ignoring errors
		log.Println(&amp;quot;done&amp;quot;)
		done &amp;lt;- struct{}{} // signal the main goroutine
	}()
	mustCopy(conn, os.Stdin)
	//conn.Close()
	if conn, ok := conn.(*net.TCPConn); ok {
		conn.CloseWrite()
	}
	&amp;lt;-done // wait for background goroutine to finish
}

//!-

func mustCopy(dst io.Writer, src io.Reader) {
	if _, err := io.Copy(dst, src); err != nil {
		log.Fatal(err)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ex-8-4&#34;&gt;Ex 8.4&lt;/h3&gt;

&lt;p&gt;Modify the reverb2 server to use a sync.WaitGroup per connection to count the number of active echo goroutines. When it falls to zero, close the write half of the TCP connection as described in Exercise 8.3. Verify that your modiﬁed netcat3 client from that exercise waits for the ﬁnal echoes of multiple concurrent shouts, even after the standard input has been closed.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//client
package main

import (
	&amp;quot;io&amp;quot;
	&amp;quot;log&amp;quot;
	&amp;quot;net&amp;quot;
	&amp;quot;os&amp;quot;
)

func init() {
	log.SetFlags(log.Ldate | log.Lmicroseconds)
}

//!+
func main() {
	f, err := os.Open(&amp;quot;a&amp;quot;)
	defer f.Close()
	conn, err := net.Dial(&amp;quot;tcp&amp;quot;, &amp;quot;localhost:8000&amp;quot;)
	if err != nil {
		log.Fatal(err)
	}
	done := make(chan struct{})
	go func() {
		io.Copy(os.Stdout, conn) // NOTE: ignoring errors
		log.Println(&amp;quot;done&amp;quot;)
		done &amp;lt;- struct{}{} // signal the main goroutine
	}()
	mustCopy(conn, f)
	//conn.Close()
	log.Printf(&amp;quot;local in server: %#v\n&amp;quot;, conn.LocalAddr())
	log.Printf(&amp;quot;remote in server: %#v\n&amp;quot;, conn.RemoteAddr())
	err = conn.(*net.TCPConn).CloseWrite() //经实验：必须要关，否则无法通知服务端输入已结束（但不应该是服务端根据EOF来判断吗？）
	log.Println(&amp;quot;write finished in client: &amp;quot;, err)
	&amp;lt;-done // wait for background goroutine to finish
	log.Println(&amp;quot;finish print&amp;quot;)
	//err = conn.(*net.TCPConn).CloseRead()
	//log.Println(&amp;quot;read finished in client: &amp;quot;, err)
	err = conn.Close()
	log.Println(err)
}

//!-

func mustCopy(dst io.Writer, src io.Reader) {
	if _, err := io.Copy(dst, src); err != nil {
		log.Fatal(err)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//server
// Copyright © 2016 Alan A. A. Donovan &amp;amp; Brian W. Kernighan.
// License: https://creativecommons.org/licenses/by-nc-sa/4.0/

// See page 224.

// Reverb2 is a TCP server that simulates an echo.
package main

import (
	&amp;quot;bufio&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;log&amp;quot;
	&amp;quot;net&amp;quot;
	&amp;quot;strings&amp;quot;
	&amp;quot;sync&amp;quot;
	&amp;quot;time&amp;quot;
)

func init() {
	log.SetFlags(log.Ldate | log.Lmicroseconds)
}
func echo(c net.Conn, shout string, delay time.Duration, wg *sync.WaitGroup) {
	defer wg.Done()
	fmt.Fprintln(c, &amp;quot;\t&amp;quot;, strings.ToUpper(shout))
	time.Sleep(delay)
	fmt.Fprintln(c, &amp;quot;\t&amp;quot;, shout)
	time.Sleep(delay)
	fmt.Fprintln(c, &amp;quot;\t&amp;quot;, strings.ToLower(shout))
}

//!+
func handleConn(c net.Conn) {
	input := bufio.NewScanner(c)
	var wg sync.WaitGroup
	for input.Scan() {
		wg.Add(1)
		go echo(c, input.Text(), 1*time.Second, &amp;amp;wg)
		fmt.Println(input.Text())
	}
	// NOTE: ignoring potential errors from input.Err()
	//err := c.(*net.TCPConn).CloseRead()
	//log.Println(&amp;quot;read finished in server: &amp;quot;, err)
	log.Println(&amp;quot;finish scan&amp;quot;)
	log.Printf(&amp;quot;local in server: %#v\n&amp;quot;, c.LocalAddr())
	log.Printf(&amp;quot;remote in server: %#v\n&amp;quot;, c.RemoteAddr())
	wg.Wait()
	err := c.(*net.TCPConn).CloseWrite()
	//err := c.Close()
	log.Println(&amp;quot;finished in server: &amp;quot;, err)
}

//!-

func main() {
	l, err := net.Listen(&amp;quot;tcp&amp;quot;, &amp;quot;localhost:8000&amp;quot;)
	if err != nil {
		log.Fatal(err)
	}
	for {
		conn, err := l.Accept()
		if err != nil {
			log.Print(err) // e.g., connection aborted
			continue
		}
		go handleConn(conn)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;//client
$ ./ex8.3
2018/01/02 08:56:18.122881 local in server: &amp;amp;net.TCPAddr{IP:net.IP{0x7f, 0x0, 0x0, 0x1}, Port:59580, Zone:&amp;quot;&amp;quot;}
2018/01/02 08:56:18.123015 remote in server: &amp;amp;net.TCPAddr{IP:net.IP{0x7f, 0x0, 0x0, 0x1}, Port:8000, Zone:&amp;quot;&amp;quot;}
2018/01/02 08:56:18.123035 write finished in client:  &amp;lt;nil&amp;gt;
	 A
	 F
	 B
	 C
	 D
	 E
	 G
	 e
	 b
	 c
	 f
	 d
	 g
	 a
	 e
	 a
	 d
	 b
	 f
	 c
	 g
2018/01/02 08:56:20.125582 done
2018/01/02 08:56:20.125625 finish print
2018/01/02 08:56:20.125699 &amp;lt;nil&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;//server
$ ./ex8.4
a
b
c
d
e
f
g
2018/01/02 08:56:18.123125 finish scan
2018/01/02 08:56:18.123409 local in server: &amp;amp;net.TCPAddr{IP:net.IP{0x7f, 0x0, 0x0, 0x1}, Port:8000, Zone:&amp;quot;&amp;quot;}
2018/01/02 08:56:18.123427 remote in server: &amp;amp;net.TCPAddr{IP:net.IP{0x7f, 0x0, 0x0, 0x1}, Port:59580, Zone:&amp;quot;&amp;quot;}
2018/01/02 08:56:20.125383 finished in server:  &amp;lt;nil&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;conn是双向的（从各自local，remote属性相反可以看出），客户端本身对连接的关闭，只会影响客户端本身通过该连接的相关操作，不会影响服务器端连接；反之亦然！&lt;/li&gt;
&lt;li&gt;经过实验，客户端通过标准输入向conn写入消息时，即使写入EOF，服务器端也还会继续等待客户端输入的到来，只有当客户端CloseWrite()后，服务器端才会放弃等待输入，继续后面的逻辑；反之服务器端写，客户端读，也是这种情况。似乎与练习要达到的效果有些出入（手动ctrl-d，文件EOF都不行）~&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>The Go Programming Language Ex（8）</title>
      <link>https://mooncaker816.github.io/2017/12/31/the-go-programming-language-ex8/</link>
      <pubDate>Sun, 31 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://mooncaker816.github.io/2017/12/31/the-go-programming-language-ex8/</guid>
      <description>&lt;h3 id=&#34;ex-7-1&#34;&gt;Ex 7.1&lt;/h3&gt;

&lt;p&gt;Using the ideas from ByteCounter, implement counters for words and for lines. You will ﬁnd bufio.ScanWords useful.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;bufio&amp;quot;
	&amp;quot;bytes&amp;quot;
	&amp;quot;fmt&amp;quot;
)

func main() {
	var c ByteCounter
	c.Write([]byte(&amp;quot;hello&amp;quot;))
	fmt.Println(c) // &amp;quot;5&amp;quot;, = len(&amp;quot;hello&amp;quot;)
	c = 0          // reset the counter
	var name = &amp;quot;Dolly&amp;quot;
	fmt.Fprintf(&amp;amp;c, &amp;quot;hello, %s&amp;quot;, name)
	fmt.Println(c) // &amp;quot;12&amp;quot;, = len(&amp;quot;hello, Dolly&amp;quot;)

	var w WordCounter
	w.Write([]byte(&amp;quot;hello world, 世界&amp;quot;))
	fmt.Println(w)
	w = 0
	var str = &amp;quot;你 好&amp;quot;
	fmt.Fprintf(&amp;amp;w, &amp;quot;hello, %s&amp;quot;, str)
	fmt.Println(w)

	var l LineCounter
	l.Write([]byte(&amp;quot;hello world, 世界\nabc\nosjoij\nwefw&amp;quot;))
	fmt.Println(l)
}

type ByteCounter int

func (c *ByteCounter) Write(p []byte) (int, error) {
	*c += ByteCounter(len(p)) // convert int to ByteCounter
	return len(p), nil
}

type WordCounter int

func (w *WordCounter) Write(p []byte) (int, error) {
	scanner := bufio.NewScanner(bytes.NewReader(p))
	scanner.Split(bufio.ScanWords)
	var count int
	for scanner.Scan() {
		count++
	}
	*w += WordCounter(count)
	return count, nil
}

type LineCounter int

func (l *LineCounter) Write(p []byte) (int, error) {
	scanner := bufio.NewScanner(bytes.NewReader(p))
	scanner.Split(bufio.ScanLines)
	var count int
	for scanner.Scan() {
		count++
	}
	*l += LineCounter(count)
	return count, nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ go run counter.go
5
12
3
3
4
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ex-7-2&#34;&gt;Ex 7.2&lt;/h3&gt;

&lt;p&gt;Write a function CountingWriter with the signature below that, given an io.Writer, returns a new Writer that wraps the original, and a pointer to an int64 variable that at any moment contains the number of bytes written to the new Writer.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;func CountingWriter(w io.Writer) (io.Writer, *int64)&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;io&amp;quot;
	&amp;quot;os&amp;quot;
)

type byteCounter struct {
	n int64
	w io.Writer
}

func (c *byteCounter) Write(p []byte) (int, error) {
	c.n += int64(len(p))
	var err error
	if c.w != nil {
		_, err = c.w.Write(p)
	}
	return len(p), err
}

func CountingWriter(w io.Writer) (io.Writer, *int64) {
	var b byteCounter
	b.w = w
	return &amp;amp;b, &amp;amp;b.n
}

func main() {
	w, n := CountingWriter(os.Stdout)
	fmt.Fprintf(w, &amp;quot;hello, word!\n&amp;quot;)
	fmt.Printf(&amp;quot;writer count [%d]\n&amp;quot;, *n)
	fmt.Fprintf(w, &amp;quot;1234567890\n&amp;quot;)
	fmt.Printf(&amp;quot;writer count [%d]\n&amp;quot;, *n)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ go run counting.go
hello, word!
writer count [13]
1234567890
writer count [24]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ex-7-11&#34;&gt;Ex 7.11&lt;/h3&gt;

&lt;p&gt;Add additional handlers so that clients can create, read, update, and delete database entries. For example, a request of the form /update?item=socks&amp;amp;price=6 will update the price of an item in the inventory and report an error if the item does not exist or if the price is invalid. (Warning: this change introduces concurrent variable updates.)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;log&amp;quot;
	&amp;quot;net/http&amp;quot;
	&amp;quot;strconv&amp;quot;
	&amp;quot;sync&amp;quot;
)

var mu sync.Mutex

func main() {
	db := database{&amp;quot;shoes&amp;quot;: 50, &amp;quot;socks&amp;quot;: 5}
	http.HandleFunc(&amp;quot;/list&amp;quot;, db.list)
	http.HandleFunc(&amp;quot;/price&amp;quot;, db.price)
	http.HandleFunc(&amp;quot;/update&amp;quot;, db.update)
	http.HandleFunc(&amp;quot;/add&amp;quot;, db.add)
	http.HandleFunc(&amp;quot;/delete&amp;quot;, db.delete)
	log.Fatal(http.ListenAndServe(&amp;quot;localhost:8000&amp;quot;, nil))
}

type dollars float32

func (d dollars) String() string { return fmt.Sprintf(&amp;quot;$%.2f&amp;quot;, d) }

type database map[string]dollars

func (db database) list(w http.ResponseWriter, req *http.Request) {
	for item, price := range db {
		fmt.Fprintf(w, &amp;quot;%s: %s\n&amp;quot;, item, price)
	}
}

func (db database) price(w http.ResponseWriter, req *http.Request) {
	item := req.URL.Query().Get(&amp;quot;item&amp;quot;)
	if price, ok := db[item]; ok {
		fmt.Fprintf(w, &amp;quot;%s\n&amp;quot;, price)
	} else {
		w.WriteHeader(http.StatusNotFound) // 404
		fmt.Fprintf(w, &amp;quot;no such item: %q\n&amp;quot;, item)
	}
}

func (db database) update(w http.ResponseWriter, req *http.Request) {
	mu.Lock()
	defer mu.Unlock()
	item := req.URL.Query().Get(&amp;quot;item&amp;quot;)
	if _, ok := db[item]; ok {
		newpricestr := req.URL.Query().Get(&amp;quot;price&amp;quot;)
		newprice, err := strconv.ParseFloat(newpricestr, 32)
		if err != nil {
			w.Write([]byte(&amp;quot;price invalid!&amp;quot;))
		} else {
			db[item] = dollars(float32(newprice))
			w.Write([]byte(&amp;quot;new price updated!\n\n&amp;quot;))
			db.list(w, req)
		}
	} else {
		fmt.Fprintf(w, &amp;quot;no such item: %q\n&amp;quot;, item)
	}
}

func (db database) add(w http.ResponseWriter, req *http.Request) {
	mu.Lock()
	defer mu.Unlock()
	item := req.URL.Query().Get(&amp;quot;item&amp;quot;)
	if _, ok := db[item]; ok {
		fmt.Fprintf(w, &amp;quot;%s already exist!&amp;quot;, item)
	} else {
		newpricestr := req.URL.Query().Get(&amp;quot;price&amp;quot;)
		if len(newpricestr) &amp;lt;= 0 {
			newpricestr = &amp;quot;0&amp;quot;
		}
		newprice, err := strconv.ParseFloat(newpricestr, 32)
		if err != nil {
			w.Write([]byte(&amp;quot;price invalid!&amp;quot;))
		} else {
			db[item] = dollars(float32(newprice))
			fmt.Fprintf(w, &amp;quot;%s added!\n\n&amp;quot;, item)
			db.list(w, req)
		}
	}
}

func (db database) delete(w http.ResponseWriter, req *http.Request) {
	mu.Lock()
	defer mu.Unlock()
	item := req.URL.Query().Get(&amp;quot;item&amp;quot;)
	if _, ok := db[item]; ok {
		delete(db, item)
		fmt.Fprintf(w, &amp;quot;%s deleted!\n\n&amp;quot;, item)
		db.list(w, req)
	} else {
		fmt.Fprintf(w, &amp;quot;%s not exist!&amp;quot;, item)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://oumnldfwl.bkt.clouddn.com/list item.png?imageView2/0/h/200&#34; alt=&#34;list&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://oumnldfwl.bkt.clouddn.com/add item.png?imageView2/0/h/200&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://oumnldfwl.bkt.clouddn.com/update price.png?imageView2/0/h/200&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://oumnldfwl.bkt.clouddn.com/delete item.png?imageView2/0/h/200&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;ex-7-12&#34;&gt;Ex 7.12&lt;/h3&gt;

&lt;p&gt;Change the handler for /list to print its output as an HTML table, not text. You may ﬁnd the html/template package (§4.6) useful.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;html/template&amp;quot;
	&amp;quot;log&amp;quot;
	&amp;quot;net/http&amp;quot;
	&amp;quot;strconv&amp;quot;
	&amp;quot;sync&amp;quot;
)

var mu sync.Mutex

const templ = `
&amp;lt;h1&amp;gt;current prices:&amp;lt;/h1&amp;gt;
&amp;lt;table&amp;gt;
&amp;lt;tr style=&#39;text-align: left&#39;&amp;gt;
  &amp;lt;th&amp;gt;Item&amp;lt;/th&amp;gt;
  &amp;lt;th&amp;gt;Price&amp;lt;/th&amp;gt;
&amp;lt;/tr&amp;gt;
{{range $key, $value := . }}
&amp;lt;tr&amp;gt;
  &amp;lt;td&amp;gt;{{$key}}&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;{{$value}}&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;
{{end}}
&amp;lt;/table&amp;gt;
`

var report = template.Must(template.New(&amp;quot;result&amp;quot;).
	Parse(templ))

func main() {
	db := database{&amp;quot;shoes&amp;quot;: 50, &amp;quot;socks&amp;quot;: 5}
	http.HandleFunc(&amp;quot;/list&amp;quot;, db.list)
	http.HandleFunc(&amp;quot;/price&amp;quot;, db.price)
	http.HandleFunc(&amp;quot;/update&amp;quot;, db.update)
	http.HandleFunc(&amp;quot;/add&amp;quot;, db.add)
	http.HandleFunc(&amp;quot;/delete&amp;quot;, db.delete)
	log.Fatal(http.ListenAndServe(&amp;quot;localhost:8000&amp;quot;, nil))
}

type dollars float32

func (d dollars) String() string { return fmt.Sprintf(&amp;quot;$%.2f&amp;quot;, d) }

type database map[string]dollars

func (db database) list(w http.ResponseWriter, req *http.Request) {
	if err := report.Execute(w, db); err != nil {
		log.Fatal(err)
	}
}

func (db database) price(w http.ResponseWriter, req *http.Request) {
	item := req.URL.Query().Get(&amp;quot;item&amp;quot;)
	if price, ok := db[item]; ok {
		fmt.Fprintf(w, &amp;quot;%s\n&amp;quot;, price)
	} else {
		w.WriteHeader(http.StatusNotFound) // 404
		fmt.Fprintf(w, &amp;quot;no such item: %q\n&amp;quot;, item)
	}
}

func (db database) update(w http.ResponseWriter, req *http.Request) {
	mu.Lock()
	defer mu.Unlock()
	item := req.URL.Query().Get(&amp;quot;item&amp;quot;)
	if _, ok := db[item]; ok {
		newpricestr := req.URL.Query().Get(&amp;quot;price&amp;quot;)
		newprice, err := strconv.ParseFloat(newpricestr, 32)
		if err != nil {
			w.Write([]byte(&amp;quot;price invalid!&amp;quot;))
		} else {
			db[item] = dollars(float32(newprice))
			w.Write([]byte(&amp;quot;new price updated!\n\n&amp;quot;))
			db.list(w, req)
		}
	} else {
		fmt.Fprintf(w, &amp;quot;no such item: %q\n&amp;quot;, item)
	}
}

func (db database) add(w http.ResponseWriter, req *http.Request) {
	mu.Lock()
	defer mu.Unlock()
	item := req.URL.Query().Get(&amp;quot;item&amp;quot;)
	if _, ok := db[item]; ok {
		fmt.Fprintf(w, &amp;quot;%s already exist!&amp;quot;, item)
	} else {
		newpricestr := req.URL.Query().Get(&amp;quot;price&amp;quot;)
		if len(newpricestr) &amp;lt;= 0 {
			newpricestr = &amp;quot;0&amp;quot;
		}
		newprice, err := strconv.ParseFloat(newpricestr, 32)
		if err != nil {
			w.Write([]byte(&amp;quot;price invalid!&amp;quot;))
		} else {
			db[item] = dollars(float32(newprice))
			fmt.Fprintf(w, &amp;quot;%s added!\n\n&amp;quot;, item)
			db.list(w, req)
		}
	}
}

func (db database) delete(w http.ResponseWriter, req *http.Request) {
	mu.Lock()
	defer mu.Unlock()
	item := req.URL.Query().Get(&amp;quot;item&amp;quot;)
	if _, ok := db[item]; ok {
		delete(db, item)
		fmt.Fprintf(w, &amp;quot;%s deleted!\n\n&amp;quot;, item)
		db.list(w, req)
	} else {
		fmt.Fprintf(w, &amp;quot;%s not exist!&amp;quot;, item)
	}
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>The Go Programming Language Ex（7）</title>
      <link>https://mooncaker816.github.io/2017/12/29/the-go-programming-language-ex7/</link>
      <pubDate>Fri, 29 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://mooncaker816.github.io/2017/12/29/the-go-programming-language-ex7/</guid>
      <description>&lt;h3 id=&#34;ex-6-1&#34;&gt;Ex 6.1&lt;/h3&gt;

&lt;p&gt;Implement these additional methods:&lt;/p&gt;

&lt;p&gt;func (*IntSet) Len() int // return the number of elements&lt;/p&gt;

&lt;p&gt;func (*IntSet) Remove(x int) //remove x from the set&lt;/p&gt;

&lt;p&gt;func (*IntSet) Clear() // remove all elements from the set&lt;/p&gt;

&lt;p&gt;func (*IntSet) Copy() *IntSet // return a copy of the set&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;ex-6-2&#34;&gt;Ex 6.2&lt;/h3&gt;

&lt;p&gt;Deﬁne a variadic (*IntSet).AddAll(&amp;hellip;int) method that allows a list of values to be added, such as s.AddAll(1, 2, 3).&lt;/p&gt;

&lt;h3 id=&#34;ex-6-3&#34;&gt;Ex 6.3&lt;/h3&gt;

&lt;p&gt;(*IntSet).UnionWith computes the union of two sets using |, the word-parallel bitwise OR operator. Implement methods for IntersectWith, DifferenceWith, and SymmetricDifference for the corresponding set operations. (The symmetric difference of two sets contains the elements present in one set or the other but not both.)&lt;/p&gt;

&lt;h3 id=&#34;ex-6-4&#34;&gt;Ex 6.4&lt;/h3&gt;

&lt;p&gt;Add a method Elems that returns a slice containing the elements of the set, suitable for iterating over with a range loop.&lt;/p&gt;

&lt;h3 id=&#34;ex-6-5&#34;&gt;Ex 6.5&lt;/h3&gt;

&lt;p&gt;The type of each word used by IntSet is uint64, but 64-bit arithmetic may be inefﬁcient on a 32-bit platform. Modify the program to use the uint type, which is the most efﬁcient unsigned integer type for the platform. Instead of dividing by 64, deﬁne a constant holding the effective size of uint in bits, 32 or 64. You can use the perhaps too-clever expression 32 &amp;lt;&amp;lt; (^uint(0) &amp;gt;&amp;gt; 63) for this purpose.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;bytes&amp;quot;
	&amp;quot;fmt&amp;quot;
)

const wordlen = 32 &amp;lt;&amp;lt; (^uint(0) &amp;gt;&amp;gt; 63) //当前计算机的位数

type IntSet struct {
	words []uint
}

func (s *IntSet) Add(x int) {
	word, bit := x/wordlen, uint(x%wordlen)
	for word &amp;gt;= len(s.words) {
		s.words = append(s.words, 0)
	}
	s.words[word] |= 1 &amp;lt;&amp;lt; bit
}

func (s *IntSet) Has(x int) bool {
	word, bit := x/wordlen, uint(x%wordlen)
	return word &amp;lt; len(s.words) &amp;amp;&amp;amp; s.words[word]&amp;amp;(1&amp;lt;&amp;lt;bit) != 0
}

func (s *IntSet) UnionWith(t *IntSet) {
	for i, tword := range t.words {
		if i &amp;lt; len(s.words) {
			s.words[i] |= tword
		} else {
			s.words = append(s.words, tword)
		}
	}
}

func (s *IntSet) String() string {
	var buf bytes.Buffer
	buf.WriteByte(&#39;{&#39;)
	for i, word := range s.words {
		if word == 0 {
			continue
		}
		for j := 0; j &amp;lt; wordlen; j++ {
			if word&amp;amp;(1&amp;lt;&amp;lt;uint(j)) != 0 {
				if buf.Len() &amp;gt; len(&amp;quot;{&amp;quot;) {
					buf.WriteByte(&#39; &#39;)
				}
				fmt.Fprintf(&amp;amp;buf, &amp;quot;%d&amp;quot;, wordlen*i+j)
			}
		}
	}
	buf.WriteByte(&#39;}&#39;)
	return buf.String()
}

func (s *IntSet) Len() int {
	var count int
	for _, n := range s.words {
		for n != 0 {
			count++
			n = n &amp;amp; (n - 1)
		}
	}
	return count
}

func (s *IntSet) Remove(x int) {
	word, bit := x/wordlen, uint(x%wordlen)
	if word &amp;lt; len(s.words) {
		s.words[word] &amp;amp;= ^(1 &amp;lt;&amp;lt; bit)
	}
}

func (s *IntSet) Clear() {
	s.words = []uint{0}
}
func (s *IntSet) Copy() *IntSet {
	ns := IntSet{make([]uint, len(s.words))}
	copy(ns.words, s.words)
	return &amp;amp;ns
}

func (s *IntSet) AddAll(x ...int) {
	for _, v := range x {
		s.Add(v)
	}
}

func (s *IntSet) IntersectWith(t *IntSet) *IntSet {
	tmp := make([]uint, 0)
	for i, tword := range t.words {
		if i &amp;lt; len(s.words) {
			tmp = append(tmp, s.words[i]&amp;amp;tword)
		}
	}
	return &amp;amp;IntSet{tmp}
}
func (s *IntSet) SymmetricDifference(t *IntSet) *IntSet {
	tmp := make([]uint, 0)
	if len(t.words) &amp;gt; len(s.words) {
		for i, tword := range t.words {
			if i &amp;lt; len(s.words) {
				tmp = append(tmp, s.words[i]^tword)
			} else {
				tmp = append(tmp, tword)
			}
		}
	} else {
		for i, sword := range s.words {
			if i &amp;lt; len(t.words) {
				tmp = append(tmp, t.words[i]^sword)
			} else {
				tmp = append(tmp, sword)
			}
		}
	}
	return &amp;amp;IntSet{tmp}
}

func (s *IntSet) DifferenceWith(t *IntSet) *IntSet {
	tmp := make([]uint, 0)
	for i, sword := range s.words {
		if i &amp;lt; len(t.words) {
			tmp = append(tmp, sword&amp;amp;^t.words[i])
		} else {
			tmp = append(tmp, sword)
		}
	}
	return &amp;amp;IntSet{tmp}
}
func (s *IntSet) Elems() []int {
	tmp := make([]int, 0)
	for i, word := range s.words {
		if word == 0 {
			continue
		}
		for j := 0; j &amp;lt; wordlen; j++ {
			if word&amp;amp;(1&amp;lt;&amp;lt;uint(j)) != 0 {
				tmp = append(tmp, wordlen*i+j)
			}
		}
	}
	return tmp
}

func main() {
	var set1, set2, set3 IntSet
	set1.Add(1)
	set1.Add(22)
	set2.Add(333)
	fmt.Println(&amp;quot;set1:&amp;quot;, &amp;amp;set1)
	fmt.Println(&amp;quot;set1 是否包含1：&amp;quot;, set1.Has(1), &amp;quot;set1 是否包含333：&amp;quot;, set1.Has(333))
	fmt.Println(&amp;quot;before union with {333}: &amp;quot;, &amp;amp;set1)
	fmt.Println(&amp;quot;len: &amp;quot;, set1.Len())
	set1.UnionWith(&amp;amp;set2)
	fmt.Println(&amp;quot;after union with {333}: &amp;quot;, &amp;amp;set1)
	fmt.Println(&amp;quot;len: &amp;quot;, set1.Len())
	set1.Remove(22)
	fmt.Println(&amp;quot;after remove 22: &amp;quot;, &amp;amp;set1)
	fmt.Println(&amp;quot;len: &amp;quot;, set1.Len())
	set3 = *set1.Copy()
	fmt.Println(&amp;quot;copy set1 to set3: &amp;quot;, &amp;amp;set3)
	set1.Clear()
	fmt.Println(&amp;quot;after clear set1: &amp;quot;, &amp;amp;set1, &amp;amp;set3)
	set3.AddAll(4444, 55555)
	fmt.Println(&amp;quot;after add all set3: &amp;quot;, &amp;amp;set3)
	set2.AddAll(55555, 666666)
	fmt.Println(&amp;quot;se2:&amp;quot;, &amp;amp;set2)
	fmt.Println(&amp;quot;se3:&amp;quot;, &amp;amp;set3)
	fmt.Println(&amp;quot;set2交set3:&amp;quot;, set2.IntersectWith(&amp;amp;set3))
	fmt.Println(&amp;quot;set2 DifferenceWith set3:&amp;quot;, set2.DifferenceWith(&amp;amp;set3))
	fmt.Println(&amp;quot;set3 DifferenceWith set2:&amp;quot;, set3.DifferenceWith(&amp;amp;set2))
	fmt.Println(&amp;quot;set2 SymmetricDifference set3:&amp;quot;, set2.SymmetricDifference(&amp;amp;set3))
	fmt.Println(&amp;quot;set3 SymmetricDifference set2:&amp;quot;, set3.SymmetricDifference(&amp;amp;set2))
	fmt.Println(&amp;quot;elem slice in set2:&amp;quot;, set2.Elems())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ go run bitmap.go
set1: {1 22}
set1 是否包含1： true set1 是否包含333： false
before union with {333}:  {1 22}
len:  2
after union with {333}:  {1 22 333}
len:  3
after remove 22:  {1 333}
len:  2
copy set1 to set3:  {1 333}
after clear set1:  {} {1 333}
after add all set3:  {1 333 4444 55555}
se2: {333 55555 666666}
se3: {1 333 4444 55555}
set2交set3: {333 55555}
set2 DifferenceWith set3: {666666}
set3 DifferenceWith set2: {1 4444}
set2 SymmetricDifference set3: {1 4444 666666}
set3 SymmetricDifference set2: {1 4444 666666}
elem slice in set2: [333 55555 666666]
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>The Go Programming Language Ex（6）</title>
      <link>https://mooncaker816.github.io/2017/12/28/the-go-programming-language-ex6/</link>
      <pubDate>Thu, 28 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://mooncaker816.github.io/2017/12/28/the-go-programming-language-ex6/</guid>
      <description>&lt;h3 id=&#34;ex-5-1&#34;&gt;Ex 5.1&lt;/h3&gt;

&lt;p&gt;Change the findlinks program to traverse the n.FirstChild linked list using recursive calls to visit instead of a loop.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;os&amp;quot;

	&amp;quot;golang.org/x/net/html&amp;quot;
)

func main() {
	doc, err := html.Parse(os.Stdin)
	if err != nil {
		fmt.Fprintf(os.Stderr, &amp;quot;findlinks1: %v\n&amp;quot;, err)
		os.Exit(1)
	}
	for _, link := range visit(nil, doc) {
		fmt.Println(link)
	}
}

// visit appends to links each link found in n and returns the result.
func visit(links []string, n *html.Node) []string {

	if n == nil {
		return links
	} else {
		if n.Type == html.ElementNode &amp;amp;&amp;amp; n.Data == &amp;quot;a&amp;quot; {
			for _, a := range n.Attr {
				if a.Key == &amp;quot;href&amp;quot; {
					links = append(links, a.Val)
				}
			}
		}
		links = visit(links, n.FirstChild)
		links = visit(links, n.NextSibling)
	}
	return links
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./ex1.7 http://www.baidu.com | ./ex5.1
/
javascript:;
javascript:;
javascript:;
/
javascript:;
https://passport.baidu.com/v2/?login&amp;amp;tpl=mn&amp;amp;u=http%3A%2F%2Fwww.baidu.com%2F
http://news.baidu.com
http://www.hao123.com
http://map.baidu.com
http://v.baidu.com
http://tieba.baidu.com
http://xueshu.baidu.com
https://passport.baidu.com/v2/?login&amp;amp;tpl=mn&amp;amp;u=http%3A%2F%2Fwww.baidu.com%2F
http://www.baidu.com/gaoji/preferences.html
http://www.baidu.com/more/
http://news.baidu.com/ns?cl=2&amp;amp;rn=20&amp;amp;tn=news&amp;amp;word=
http://tieba.baidu.com/f?kw=&amp;amp;fr=wwwt
http://zhidao.baidu.com/q?ct=17&amp;amp;pn=0&amp;amp;tn=ikaslist&amp;amp;rn=10&amp;amp;word=&amp;amp;fr=wwwt
http://music.baidu.com/search?fr=ps&amp;amp;ie=utf-8&amp;amp;key=
http://image.baidu.com/search/index?tn=baiduimage&amp;amp;ps=1&amp;amp;ct=201326592&amp;amp;lm=-1&amp;amp;cl=2&amp;amp;nc=1&amp;amp;ie=utf-8&amp;amp;word=
http://v.baidu.com/v?ct=301989888&amp;amp;rn=20&amp;amp;pn=0&amp;amp;db=0&amp;amp;s=25&amp;amp;ie=utf-8&amp;amp;word=
http://map.baidu.com/m?word=&amp;amp;fr=ps01000
http://wenku.baidu.com/search?word=&amp;amp;lm=0&amp;amp;od=0&amp;amp;ie=utf-8
//www.baidu.com/more/
//www.baidu.com/cache/sethelp/help.html
http://home.baidu.com
http://ir.baidu.com
http://e.baidu.com/?refer=888
http://www.baidu.com/duty/
http://jianyi.baidu.com/
http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=11000002000001
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ex-5-2&#34;&gt;Ex 5.2&lt;/h3&gt;

&lt;p&gt;Write a function to populate a mapping from element names—p, div, span, and so on—to the number of elements with that name in an HTML document tree.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;os&amp;quot;

	&amp;quot;golang.org/x/net/html&amp;quot;
)

func main() {
	doc, err := html.Parse(os.Stdin)
	if err != nil {
		fmt.Fprintf(os.Stderr, &amp;quot;findlinks1: %v\n&amp;quot;, err)
		os.Exit(1)
	}
	m := make(map[string]int)
	for k, v := range check(m, doc) {
		fmt.Printf(&amp;quot;%s:%d\n&amp;quot;, k, v)
	}
}

func check(m map[string]int, n *html.Node) map[string]int {
	if n == nil {
		return m
	} else {
		if n.Type == html.ElementNode {
			m[n.Data]++
		}
		m = check(m, n.FirstChild)
		m = check(m, n.NextSibling)
	}
	return m
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./ex1.7 http://www.baidu.com | ./ex5.2
body:1
img:2
map:1
area:1
a:32
i:3
head:1
title:1
style:3
ul:1
meta:4
link:11
form:1
span:5
li:4
p:3
html:1
script:13
noscript:1
div:21
input:14
b:2
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ex-5-5&#34;&gt;Ex 5.5&lt;/h3&gt;

&lt;p&gt;Implement countWordsAndImages. (See Exercise 4.9 for word-splitting.)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;bufio&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;net/http&amp;quot;
	&amp;quot;strings&amp;quot;

	&amp;quot;golang.org/x/net/html&amp;quot;
)

func main() {
	url := &amp;quot;http://www.baidu.com&amp;quot;
	w, i, err := CountWordsAndImages(url)
	if err != nil {
		fmt.Println(&amp;quot;CountWordsAndImages error: &amp;quot;, err)
	}
	fmt.Printf(&amp;quot;words = %d,images = %d\n&amp;quot;, w, i)
}

func CountWordsAndImages(url string) (words, images int, err error) {
	resp, err := http.Get(url)
	if err != nil {
		return
	}
	doc, err := html.Parse(resp.Body)
	resp.Body.Close()
	if err != nil {
		err = fmt.Errorf(&amp;quot;parsing HTML: %s&amp;quot;, err)
		return
	}
	words, images = countWordsAndImages(doc)
	return
}

func countWordsAndImages(n *html.Node) (words, images int) {
	if n == nil {
		return
	} else {
		if n.Type == html.ElementNode {
			if n.Data == &amp;quot;img&amp;quot; {
				images++
			}
		} else if n.Type == html.TextNode {
			scanner := bufio.NewScanner(strings.NewReader(n.Data))
			scanner.Split(bufio.ScanWords)
			for scanner.Scan() {
				words++
			}
		}
		w1, i1 := countWordsAndImages(n.FirstChild)
		words += w1
		images += i1
		w2, i2 := countWordsAndImages(n.NextSibling)
		words += w2
		images += i2
	}
	return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ go run countwi.go
words = 2805,images = 2
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ex-5-6&#34;&gt;Ex 5.6&lt;/h3&gt;

&lt;p&gt;Modify the corner function in gopl.io/ch3/surface (§3.2) to use named results and a bare return statement.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;math&amp;quot;
	&amp;quot;os&amp;quot;
)

const (
	width, height = 600, 320            // canvas size in pixels
	cells         = 100                 // number of grid cells
	xyrange       = 30.0                // axis ranges (-xyrange..+xyrange)
	xyscale       = width / 2 / xyrange // pixels per x or y unit
	zscale        = height * 0.4        // pixels per z unit
	angle         = math.Pi / 6         // angle of x, y axes (=30°)
)

var sin30, cos30 = math.Sin(angle), math.Cos(angle) // sin(30°), cos(30°)

func main() {
	//fmt.Printf(&amp;quot;&amp;lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; &amp;quot;+
	f, err := os.Create(&amp;quot;test.svg&amp;quot;)
	if err != nil {
		fmt.Println(&amp;quot;create file error &amp;quot;, err)
		return
	}
	fmt.Fprintf(f, &amp;quot;&amp;lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; &amp;quot;+
		&amp;quot;style=&#39;stroke: grey; fill: white; stroke-width: 0.7&#39; &amp;quot;+
		&amp;quot;width=&#39;%d&#39; height=&#39;%d&#39;&amp;gt;&amp;quot;, width, height)
	for i := 0; i &amp;lt; cells; i++ {
		for j := 0; j &amp;lt; cells; j++ {
			ax, ay := corner(i+1, j)
			bx, by := corner(i, j)
			cx, cy := corner(i, j+1)
			dx, dy := corner(i+1, j+1)
			fmt.Fprintf(f, &amp;quot;&amp;lt;polygon points=&#39;%g,%g %g,%g %g,%g %g,%g&#39;/&amp;gt;\n&amp;quot;,
				ax, ay, bx, by, cx, cy, dx, dy)
		}
	}
	fmt.Fprintln(f, &amp;quot;&amp;lt;/svg&amp;gt;&amp;quot;)
}

func corner(i, j int) (sx, sy float64) {
	// Find point (x,y) at corner of cell (i,j).
	x := xyrange * (float64(i)/cells - 0.5)
	y := xyrange * (float64(j)/cells - 0.5)

	// Compute surface height z.
	z := f(x, y)

	// Project (x,y,z) isometrically onto 2-D SVG canvas (sx,sy).
	sx = width/2 + (x-y)*cos30*xyscale
	sy = height/2 + (x+y)*sin30*xyscale - z*zscale
	return
}

func f(x, y float64) float64 {
	r := math.Hypot(x, y) // distance from (0,0)
	return math.Sin(r) / r
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ex-5-7&#34;&gt;Ex 5.7&lt;/h3&gt;

&lt;p&gt;Develop startElement and endElement into a general HTML pre Print comment nodes, text nodes, and the attributes of each element (&lt;a href=&#39;...&#39;&gt;). Use short forms like &lt;img/&gt; instead of &lt;img&gt;&lt;/img&gt; when an element has no children. Write a test to ensure that the output can be parsed successfully. (See Chapter 11.)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;net/http&amp;quot;
	&amp;quot;os&amp;quot;

	&amp;quot;golang.org/x/net/html&amp;quot;
)

func main() {
	for _, url := range os.Args[1:] {
		outline(url)
	}
}

func outline(url string) error {
	resp, err := http.Get(url)
	if err != nil {
		return err
	}
	defer resp.Body.Close()
	doc, err := html.Parse(resp.Body)
	if err != nil {
		return err
	}

	forEachNode(doc, startElement, endElement)

	return nil
}

func forEachNode(n *html.Node, pre, post func(n *html.Node)) {
	if pre != nil {
		pre(n)
	}
	for c := n.FirstChild; c != nil; c = c.NextSibling {
		forEachNode(c, pre, post)
	}
	if post != nil {
		post(n)
	}
}

var depth int

func startElement(n *html.Node) {
	if n.Type == html.ElementNode ||
		n.Type == html.TextNode ||
		n.Type == html.CommentNode {
		if n.DataAtom != 0 { //去除无法识别标签的节点，如空白的textnode等
			var attr string
			for _, v := range n.Attr {
				attr += &amp;quot; &amp;quot; + v.Key + &amp;quot;=&#39;&amp;quot; + v.Val + &amp;quot;&#39;&amp;quot;
			}
			if n.FirstChild == nil {
				fmt.Printf(&amp;quot;%*s&amp;lt;%s/&amp;gt;\n&amp;quot;, depth*2, &amp;quot;&amp;quot;, n.Data)
			} else {
				fmt.Printf(&amp;quot;%*s&amp;lt;%s%s&amp;gt;\n&amp;quot;, depth*2, &amp;quot;&amp;quot;, n.Data, attr)
			}
			depth++
		}
	}
}
func endElement(n *html.Node) {
	if n.Type == html.ElementNode ||
		n.Type == html.TextNode ||
		n.Type == html.CommentNode {
		if n.DataAtom != 0 {
			depth--
			if n.FirstChild != nil {
				fmt.Printf(&amp;quot;%*s&amp;lt;/%s&amp;gt;\n&amp;quot;, depth*2, &amp;quot;&amp;quot;, n.Data)
			}
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./ex5.7 http://gopl.io
&amp;lt;html xmlns=&#39;http://www.w3.org/1999/xhtml&#39;&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;meta/&amp;gt;
    &amp;lt;title&amp;gt;
    &amp;lt;/title&amp;gt;
    &amp;lt;script&amp;gt;
    &amp;lt;/script&amp;gt;
    &amp;lt;link/&amp;gt;
    &amp;lt;style&amp;gt;
    &amp;lt;/style&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;table&amp;gt;
      &amp;lt;tbody&amp;gt;
        &amp;lt;tr&amp;gt;
          &amp;lt;td&amp;gt;
            &amp;lt;a href=&#39;http://www.informit.com/store/go-programming-language-9780134190440&#39;&amp;gt;
              &amp;lt;img/&amp;gt;
            &amp;lt;/a&amp;gt;
            &amp;lt;br/&amp;gt;
            &amp;lt;div style=&#39;text-align: center&#39;&amp;gt;
              &amp;lt;a href=&#39;http://www.amazon.com/dp/0134190440&#39;&amp;gt;
                &amp;lt;img/&amp;gt;
              &amp;lt;/a&amp;gt;
              &amp;lt;a href=&#39;http://www.informit.com/store/go-programming-language-9780134190440&#39;&amp;gt;
                &amp;lt;img/&amp;gt;
              &amp;lt;/a&amp;gt;
              &amp;lt;a href=&#39;http://www.barnesandnoble.com/w/1121601944&#39;&amp;gt;
                &amp;lt;img/&amp;gt;
              &amp;lt;/a&amp;gt;
            &amp;lt;/div&amp;gt;
            &amp;lt;br/&amp;gt;
          &amp;lt;/td&amp;gt;
          &amp;lt;td width=&#39;500&#39;&amp;gt;
            &amp;lt;h1 class=&#39;center&#39;&amp;gt;
            &amp;lt;/h1&amp;gt;
            &amp;lt;p class=&#39;biblio center&#39;&amp;gt;
              &amp;lt;br/&amp;gt;
              &amp;lt;br/&amp;gt;
              &amp;lt;br/&amp;gt;
              &amp;lt;tt&amp;gt;
              &amp;lt;/tt&amp;gt;
              &amp;lt;tt&amp;gt;
              &amp;lt;/tt&amp;gt;
              &amp;lt;tt&amp;gt;
              &amp;lt;/tt&amp;gt;
            &amp;lt;/p&amp;gt;
            &amp;lt;div id=&#39;toc&#39;&amp;gt;
              &amp;lt;table&amp;gt;
                &amp;lt;tbody&amp;gt;
                  &amp;lt;tr&amp;gt;
                    &amp;lt;td&amp;gt;
                      &amp;lt;h1&amp;gt;
                        &amp;lt;a href=&#39;ch1.pdf&#39;&amp;gt;
                        &amp;lt;/a&amp;gt;
                      &amp;lt;/h1&amp;gt;
                      &amp;lt;h1&amp;gt;
                        &amp;lt;a href=&#39;ch1.pdf&#39;&amp;gt;
                        &amp;lt;/a&amp;gt;
                      &amp;lt;/h1&amp;gt;
                      &amp;lt;h1&amp;gt;
                        &amp;lt;a href=&#39;ch1.pdf&#39;&amp;gt;
                        &amp;lt;/a&amp;gt;
                      &amp;lt;/h1&amp;gt;
                      &amp;lt;h1&amp;gt;
                      &amp;lt;/h1&amp;gt;
                      &amp;lt;h1&amp;gt;
                      &amp;lt;/h1&amp;gt;
                      &amp;lt;h1&amp;gt;
                      &amp;lt;/h1&amp;gt;
                      &amp;lt;h1&amp;gt;
                      &amp;lt;/h1&amp;gt;
                      &amp;lt;h1&amp;gt;
                      &amp;lt;/h1&amp;gt;
                    &amp;lt;/td&amp;gt;
                    &amp;lt;td&amp;gt;
                      &amp;lt;h1&amp;gt;
                      &amp;lt;/h1&amp;gt;
                      &amp;lt;h1&amp;gt;
                      &amp;lt;/h1&amp;gt;
                      &amp;lt;h1&amp;gt;
                      &amp;lt;/h1&amp;gt;
                      &amp;lt;h1&amp;gt;
                      &amp;lt;/h1&amp;gt;
                      &amp;lt;h1&amp;gt;
                      &amp;lt;/h1&amp;gt;
                      &amp;lt;h1&amp;gt;
                      &amp;lt;/h1&amp;gt;
                      &amp;lt;h1&amp;gt;
                      &amp;lt;/h1&amp;gt;
                      &amp;lt;h1&amp;gt;
                        &amp;lt;a href=&#39;ch1.pdf&#39;&amp;gt;
                        &amp;lt;/a&amp;gt;
                      &amp;lt;/h1&amp;gt;
                    &amp;lt;/td&amp;gt;
                  &amp;lt;/tr&amp;gt;
                  &amp;lt;tr&amp;gt;
                    &amp;lt;td colspan=&#39;2&#39;&amp;gt;
                      &amp;lt;h1&amp;gt;
                        &amp;lt;a href=&#39;https://github.com/adonovan/gopl.io/&#39;&amp;gt;
                        &amp;lt;/a&amp;gt;
                        &amp;lt;a href=&#39;reviews.html&#39;&amp;gt;
                        &amp;lt;/a&amp;gt;
                        &amp;lt;a href=&#39;translations.html&#39;&amp;gt;
                        &amp;lt;/a&amp;gt;
                        &amp;lt;a href=&#39;errata.html&#39;&amp;gt;
                        &amp;lt;/a&amp;gt;
                      &amp;lt;/h1&amp;gt;
                    &amp;lt;/td&amp;gt;
                  &amp;lt;/tr&amp;gt;
                &amp;lt;/tbody&amp;gt;
              &amp;lt;/table&amp;gt;
            &amp;lt;/div&amp;gt;
            &amp;lt;p class=&#39;bio&#39;&amp;gt;
              &amp;lt;a href=&#39;http://golang.org/s/oracle-user-manual&#39;&amp;gt;
                &amp;lt;code&amp;gt;
                &amp;lt;/code&amp;gt;
              &amp;lt;/a&amp;gt;
              &amp;lt;a href=&#39;http://golang.org/lib/godoc/analysis/help.html&#39;&amp;gt;
                &amp;lt;code&amp;gt;
                &amp;lt;/code&amp;gt;
              &amp;lt;/a&amp;gt;
              &amp;lt;a href=&#39;https://github.com/golang/tools/blob/master/refactor/eg/eg.go&#39;&amp;gt;
                &amp;lt;code&amp;gt;
                &amp;lt;/code&amp;gt;
              &amp;lt;/a&amp;gt;
              &amp;lt;a href=&#39;https://github.com/golang/tools/blob/master/refactor/rename/rename.go&#39;&amp;gt;
                &amp;lt;code&amp;gt;
                &amp;lt;/code&amp;gt;
              &amp;lt;/a&amp;gt;
            &amp;lt;/p&amp;gt;
            &amp;lt;p class=&#39;bio&#39;&amp;gt;
              &amp;lt;a href=&#39;http://www.amazon.com/dp/0131103628?tracking_id=disfordig-20&#39;&amp;gt;
              &amp;lt;/a&amp;gt;
              &amp;lt;a href=&#39;http://www.amazon.com/dp/020161586X?tracking_id=disfordig-20&#39;&amp;gt;
              &amp;lt;/a&amp;gt;
            &amp;lt;/p&amp;gt;
          &amp;lt;/td&amp;gt;
        &amp;lt;/tr&amp;gt;
      &amp;lt;/tbody&amp;gt;
    &amp;lt;/table&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;遍历TextNode时，含有很多空节点（其实就是空格，也当成了一个节点），或许应该在parse阶段就抛弃这些不是节点的节点。本习题中，我暂时借用了元素节点的字段&lt;code&gt;DataAtom  atom.Atom&lt;/code&gt;，若为0，则说明该节点标签无法识别。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;// A Node consists of a NodeType and some Data (tag name for element nodes,
// content for text) and are part of a tree of Nodes. Element nodes may also
// have a Namespace and contain a slice of Attributes. Data is unescaped, so
// that it looks like &amp;ldquo;a&amp;lt;b&amp;rdquo; rather than &amp;ldquo;a&amp;lt;b&amp;rdquo;. For element nodes, DataAtom
// is the atom for Data, or zero if Data is not a known tag name.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;ex-5-8&#34;&gt;Ex 5.8&lt;/h3&gt;

&lt;p&gt;Modify forEachNode so that the pre and post functions return a boolean re indicating whether to continue the traversal. Use it to write a function ElementByID with the following signature that ﬁnds the ﬁrst HTML element with the speciﬁed id attribute. The function should stop the traversal as soon as a match is found.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;func ElementByID(doc *html.Node, id string) *html.Node&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;log&amp;quot;
	&amp;quot;net/http&amp;quot;
	&amp;quot;os&amp;quot;

	&amp;quot;golang.org/x/net/html&amp;quot;
)

var custID = &amp;quot;css_index_result&amp;quot;

//var custID = &amp;quot;toc&amp;quot;

func main() {
	for _, url := range os.Args[1:] {
		outline(url)
	}
}

func outline(url string) error {
	resp, err := http.Get(url)
	if err != nil {
		return err
	}
	defer resp.Body.Close()
	doc, err := html.Parse(resp.Body)
	if err != nil {
		return err
	}
	//forEachNode(doc, &amp;quot;&amp;quot;, startElement, endElement)
	fmt.Printf(&amp;quot;%#v:\n&amp;quot;, getElementByID(doc, custID))
	return nil
}

func forEachNode(n *html.Node, id string, pre, post func(n *html.Node, id string) bool) *html.Node {
	var rtn *html.Node
	if pre != nil {
		if !pre(n, id) {
			rtn = n
		}
	}
	for c := n.FirstChild; c != nil &amp;amp;&amp;amp; rtn == nil; c = c.NextSibling {
		rtn = forEachNode(c, id, pre, post)
	}
	if post != nil {
		if !post(n, id) {
			rtn = n
		}
	}
	return rtn
}

var depth int

func startElement(n *html.Node, id string) bool {
	if n.Type == html.ElementNode ||
		n.Type == html.TextNode ||
		n.Type == html.CommentNode {
		if n.DataAtom != 0 { //去除无法识别标签的节点，如空白的textnode等
			var attr string
			for _, v := range n.Attr {
				attr += &amp;quot; &amp;quot; + v.Key + &amp;quot;=&#39;&amp;quot; + v.Val + &amp;quot;&#39;&amp;quot;
			}
			if n.FirstChild == nil {
				fmt.Printf(&amp;quot;%*s&amp;lt;%s/&amp;gt;\n&amp;quot;, depth*2, &amp;quot;&amp;quot;, n.Data)
			} else {
				fmt.Printf(&amp;quot;%*s&amp;lt;%s%s&amp;gt;\n&amp;quot;, depth*2, &amp;quot;&amp;quot;, n.Data, attr)
			}
			depth++
		}
		if n.Type == html.ElementNode {
			for _, v := range n.Attr {
				if v.Key == &amp;quot;id&amp;quot; &amp;amp;&amp;amp; v.Val == id {
					log.Printf(&amp;quot;%#v\n&amp;quot;, n)
					return false
				}
			}
		}
	}
	return true
}
func endElement(n *html.Node, id string) bool {
	if n.Type == html.ElementNode ||
		n.Type == html.TextNode ||
		n.Type == html.CommentNode {
		if n.DataAtom != 0 {
			depth--
			if n.FirstChild != nil {
				fmt.Printf(&amp;quot;%*s&amp;lt;/%s&amp;gt;\n&amp;quot;, depth*2, &amp;quot;&amp;quot;, n.Data)
			}
		}
	}
	return true
}

func getElementByID(doc *html.Node, id string) *html.Node {
	return forEachNode(doc, id, startElement, endElement)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./ex5.7 http://www.baidu.com
&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;meta/&amp;gt;
    &amp;lt;meta/&amp;gt;
    &amp;lt;meta/&amp;gt;
    &amp;lt;meta/&amp;gt;
    &amp;lt;link/&amp;gt;
    &amp;lt;link/&amp;gt;
    &amp;lt;link/&amp;gt;
    &amp;lt;link/&amp;gt;
    &amp;lt;link/&amp;gt;
    &amp;lt;link/&amp;gt;
    &amp;lt;link/&amp;gt;
    &amp;lt;link/&amp;gt;
    &amp;lt;link/&amp;gt;
    &amp;lt;link/&amp;gt;
    &amp;lt;link/&amp;gt;
    &amp;lt;title&amp;gt;
    &amp;lt;/title&amp;gt;
    &amp;lt;style id=&#39;css_index&#39; index=&#39;index&#39; type=&#39;text/css&#39;&amp;gt;
    &amp;lt;/style&amp;gt;
    &amp;lt;style data-for=&#39;debug&#39;&amp;gt;
    &amp;lt;/style&amp;gt;
    &amp;lt;style data-for=&#39;result&#39; id=&#39;css_index_result&#39; type=&#39;text/css&#39;&amp;gt;
2018/01/02 17:53:11 &amp;amp;html.Node{Parent:(*html.Node)(0xc4201322a0), FirstChild:(*html.Node)(0xc4201336c0), LastChild:(*html.Node)(0xc4201336c0), PrevSibling:(*html.Node)(0xc4201335e0), NextSibling:(*html.Node)(0xc420133730), Type:0x3, DataAtom:0x6f905, Data:&amp;quot;style&amp;quot;, Namespace:&amp;quot;&amp;quot;, Attr:[]html.Attribute{html.Attribute{Namespace:&amp;quot;&amp;quot;, Key:&amp;quot;data-for&amp;quot;, Val:&amp;quot;result&amp;quot;}, html.Attribute{Namespace:&amp;quot;&amp;quot;, Key:&amp;quot;id&amp;quot;, Val:&amp;quot;css_index_result&amp;quot;}, html.Attribute{Namespace:&amp;quot;&amp;quot;, Key:&amp;quot;type&amp;quot;, Val:&amp;quot;text/css&amp;quot;}}}
    &amp;lt;/style&amp;gt;
  &amp;lt;/head&amp;gt;
&amp;lt;/html&amp;gt;
&amp;amp;html.Node{Parent:(*html.Node)(0xc4201322a0), FirstChild:(*html.Node)(0xc4201336c0), LastChild:(*html.Node)(0xc4201336c0), PrevSibling:(*html.Node)(0xc4201335e0), NextSibling:(*html.Node)(0xc420133730), Type:0x3, DataAtom:0x6f905, Data:&amp;quot;style&amp;quot;, Namespace:&amp;quot;&amp;quot;, Attr:[]html.Attribute{html.Attribute{Namespace:&amp;quot;&amp;quot;, Key:&amp;quot;data-for&amp;quot;, Val:&amp;quot;result&amp;quot;}, html.Attribute{Namespace:&amp;quot;&amp;quot;, Key:&amp;quot;id&amp;quot;, Val:&amp;quot;css_index_result&amp;quot;}, html.Attribute{Namespace:&amp;quot;&amp;quot;, Key:&amp;quot;type&amp;quot;, Val:&amp;quot;text/css&amp;quot;}}}:
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ex-5-12&#34;&gt;Ex 5.12&lt;/h3&gt;

&lt;p&gt;The startElement and endElement functions in gopl.io/ch5/outline2 (§5.5) share a global variable, depth. Turn them into anonymous functions that share a variable local to the outline function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Copyright © 2016 Alan A. A. Donovan &amp;amp; Brian W. Kernighan.
// License: https://creativecommons.org/licenses/by-nc-sa/4.0/

// See page 133.

// Outline prints the outline of an HTML document tree.
package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;net/http&amp;quot;
	&amp;quot;os&amp;quot;

	&amp;quot;golang.org/x/net/html&amp;quot;
)

func main() {
	for _, url := range os.Args[1:] {
		outline(url)
	}
}

func outline(url string) error {
	resp, err := http.Get(url)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	doc, err := html.Parse(resp.Body)
	if err != nil {
		return err
	}
	var depth int
	startElement := func(n *html.Node) {
		if n.Type == html.ElementNode {
			fmt.Printf(&amp;quot;%*s&amp;lt;%s&amp;gt;\n&amp;quot;, depth*2, &amp;quot;&amp;quot;, n.Data)
			depth++
		}
	}

	endElement := func(n *html.Node) {
		if n.Type == html.ElementNode {
			depth--
			fmt.Printf(&amp;quot;%*s&amp;lt;/%s&amp;gt;\n&amp;quot;, depth*2, &amp;quot;&amp;quot;, n.Data)
		}
	}
	//!+call
	forEachNode(doc, startElement, endElement)
	//!-call

	return nil
}

//!+forEachNode
// forEachNode calls the functions pre(x) and post(x) for each node
// x in the tree rooted at n. Both functions are optional.
// pre is called before the children are visited (preorder) and
// post is called after (postorder).
func forEachNode(n *html.Node, pre, post func(n *html.Node)) {
	if pre != nil {
		pre(n)
	}

	for c := n.FirstChild; c != nil; c = c.NextSibling {
		forEachNode(c, pre, post)
	}

	if post != nil {
		post(n)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ex-5-13&#34;&gt;Ex 5.13&lt;/h3&gt;

&lt;p&gt;Modify crawl to make local copies of the pages it ﬁnds, creating directories as necessary. Don’t make copies of pages that come from a different domain. For example, if the original page comes from golang.org, save all ﬁles from there, but exclude ones from vimeo.com.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;io&amp;quot;
	&amp;quot;log&amp;quot;
	&amp;quot;net/http&amp;quot;
	&amp;quot;net/url&amp;quot;
	&amp;quot;os&amp;quot;
	&amp;quot;strconv&amp;quot;
	&amp;quot;strings&amp;quot;
	&amp;quot;time&amp;quot;

	&amp;quot;golang.org/x/net/html&amp;quot;
	&amp;quot;gopl.io/ch5/links&amp;quot;
)

// Extract makes an HTTP GET request to the specified URL, parses
// the response as HTML, and returns the links in the HTML document.
func Extract(urlstr string) ([]string, error) {
	resp, err := http.Get(urlstr)
	if err != nil {
		return nil, err
	}
	if resp.StatusCode != http.StatusOK {
		resp.Body.Close()
		return nil, fmt.Errorf(&amp;quot;getting %s: %s&amp;quot;, urlstr, resp.Status)
	}
	doc, err := html.Parse(resp.Body)
	resp.Body.Close()
	if err != nil {
		return nil, fmt.Errorf(&amp;quot;parsing %s as HTML: %v&amp;quot;, urlstr, err)
	}
	var links []string
	visitNode := func(n *html.Node) {
		if n.Type == html.ElementNode &amp;amp;&amp;amp; n.Data == &amp;quot;a&amp;quot; {
			for _, a := range n.Attr {
				if a.Key != &amp;quot;href&amp;quot; {
					continue
				}
				link, err := resp.Request.URL.Parse(a.Val)
				if err != nil {
					continue // ignore bad URLs
				}
				links = append(links, link.String())
			}
		}
	}
	forEachNode(doc, visitNode, nil)
	return links, nil
}

//!-Extract

// Copied from gopl.io/ch5/outline2.
func forEachNode(n *html.Node, pre, post func(n *html.Node)) {
	if pre != nil {
		pre(n)
	}
	for c := n.FirstChild; c != nil; c = c.NextSibling {
		forEachNode(c, pre, post)
	}
	if post != nil {
		post(n)
	}
}

func breadthFirst(f func(item string, host []string) []string, worklist []string) {
	seen := make(map[string]bool)
	host := make([]string, len(worklist))
	for i, v := range worklist {
		u, err := url.Parse(v)
		if err != nil {
			fmt.Println(&amp;quot;initial url parse failed&amp;quot;)
			return
		}
		host[i] = u.Host
	}
	for len(worklist) &amp;gt; 0 {
		items := worklist
		worklist = nil
		for _, item := range items {
			if !seen[item] {
				seen[item] = true
				worklist = append(worklist, f(item, host)...)
			}
		}
	}
}

//!-breadthFirst

//!+crawl
func crawl(urlstr string, sl []string) []string {
	fmt.Println(urlstr)
	copycontent(urlstr, sl)
	list, err := links.Extract(urlstr)
	if err != nil {
		log.Print(err)
	}
	return list
}

func copycontent(s string, sl []string) {
	u, err := url.Parse(s)
	if err != nil {
		fmt.Println(&amp;quot;url parse failed&amp;quot;)
		return
	}
	for _, v := range sl {
		if u.Host == v {
			resp, err := http.Get(s)
			if err != nil {
				fmt.Println(err)
				return
			}
			if resp.StatusCode != http.StatusOK {
				resp.Body.Close()
				return
			}
			//fmt.Println(path)
			dir, _ := os.Getwd() //当前的目录
			var filename, filepart, dirpart string
			ns := strings.Count(u.Path, &amp;quot;/&amp;quot;)
			if ns == 0 || ns == 1 &amp;amp;&amp;amp; len(u.Path) == 1 {
				filepart = &amp;quot;&amp;quot;
				filename = strconv.FormatInt(time.Now().Unix(), 10) + &amp;quot;.html&amp;quot;
				dirpart = &amp;quot;/&amp;quot;
			} else {
				filepart = u.Path[strings.LastIndex(u.Path, &amp;quot;/&amp;quot;)+1:]
				dirpart = u.Path[:strings.LastIndex(u.Path, &amp;quot;/&amp;quot;)+1]
				if strings.Contains(filepart, &amp;quot;.&amp;quot;) {
					filename = filepart
				} else {
					dirpart = u.Path
					filename = strconv.FormatInt(time.Now().Unix(), 10) + &amp;quot;.html&amp;quot;
				}
			}

			fullpath := dir + &amp;quot;/&amp;quot; + u.Host + dirpart
			_, err = os.Stat(fullpath)
			if err != nil {
				err = os.MkdirAll(fullpath, os.ModePerm) //在当前目录下生成md目录
				if err != nil {
					fmt.Println(&amp;quot;create folder failed! &amp;quot;, fullpath, err)
					return
				}
			}
			filename = dir + &amp;quot;/&amp;quot; + u.Host + dirpart + &amp;quot;/&amp;quot; + filename
			f, err := os.Create(filename)
			if err != nil {
				fmt.Println(&amp;quot;create file error:&amp;quot;, err, s)
				return
			}
			_, err = io.Copy(f, resp.Body)
			if err != nil {
				fmt.Println(&amp;quot;failed in copy&amp;quot;)
				return
			}
			resp.Body.Close()
		}
	}
}
func main() {
	breadthFirst(crawl, os.Args[1:])
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>The Go Programming Language Ex（5）</title>
      <link>https://mooncaker816.github.io/2017/12/24/the-go-programming-language-ex5/</link>
      <pubDate>Sun, 24 Dec 2017 19:00:00 +0000</pubDate>
      
      <guid>https://mooncaker816.github.io/2017/12/24/the-go-programming-language-ex5/</guid>
      <description>&lt;h3 id=&#34;ex-4-8&#34;&gt;Ex 4.8&lt;/h3&gt;

&lt;p&gt;Modify charcount to count letters, digits, and so on in their Unicode categories, using functions like unicode.IsLetter.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;bufio&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;io&amp;quot;
	&amp;quot;os&amp;quot;
	&amp;quot;unicode&amp;quot;
)

func main() {
	counts := make(map[string]int)                       // counts of Unicode characters
	invalid, letter, digit, mark, other := 0, 0, 0, 0, 0 // count of invalid UTF-8 characters

	in := bufio.NewReader(os.Stdin)
	for {
		r, n, err := in.ReadRune() // returns rune, nbytes, error
		if err == io.EOF {
			break
		}
		if err != nil {
			fmt.Fprintf(os.Stderr, &amp;quot;charcount: %v\n&amp;quot;, err)
			os.Exit(1)
		}
		if r == unicode.ReplacementChar &amp;amp;&amp;amp; n == 1 {
			invalid++
			continue
		} else if unicode.IsLetter(r) {
			letter++
		} else if unicode.IsDigit(r) {
			digit++
		} else if unicode.IsMark(r) {
			mark++
		} else {
			other++
			fmt.Println(r)
		}
	}
	counts[&amp;quot;invalid&amp;quot;] = invalid
	counts[&amp;quot;letter&amp;quot;] = letter
	counts[&amp;quot;digit&amp;quot;] = digit
	counts[&amp;quot;mark&amp;quot;] = mark
	counts[&amp;quot;other&amp;quot;] = other

	for c, n := range counts {
		fmt.Printf(&amp;quot;%s\t:%d\n&amp;quot;, c, n)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;./ex4.8
sdfwwer 1434jipi三是奇偶i问
32
10
invalid	:0
letter	:17
digit	:4
mark	:0
other	:2
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;显然汉字也被认为是letter&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;终端模拟EOF 为 ctrl + d&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;ex-4-9&#34;&gt;Ex 4.9&lt;/h3&gt;

&lt;p&gt;Write a program wordfreq to report the frequency of each word in an input text ﬁle. Call input.Split(bufio.ScanWords) before the ﬁrst call to Scan to break the input into words instead of lines.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;bufio&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;strings&amp;quot;
)

func main() {
	words := make(map[string]int)
	input := &amp;quot;foo  bar   baz foo 我们 foo 我们&amp;quot;
	scanner := bufio.NewScanner(strings.NewReader(input))
	scanner.Split(bufio.ScanWords)
	for scanner.Scan() {
		//fmt.Println(scanner.Text())
		words[scanner.Text()]++
	}
	for k, v := range words {
		fmt.Printf(&amp;quot;%s : %d\n&amp;quot;, k, v)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ go run wordfreq.go
baz : 1
我们 : 2
foo : 3
bar : 1
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ex4-13&#34;&gt;Ex4.13&lt;/h3&gt;

&lt;p&gt;The JSON-based web service of the Open Movie Database lets you s &lt;a href=&#34;https://omdbapi.com/&#34; target=&#34;_blank&#34;&gt;https://omdbapi.com/&lt;/a&gt; for a movie by name and download its poster image. Write a tool poster that downloads the poster image for the movie named on the command line.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;encoding/json&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;io&amp;quot;
	&amp;quot;net/http&amp;quot;
	&amp;quot;os&amp;quot;
)

const OmdbAPI = &amp;quot;http://www.omdbapi.com/?i=tt3896198&amp;amp;apikey=7b94e6bd&amp;amp;t=&amp;quot;

type Movie struct {
	Title    string
	Year     string
	Poster   string
	Response string
	Errormsg string `json:&amp;quot;Error,omitempty&amp;quot;`
}

func main() {
	for i := 1; i &amp;lt; len(os.Args); i++ {
		url := OmdbAPI + os.Args[i]
		resp, err := http.Get(url)
		if err != nil {
			fmt.Println(&amp;quot;http get error &amp;quot;, err)
			return
		}
		defer resp.Body.Close()
		var result Movie
		err = json.NewDecoder(resp.Body).Decode(&amp;amp;result)
		if err != nil {
			fmt.Println(&amp;quot;decode failed&amp;quot;)
			return
		}
		fmt.Printf(&amp;quot;%#v\n&amp;quot;, result)
		fmt.Printf(&amp;quot;%v\n&amp;quot;, result)
		if result.Response == &amp;quot;false&amp;quot; {
			fmt.Println(result.Errormsg)
		} else {
			fmt.Println(&amp;quot;starting download poster&amp;quot;)
			result.Poster = &amp;quot;https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike92%2C5%2C5%2C92%2C30/sign=5a60b1a4cf8065386fe7ac41f6b4ca21/fd039245d688d43f4ee7a518781ed21b0ff43b89.jpg&amp;quot;
			posterres, err := http.Get(result.Poster)
			if err != nil {
				fmt.Println(&amp;quot;get poster url error, download failed&amp;quot;, err)
				return
			} else {
				filename := result.Title + &amp;quot;.jpg&amp;quot;
				f, err := os.Create(filename)
				if err != nil {
					fmt.Println(&amp;quot;create file error&amp;quot;)
					return
				}
				io.Copy(f, posterres.Body)
			}
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./ex4.13 triangle triangleeeee
main.Movie{Title:&amp;quot;Triangle&amp;quot;, Year:&amp;quot;2009&amp;quot;, Poster:&amp;quot;https://images-na.ssl-images-amazon.com/images/M/MV5BY2VlODI5ZmMtZDExYS00OWI4LWJiMWItZWZkZWRkNzlmZWI2XkEyXkFqcGdeQXVyMTQxNzMzNDI@._V1_SX300.jpg&amp;quot;, Response:&amp;quot;True&amp;quot;, Errormsg:&amp;quot;&amp;quot;}
{Triangle 2009 https://images-na.ssl-images-amazon.com/images/M/MV5BY2VlODI5ZmMtZDExYS00OWI4LWJiMWItZWZkZWRkNzlmZWI2XkEyXkFqcGdeQXVyMTQxNzMzNDI@._V1_SX300.jpg True }
starting download poster
download finished
main.Movie{Title:&amp;quot;&amp;quot;, Year:&amp;quot;&amp;quot;, Poster:&amp;quot;&amp;quot;, Response:&amp;quot;False&amp;quot;, Errormsg:&amp;quot;Movie not found!&amp;quot;}
{   False Movie not found!}
Movie not found!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://oumnldfwl.bkt.clouddn.com/ex4.13.png&#34; alt=&#34;Triangle.jpg&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;ex-4-14&#34;&gt;Ex 4.14&lt;/h3&gt;

&lt;p&gt;Create a web server that queries GitHub once and then allows navigation of the list of bug reports, milestones, and users.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;encoding/json&amp;quot;
	&amp;quot;fmt&amp;quot;
	temp2 &amp;quot;html/template&amp;quot;
	&amp;quot;log&amp;quot;
	&amp;quot;net/http&amp;quot;
	&amp;quot;net/url&amp;quot;
	&amp;quot;os&amp;quot;
	&amp;quot;strings&amp;quot;
	temp1 &amp;quot;text/template&amp;quot;
	&amp;quot;time&amp;quot;
)

const IssuesURL = &amp;quot;https://api.github.com/search/issues&amp;quot;

//!+template
const templ1 = `{{.TotalCount}} issues:
{{range .Items}}----------------------------------------
Number: {{.Number}}
User:   {{.User.Login}}
Title:  {{.Title | printf &amp;quot;%.64s&amp;quot;}}
Age:    {{.CreatedAt | daysAgo}} days
Milestone: {{.Milestone.Title}}
{{end}}`
const templ2 = `
&amp;lt;h1&amp;gt;{{.TotalCount}} issues&amp;lt;/h1&amp;gt;
&amp;lt;table&amp;gt;
&amp;lt;tr style=&#39;text-align: left&#39;&amp;gt;
  &amp;lt;th&amp;gt;#&amp;lt;/th&amp;gt;
  &amp;lt;th&amp;gt;State&amp;lt;/th&amp;gt;
  &amp;lt;th&amp;gt;User&amp;lt;/th&amp;gt;
  &amp;lt;th&amp;gt;Title&amp;lt;/th&amp;gt;
  &amp;lt;th&amp;gt;Milestone&amp;lt;/th&amp;gt;
&amp;lt;/tr&amp;gt;
{{range .Items}}
&amp;lt;tr&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;{{.HTMLURL}}&#39;&amp;gt;{{.Number}}&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;{{.State}}&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;{{.User.HTMLURL}}&#39;&amp;gt;{{.User.Login}}&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;{{.HTMLURL}}&#39;&amp;gt;{{.Title}}&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;{{.Milestone.HTMLURL}}&#39;&amp;gt;{{.Milestone.Title}}&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;
{{end}}
&amp;lt;/table&amp;gt;
`

//!-template

type IssuesSearchResult struct {
	TotalCount int `json:&amp;quot;total_count&amp;quot;`
	Items      []*Issue
}

type Issue struct {
	Number    int
	HTMLURL   string `json:&amp;quot;html_url&amp;quot;`
	Title     string
	State     string
	User      *User
	CreatedAt time.Time `json:&amp;quot;created_at&amp;quot;`
	Body      string    // in Markdown format
	Milestone *Milestone
}

type User struct {
	Login   string
	HTMLURL string `json:&amp;quot;html_url&amp;quot;`
}

type Milestone struct {
	Title   string
	HTMLURL string `json:&amp;quot;html_url&amp;quot;`
}

var report1 = temp1.Must(temp1.New(&amp;quot;issuelist1&amp;quot;).
	Funcs(temp1.FuncMap{&amp;quot;daysAgo&amp;quot;: daysAgo}).
	Parse(templ1))
var report2 = temp2.Must(temp2.New(&amp;quot;issuelist2&amp;quot;).
	Funcs(temp2.FuncMap{&amp;quot;daysAgo&amp;quot;: daysAgo}).
	Parse(templ2))

func main() {
	result, err := SearchIssues(os.Args[1:])
	if err != nil {
		log.Fatal(err)
	}
	f1, err := os.Create(&amp;quot;report.txt&amp;quot;)
	if err := report1.Execute(f1, result); err != nil {
		log.Fatal(err)
	}
	f2, err := os.Create(&amp;quot;report.html&amp;quot;)
	if err := report2.Execute(f2, result); err != nil {
		log.Fatal(err)
	}
}

func daysAgo(t time.Time) int {
	return int(time.Since(t).Hours() / 24)
}

// SearchIssues queries the GitHub issue tracker.
func SearchIssues(terms []string) (*IssuesSearchResult, error) {
	q := url.QueryEscape(strings.Join(terms, &amp;quot; &amp;quot;))
	resp, err := http.Get(IssuesURL + &amp;quot;?q=&amp;quot; + q)
	if err != nil {
		return nil, err
	}
	// We must close resp.Body on all execution paths.
	// (Chapter 5 presents &#39;defer&#39;, which makes this simpler.)
	if resp.StatusCode != http.StatusOK {
		resp.Body.Close()
		return nil, fmt.Errorf(&amp;quot;search query failed: %s&amp;quot;, resp.Status)
	}
	var result IssuesSearchResult
	if err := json.NewDecoder(resp.Body).Decode(&amp;amp;result); err != nil {
		resp.Body.Close()
		return nil, err
	}
	resp.Body.Close()
	return &amp;amp;result, nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;//report.txt
41 issues:
----------------------------------------
Number: 23188
User:   ianlancetaylor
Title:  cmd/compile: incorrect order of evaluation according to spec
Age:    7 days
Milestone: Go1.11
----------------------------------------
Number: 23183
User:   terinjokes
Title:  net/http: muxer no longer redirects host patterns in go1.10
Age:    7 days
Milestone: Go1.10
----------------------------------------
Number: 23181
User:   hirochachacha
Title:  cmd/buildid: rewrite algorithm is broken
Age:    7 days
Milestone: Go1.10
----------------------------------------
Number: 23180
User:   aarzilli
Title:  cmd/go: go test -c does not apply specified gcflags to all packa
Age:    7 days
Milestone: Go1.10
----------------------------------------
Number: 23166
User:   mvdan
Title:  x/tools/go/ssa/interp: tests consistently failing on darwin
Age:    8 days
Milestone: Go1.10
----------------------------------------
Number: 23146
User:   bradfitz
Title:  cmd/vet: stderr spam during testing
Age:    12 days
Milestone: Go1.10
----------------------------------------
Number: 23122
User:   rsc
Title:  all: remove support for OS X 10.8 and 10.9
Age:    13 days
Milestone: Go1.11
----------------------------------------
Number: 23098
User:   mikioh
Title:  runtime: loop over allp causes a nil pointer dereference crash
Age:    15 days
Milestone: Go1.10
----------------------------------------
Number: 23037
User:   zolotov
Title:  cmd/go: add JSON output for building package failures while runn
Age:    19 days
Milestone: Go1.10
----------------------------------------
Number: 23036
User:   zolotov
Title:  cmd/test2json: filtering out testing service messages or mark th
Age:    19 days
Milestone: Go1.10
----------------------------------------
Number: 23011
User:   bradfitz
Title:  build: announce end of support for old macOS releases
Age:    21 days
Milestone: Go1.11
----------------------------------------
Number: 23010
User:   rsc
Title:  net/http: ResponseWriter panics in WriteHeaders that were former
Age:    21 days
Milestone: Go1.10
----------------------------------------
Number: 23009
User:   rsc
Title:  net/http/httputil: ReverseProxy change conflicts with future Rev
Age:    21 days
Milestone: Go1.10
----------------------------------------
Number: 22984
User:   rsc
Title:  cmd/go: test -json not cached
Age:    22 days
Milestone: Go1.10
----------------------------------------
Number: 22924
User:   chipaca
Title:  syscall: on linux 386 doesn&#39;t support syscalls that don&#39;t fail
Age:    27 days
Milestone: Go1.11
----------------------------------------
Number: 22781
User:   pciet
Title:  runtime: fatal error: sweep increased allocation count, go1.9.x
Age:    39 days
Milestone: Go1.9.3
----------------------------------------
Number: 22637
User:   ianlancetaylor
Title:  crypto: examine and probably remove OpenSSL derived code
Age:    48 days
Milestone: Go1.10
----------------------------------------
Number: 22487
User:   tklauser
Title:  lib/time: update tzdata before 1.10 release
Age:    58 days
Milestone: Go1.10
----------------------------------------
Number: 22475
User:   rsc
Title:  cmd/go: include GOROOT in linkActionID hash
Age:    59 days
Milestone: Go1.10
----------------------------------------
Number: 22472
User:   rsc
Title:  cmd/go: implement gccgo support for content-based staleness
Age:    60 days
Milestone: Go1.10
----------------------------------------
Number: 22444
User:   griesemer
Title:  cmd/compile: missing wrapper function for call of literal method
Age:    62 days
Milestone: Go1.11
----------------------------------------
Number: 22429
User:   TheTincho
Title:  cmd/compile: invalid instruction error for FMOVD when compiling 
Age:    63 days
Milestone: Go1.9.3
----------------------------------------
Number: 22349
User:   alexbrainman
Title:  net: ipStackCapabilities.probe creates sockets that can escape i
Age:    68 days
Milestone: Go1.10
----------------------------------------
Number: 22224
User:   siebenmann
Title:  cmd/go: build failure on amd64 Linux with an error in TestTwoGop
Age:    76 days
Milestone: Go1.10
----------------------------------------
Number: 22204
User:   tmm1
Title:  runtime: sigpanic during GC on android/arm64
Age:    77 days
Milestone: Go1.10
----------------------------------------
Number: 22155
User:   rsc
Title:  cmd/go: GOROOT override using linker -X flag is probably not rig
Age:    82 days
Milestone: Go1.10
----------------------------------------
Number: 21431
User:   josharian
Title:  runtime: stack split at a bad time on mipsle
Age:    135 days
Milestone: Go1.10
----------------------------------------
Number: 21282
User:   dsnet
Title:  cmd/compile: incorrect type assertions on conflicting package na
Age:    146 days
Milestone: Go1.11
----------------------------------------
Number: 21221
User:   vibhavp
Title:  cmd/compile: internal compiler error: constant type mismatch whe
Age:    150 days
Milestone: Go1.11
----------------------------------------
Number: 20790
User:   mikioh
Title:  net: DefaultResolver.Lookup{Host,IPAddr} and LookupHost fail to 
Age:    185 days
Milestone: Go1.11
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;//report.html

&amp;lt;h1&amp;gt;41 issues&amp;lt;/h1&amp;gt;
&amp;lt;table&amp;gt;
&amp;lt;tr style=&#39;text-align: left&#39;&amp;gt;
  &amp;lt;th&amp;gt;#&amp;lt;/th&amp;gt;
  &amp;lt;th&amp;gt;State&amp;lt;/th&amp;gt;
  &amp;lt;th&amp;gt;User&amp;lt;/th&amp;gt;
  &amp;lt;th&amp;gt;Title&amp;lt;/th&amp;gt;
  &amp;lt;th&amp;gt;Milestone&amp;lt;/th&amp;gt;
&amp;lt;/tr&amp;gt;

&amp;lt;tr&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/23188&#39;&amp;gt;23188&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;open&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/ianlancetaylor&#39;&amp;gt;ianlancetaylor&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/23188&#39;&amp;gt;cmd/compile: incorrect order of evaluation according to spec&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/milestone/62&#39;&amp;gt;Go1.11&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;

&amp;lt;tr&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/23183&#39;&amp;gt;23183&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;open&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/terinjokes&#39;&amp;gt;terinjokes&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/23183&#39;&amp;gt;net/http: muxer no longer redirects host patterns in go1.10&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/milestone/56&#39;&amp;gt;Go1.10&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;

&amp;lt;tr&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/23181&#39;&amp;gt;23181&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;open&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/hirochachacha&#39;&amp;gt;hirochachacha&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/23181&#39;&amp;gt;cmd/buildid: rewrite algorithm is broken&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/milestone/56&#39;&amp;gt;Go1.10&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;

&amp;lt;tr&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/23180&#39;&amp;gt;23180&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;open&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/aarzilli&#39;&amp;gt;aarzilli&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/23180&#39;&amp;gt;cmd/go: go test -c does not apply specified gcflags to all packages&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/milestone/56&#39;&amp;gt;Go1.10&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;

&amp;lt;tr&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/23166&#39;&amp;gt;23166&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;open&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/mvdan&#39;&amp;gt;mvdan&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/23166&#39;&amp;gt;x/tools/go/ssa/interp: tests consistently failing on darwin&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/milestone/56&#39;&amp;gt;Go1.10&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;

&amp;lt;tr&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/23146&#39;&amp;gt;23146&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;open&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/bradfitz&#39;&amp;gt;bradfitz&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/23146&#39;&amp;gt;cmd/vet: stderr spam during testing&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/milestone/56&#39;&amp;gt;Go1.10&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;

&amp;lt;tr&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/23122&#39;&amp;gt;23122&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;open&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/rsc&#39;&amp;gt;rsc&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/23122&#39;&amp;gt;all: remove support for OS X 10.8 and 10.9&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/milestone/62&#39;&amp;gt;Go1.11&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;

&amp;lt;tr&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/23098&#39;&amp;gt;23098&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;open&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/mikioh&#39;&amp;gt;mikioh&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/23098&#39;&amp;gt;runtime: loop over allp causes a nil pointer dereference crash&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/milestone/56&#39;&amp;gt;Go1.10&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;

&amp;lt;tr&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/23037&#39;&amp;gt;23037&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;open&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/zolotov&#39;&amp;gt;zolotov&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/23037&#39;&amp;gt;cmd/go: add JSON output for building package failures while running go test on directory with several packages&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/milestone/56&#39;&amp;gt;Go1.10&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;

&amp;lt;tr&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/23036&#39;&amp;gt;23036&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;open&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/zolotov&#39;&amp;gt;zolotov&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/23036&#39;&amp;gt;cmd/test2json: filtering out testing service messages or mark them in a special way&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/milestone/56&#39;&amp;gt;Go1.10&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;

&amp;lt;tr&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/23011&#39;&amp;gt;23011&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;open&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/bradfitz&#39;&amp;gt;bradfitz&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/23011&#39;&amp;gt;build: announce end of support for old macOS releases&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/milestone/62&#39;&amp;gt;Go1.11&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;

&amp;lt;tr&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/23010&#39;&amp;gt;23010&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;open&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/rsc&#39;&amp;gt;rsc&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/23010&#39;&amp;gt;net/http: ResponseWriter panics in WriteHeaders that were formerly ignored&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/milestone/56&#39;&amp;gt;Go1.10&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;

&amp;lt;tr&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/23009&#39;&amp;gt;23009&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;open&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/rsc&#39;&amp;gt;rsc&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/23009&#39;&amp;gt;net/http/httputil: ReverseProxy change conflicts with future ReverseProxy plans&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/milestone/56&#39;&amp;gt;Go1.10&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;

&amp;lt;tr&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/22984&#39;&amp;gt;22984&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;open&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/rsc&#39;&amp;gt;rsc&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/22984&#39;&amp;gt;cmd/go: test -json not cached&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/milestone/56&#39;&amp;gt;Go1.10&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;

&amp;lt;tr&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/22924&#39;&amp;gt;22924&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;open&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/chipaca&#39;&amp;gt;chipaca&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/22924&#39;&amp;gt;syscall: on linux 386 doesn&amp;amp;#39;t support syscalls that don&amp;amp;#39;t fail&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/milestone/62&#39;&amp;gt;Go1.11&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;

&amp;lt;tr&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/22781&#39;&amp;gt;22781&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;open&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/pciet&#39;&amp;gt;pciet&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/22781&#39;&amp;gt;runtime: fatal error: sweep increased allocation count, go1.9.x&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/milestone/63&#39;&amp;gt;Go1.9.3&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;

&amp;lt;tr&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/22637&#39;&amp;gt;22637&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;open&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/ianlancetaylor&#39;&amp;gt;ianlancetaylor&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/22637&#39;&amp;gt;crypto: examine and probably remove OpenSSL derived code&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/milestone/56&#39;&amp;gt;Go1.10&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;

&amp;lt;tr&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/22487&#39;&amp;gt;22487&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;open&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/tklauser&#39;&amp;gt;tklauser&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/22487&#39;&amp;gt;lib/time: update tzdata before 1.10 release&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/milestone/56&#39;&amp;gt;Go1.10&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;

&amp;lt;tr&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/22475&#39;&amp;gt;22475&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;open&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/rsc&#39;&amp;gt;rsc&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/22475&#39;&amp;gt;cmd/go: include GOROOT in linkActionID hash&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/milestone/56&#39;&amp;gt;Go1.10&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;

&amp;lt;tr&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/22472&#39;&amp;gt;22472&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;open&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/rsc&#39;&amp;gt;rsc&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/22472&#39;&amp;gt;cmd/go: implement gccgo support for content-based staleness&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/milestone/56&#39;&amp;gt;Go1.10&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;

&amp;lt;tr&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/22444&#39;&amp;gt;22444&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;open&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/griesemer&#39;&amp;gt;griesemer&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/22444&#39;&amp;gt;cmd/compile: missing wrapper function for call of literal method expression&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/milestone/62&#39;&amp;gt;Go1.11&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;

&amp;lt;tr&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/22429&#39;&amp;gt;22429&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;open&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/TheTincho&#39;&amp;gt;TheTincho&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/22429&#39;&amp;gt;cmd/compile: invalid instruction error for FMOVD when compiling for 387&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/milestone/63&#39;&amp;gt;Go1.9.3&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;

&amp;lt;tr&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/22349&#39;&amp;gt;22349&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;open&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/alexbrainman&#39;&amp;gt;alexbrainman&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/22349&#39;&amp;gt;net: ipStackCapabilities.probe creates sockets that can escape into child process&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/milestone/56&#39;&amp;gt;Go1.10&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;

&amp;lt;tr&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/22224&#39;&amp;gt;22224&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;open&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/siebenmann&#39;&amp;gt;siebenmann&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/22224&#39;&amp;gt;cmd/go: build failure on amd64 Linux with an error in TestTwoGopathShlibsGccgo from CL 69831  onward&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/milestone/56&#39;&amp;gt;Go1.10&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;

&amp;lt;tr&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/22204&#39;&amp;gt;22204&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;open&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/tmm1&#39;&amp;gt;tmm1&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/22204&#39;&amp;gt;runtime: sigpanic during GC on android/arm64&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/milestone/56&#39;&amp;gt;Go1.10&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;

&amp;lt;tr&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/22155&#39;&amp;gt;22155&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;open&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/rsc&#39;&amp;gt;rsc&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/22155&#39;&amp;gt;cmd/go: GOROOT override using linker -X flag is probably not right&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/milestone/56&#39;&amp;gt;Go1.10&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;

&amp;lt;tr&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/21431&#39;&amp;gt;21431&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;open&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/josharian&#39;&amp;gt;josharian&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/21431&#39;&amp;gt;runtime: stack split at a bad time on mipsle&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/milestone/56&#39;&amp;gt;Go1.10&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;

&amp;lt;tr&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/21282&#39;&amp;gt;21282&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;open&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/dsnet&#39;&amp;gt;dsnet&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/21282&#39;&amp;gt;cmd/compile: incorrect type assertions on conflicting package names&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/milestone/62&#39;&amp;gt;Go1.11&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;

&amp;lt;tr&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/21221&#39;&amp;gt;21221&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;open&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/vibhavp&#39;&amp;gt;vibhavp&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/21221&#39;&amp;gt;cmd/compile: internal compiler error: constant type mismatch when comparing two unsafe.Pointer rvalues&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/milestone/62&#39;&amp;gt;Go1.11&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;

&amp;lt;tr&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/20790&#39;&amp;gt;20790&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;open&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/mikioh&#39;&amp;gt;mikioh&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/20790&#39;&amp;gt;net: DefaultResolver.Lookup{Host,IPAddr} and LookupHost fail to parse a literal IPv6 address w/ zone&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/milestone/62&#39;&amp;gt;Go1.11&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;

&amp;lt;/table&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://oumnldfwl.bkt.clouddn.com/ex4.14.png&#34; alt=&#34;ex4.14 report.html&#34; /&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>The Go Programming Language Ex（4）</title>
      <link>https://mooncaker816.github.io/2017/12/23/the-go-programming-language-ex4/</link>
      <pubDate>Sat, 23 Dec 2017 19:00:00 +0000</pubDate>
      
      <guid>https://mooncaker816.github.io/2017/12/23/the-go-programming-language-ex4/</guid>
      <description>&lt;h3 id=&#34;ex-4-1&#34;&gt;Ex 4.1&lt;/h3&gt;

&lt;p&gt;Write a function that counts the number of bits that are different in two SHA256 hashes. (See PopCount from Section 2.6.2.)&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;crypto/sha256&amp;quot;
	&amp;quot;fmt&amp;quot;
)

func main() {
	str1 := &amp;quot;abc&amp;quot;
	str2 := &amp;quot;xyz&amp;quot;
	hash1 := sha256.Sum256([]byte(str1))
	hash2 := sha256.Sum256([]byte(str2))
	var dif int
	for i := 0; i &amp;lt; 32; i++ {
		dif += popcount(hash1[i] ^ hash2[i])
	}
	fmt.Printf(&amp;quot;there are %d different bits between these 2 hashes\n&amp;quot;, dif)
}

func popcount(x byte) int {
	var count int
	for x != 0 {
		count++
		x &amp;amp;= x - 1
	}
	return count
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ go run difhash.go
there are 121 different bits between these 2 hashes
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ex-4-2&#34;&gt;Ex 4.2&lt;/h3&gt;

&lt;p&gt;Write a program that prints the SHA256 hash of its standard input by default but supports a command-line ﬂag to print the SHA384 or SHA512 hash instead.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;crypto/sha256&amp;quot;
	&amp;quot;crypto/sha512&amp;quot;
	&amp;quot;flag&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;log&amp;quot;
)

func main() {
	method := flag.String(&amp;quot;sha&amp;quot;, &amp;quot;256&amp;quot;, &amp;quot;default is SHA256, optional 384,512&amp;quot;)
	flag.Parse()
	//去掉flag参数后剩余的输入参数，此处为需要计算hash的字符串
	fmt.Printf(&amp;quot;there are %d non-flag input params\n&amp;quot;, flag.NArg())
	for i, str := range flag.Args() {
		switch *method {
		case &amp;quot;256&amp;quot;:
			c := sha256.Sum256([]byte(str))
			fmt.Printf(&amp;quot;#%d:SHA256 of %s is %x\n&amp;quot;, i, str, c)
		case &amp;quot;384&amp;quot;:
			c := sha512.Sum384([]byte(str))
			fmt.Printf(&amp;quot;#%d:SHA384 of %s is %x\n&amp;quot;, i, str, c)
		case &amp;quot;512&amp;quot;:
			c := sha512.Sum512([]byte(str))
			fmt.Printf(&amp;quot;#%d:SHA512 of %s is %x\n&amp;quot;, i, str, c)
		default:
			log.Fatal(&amp;quot;not support&amp;quot;)
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./ex4.2 -sha 256 a b c abc
there are 4 non-flag input params
#0:SHA256 of a is ca978112ca1bbdcafac231b39a23dc4da786eff8147c4e72b9807785afee48bb
#1:SHA256 of b is 3e23e8160039594a33894f6564e1b1348bbd7a0088d42c4acb73eeaed59c009d
#2:SHA256 of c is 2e7d2c03a9507ae265ecf5b5356885a53393a2029d241394997265a1a25aefc6
#3:SHA256 of abc is ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad
$ ./ex4.2 -sha 384 a b c abc
there are 4 non-flag input params
#0:SHA384 of a is 54a59b9f22b0b80880d8427e548b7c23abd873486e1f035dce9cd697e85175033caa88e6d57bc35efae0b5afd3145f31
#1:SHA384 of b is 98a906182cdcfb1eb4eb47117600f68958e2ddd140248b47984f4bde6587b89c8215c3da895a336e94ad1aca39015c40
#2:SHA384 of c is 40f98a05660bf871802ee59964de1945bd731a45cc7f48e4dadd92f34a7eeec089e149ad8c2434f11792e588b740d997
#3:SHA384 of abc is cb00753f45a35e8bb5a03d699ac65007272c32ab0eded1631a8b605a43ff5bed8086072ba1e7cc2358baeca134c825a7
$ ./ex4.2 -sha 512 a b c abc
there are 4 non-flag input params
#0:SHA512 of a is 1f40fc92da241694750979ee6cf582f2d5d7d28e18335de05abc54d0560e0f5302860c652bf08d560252aa5e74210546f369fbbbce8c12cfc7957b2652fe9a75
#1:SHA512 of b is 5267768822ee624d48fce15ec5ca79cbd602cb7f4c2157a516556991f22ef8c7b5ef7b18d1ff41c59370efb0858651d44a936c11b7b144c48fe04df3c6a3e8da
#2:SHA512 of c is acc28db2beb7b42baa1cb0243d401ccb4e3fce44d7b02879a52799aadff541522d8822598b2fa664f9d5156c00c924805d75c3868bd56c2acb81d37e98e35adc
#3:SHA512 of abc is ddaf35a193617abacc417349ae20413112e6fa4e89a97ea20a9eeee64b55d39a2192992a274fc1a836ba3c23a3feebbd454d4423643ce80e2a9ac94fa54ca49f
$ ./ex4.2 -sha 777 a b c abc
there are 4 non-flag input params
2017/12/22 20:53:41 not support
$./ex4.2 a b c abc
there are 4 non-flag input params
#0:SHA256 of a is ca978112ca1bbdcafac231b39a23dc4da786eff8147c4e72b9807785afee48bb
#1:SHA256 of b is 3e23e8160039594a33894f6564e1b1348bbd7a0088d42c4acb73eeaed59c009d
#2:SHA256 of c is 2e7d2c03a9507ae265ecf5b5356885a53393a2029d241394997265a1a25aefc6
#3:SHA256 of abc is ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ex-4-3&#34;&gt;Ex 4.3&lt;/h3&gt;

&lt;p&gt;Rewrite reverse to use an array pointer instead of a slice.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
)

func main() {
	s := [5]byte{1, 2, 3, 4, 5}
	fmt.Println(s)
	reverse(&amp;amp;s)
	fmt.Println(s)
}

func reverse(a *[5]byte) {
	for i, j := 0, len(a)-1; i &amp;lt; j; i, j = i+1, j-1 {
		a[i], a[j] = a[j], a[i]
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ go run reverse.go
[1 2 3 4 5]
[5 4 3 2 1]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ex-4-4&#34;&gt;Ex 4.4&lt;/h3&gt;

&lt;p&gt;Write a version of rotate that operates in a single pass.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;log&amp;quot;
)

func main() {
	s := []int{0, 1, 2, 3, 4, 5, 6, 7, 8}
	rotate(&amp;amp;s, 3)
	fmt.Println(s)
}

func rotate(s *[]int, n int) {
	if n &amp;gt; len(*s) {
		log.Fatal(&amp;quot;invalid rotate num&amp;quot;)
	}
	var ls []int
	ls = append(ls, (*s)[n:]...)
	ls = append(ls, (*s)[:n]...)
	*s = ls
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ go run rotate.go
[3 4 5 6 7 8 0 1 2]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ex-4-5&#34;&gt;Ex 4.5&lt;/h3&gt;

&lt;p&gt;Write an in-place function to eliminate adjacent duplicates in a []string slice.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
)

func main() {
	s1 := []string{&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;, &amp;quot;d&amp;quot;, &amp;quot;d&amp;quot;}
	s11 := s1
	dup(&amp;amp;s1)
	dup1(&amp;amp;s11)
	fmt.Println(s1, s11)
	s2 := []string{&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;}
	s21 := s2
	dup(&amp;amp;s2)
	dup(&amp;amp;s21)
	fmt.Println(s2, s21)
}

func dup(s *[]string) {
	var ls []string
	ls = append(ls, (*s)[0])
	for i := 0; i &amp;lt; len(*s)-1; i++ {
		if (*s)[i] != (*s)[i+1] {
			ls = append(ls, (*s)[i+1])
		}
	}
	*s = ls
}

func dup1(s *[]string) {
	j := 0
	var temp string
	for i := range *s {
		(*s)[j] = (*s)[i]
		j++
		if i &amp;gt; 0 &amp;amp;&amp;amp; temp == (*s)[i] {
			j--
		}
		temp = (*s)[i]
	}
	*s = (*s)[:j]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ go run dup.go
[a b c d] [a b c d]
[a b c] [a b c]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ex-4-6&#34;&gt;Ex 4.6&lt;/h3&gt;

&lt;p&gt;Write an in-place function that squashes each run of adjacent Unicode spac (see unicode.IsSpace) in a UTF-8-encoded []byte slice into a single ASCII space.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;unicode&amp;quot;
	&amp;quot;unicode/utf8&amp;quot;
)

func main() {
	str := &amp;quot;\t世界a \na\r\t\vb   &amp;quot;
	s1 := []byte(str)
	s2 := []byte(str)
	//s1 := []byte{&#39;a&#39;, &#39;b&#39;, &#39; &#39;, &#39;	&#39;, &#39;\n&#39;, &#39;c&#39;, &#39; &#39;}
	fmt.Printf(&amp;quot;before:%d %[1]v %[1]s\n&amp;quot;, s1)
	utf8space(&amp;amp;s1)
	fmt.Printf(&amp;quot;after:%d %[1]v %[1]s\n&amp;quot;, s1)
	//s2 := []byte{&#39;1&#39;, &#39;2&#39;, &#39; &#39;, &#39;	&#39;, &#39;\n&#39;, &#39;3&#39;, &#39; &#39;, &#39;\t&#39;}
	fmt.Printf(&amp;quot;before:%d %[1]v %[1]s\n&amp;quot;, s2)
	utf8space2(&amp;amp;s2)
	fmt.Printf(&amp;quot;after:%d %[1]v %[1]s\n&amp;quot;, s2)
}

func utf8space(s *[]byte) {
	var ls []byte
	runes := []rune(string(*s))
	spaceInd := false
	for _, r := range runes {
		if !unicode.IsSpace(r) {
			spaceInd = false
			ls = append(ls, []byte(string(r))...)
		} else if unicode.IsSpace(r) &amp;amp;&amp;amp; !spaceInd {
			spaceInd = true
			ls = append(ls, byte(32))
		}
	}
	*s = ls
}

func utf8space2(s *[]byte) {
	str := string(*s)
	spaceInd := false
	j := 0
	for i, r := range str {
		bytelen := utf8.RuneLen(r)
		if !unicode.IsSpace(r) {
			spaceInd = false
			copy((*s)[j:], (*s)[i:i+bytelen])
			j += bytelen
		} else if unicode.IsSpace(r) &amp;amp;&amp;amp; !spaceInd {
			spaceInd = true
			bytelen = 1
			copy((*s)[j:], &amp;quot; &amp;quot;)
			j += bytelen
		}
	}
	*s = (*s)[:j]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ go run utf8space.go
before:[9 228 184 150 231 149 140 97 32 10 97 13 9 11 98 32 32 32] [9 228 184 150 231 149 140 97 32 10 97 13 9 11 98 32 32 32] 	世界a
a
        b
after:[32 228 184 150 231 149 140 97 32 97 32 98 32] [32 228 184 150 231 149 140 97 32 97 32 98 32]  世界a a b
before:[9 228 184 150 231 149 140 97 32 10 97 13 9 11 98 32 32 32] [9 228 184 150 231 149 140 97 32 10 97 13 9 11 98 32 32 32] 	世界a
a
        b
after:[32 228 184 150 231 149 140 97 32 97 32 98 32] [32 228 184 150 231 149 140 97 32 97 32 98 32]  世界a a b
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;for range遍历&lt;u&gt;&lt;code&gt;字符串&lt;/code&gt;&lt;/u&gt;的时候，i为当前字符开始的位置，v为当前字符。换句话说，字符串包含多字节utf8字符时，i不连续，因为遍历的单位不是byte，而是rune（unicode）。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://oumnldfwl.bkt.clouddn.com/range%20loop%20for%20string.png&#34; alt=&#34;range loop for string&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;ex-4-7&#34;&gt;Ex 4.7&lt;/h3&gt;

&lt;p&gt;Modify reverse to reverse the characters of a []byte slice that represents a UTF-8-encoded string, in place. Can you do it without allocating new memory?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;unicode&amp;quot;
)

func main() {
	str := &amp;quot;\U00000080world,世界,hello,你好&amp;quot;
	s1 := []byte(str) //每个元素根据utf8的格式，确定utf8表达字符的字节数，或为单字节或为多字节
	s2 := []rune(str) //一个元素就是一个unicode
	fmt.Printf(&amp;quot;% x \n % x\n&amp;quot;, s1, s2)
	fmt.Println(Reverse(str))
	reverse(s2)
	fmt.Println(string(s2))
}

// Reverse reverses the input while respecting UTF8 encoding and combined characters
func Reverse(text string) string {
	textRunes := []rune(text)
	textRunesLength := len(textRunes)
	if textRunesLength &amp;lt;= 1 {
		return text
	}

	i, j := 0, 0
	for i &amp;lt; textRunesLength &amp;amp;&amp;amp; j &amp;lt; textRunesLength {
		j = i + 1
		for j &amp;lt; textRunesLength &amp;amp;&amp;amp; isMark(textRunes[j]) {
			j++
		}

		if isMark(textRunes[j-1]) {
			// Reverses Combined Characters
			reverse(textRunes[i:j])
		}

		i = j
	}

	// Reverses the entire array
	reverse(textRunes)

	return string(textRunes)
}

func reverse(runes []rune) {
	for i, j := 0, len(runes)-1; i &amp;lt; j; i, j = i+1, j-1 {
		runes[i], runes[j] = runes[j], runes[i]
	}
}

// isMark determines whether the rune is a marker
func isMark(r rune) bool {
	return unicode.Is(unicode.Mn, r) || unicode.Is(unicode.Me, r) || unicode.Is(unicode.Mc, r)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ go run utf8reverse.go
c2 80 77 6f 72 6c 64 2c e4 b8 96 e7 95 8c 2c 68 65 6c 6c 6f 2c e4 bd a0 e5 a5 bd
 [ 80  77  6f  72  6c  64  2c  4e16  754c  2c  68  65  6c  6c  6f  2c  4f60  597d]
好你,olleh,界世,dlrow
好你,olleh,界世,dlrow
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Reverse：确保了组合字符（多个unicode组合成一个字符）翻转的正确性&lt;/p&gt;

&lt;p&gt;reverse：不考虑组合字符，翻转正确&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>The Go Programming Language Ex（3）</title>
      <link>https://mooncaker816.github.io/2017/12/22/the-go-programming-language-ex3/</link>
      <pubDate>Fri, 22 Dec 2017 17:00:00 +0000</pubDate>
      
      <guid>https://mooncaker816.github.io/2017/12/22/the-go-programming-language-ex3/</guid>
      <description>&lt;h3 id=&#34;ex-3-10&#34;&gt;Ex 3.10&lt;/h3&gt;

&lt;p&gt;Write a non-recursive version of comma, using bytes.Buffer instead of str concatenation.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;bytes&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;log&amp;quot;
	&amp;quot;os&amp;quot;
)

func main() {
	for _, v := range os.Args[1:] {
		s := []byte(v)
		var buf bytes.Buffer
		for i, j := len(s)-1, 0; i &amp;gt;= 0; i-- {
			err := buf.WriteByte(s[i])
			if err != nil {
				log.Fatal(&amp;quot;write buf failed&amp;quot;)
			}
			if j++; j != len(s) &amp;amp;&amp;amp; j%3 == 0 {
				err = buf.WriteByte(&#39;,&#39;)
			}
		}
		fmt.Println(Reverse(buf.String()))
	}

}

func Reverse(s string) string {
	r := []rune(s)
	for i, j := len(r)-1, 0; i &amp;gt; j; i, j = i-1, j+1 {
		r[i], r[j] = r[j], r[i]
	}
	return string(r)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./ex3.10 12345678 829356934592162 23 7777 333
12,345,678
829,356,934,592,162
23
7,777
333
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ex-3-11&#34;&gt;Ex 3.11&lt;/h3&gt;

&lt;p&gt;Enhance comma so that it deals correctly with ﬂoating-point numbers and an optional sign.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;bytes&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;log&amp;quot;
	&amp;quot;os&amp;quot;
)

func main() {
	for _, v := range os.Args[1:] {
		var lbuf, rbuf bytes.Buffer
		var lstr, rstr, sign string
		if v[0] == &#39;+&#39; || v[0] == &#39;-&#39; {
			sign = string(v[0])
			v = v[1:]
		}
		chars := bytes.SplitAfterN([]byte(v), []byte(&amp;quot;.&amp;quot;), 2)
		for ix, pc := range chars {
			if ix == 0 {
				if pc[len(pc)-1] == &#39;.&#39; {
					pc = pc[:len(pc)-1]
					err := lbuf.WriteByte(&#39;.&#39;)
					if err != nil {
						log.Fatal(&amp;quot;write &#39;.&#39; in buf failed&amp;quot;)
					}
				}
				if len(pc) &amp;gt; 0 {
					for i, j := len(pc)-1, 0; i &amp;gt;= 0; i-- {
						err := lbuf.WriteByte(pc[i])
						if err != nil {
							log.Fatal(&amp;quot;write int part in buf failed&amp;quot;)
						}
						if j++; j != len(pc) &amp;amp;&amp;amp; j%3 == 0 {
							err = lbuf.WriteByte(&#39;,&#39;)
						}
					}
					lstr = Reverse(lbuf.String())
				}
			}
			if ix == 1 {
				if len(pc) &amp;gt; 0 {
					for i, j := 0, 0; i &amp;lt; len(pc); i++ {
						err := rbuf.WriteByte(pc[i])
						if err != nil {
							log.Fatal(&amp;quot;write float part in buf failed&amp;quot;)
						}
						if j++; j != len(pc) &amp;amp;&amp;amp; j%3 == 0 {
							err = rbuf.WriteByte(&#39;,&#39;)
						}
					}
					rstr = rbuf.String()
				} else {
					rstr = &amp;quot;0&amp;quot;
				}
			}
		}
		fmt.Println(sign + lstr + rstr)
	}
}

func Reverse(s string) string {
	r := []rune(s)
	for i, j := len(r)-1, 0; i &amp;gt; j; i, j = i-1, j+1 {
		r[i], r[j] = r[j], r[i]
	}
	return string(r)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ go run comma.go +123456.4563 -2342335352234.234 234235235211 +1243535353434 24533. 454545.345354456
+123,456.456,3
-2,342,335,352,234.234
234,235,235,211
+1,243,535,353,434
24,533.0
454,545.345,354,456
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ex-3-12&#34;&gt;Ex 3.12&lt;/h3&gt;

&lt;p&gt;Write a function that reports whether two strings are anagrams of each other, that is, they contain the same letters in a different order.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;os&amp;quot;
	&amp;quot;sort&amp;quot;
)

func main() {
	s1 := []rune(os.Args[1])
	s2 := []rune(os.Args[2])
	var ss1 = make([]string, len(s1))
	var ss2 = make([]string, len(s2))
	for i, v := range s1 {
		ss1[i] = string(v)
	}
	for i, v := range s2 {
		ss2[i] = string(v)
	}
	sort.Strings(ss1)
	sort.Strings(ss2)
	if len(ss1) != len(ss2) {
		fmt.Println(&amp;quot;they are NOT anagrams strings&amp;quot;)
		return
	}
	for i := 0; i &amp;lt; len(ss1); i++ {
		if ss1[i] != ss2[i] {
			fmt.Println(&amp;quot;they are NOT anagrams strings&amp;quot;)
			return
		}
	}
	fmt.Println(&amp;quot;they are anagrams strings&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ go run anagrams.go abcdefg acdefgb
they are anagrams strings
$ go run anagrams.go aabbccdd dcbadcba
they are anagrams strings
$ go run anagrams.go abcde dbca
they are NOT anagrams strings
$ go run anagrams.go abcde dbcaf
they are NOT anagrams strings
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ex-3-13&#34;&gt;Ex 3.13&lt;/h3&gt;

&lt;p&gt;Write const declarations for KB, MB, up through YB as compactly as you can.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
)

const (
	_   = int64(1) &amp;lt;&amp;lt; (10 * iota)
	KiB // 1024        2e1
	MiB // 1048576     2e20
	GiB // 1073741824  2e30
	TiB // 1099511627776
	PiB // 1125899906842624
	EiB // 1152921504606846976
	//ZiB // 1180591620717411303424  overflow
	//YiB // 1208925819614629174706176 overflow
	KB = int64(1000)
	MB = 1000 * KB
	GB = 1000 * MB
	TB = 1000 * GB
	PB = 1000 * TB
	EB = 1000 * PB
)

func main() {
	fmt.Println(KiB, MiB, GiB, TiB, PiB, EiB)
	fmt.Println(KB, MB, GB, TB, PB, EB)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ go run const.go
1024 1048576 1073741824 1099511627776 1125899906842624 1152921504606846976
1000 1000000 1000000000 1000000000000 1000000000000000 1000000000000000000
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>The Go Programming Language Ex（2）</title>
      <link>https://mooncaker816.github.io/2017/12/21/the-go-programming-language-ex2/</link>
      <pubDate>Thu, 21 Dec 2017 17:00:00 +0000</pubDate>
      
      <guid>https://mooncaker816.github.io/2017/12/21/the-go-programming-language-ex2/</guid>
      <description>&lt;h3 id=&#34;ex-2-1&#34;&gt;Ex 2.1&lt;/h3&gt;

&lt;p&gt;Add types, constants, and functions to tempconv for processing temperatures in the Kelvin scale, where zero Kelvin is −273.15°C and a difference of 1K has the same magnitude as 1°C.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package tempconv

import &amp;quot;fmt&amp;quot;

type Celsius float64
type Fahrenheit float64
type Kelvin float64

const (
	AbsoluteZeroC Celsius = -273.15
	FreezingC     Celsius = 0
	BoilingC      Celsius = 100
)

func (c Celsius) String() string    { return fmt.Sprintf(&amp;quot;%g°C&amp;quot;, c) }
func (f Fahrenheit) String() string { return fmt.Sprintf(&amp;quot;%g°F&amp;quot;, f) }
func (k Kelvin) String() string     { return fmt.Sprintf(&amp;quot;%g°K&amp;quot;, k) }

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package tempconv

// CToF converts a Celsius temperature to Fahrenheit.
func CToF(c Celsius) Fahrenheit { return Fahrenheit(c*9/5 + 32) }

// FToC converts a Fahrenheit temperature to Celsius.
func FToC(f Fahrenheit) Celsius { return Celsius((f - 32) * 5 / 9) }

//CToK converts a Celsius temperature to Kelvin.
func CToK(c Celsius) Kelvin { return Kelvin(c + 273.15) }

//KToC converts a Kelvin temperature to Celsius.
func KToC(k Kelvin) Celsius { return Celsius(k - 273.15) }

//FToK converts a Fahrenheit temperature to Kelvin.
func FToK(f Fahrenheit) Kelvin { return Kelvin((f-32)*5/9 + 273.15) }

// KToF converts a Kelvin temperature to Fahrenheit.
func KToF(k Kelvin) Fahrenheit { return Fahrenheit((k-273.15)*9/5 + 32) }

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;The_Go_Programming_Language_Exercises/CH2/ex2.1/tempconv&amp;quot;
)

func main() {
	fmt.Println(tempconv.CToK(tempconv.BoilingC))
	k1 := tempconv.Kelvin(273)
	fmt.Println(tempconv.KToC(k1))
	fmt.Println(tempconv.KToF(k1))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ go run main.go
373.15°K
-0.14999999999997726°C
31.73000000000004°F
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ex-2-2&#34;&gt;Ex 2.2&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;bufio&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;io&amp;quot;
	&amp;quot;os&amp;quot;
	&amp;quot;strconv&amp;quot;
	&amp;quot;strings&amp;quot;

	&amp;quot;The_Go_Programming_Language_Exercises/CH2/ex2.2/unitconv&amp;quot;
)

func main() {
	var s []string
	if len(os.Args) &amp;gt; 1 {
		s = os.Args[1:]
	} else {
		input, err := os.Open(&amp;quot;a&amp;quot;)
		if err != nil {
			fmt.Println(&amp;quot;happend a error when opening&amp;quot;, err)
		}
		defer input.Close()
		buf := bufio.NewReader(input)
		for {
			line, err := buf.ReadString(&#39;\n&#39;)
			line = strings.TrimSpace(line)
			s = append(s, line)
			if err != nil {
				if err == io.EOF {
					break
				}
				fmt.Fprintf(os.Stderr, &amp;quot;reading error %v\n&amp;quot;, err)
				os.Exit(1)
			}
		}
	}
	for _, arg := range s {
		t, err := strconv.ParseFloat(arg, 64)
		if err != nil {
			fmt.Fprintf(os.Stderr, &amp;quot;invalid input: %v\n&amp;quot;, err)
			os.Exit(1)
		}
		f := unitconv.Fahrenheit(t)
		c := unitconv.Celsius(t)
		p := unitconv.Pounds(t)
		kg := unitconv.Kilograms(t)
		fe := unitconv.Feet(t)
		m := unitconv.Meter(t)
		fmt.Printf(&amp;quot;%s = %s, %s = %s\n&amp;quot;, f, unitconv.FToC(f), c, unitconv.CToF(c))
		fmt.Printf(&amp;quot;%s = %s, %s = %s\n&amp;quot;, p, unitconv.PToKg(p), kg, unitconv.KgToP(kg))
		fmt.Printf(&amp;quot;%s = %s, %s = %s\n&amp;quot;, fe, unitconv.FeToM(fe), m, unitconv.MToFe(m))
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//file a
11
22
33
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./ex2.2
11°F = -11.666666666666666°C, 11°C = 51.8°F
11 pounds = 4.9895160700000005 kilograms, 11 kilograms = 24.2508488403368 pounds
11 feets = 3.3528000000000002 meters, 11 meters = 36.08913 feets
22°F = -5.555555555555555°C, 22°C = 71.6°F
22 pounds = 9.979032140000001 kilograms, 22 kilograms = 48.5016976806736 pounds
22 feets = 6.7056000000000004 meters, 22 meters = 72.17826 feets
33°F = 0.5555555555555556°C, 33°C = 91.4°F
33 pounds = 14.968548210000002 kilograms, 33 kilograms = 72.7525465210104 pounds
33 feets = 10.0584 meters, 33 meters = 108.26738999999999 feets

$ ./ex2.2 11 22 33 44.5
11°F = -11.666666666666666°C, 11°C = 51.8°F
11 pounds = 4.9895160700000005 kilograms, 11 kilograms = 24.2508488403368 pounds
11 feets = 3.3528000000000002 meters, 11 meters = 36.08913 feets
22°F = -5.555555555555555°C, 22°C = 71.6°F
22 pounds = 9.979032140000001 kilograms, 22 kilograms = 48.5016976806736 pounds
22 feets = 6.7056000000000004 meters, 22 meters = 72.17826 feets
33°F = 0.5555555555555556°C, 33°C = 91.4°F
33 pounds = 14.968548210000002 kilograms, 33 kilograms = 72.7525465210104 pounds
33 feets = 10.0584 meters, 33 meters = 108.26738999999999 feets
44.5°F = 6.944444444444445°C, 44.5°C = 112.1°F
44.5 pounds = 20.184860465 kilograms, 44.5 kilograms = 98.10570667227161 pounds
44.5 feets = 13.563600000000001 meters, 44.5 meters = 145.996935 feets
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ex-2-3-2-4-2-5&#34;&gt;Ex 2.3 2.4 2.5&lt;/h3&gt;

&lt;p&gt;Rewrite PopCount to use a loop instead of a single expression. Compare the performance of the two versions. (Section 11.4 shows how to compare the performance of different implementations systematically.)&lt;/p&gt;

&lt;p&gt;Write a version of PopCount that counts bits by shifting its argument through 64 bit positions, testing the rightmost bit each time. Compare its performance to the tablelookup version.&lt;/p&gt;

&lt;p&gt;The expression x&amp;amp;(x-1) clears the rightmost non-zero bit of x. Write a version of PopCount that counts bits by using this fact, and assess its performance.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package popcount_test

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;io/ioutil&amp;quot;
	&amp;quot;testing&amp;quot;
)

func init() {
	for i := range pc {
		pc[i] = pc[i/2] + byte(i&amp;amp;1)
	}
	for i := 0; i &amp;lt; 256; i++ {
		n[i] = i
	}
}

var pc [256]byte
var n = make([]int, 256)

//通过v&amp;amp;(v-1)，将v对应的二进制中最右的非零位置零，直到v=0为止，此时置零的次数即为popcount的值
func BenchmarkPopCount1(b *testing.B) {
	for i := 0; i &amp;lt; b.N; i++ {
		for _, v := range n {
			var count int
			for v != 0 {
				count++
				v &amp;amp;= v - 1
			}
			fmt.Fprintln(ioutil.Discard, count)
			//fmt.Fprintln(os.Stdout, count)
		}
	}
}

//把64位平均分为8份，每份对应一个字节，读出该字节的数值，去预先准备好的单字节(8位)所能存储的所有数值对应的popcount的表中查询出每份的popcount，再相加8份的popcount
func BenchmarkPopCount2(b *testing.B) {
	for i := 0; i &amp;lt; b.N; i++ {
		for _, x := range n {
			count := int(pc[byte(x&amp;gt;&amp;gt;(0*8))] +
				pc[byte(x&amp;gt;&amp;gt;(1*8))] +
				pc[byte(x&amp;gt;&amp;gt;(2*8))] +
				pc[byte(x&amp;gt;&amp;gt;(3*8))] +
				pc[byte(x&amp;gt;&amp;gt;(4*8))] +
				pc[byte(x&amp;gt;&amp;gt;(5*8))] +
				pc[byte(x&amp;gt;&amp;gt;(6*8))] +
				pc[byte(x&amp;gt;&amp;gt;(7*8))])
			fmt.Fprintln(ioutil.Discard, count)
			//fmt.Fprintln(os.Stdout, count)
		}
	}
}

//从最右开始一位一位检查是否为1
func BenchmarkPopCount3(b *testing.B) {
	for i := 0; i &amp;lt; b.N; i++ {
		for _, v := range n {
			var count int
			for ; v != 0; v &amp;gt;&amp;gt;= 1 {
				count += v &amp;amp; 1
			}
			fmt.Fprintln(ioutil.Discard, count)
			//fmt.Fprintln(os.Stdout, count)
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ go test -v -run=&amp;quot;none&amp;quot; -bench=. -benchtime=&amp;quot;3s&amp;quot; -benchmem
BenchmarkPopCount1-4   	  200000	     23154 ns/op	    2048 B/op	     256 allocs/op
BenchmarkPopCount2-4   	  200000	     21941 ns/op	    2048 B/op	     256 allocs/op
BenchmarkPopCount3-4   	  200000	     24450 ns/op	    2048 B/op	     256 allocs/op
PASS
ok  	The_Go_Programming_Language_Exercises/CH2/ex2.3	14.646s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;n&amp;amp;(n-1) ：将n的二进制最右边的非零位置零&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;平均来说，此3种方法中查表最快，n&amp;amp;(n-1)居中，一位一位数最慢&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
