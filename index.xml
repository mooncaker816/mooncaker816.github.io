<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Mooncaker816 on Mooncaker816</title>
    <link>https://mooncaker816.github.io/</link>
    <description>Recent content in Mooncaker816 on Mooncaker816</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <copyright>&amp;copy; 2018-Present</copyright>
    <lastBuildDate>Wed, 20 Apr 2016 00:00:00 +0800</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>天文算法2</title>
      <link>https://mooncaker816.github.io/2018/05/13/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%952/</link>
      <pubDate>Sun, 13 May 2018 19:38:14 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/05/13/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%952/</guid>
      <description>&lt;h1 id=&#34;第四章-拟合-curve-fitting&#34;&gt;第四章 拟合 Curve Fitting&lt;/h1&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;什么是拟合&#34;&gt;什么是拟合&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;曲线拟合(Curve Fitting)的数学定义是指用连续曲线近似地刻画或比拟平面上一组离散点所表示的坐标之间的函数关系，是一种用解析表达式逼近离散数据的方法。曲线拟合通俗的说法就是“拉曲线”，也就是将现有数据透过数学方法来代入一条数学方程式的表示方法。科学和工程遇到的很多问题，往往只能通过诸如采样、实验等方法获得若干离散的数据，根据这些数据，如果能够找到一个连续的函数（也就是曲线）或者更加密集的离散方程，使得实验数据与方程的曲线能够在最大程度上近似吻合，就可以根据曲线方程对数据进行数学计算，对实验结果进行理论分析，甚至对某些不具备测量条件的位置的结果进行估算。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;最小二乘拟合&#34;&gt;最小二乘拟合&lt;/h2&gt;

&lt;p&gt;考虑 N 个数据点，它们的坐标是$(x_1,y_1),(x_2,y_2),\dots,(x_n,y_n)$
假设这些值中的 X 是严格的精确值，Y 的值是测量值(含有一些误差)。
对于一个给定的 X，如$x_1$，对应的值$y_1$与曲线 C 上对应的 Y 值将存在一个差值$d_1$，我们称这个差值为偏差、误差或残差，它可能是正、负或零。类似的，$x_2,\dots,x_n$,对应的差值为 $d_2,\dots,d_n$。&lt;/p&gt;

&lt;p&gt;我们用 $d_1^2+d_2^2+\cdots+d_n^2$ 作为衡量曲线 C 拟合的“最佳”程度，这个值越小越好，越大则越不好。因此，我们做以下定义：任何一种类型的曲线，它们都有一个共同的特性， 当 $$\sum_{i=1}^n d_i^2$$最小时，称为最佳拟合曲线。&lt;/p&gt;

&lt;p&gt;一条曲线具有这一特性时，称之为“最小二乘拟合”， 这样的曲线称为“最小二乘曲线”。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;最小二乘线性拟合&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;假设拟合的曲线为直线$y=ax+b$,则最小二乘差方和为：
$$\sum_{i=1}^n[y_i-(ax_i+b)]^2$$
对上式中a求偏导&lt;/p&gt;

&lt;p&gt;\begin{multline}
\shoveleft
\begin{aligned}
\frac \partial {\partial a}\sum_{i=1}^n[y_i-(ax_i+b)]^2 &amp;amp;= -2\sum_{i=1}^n({x_iy_i}-a{x_i^2}-b{x_i})\\[2ex]
&amp;amp; =-2\sum_{i=1}^n{x_i}[{y_i}-(a{x_i}+b)]\\[2ex]
\end{aligned}
\end{multline}&lt;/p&gt;

&lt;p&gt;\begin{multline}
\shoveleft
\because y_i = ax_i+b\\[2ex]
\shoveleft
\therefore -2\sum_{i=1}^n{x_i}[{y_i}-(a{x_i}+b)] = 0\\[2ex]
\shoveleft
\therefore \sum_{i=1}^n{x_iy_i}-a\sum_{i=1}^n{x_i^2}-b\sum_{i=1}^n{x_i}=0
\end{multline}&lt;/p&gt;

&lt;p&gt;同理对b求偏导可得：
\begin{align}
\sum_{i=1}^n{y_i}-a\sum_{i=1}^n{x_i}-bn=0
\end{align}&lt;/p&gt;

&lt;p&gt;求解关于a,b 的二元一次方程组，
\begin{cases}
\sum\limits_{i=1}^n{x_iy_i}-a\sum\limits_{i=1}^n{x_i^2}-b\sum\limits_{i=1}^n{x_i}=0 \\[2ex]
\sum\limits_{i=1}^n{y_i}-a\sum\limits_{i=1}^n{x_i}-bn=0
\end{cases}&lt;/p&gt;

&lt;p&gt;得
\begin{align}
a &amp;amp;= \frac {\sum\limits_{i=1}^n{x_i}\sum\limits_{i=1}^n{y_i}-n\sum\limits_{i=1}^n{x_iy_i}}{(\sum\limits_{i=1}^n{x_i})^2-n\sum\limits_{i=1}^n{x_i}^2}\\[2ex]
b &amp;amp;= \frac {\sum\limits_{i=1}^n{x_i}\sum\limits_{i=1}^n{x_iy_i}-\sum\limits_{i=1}^n{y_i}\sum\limits_{i=1}^n{x_i}^2}{(\sum\limits_{i=1}^n{x_i})^2-n\sum\limits_{i=1}^n{x_i}^2}
\end{align}&lt;/p&gt;

&lt;p&gt;皮尔逊相关系数r：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E7%9A%AE%E5%B0%94%E9%80%8A%E7%A7%AF%E7%9F%A9%E7%9B%B8%E5%85%B3%E7%B3%BB%E6%95%B0&#34; target=&#34;_blank&#34;&gt;定义&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;由定义可知，
\begin{align}
r=\frac {\sum\limits_{i=1}^n(x_i-\bar x)(y_i-\bar y)}{\sqrt {\sum\limits_{i=1}^n(x_i-\bar x)^2}\sqrt {\sum\limits_{i=1}^n(y_i-\bar y)^2}}, \\[2ex]
\text {其中 } \bar x=\frac 1n\sum_{i=1}^nx_i,\bar y=\frac 1n\sum_{i=1}^ny_i
\end{align}&lt;/p&gt;

&lt;p&gt;\begin{multline}
\shoveleft
\begin{aligned}
化简 \ \  &amp;amp; \sum\limits_{i=1}^n(x_i-\bar x)(y_i-\bar y)\\[2ex]
= &amp;amp; \sum\limits_{i=1}^n(x_iy_i-x_i\bar y-\bar xy_i+\bar x\bar y)\\[2ex]
= &amp;amp; \sum\limits_{i=1}^nx_iy_i - \sum\limits_{i=1}^nx_i\bar y - \sum\limits_{i=1}^n\bar xy_i+\sum\limits_{i=1}^n\bar x\bar y\\[2ex]
= &amp;amp; \sum\limits_{i=1}^nx_iy_i - \frac 1n\sum\limits_{i=1}^ny_i\sum\limits_{i=1}^nx_i - \frac 1n\sum\limits_{i=1}^nx_i\sum\limits_{i=1}^ny_i + \frac 1n\sum\limits_{i=1}^nx_i\sum\limits_{i=1}^ny_i\\[2ex]
= &amp;amp; \sum\limits_{i=1}^nx_iy_i - \frac 1n\sum\limits_{i=1}^ny_i\sum\limits_{i=1}^nx_i\\[2ex]
化简 \ \  &amp;amp; \sum\limits_{i=1}^n(x_i-\bar x)^2\\[2ex]
= &amp;amp; \sum\limits_{i=1}^n(x_i^2-2x_i\bar x+\bar x^2)\\[2ex]
= &amp;amp; \sum\limits_{i=1}^nx_i^2 - 2\bar x\sum\limits_{i=1}^nx_i + n\bar x^2\\[2ex]
= &amp;amp; \sum\limits_{i=1}^nx_i^2 - 2n\bar x^2 + n\bar x^2\\[2ex]
= &amp;amp; \sum\limits_{i=1}^nx_i^2 - n\bar x^2\\[2ex]
= &amp;amp; \sum\limits_{i=1}^nx_i^2 - \frac 1n(\sum\limits_{i=1}^nx_i)^2\\[2ex]
同上 \ \  &amp;amp; \sum\limits_{i=1}^n(y_i-\bar y)^2\\[2ex]
= &amp;amp; \sum\limits_{i=1}^ny_i^2 - \frac 1n(\sum\limits_{i=1}^ny_i)^2\\[2ex]
\end{aligned}
\end{multline}
\begin{multline}
\shoveleft
\begin{aligned}
\therefore \ \ r&amp;amp;=\frac {\sum\limits_{i=1}^nx_iy_i - \frac 1n\sum\limits_{i=1}^ny_i\sum\limits_{i=1}^nx_i}{\sqrt{\sum\limits_{i=1}^nx_i^2 - \frac 1n(\sum\limits_{i=1}^nx_i)^2}\sqrt{\sum\limits_{i=1}^ny_i^2 - \frac 1n(\sum\limits_{i=1}^ny_i)^2}}\\[2ex]
&amp;amp; =\frac {n\sum\limits_{i=1}^nx_iy_i - \sum\limits_{i=1}^ny_i\sum\limits_{i=1}^nx_i}{\sqrt{n\sum\limits_{i=1}^nx_i^2 - (\sum\limits_{i=1}^nx_i)^2}\sqrt{n\sum\limits_{i=1}^ny_i^2 - (\sum\limits_{i=1}^ny_i)^2}}
\end{aligned}
\end{multline}&lt;/p&gt;

&lt;p&gt;这个系数介于+1 到-1 之间。如果值为+1 或-1，说明 x 和 y 之间有完全的线性关系，所有的点(x,y)精确的在同一条直线上。如果 r = +1，y 随 x 单调递增，如果 r = -1，y 随 x 单调递减。&lt;/p&gt;

&lt;p&gt;到这里我们就已经推导出求解线性方程和相关系数的公式，再结合代码看看&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Linear fits a line to sample data.
//
// Argument p is a list of data points.  Results a and b are coefficients
// of the best fit line y = ax + b.
// 求解线性拟合直线
// sx = ∑x sy = ∑y sxy = ∑xy sx2 = ∑x^2
func Linear(p []struct{ X, Y float64 }) (a, b float64) {
	var sx, sy, sx2, sxy float64
	for i := range p {
		x := p[i].X
		y := p[i].Y
		sx += x
		sy += y
		sx2 += x * x
		sxy += x * y
	}
	n := float64(len(p))
	d := n*sx2 - sx*sx
	// (4.2) p. 36
	a = (n*sxy - sx*sy) / d
	b = (sy*sx2 - sx*sxy) / d
	return
}

// CorrelationCoefficient returns a correlation coefficient for sample data.
// 求解相关系数 r
func CorrelationCoefficient(p []struct{ X, Y float64 }) float64 {
	var sx, sy, sx2, sy2, sxy float64
	for i := range p {
		x := p[i].X
		y := p[i].Y
		sx += x
		sy += y
		sx2 += x * x
		sy2 += y * y
		sxy += x * y
	}
	n := float64(len(p))
	// (4.3) p. 38
	return (n*sxy - sx*sy) / (math.Sqrt(n*sx2-sx*sx) * math.Sqrt(n*sy2-sy*sy))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;二次曲线拟合&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>天文算法1</title>
      <link>https://mooncaker816.github.io/2018/05/12/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%951/</link>
      <pubDate>Sat, 12 May 2018 21:43:17 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/05/12/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%951/</guid>
      <description>&lt;h2 id=&#34;①背景&#34;&gt;①背景&lt;/h2&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;计算精确的农历节气和日月合朔时间点，需要使用天文算法来实现。《Astronomical Algorithms》正是这么一本不那么让人望而生畏的介绍天文算法的书籍，国内比较出名的寿星万年历亦是基于此书中的算法。&lt;/p&gt;

&lt;p&gt;作为一名 Gopher 本想自造轮子来实现，但是万能的 Github 上已有前人身先士卒，直接上地址&lt;a href=&#34;https://github.com/soniakeys/meeus&#34; target=&#34;_blank&#34;&gt;meeus&lt;/a&gt;，该库基本上完整的实现了Astronomical Algorithms中的算法，而且每一章节对应一个 package，浏览起来不会让人感觉没有头绪。&lt;/p&gt;

&lt;p&gt;好了，话不多说，接下来就结合书和代码来学习。&lt;/p&gt;

&lt;h2 id=&#34;②第一章hints-and-tips&#34;&gt;②第一章Hints and Tips&lt;/h2&gt;

&lt;p&gt;略&lt;/p&gt;

&lt;h2 id=&#34;③第二章-about-accuracy&#34;&gt;③第二章 About accuracy&lt;/h2&gt;

&lt;p&gt;略&lt;/p&gt;

&lt;h2 id=&#34;④第三章-interpolation-插值&#34;&gt;④第三章 Interpolation 插值&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%A6&#34; target=&#34;_blank&#34;&gt;数学&lt;/a&gt;的&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90&#34; target=&#34;_blank&#34;&gt;数值分析&lt;/a&gt;领域中，&lt;strong&gt;内插&lt;/strong&gt;或称插值（英语：interpolation)是一种通过已知的、&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E9%9B%A2%E6%95%A3&#34; target=&#34;_blank&#34;&gt;离散&lt;/a&gt;的&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE&#34; target=&#34;_blank&#34;&gt;数据&lt;/a&gt;点，在范围内推求新数据点的过程或方法。求解&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E7%A7%91%E5%AD%A6&#34; target=&#34;_blank&#34;&gt;科学&lt;/a&gt;和&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%B7%A5%E7%A8%8B&#34; target=&#34;_blank&#34;&gt;工程&lt;/a&gt;的问题时，通常有许多数据点借由&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E9%87%87%E6%A0%B7&#34; target=&#34;_blank&#34;&gt;采样&lt;/a&gt;、&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%AE%9E%E9%AA%8C&#34; target=&#34;_blank&#34;&gt;实验&lt;/a&gt;等方法获得，这些数据可能代表了有限个数值函数，其中自变量的值。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;本章主要介绍了低阶等距节点牛顿插值和拉格朗日插值的应用。&lt;/p&gt;

&lt;h3 id=&#34;1-牛顿插值&#34;&gt;1. &lt;strong&gt;牛顿插值&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E7%89%9B%E9%A1%BF%E5%A4%9A%E9%A1%B9%E5%BC%8F&#34; target=&#34;_blank&#34;&gt;牛顿多项式&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%B7%AE%E5%88%86&#34; target=&#34;_blank&#34;&gt;差分&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;2-三点等距二阶差商的牛顿插值&#34;&gt;2. &lt;strong&gt;三点等距二阶差商的牛顿插值&lt;/strong&gt;&lt;/h3&gt;

&lt;h4 id=&#34;2-1-插值公式&#34;&gt;2.1  插值公式&lt;/h4&gt;

&lt;p&gt;二阶牛顿插值多项式为:
$N(x) = [y_0] + [y_0,y_1](x-x_0) + [y_0,y_1,y_2](x-x_0)(x-x_1)$，如下图
&lt;img src=&#34;https://wikimedia.org/api/rest_v1/media/math/render/svg/b8d0bfa61c4977eeaf3022de361f67dd5f4cb8a9&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;假设有三点$(x_0,y_0),(x_1,y_1),(x_2,y_2),x_0,x_1,x_2$等距(单位长度1) ,&lt;/p&gt;

&lt;p&gt;且$n$ 为插值因子,$x$距离$x_1$最近
\begin{align}
n&amp;amp;=(x-x_1)/单位长度\\&lt;br /&gt;
&amp;amp;=x-x1
\end{align}&lt;/p&gt;

&lt;p&gt;令 $a=y_1-y_0, b=y_2-y_1,c=b-a=y_0+y_2-2y_1$
则有：
\begin{align}
x-x_0 &amp;amp;= x-x_1 + 1\\&lt;br /&gt;
&amp;amp;= n + 1
\end{align}
\begin{align}
f(x) &amp;amp;= y_0 + a(x-x_0)+(c/(x_2-x_0))(x-x_0)(x-x_1)\\&lt;br /&gt;
&amp;amp;= y_0 + a(n+1) + 0.5c(n+1)n\\&lt;br /&gt;
&amp;amp;= y_1-a + an + a + 0.5n(cn+c)\\&lt;br /&gt;
&amp;amp;= y_1 + 0.5n(cn+b-a+2a)\\&lt;br /&gt;
&amp;amp;= y_1 + 0.5n(cn+a+b)\\&lt;br /&gt;
\end{align}&lt;/p&gt;

&lt;p&gt;即为算法中三点插值的公式.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;书中三点从1开始计数，公式为:$y_2+0.5n(cn+a+b)$&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Len3 allows second difference interpolation.
// 等距三点插值结构
type Len3 struct {
x1, x3             float64   //x1,x3分别为起始点和终止点，无需给出x2，因为等距
y                  []float64 //y为x1,x2,x3对应的值的序列
a, b, c            float64   //a=y2-y1, b=y3-y2, c=b-a=y3+y1-2y2
abSum, xSum, xDiff float64   //计数插值的中间变量
}

// NewLen3 prepares a Len3 object from a table of three rows of x and y values.
//
// X values must be equally spaced, so only the first and last are supplied.
// X1 must not equal x3.  Y must be a slice of three y values.
// 根据上述定义，创建三点插值结构
func NewLen3(x1, x3 float64, y []float64) (*Len3, error) {
if len(y) != 3 {
	return nil, ErrorNot3
}
if x3 == x1 {
	return nil, ErrorNoXRange
}
d := &amp;amp;Len3{
	x1: x1,
	x3: x3,
	y:  append([]float64{}, y...),
}
// differences. (3.1) p. 23
d.a = y[1] - y[0]
d.b = y[2] - y[1]
d.c = d.b - d.a
// other intermediate values
d.abSum = d.a + d.b
d.xSum = x3 + x1
d.xDiff = x3 - x1
return d, nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;考虑到实际问题中一般可能多于三点，此时只要选取目标点附近的三点即可，可用以下函数来自动构造&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Len3ForInterpolateX is a special purpose Len3 constructor.
//
// Like NewLen3, it takes a table of x and y values, but it is not limited
// to tables of 3 rows.  An X value is also passed that represents the
// interpolation target x value.  Len3ForInterpolateX will locate the
// appropriate three rows of the table for interpolating for x, and initialize
// the Len3 object for those rows.
//
//	x is the target for interpolation
//	x1 is the x value corresponding to the first y value of the table.
//	xn is the x value corresponding to the last y value of the table.
//	y is all y values in the table.  len(y) should be &amp;gt;= 3.
//
// 给定n个点，但是我们只需选取离目标点x最接近的三个点来做三点插值，
// 此时可用以下函数来自动选择最优三点，来构造三点插值
// 同样，前提是n个点等距，且与y一一对应
func Len3ForInterpolateX(x, x1, xn float64, y []float64) (*Len3, error) {
	if len(y) &amp;gt; 3 {
		interval := (xn - x1) / float64(len(y)-1)
		if interval == 0 {
			return nil, ErrorNoXRange
		}
		nearestX := int((x-x1)/interval + .5)
		if nearestX &amp;lt; 1 {
			nearestX = 1
		} else if nearestX &amp;gt; len(y)-2 {
			nearestX = len(y) - 2
		}
		y = y[nearestX-1 : nearestX+2]
		xn = x1 + float64(nearestX+1)*interval
		x1 = x1 + float64(nearestX-1)*interval
	}
	return NewLen3(x1, xn, y)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;插值因子 $n$ 为：目标点 $x$ 与 中间点 $x_2$之差除以实际步长&lt;br /&gt;
\begin{equation}
\because n = 2(x - x_2)/(x_3-x_1), x_2 = x_1 + (x_3-x_1)/2\\&lt;br /&gt;
\therefore n = [2x - (x_1+x_3)]/(x_3-x_1)\\&lt;br /&gt;
\end{equation}&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// InterpolateX interpolates for a given x value.
// 计算插值因子n，调用非严格插值计算
func (d *Len3) InterpolateX(x float64) (y float64) {
	n := (2*x - d.xSum) / d.xDiff
	return d.InterpolateN(n)
}

// InterpolateXStrict interpolates for a given x value,
// restricting x to the range x1 to x3 given to the constructor NewLen3.
// 计算插值因子n，调用严格插值计算
func (d *Len3) InterpolateXStrict(x float64) (y float64, err error) {
	n := (2*x - d.xSum) / d.xDiff
	y, err = d.InterpolateNStrict(n)
	if err == ErrorNOutOfRange {
		err = ErrorXOutOfRange
	}
	return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过调用三点插值公式获得目标插值，这里分为严格模式和非严格模式，&lt;/p&gt;

&lt;p&gt;所谓严格模式就是指目标点一定在三点的范围之内且必须离我们选择的三点的中间点最近，确保插值子$|n|&amp;lt;=1$；&lt;/p&gt;

&lt;p&gt;非严格模式就没有上述规定，可能目标点已经超出三点范围，得出的结果也相对不如严格模式精确。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// InterpolateN interpolates for a given interpolating factor n.
//
// This is interpolation formula (3.3)
//
// The interpolation factor n is x-x2 in units of the tabular x interval.
// (See Meeus p. 24.)
// 非严格插值计算，不用保证目标点插值因子绝对值小于等于1，
// 即不用保证离我们所选三点中点距离小于一个步长
func (d *Len3) InterpolateN(n float64) (y float64) {
	return d.y[1] + n*.5*(d.abSum+n*d.c)
}

// InterpolateNStrict interpolates for a given interpolating factor n.
//
// N is restricted to the range [-1..1] corresponding to the range x1 to x3
// given to the constructor NewLen3.
// 严格插值计算，必须保证目标点插值因子绝对值小于等于1，
// 即必须保证离我们所选三点中点距离小于一个步长
func (d *Len3) InterpolateNStrict(n float64) (y float64, err error) {
	if n &amp;lt; -1 || n &amp;gt; 1 {
		return 0, ErrorNOutOfRange
	}
	return d.InterpolateN(n), nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;2-2-极值&#34;&gt;2.2 &lt;strong&gt;极值&lt;/strong&gt;：&lt;/h4&gt;

&lt;p&gt;因为 $y_1 + 0.5n(cn+a+b)$是关于 $n$ 的二次函数($c \neq 0$时)，由二次函数的性质可知：&lt;/p&gt;

&lt;p&gt;当 $n=-(a+b)/(2c)$时，有极值$-(a+b)^2/(8c)$&lt;/p&gt;

&lt;p&gt;但是如果插值因子$|n|&amp;gt;1$,则无法取到(已超出插值函数的定义域)&lt;/p&gt;

&lt;p&gt;再由$n = [2x - (x_1+x_3)]/(x_3-x_1)$&lt;/p&gt;

&lt;p&gt;得出此时实际$x = [n(x_3-x_1)+(x_1+x_3)]/2$&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Extremum returns the x and y values at the extremum.
//
// Results are restricted to the range of the table given to the constructor
// NewLen3.
func (d *Len3) Extremum() (x, y float64, err error) {
	if d.c == 0 {
		return 0, 0, ErrorNoExtremum
	}
	n := d.abSum / (-2 * d.c) // (3.5), p. 25
	if n &amp;lt; -1 || n &amp;gt; 1 {
		return 0, 0, ErrorExtremumOutside
	}
	x = .5 * (d.xSum + d.xDiff*n)          // 根据实际步长得出极值点x
	y = d.y[1] - (d.abSum*d.abSum)/(8*d.c) // (3.4), p. 25
	return x, y, nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;2-3-根&#34;&gt;2.3 根&lt;/h4&gt;

&lt;p&gt;和普通方程类似，有时候我们需要求解插值函数的&amp;rdquo;根&amp;rdquo;，即 $y=0$所对应的插值点&lt;/p&gt;

&lt;p&gt;同样借助 $y=y_1+ 0.5n(cn+a+b)$,令 $y=0$&lt;/p&gt;

&lt;p&gt;得$n = -2y_1/(cn+a+b)$&lt;/p&gt;

&lt;p&gt;此时再利用迭代法求解近似根 $n_0$&lt;/p&gt;

&lt;p&gt;当插值曲线曲率比较大时，可采用以下修正量来进行迭代，直到满足精度要求为止&lt;/p&gt;

&lt;p&gt;$Δn_0 = -[ 2y_1 +n_0 (a+b+cn_0 ) ]/(a +b + 2cn_0 )$&lt;/p&gt;

&lt;p&gt;求解得到满足精度要求的 $n$ 后，再根据实际步长得出 $x$，即为&amp;rdquo;根&amp;rdquo;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Len3Zero finds a zero of the quadratic function represented by the table.
//
// That is, it returns an x value that yields y=0.
//
// Argument strong switches between two strategies for the estimation step.
// when iterating to converge on the zero.
//
// Strong=false specifies a quick and dirty estimate that works well
// for gentle curves, but can work poorly or fail on more dramatic curves.
//
// Strong=true specifies a more sophisticated and thus somewhat more
// expensive estimate.  However, if the curve has quick changes, This estimate
// will converge more reliably and in fewer steps, making it a better choice.
//
// Results are restricted to the range of the table given to the constructor
// NewLen3.
// strong 为考虑修正量的迭代方式，更为精确
func (d *Len3) Zero(strong bool) (x float64, err error) {
	var f iterFunc
	if strong {
		// (3.7), p. 27
		f = func(n0 float64) float64 {
			return n0 - (2*d.y[1]+n0*(d.abSum+d.c*n0))/(d.abSum+2*d.c*n0)
		}
	} else {
		// (3.6), p. 26
		f = func(n0 float64) float64 {
			return -2 * d.y[1] / (d.abSum + d.c*n0)
		}
	}
	n0, ok := iterate(0, f)
	if !ok {
		return 0, ErrorNoConverge
	}
	if n0 &amp;gt; 1 || n0 &amp;lt; -1 {
		return 0, ErrorZeroOutside
	}
	return .5 * (d.xSum + d.xDiff*n0), nil // success
}

type iterFunc func(n0 float64) (n1 float64)

func iterate(n0 float64, f iterFunc) (n1 float64, ok bool) {
	for limit := 0; limit &amp;lt; 50; limit++ {
		n1 = f(n0)
		if math.IsInf(n1, 0) || math.IsNaN(n1) {
			break // failure to converge
		}
		if math.Abs((n1-n0)/n0) &amp;lt; 1e-15 {
			return n1, true // success
		}
		n0 = n1
	}
	return 0, false // failure to converge
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3-五点等距四阶差商的牛顿插值&#34;&gt;3.  &lt;strong&gt;五点等距四阶差商的牛顿插值&lt;/strong&gt;&lt;/h3&gt;

&lt;h4 id=&#34;3-1-五点插值公式&#34;&gt;3.1 五点插值公式&lt;/h4&gt;

&lt;p&gt;五点和三点类似，这里直接给出公式，不再进行推导&lt;/p&gt;

&lt;p&gt;5点：$(x_1,y_1),(x_2,y_2),(x_3,y_3),(x_4,y_4),(x_5,y_5)$&lt;/p&gt;

&lt;p&gt;$y=y_3+ \frac {n} {2}(b+c)+\frac {n^2} {2}f+\frac{n(n^2-1)}{12}(h+j)+\frac {n^2(n^2-1)}{24k}$&lt;/p&gt;

&lt;p&gt;或者&lt;/p&gt;

&lt;p&gt;$y=y_3+n(\frac {b+c}{2}-\frac {h+j}{12})+n^2(\frac {f}{2}-\frac {k}{24})+n^3(\frac {h+j}{12})+n^4(\frac {k}{24})$&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Len5 allows fourth difference interpolation.
// 五点等距插值结构
type Len5 struct {
	x1, x5      float64   // x1为起始点，x5为终止点
	y           []float64 // y 为x1,x2,x3,x4,x5的一一映射
	a, b, c, d  float64   // a=y2-y1, b=y3-y2, c=y4-y3, d=y5-y4
	e, f, g     float64   // e=b-a, f=c-b, g=d-c
	h, j, k     float64   // h=f-e, j=g-f, k=j-h
	y3          float64   // y3为中间点的 y 值
	xSum, xDiff float64   // xSum=x1+x5, xDiff=x5-x1
	interpCoeff []float64 // 插值函数对应插值因子 n 的各项系数（0-4）
}

// NewLen5 prepares a Len5 object from a table of five rows of x and y values.
//
// X values must be equally spaced, so only the first and last are supplied.
// X1 must not equal x5.  Y must be a slice of five y values.
// 构造5点插值结构
func NewLen5(x1, x5 float64, y []float64) (*Len5, error) {
	if len(y) != 5 {
		return nil, ErrorNot5
	}
	if x5 == x1 {
		return nil, ErrorNoXRange
	}
	d := &amp;amp;Len5{
		x1: x1,
		x5: x5,
		y:  append([]float64{}, y...),
		y3: y[2],
	}
	// differences
	d.a = y[1] - y[0]
	d.b = y[2] - y[1]
	d.c = y[3] - y[2]
	d.d = y[4] - y[3]
	d.e = d.b - d.a
	d.f = d.c - d.b
	d.g = d.d - d.c
	d.h = d.f - d.e
	d.j = d.g - d.f
	d.k = d.j - d.h
	// other intermediate values
	d.xSum = x5 + x1
	d.xDiff = x5 - x1
	d.interpCoeff = []float64{ // (3.8) p. 28
		d.y3,
		(d.b+d.c)/2 - (d.h+d.j)/12,
		d.f/2 - d.k/24,
		(d.h + d.j) / 12,
		d.k / 24,
	}
	return d, nil
}
// InterpolateX interpolates for a given x value.
func (d *Len5) InterpolateX(x float64) (y float64) {
	n := (4*x - 2*d.xSum) / d.xDiff
	return d.InterpolateN(n)
}
// InterpolateXStrict interpolates for a given x value,
// restricting x to the range x1 to x5 given to the the constructor NewLen5.
func (d *Len5) InterpolateXStrict(x float64) (y float64, err error) {
	n := (4*x - 2*d.xSum) / d.xDiff
	y, err = d.InterpolateNStrict(n)
	if err == ErrorNOutOfRange {
		err = ErrorXOutOfRange
	}
	return
}
// InterpolateN interpolates for a given interpolating factor n.
//
// The interpolation factor n is x-x3 in units of the tabular x interval.
// (See Meeus p. 28.)
// Horner 为工具函数，求解多项式之和，interpCoeff为多项式系数
func (d *Len5) InterpolateN(n float64) (y float64) {
	return base.Horner(n, d.interpCoeff...)
}
// InterpolateNStrict interpolates for a given interpolating factor n.
//
// N is restricted to the range [-1..1].  This is only half the range given
// to the constructor NewLen5, but is the recommendation given on p. 31.
func (d *Len5) InterpolateNStrict(n float64) (y float64, err error) {
	if n &amp;lt; -1 || n &amp;gt; 1 {
		return 0, ErrorNOutOfRange
	}
	return base.Horner(n, d.interpCoeff...), nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;3-2-五点极值&#34;&gt;3.2 五点极值&lt;/h4&gt;

&lt;p&gt;函数的极值对应的插值因子 $n_m$ 可通过解以下方程得到：&lt;/p&gt;

&lt;p&gt;$n_m=\frac {6b+6c-h-j+3n_m^2(h+j)+2n_m^3k}{k-12f}$&lt;/p&gt;

&lt;p&gt;和上面的一样，我们可以执行迭代。首次，把 $n_m=0$代 入方程右边,迭代求得$n_m$&lt;/p&gt;

&lt;p&gt;当我们最后得到$n_m$后，$x_m=\frac {x_1+x_5}{2}+\frac {x_5-x_1}{4}n_m$&lt;/p&gt;

&lt;p&gt;再代入5点插值函数就可以获得极值&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Extremum returns the x and y values at the extremum.
//
// Results are restricted to the range of the table given to the constructor
// NewLen5.  (Meeus actually recommends restricting the range to one unit of
// the tabular interval, but that seems a little harsh.)
// 5点插值极值
func (d *Len5) Extremum() (x, y float64, err error) {
	// (3.9) p. 29
	nCoeff := []float64{
		6*(d.b+d.c) - d.h - d.j,
		0,
		3 * (d.h + d.k), // 不应该是 d.h+d.j 吗？
		2 * d.k,
	}
	den := d.k - 12*d.f
	if den == 0 {
		return 0, 0, ErrorExtremumOutside
	}
	n0, ok := iterate(0, func(n0 float64) float64 {
		return base.Horner(n0, nCoeff...) / den
	})
	if !ok {
		return 0, 0, ErrorNoConverge
	}
	if n0 &amp;lt; -2 || n0 &amp;gt; 2 {
		return 0, 0, ErrorExtremumOutside
	}
	x = .5*d.xSum + .25*d.xDiff*n0
	y = base.Horner(n0, d.interpCoeff...)
	return x, y, nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;3-3-五点求根&#34;&gt;3.3 五点求根&lt;/h4&gt;

&lt;p&gt;令$y=0$通过以下公式迭代求插值因子$n_0$,起始$n_0=0$&lt;/p&gt;

&lt;p&gt;$n_0=\frac {-24y_3+n_0^2(k-12f)-2n_0^3(h+j)-n_0^4k}{2(6b+6c-h-j)}$&lt;/p&gt;

&lt;p&gt;当曲率比较大时，同样可以加入修正&lt;/p&gt;

&lt;p&gt;$Δn_0 =-\frac {Mn_0^4+Nn_0^3+Pn_0^2+Qn_0+y_3}{4Mn_0^3+3Nn_0^2+2Pn_0+Q},$&lt;/p&gt;

&lt;p&gt;$(M=\frac{k}{24},N=\frac{h+j}{12},P=\frac{f}{2}-M,Q=\frac{b+c}{2}-N)$&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Len5Zero finds a zero of the quartic function represented by the table.
//
// That is, it returns an x value that yields y=0.
//
// Argument strong switches between two strategies for the estimation step.
// when iterating to converge on the zero.
//
// Strong=false specifies a quick and dirty estimate that works well
// for gentle curves, but can work poorly or fail on more dramatic curves.
//
// Strong=true specifies a more sophisticated and thus somewhat more
// expensive estimate.  However, if the curve has quick changes, This estimate
// will converge more reliably and in fewer steps, making it a better choice.
//
// Results are restricted to the range of the table given to the constructor
// NewLen5.
// strong 为带修正模式
func (d *Len5) Zero(strong bool) (x float64, err error) {
	var f iterFunc
	if strong {
		// (3.11), p. 29
		M := d.k / 24
		N := (d.h + d.j) / 12
		P := d.f/2 - M
		Q := (d.b+d.c)/2 - N
		numCoeff := []float64{d.y3, Q, P, N, M}
		denCoeff := []float64{Q, 2 * P, 3 * N, 4 * M}
		f = func(n0 float64) float64 {
			return n0 -
				base.Horner(n0, numCoeff...)/base.Horner(n0, denCoeff...)
		}
	} else {
		// (3.10), p. 29
		numCoeff := []float64{
			-24 * d.y3,
			0,
			d.k - 12*d.f,
			-2 * (d.h + d.j),
			-d.k,
		}
		den := 12*(d.b+d.c) - 2*(d.h+d.j)
		f = func(n0 float64) float64 {
			return base.Horner(n0, numCoeff...) / den
		}
	}
	n0, ok := iterate(0, f)
	if !ok {
		return 0, ErrorNoConverge
	}
	if n0 &amp;gt; 2 || n0 &amp;lt; -2 {
		return 0, ErrorZeroOutside
	}
	x = .5*d.xSum + .25*d.xDiff*n0
	return x, nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;4-四点等距中间点插值&#34;&gt;4. &lt;strong&gt;四点等距中间点插值&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;假设有$(x_1,y_1),(x_2,y_2),(x_3,y_3),(x_4,y_4)$
那么 $x_2$到 $x_3$ 之间的中点对应的函数值为：
$y = [ 9(y_2 +y_3 ) - y_1 - y_4 ] / 16$&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Len4Half interpolates a center value from a table of four rows.
func Len4Half(y []float64) (float64, error) {
	if len(y) != 4 {
		return 0, ErrorNot4
	}
	// (3.12) p. 32
	return (9*(y[1]+y[2]) - y[0] - y[3]) / 16, nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;5-横坐标不等间距插值-拉格朗日插值&#34;&gt;5. &lt;strong&gt;横坐标不等间距插值：拉格朗日插值&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;\begin{align}
y=y_1L_1+y_2L_2+\cdots+y_nL_n\\[2ex]
L_i = \prod_{
\substack{
i+1\\&lt;br /&gt;
i \neq j
}}^n
\frac {x-x_j}{x_i-x_j}
\end{align}&lt;/p&gt;

&lt;p&gt;上式是一个 $n-1$ 阶的多项式，这是利用 $y_1,y_2,\dots y_n$ 所能得到的唯一的一个 $n-1$ 阶多项式（注：多项式 插值具有唯一性）。但拉格朗日公式本身有个缺点，就是没有给出所需的数据点数量，以争取达到理想的精度。不过， 当我们希望表达一个函数的明确的插值多项式时，而$x$ 又远离插值节点，那么使用拉格朗日公式是有益的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Lagrange performs interpolation with unequally-spaced abscissae.
//
// Given a table of X and Y values, interpolate a new y value for argument x.
//
// X values in the table do not have to be equally spaced; they do not even
// have to be in order.  They must however, be distinct.
// table 中包含了 n 个点且xi 必须互异,x 为目标插值点
func Lagrange(x float64, table []struct{ X, Y float64 }) (y float64) {
	// method of BASIC program, p. 33.
	sum := 0.
	for i := range table {
		xi := table[i].X
		prod := 1.
		for j := range table {
			if i != j {
				xj := table[j].X
				prod *= (x - xj) / (xi - xj)
			}
		}
		sum += table[i].Y * prod
	}
	return sum
}
// LagrangePoly uses the formula of Lagrange to produce an interpolating
// polynomial.
//
// X values in the table do not have to be equally spaced; they do not even
// have to be in order.  They must however, be distinct.
//
// The returned polynomial will be of degree n-1 where n is the number of rows
// in the table.  It can be evaluated for x using common.Horner.
// 构造拉格朗日多项式，返回各项系数(0-n)
func LagrangePoly(table []struct{ X, Y float64 }) []float64 {
	// Method not fully described by Meeus, but needed for numerical solution
	// to Example 3.g.
	sum := make([]float64, len(table))
	prod := make([]float64, len(table))
	last := len(table) - 1
	for i := range table {
		xi := table[i].X
		yi := table[i].Y
		prod[last] = 1
		den := 1.
		n := last
		for j := range table {
			if i != j {
				xj := table[j].X
				prod[n-1] = prod[n] * -xj
				for k := n; k &amp;lt; last; k++ {
					prod[k] -= prod[k+1] * xj
				}
				n--
				den *= (xi - xj)
			}
		}
		for j, pj := range prod {
			sum[j] += yi * pj / den
		}
	}
	return sum
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>寿星万年历的Go 语言实现（一）</title>
      <link>https://mooncaker816.github.io/tmp/%E4%B8%87%E5%B9%B4%E5%8E%86/</link>
      <pubDate>Wed, 09 May 2018 14:43:35 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/tmp/%E4%B8%87%E5%B9%B4%E5%8E%86/</guid>
      <description>&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;①-背景&#34;&gt;① 背景&lt;/h2&gt;

&lt;p&gt;​        由于要用到农历的节气信息，查阅资料发现，非天文算法实现的日历无法准确的获得节气的时间点，所以只能使用天文算法来推演。&lt;/p&gt;

&lt;p&gt;​        通过度娘，我找到了由许剑伟先生开发的《寿星万年历》，该软件是一套开源的精准的年代跨度大的天文历法工具，有很多有趣的功能，感兴趣的同学可以自行搜索，在此感谢许先生的无私。&lt;/p&gt;

&lt;p&gt;​   接下来就打算把这套算法以 Go 来实现：&lt;a href=&#34;https://github.com/mooncaker816/go-calendar&#34; target=&#34;_blank&#34;&gt;Github&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;②-基本概念&#34;&gt;② 基本概念&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;公历&lt;/strong&gt;（solar calendar）：公历中规定平年有365日，闰年366日。每年含有12个月。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;儒略历&lt;/strong&gt;（Julian calendar）: 在1582年10月4日以前, 规定每4年设置一个闰年，平均年长度为365.25天&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;格里高利历&lt;/strong&gt;（Gregorian calendar）: 在1582年10月15日之后, 规定每400年97闰，平均年长度为365.2425天&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;由于儒略历存在严重的“多闰”问题，到了1582年，公历跑快了10天左右，当时就人为调整了10天，并从此改用格里历。因此务必注意1582年10月4日（儒略历）的下一日为1582年10月15日（格里高利历）。也就是说1582年10月份少了10天。&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;闰年&lt;/strong&gt; (leap year)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;儒略历&lt;/strong&gt;: 能被4整除的年份为闰年（产生多润的原因）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;格里高利历&lt;/strong&gt;: 能被4整除但不能被100整除的非世纪年 + 能被400整除的世纪年&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;儒略日&lt;/strong&gt;（Julian Day）&amp;amp; &lt;strong&gt;儒略日数&lt;/strong&gt;（Julian Day Number，JDN）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;儒略日数的计算&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;从&lt;a href=&#34;https://baike.baidu.com/item/%E6%A0%BC%E6%9E%97%E5%A8%81%E6%B2%BB%E6%A0%87%E5%87%86%E6%97%B6%E9%97%B4&#34; target=&#34;_blank&#34;&gt;格林威治标准时间&lt;/a&gt;的中午开始，包含一个整天的时间，起点的时间（0日）回溯至&lt;a href=&#34;https://baike.baidu.com/item/%E5%84%92%E7%95%A5%E5%8E%86&#34; target=&#34;_blank&#34;&gt;儒略历&lt;/a&gt;的公元前4713年1月1日中午12点（在&lt;a href=&#34;https://baike.baidu.com/item/%E6%A0%BC%E9%87%8C%E5%8E%86&#34; target=&#34;_blank&#34;&gt;格里历&lt;/a&gt;是公元前4714年11月24日），这个日期是三种多年周期的共同起点，且是历史上最接近现代的一个起点。例如，2000年1月1日的&lt;a href=&#34;https://baike.baidu.com/item/UT&#34; target=&#34;_blank&#34;&gt;UT&lt;/a&gt;12:00是儒略日2,451,545。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;设Y为给定年份，M为月份，D为该月日期（可以带小数）。&lt;/p&gt;

&lt;p&gt;若M &amp;gt; 2，Y和M不变，若 M =1或2，以Y–1代Y，以M+12代M，换句话说，如果日期在1月或2月，则被看作是在前一年的13月或14月。&lt;/p&gt;

&lt;p&gt;对格里高利历有 ：A = INT（Y/100） B = 2 - A + INT(A/4)&lt;/p&gt;

&lt;p&gt;对儒略历，取 B = 0&lt;/p&gt;

&lt;p&gt;要求的儒略日即为：JD = INT(365.25(Y+4716))+INT(30.6001(M+1))+D+B-1524.5&lt;/p&gt;

&lt;p&gt;使用数值30.6取代30.6001才是正确的，但我们仍使用30.6001，以确保总能取得恰当的整数。事实上可用30.601甚至30.61来取代30.6001。例如，5乘30.6精确等于153，然而大多数计算机不能精确表示出30.6，这导致得出一个152.999 9998的结果，它的整数部分为152，如此算出的JD就不正确了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;​  &lt;a href=&#34;https://github.com/mooncaker816/go-calendar/blob/master/greg.go&#34; target=&#34;_blank&#34;&gt;详细代码&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;儒略日反推日期&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;将JD加上0.5，令 Z 为其整数部分，F 为尾数（小数）部分。&lt;/p&gt;

&lt;p&gt;若 Z &amp;lt; 2299161，取A = Z&lt;/p&gt;

&lt;p&gt;若 Z 大于等于2299 161，计算 α=INT((Z-1867216.25)/36524.25) ，A=Z+1+α-INT(α/4)&lt;/p&gt;

&lt;p&gt;然后计算&lt;/p&gt;

&lt;p&gt;B = A+1524&lt;/p&gt;

&lt;p&gt;C = INT((B-122.1)/365.25)&lt;/p&gt;

&lt;p&gt;D = INT(365.25C)&lt;/p&gt;

&lt;p&gt;E = INT((B-D)/30.6001)&lt;/p&gt;

&lt;p&gt;该月日期（带小数部分）则为：d = B - D - INT(30.6001E) + F&lt;/p&gt;

&lt;p&gt;月份m为：
IF E &amp;lt; 14 THEN m = E – 1
IF E=14 or E=15 THEN m = E – 13&lt;/p&gt;

&lt;p&gt;年份为y：
IF m&amp;gt;2 THEN y = C – 4716
IF m =1 or m=2 THEN y = C – 4715&lt;/p&gt;

&lt;p&gt;这个公式里求E时用的数30.6001不能代之以30.6，哪怕计算机没有先前所说的问题。否则，你得到的结果会是2月0日而不是1月31日，或者4月0日而不是3月31日。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;​  &lt;a href=&#34;https://github.com/mooncaker816/go-calendar/blob/master/julian.go&#34; target=&#34;_blank&#34;&gt;详细代码&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;日期算星期&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;计算该日0时的儒略日，加上1.5，再除以7 ，所得余数将指示出星期几：若余数为0，则为星期日，1为星期一，2为星期二，3为星期三，4为星期四，5为星期五，6为星期六。&lt;/p&gt;

&lt;p&gt;儒略历到格里高利历的换算并不影响星期。因而，在1582年，10月4日星期四接下来的一天便是10月15日星期五。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;​  &lt;a href=&#34;https://github.com/mooncaker816/go-calendar/blob/master/greg.go&#34; target=&#34;_blank&#34;&gt;详细代码&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;坐标系统&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;地平坐标系统&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;在*地平*或高度方位系统，观测者位于地球上，围绕着自身的自转轴每一&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E6%81%92%E6%98%9F%E6%97%A5&#34; target=&#34;_blank&#34;&gt;恒星日&lt;/a&gt;（23h56m）相对于固定的&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E6%81%86%E6%98%9F&#34; target=&#34;_blank&#34;&gt;恒星&lt;/a&gt;背景旋转一周。在地平系统中，天体位置的定位主要用于计算出与没的短暂时间，例如，太阳升起和沉没时间的计算。过去它也用于导航，例如，确定行星位置的高度与方位，依据时间确定船只正确的经度和纬度。许多望远镜也采用经纬仪的架台，然后依据时间、地理位置，利用电脑计算天体在地平上的位置（高度和方位）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/b/b7/Horizontal_coordinate_system_2_%28zh%29.png&#34; alt=&#34;地平坐标系统&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;地平坐标系&lt;/strong&gt;，又作&lt;strong&gt;地平座标系&lt;/strong&gt;，是&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%A4%A9%E7%90%83%E5%9D%90%E6%A0%87%E7%B3%BB%E7%BB%9F&#34; target=&#34;_blank&#34;&gt;天球坐标系统&lt;/a&gt;中的一种，以观测者所在地为中心点，所在地的&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%9C%B0%E5%B9%B3%E7%B7%9A&#34; target=&#34;_blank&#34;&gt;地平线&lt;/a&gt;作为&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%9F%BA%E7%A4%8E%E5%B9%B3%E9%9D%A2&#34; target=&#34;_blank&#34;&gt;基础平面&lt;/a&gt;，将天球适当的分成能看见的上&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%8D%8A%E7%90%83&#34; target=&#34;_blank&#34;&gt;半球&lt;/a&gt;和看不见（被地球本身遮蔽）的下半球。上半球的顶点（最高点）称为&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%A4%A9%E9%A0%82&#34; target=&#34;_blank&#34;&gt;天顶&lt;/a&gt;，下半球的顶点（最低点）称为&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%A4%A9%E5%BA%95&#34; target=&#34;_blank&#34;&gt;地底&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;地平坐标系统是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;高度角（Altitude, Alt）或仰角又称&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%A4%A9%E7%90%83%E5%9D%90%E6%A0%87%E7%B3%BB%E7%BB%9F&#34; target=&#34;_blank&#34;&gt;地平纬度&lt;/a&gt;，是天体和观测者所在地的地平线的夹角，有时就称为*高度*或海拔标高（elevation, geometric height）。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E6%96%B9%E4%BD%8D%E8%A7%92&#34; target=&#34;_blank&#34;&gt;方位角&lt;/a&gt;（Azimuth, Az）又称地平经度，是沿着地平线测量的角度（由正北方为起点向东方测量）。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因此&lt;strong&gt;地平坐标系&lt;/strong&gt;有时也被称为&lt;strong&gt;高度/方位（Alt/Az）坐标系统&lt;/strong&gt;。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;赤道坐标系统&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;*赤道*坐标系统以地球的中心为中心并且固定住环绕我们的天空，因此它看起来与地球固定在一起，而我们在地球的表面上绕着自身的轴旋转。赤道坐标描述的天空，包括所见的太阳系，和现在所有的星图几乎全都用赤道坐标来绘制，而古代的东方天文学家早已使用这种坐标绘制星图。&lt;/p&gt;

&lt;p&gt;*赤道*系统是专业天文学家最常用的坐标系统，业余天文学家也使用赤道系统的架台在夜晚追踪天空的运动。天体被调整好的望远镜或其它种类的仪器找到之后，这些天体就会使用与赤道坐标匹配来标示它们的位置。&lt;/p&gt;

&lt;p&gt;最常被选用的赤道系统是古老的&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E6%9B%86%E5%85%83&#34; target=&#34;_blank&#34;&gt;1950分点&lt;/a&gt;或现代的&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E6%9B%86%E5%85%83&#34; target=&#34;_blank&#34;&gt;2000分点&lt;/a&gt;，但也可以使用标示日期的赤道系统，意味着必须考量日期的需要，例如对一颗行星或太空船位置的测量。也有细分到“平均日”坐标，它们采用平均值而忽略&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E7%AB%A0%E5%8B%95&#34; target=&#34;_blank&#34;&gt;章动&lt;/a&gt;和包含章动的&amp;rdquo;真正日期&amp;rdquo;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;黄道坐标系统&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;黄道坐标系统是一种古老的坐标系统，使用在&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%A4%A9%E6%96%87%E5%AD%B8&#34; target=&#34;_blank&#34;&gt;天文学&lt;/a&gt;和&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%8D%A0%E6%98%9F%E8%A1%93&#34; target=&#34;_blank&#34;&gt;占星术&lt;/a&gt;上未分家前的星图上，特别是在西方世界。&lt;/p&gt;

&lt;p&gt;黄道系统描述的是行星环绕太阳移动的轨道，它的中心在太阳系的重心，也就是太阳的位置。它的基本平面是地球的轨道面，称为黄道面。在行星科学中被大量使用，像是计算行星的位置和其他重要的行星轨道参数：倾角、升交点、降交点、近日点位置等等。&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>Linux Centos 命令之 cp,rm,mv</title>
      <link>https://mooncaker816.github.io/2018/04/21/linux-centos-%E5%91%BD%E4%BB%A4%E4%B9%8B-cprmmv/</link>
      <pubDate>Sat, 21 Apr 2018 13:50:00 +0000</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/04/21/linux-centos-%E5%91%BD%E4%BB%A4%E4%B9%8B-cprmmv/</guid>
      <description>&lt;h2 id=&#34;cp-copy-拷贝目录-文件&#34;&gt;cp - copy 拷贝目录，文件&lt;/h2&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;usage&#34;&gt;Usage：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Usage: cp [OPTION]... [-T] SOURCE DEST
  or:  cp [OPTION]... SOURCE... DIRECTORY
  or:  cp [OPTION]... -t DIRECTORY SOURCE...
Copy SOURCE to DEST, or multiple SOURCE(s) to DIRECTORY.

Mandatory arguments to long options are mandatory for short options too.
  -a, --archive                same as -dR --preserve=all
      --attributes-only        don&#39;t copy the file data, just the attributes
      --backup[=CONTROL]       make a backup of each existing destination file
  -b                           like --backup but does not accept an argument
      --copy-contents          copy contents of special files when recursive
  -d                           same as --no-dereference --preserve=links
  -f, --force                  if an existing destination file cannot be
                                 opened, remove it and try again (this option
                                 is ignored when the -n option is also used)
  -i, --interactive            prompt before overwrite (overrides a previous -n
                                  option)
  -H                           follow command-line symbolic links in SOURCE
  -l, --link                   hard link files instead of copying
  -L, --dereference            always follow symbolic links in SOURCE
  -n, --no-clobber             do not overwrite an existing file (overrides
                                 a previous -i option)
  -P, --no-dereference         never follow symbolic links in SOURCE
  -p                           same as --preserve=mode,ownership,timestamps
      --preserve[=ATTR_LIST]   preserve the specified attributes (default:
                                 mode,ownership,timestamps), if possible
                                 additional attributes: context, links, xattr,
                                 all
  -c                           deprecated, same as --preserve=context
      --no-preserve=ATTR_LIST  don&#39;t preserve the specified attributes
      --parents                use full source file name under DIRECTORY
  -R, -r, --recursive          copy directories recursively
      --reflink[=WHEN]         control clone/CoW copies. See below
      --remove-destination     remove each existing destination file before
                                 attempting to open it (contrast with --force)
      --sparse=WHEN            control creation of sparse files. See below
      --strip-trailing-slashes  remove any trailing slashes from each SOURCE
                                 argument
  -s, --symbolic-link          make symbolic links instead of copying
  -S, --suffix=SUFFIX          override the usual backup suffix
  -t, --target-directory=DIRECTORY  copy all SOURCE arguments into DIRECTORY
  -T, --no-target-directory    treat DEST as a normal file
  -u, --update                 copy only when the SOURCE file is newer
                                 than the destination file or when the
                                 destination file is missing
  -v, --verbose                explain what is being done
  -x, --one-file-system        stay on this file system
  -Z                           set SELinux security context of destination
                                 file to default type
      --context[=CTX]          like -Z, or if CTX is specified then set the
                                 SELinux or SMACK security context to CTX
      --help     display this help and exit
      --version  output version information and exit

By default, sparse SOURCE files are detected by a crude heuristic and the
corresponding DEST file is made sparse as well.  That is the behavior
selected by --sparse=auto.  Specify --sparse=always to create a sparse DEST
file whenever the SOURCE file contains a long enough sequence of zero bytes.
Use --sparse=never to inhibit creation of sparse files.

When --reflink[=always] is specified, perform a lightweight copy, where the
data blocks are copied only when modified.  If this is not possible the copy
fails, or if --reflink=auto is specified, fall back to a standard copy.

The backup suffix is &#39;~&#39;, unless set with --suffix or SIMPLE_BACKUP_SUFFIX.
The version control method may be selected via the --backup option or through
the VERSION_CONTROL environment variable.  Here are the values:

  none, off       never make backups (even if --backup is given)
  numbered, t     make numbered backups
  existing, nil   numbered if numbered backups exist, simple otherwise
  simple, never   always make simple backups

As a special case, cp makes a backup of SOURCE when the force and backup
options are given and SOURCE and DEST are the same name for an existing,
regular file.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;常用选项&#34;&gt;常用选项：&lt;/h3&gt;

&lt;p&gt;-a / -p：连同文件属性一起复制（用户组属性受 id 权限限制）&lt;/p&gt;

&lt;p&gt;-i（interactive）：覆盖询问&lt;/p&gt;

&lt;p&gt;-r（recursive）： 用于目录的递归复制&lt;/p&gt;

&lt;p&gt;-u （update）：source 比 destination 新才复制&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;覆盖询问&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@78063f0fe2e8 ~]# cp ~/.bashrc /tmp/bashrc
[root@78063f0fe2e8 ~]# cp -i ~/.bashrc /tmp/bashrc
cp: overwrite ‘/tmp/bashrc’? y
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;连同文件属性一起复制&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@78063f0fe2e8 ~]# cd /tmp
[root@78063f0fe2e8 tmp]# cp /var/log/wtmp .
[root@78063f0fe2e8 tmp]# ls -l /var/log/wtmp wtmp
-rw-rw-r-- 1 root utmp 0 Apr  2 18:38 /var/log/wtmp
-rw-r--r-- 1 root root 0 Apr 21 06:23 wtmp
[root@78063f0fe2e8 tmp]# cp -a /var/log/wtmp wtmp2
[root@78063f0fe2e8 tmp]# ls -l /var/log/wtmp wtmp2
-rw-rw-r-- 1 root utmp 0 Apr  2 18:38 /var/log/wtmp
-rw-rw-r-- 1 root utmp 0 Apr  2 18:38 wtmp2
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;用于目录的递归复制&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@78063f0fe2e8 tmp]# cp /etc /tmp
cp: omitting directory ‘/etc’
[root@78063f0fe2e8 tmp]# cp -r /etc /tmp
&lt;/code&gt;&lt;/pre&gt;

&lt;asciinema-player src=&#34;https://mooncaker816.github.io/asciinema/177529&#34; cols=&#34;80&#34; rows=&#34;24&#34;&gt;&lt;/asciinema-player&gt;

&lt;h2 id=&#34;rm-remove-删除目录或文件&#34;&gt;rm - remove 删除目录或文件&lt;/h2&gt;

&lt;h3 id=&#34;usage-1&#34;&gt;Usage：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Usage: rm [OPTION]... FILE...
Remove (unlink) the FILE(s).

  -f, --force           ignore nonexistent files and arguments, never prompt
  -i                    prompt before every removal
  -I                    prompt once before removing more than three files, or
                          when removing recursively; less intrusive than -i,
                          while still giving protection against most mistakes
      --interactive[=WHEN]  prompt according to WHEN: never, once (-I), or
                          always (-i); without WHEN, prompt always
      --one-file-system  when removing a hierarchy recursively, skip any
                          directory that is on a file system different from
                          that of the corresponding command line argument
      --no-preserve-root  do not treat &#39;/&#39; specially
      --preserve-root   do not remove &#39;/&#39; (default)
  -r, -R, --recursive   remove directories and their contents recursively
  -d, --dir             remove empty directories
  -v, --verbose         explain what is being done
      --help     display this help and exit
      --version  output version information and exit

By default, rm does not remove directories.  Use the --recursive (-r or -R)
option to remove each listed directory, too, along with all of its contents.

To remove a file whose name starts with a &#39;-&#39;, for example &#39;-foo&#39;,
use one of these commands:
  rm -- -foo

  rm ./-foo

Note that if you use rm to remove a file, it might be possible to recover
some of its contents, given sufficient expertise and/or time.  For greater
assurance that the contents are truly unrecoverable, consider using shred.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;常用选项-1&#34;&gt;常用选项：&lt;/h3&gt;

&lt;p&gt;-f（force）：忽略不存在的文件&lt;/p&gt;

&lt;p&gt;-i（interactive）：询问删除&lt;/p&gt;

&lt;p&gt;-r（recursive）：递归删除&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sh-4.2# cd /tmp
sh-4.2# ls
bashrc		  mingle1  tmpxq2sylvo-ascii.cast  wtmp2
ks-script-hE5IPf  test1    wtmp			   yum.log
sh-4.2# rm -i bashrc
rm: remove regular file ‘bashrc’? y
sh-4.2# ls
ks-script-hE5IPf  mingle1  test1  tmpxq2sylvo-ascii.cast  wtmp	wtmp2  yum.log
sh-4.2# rmdir mingle1
sh-4.2# rmdir test1
rmdir: failed to remove ‘test1’: Directory not empty
sh-4.2# rm -rf test1
sh-4.2# ls
ks-script-hE5IPf  tmpxq2sylvo-ascii.cast  wtmp	wtmp2  yum.log
sh-4.2# touch ./-aaa-
sh-4.2# ls
-aaa-  ks-script-hE5IPf  tmpxq2sylvo-ascii.cast  wtmp  wtmp2  yum.log
sh-4.2# rm -f -aaa-
rm: invalid option -- &#39;a&#39;
Try &#39;rm ./-aaa-&#39; to remove the file ‘-aaa-’.
Try &#39;rm --help&#39; for more information.
sh-4.2# rm -f ./-aaa-
sh-4.2# ls
ks-script-hE5IPf  tmpxq2sylvo-ascii.cast  wtmp	wtmp2  yum.log
sh-4.2# rm -rf wtmp*
sh-4.2# ls
ks-script-hE5IPf  tmpxq2sylvo-ascii.cast  yum.log
&lt;/code&gt;&lt;/pre&gt;

&lt;asciinema-player src=&#34;https://mooncaker816.github.io/asciinema/177530&#34; cols=&#34;80&#34; rows=&#34;24&#34;&gt;&lt;/asciinema-player&gt;

&lt;h2 id=&#34;mv-move-移动文件或目录-更名&#34;&gt;mv - move 移动文件或目录，更名&lt;/h2&gt;

&lt;h3 id=&#34;usage-2&#34;&gt;Usage：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Usage: mv [OPTION]... [-T] SOURCE DEST
  or:  mv [OPTION]... SOURCE... DIRECTORY
  or:  mv [OPTION]... -t DIRECTORY SOURCE...
Rename SOURCE to DEST, or move SOURCE(s) to DIRECTORY.

Mandatory arguments to long options are mandatory for short options too.
      --backup[=CONTROL]       make a backup of each existing destination file
  -b                           like --backup but does not accept an argument
  -f, --force                  do not prompt before overwriting
  -i, --interactive            prompt before overwrite
  -n, --no-clobber             do not overwrite an existing file
If you specify more than one of -i, -f, -n, only the final one takes effect.
      --strip-trailing-slashes  remove any trailing slashes from each SOURCE
                                 argument
  -S, --suffix=SUFFIX          override the usual backup suffix
  -t, --target-directory=DIRECTORY  move all SOURCE arguments into DIRECTORY
  -T, --no-target-directory    treat DEST as a normal file
  -u, --update                 move only when the SOURCE file is newer
                                 than the destination file or when the
                                 destination file is missing
  -v, --verbose                explain what is being done
  -Z, --context                set SELinux security context of destination
                                 file to default type
      --help     display this help and exit
      --version  output version information and exit

The backup suffix is &#39;~&#39;, unless set with --suffix or SIMPLE_BACKUP_SUFFIX.
The version control method may be selected via the --backup option or through
the VERSION_CONTROL environment variable.  Here are the values:

  none, off       never make backups (even if --backup is given)
  numbered, t     make numbered backups
  existing, nil   numbered if numbered backups exist, simple otherwise
  simple, never   always make simple backups
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;常用选项-2&#34;&gt;常用选项：&lt;/h3&gt;

&lt;p&gt;-f（force）：不询问直接覆盖&lt;/p&gt;

&lt;p&gt;-i（ interactive）： 询问覆盖&lt;/p&gt;

&lt;p&gt;-u（update）：source 新于 destination 才会 move&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;普通移动&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sh-4.2# cd /tmp
sh-4.2# cp ~/.bashrc bashrc1
sh-4.2# cp ~/.bashrc bashrc2
sh-4.2# ls
bashrc1  bashrc2  ks-script-hE5IPf  tmp8u627nsx-ascii.cast  yum.log
sh-4.2# mkdir mvtest
sh-4.2# ls
bashrc1  bashrc2  ks-script-hE5IPf  mvtest  tmp8u627nsx-ascii.cast  yum.log
sh-4.2# mv bashrc1 bashrc2 mvtest
sh-4.2# ls
ks-script-hE5IPf  mvtest  tmp8u627nsx-ascii.cast  yum.log
sh-4.2# cd mvtest
sh-4.2# ls
bashrc1  bashrc2
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;重命名&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sh-4.2# cd ..
sh-4.2# ls
ks-script-hE5IPf  mvtest  tmp8u627nsx-ascii.cast  yum.log
sh-4.2# mv mvtest mvtest2
sh-4.2# ls
ks-script-hE5IPf  mvtest2  tmp8u627nsx-ascii.cast  yum.log
&lt;/code&gt;&lt;/pre&gt;

&lt;asciinema-player src=&#34;https://mooncaker816.github.io/asciinema/177531&#34; cols=&#34;80&#34; rows=&#34;24&#34;&gt;&lt;/asciinema-player&gt;</description>
    </item>
    
    <item>
      <title>Linux Centos 命令之 touch,cat,tac,more,less</title>
      <link>https://mooncaker816.github.io/2018/04/21/linux-centos-%E5%91%BD%E4%BB%A4%E4%B9%8B-touchcattacmoreless/</link>
      <pubDate>Sat, 21 Apr 2018 13:50:00 +0000</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/04/21/linux-centos-%E5%91%BD%E4%BB%A4%E4%B9%8B-touchcattacmoreless/</guid>
      <description>&lt;h2 id=&#34;touch-创建空文件-修改时间&#34;&gt;touch -  创建空文件，修改时间&lt;/h2&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;usage&#34;&gt;Usage：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Usage: touch [OPTION]... FILE...
Update the access and modification times of each FILE to the current time.

A FILE argument that does not exist is created empty, unless -c or -h
is supplied.

A FILE argument string of - is handled specially and causes touch to
change the times of the file associated with standard output.

Mandatory arguments to long options are mandatory for short options too.
  -a                     change only the access time
  -c, --no-create        do not create any files
  -d, --date=STRING      parse STRING and use it instead of current time
  -f                     (ignored)
  -h, --no-dereference   affect each symbolic link instead of any referenced
                         file (useful only on systems that can change the
                         timestamps of a symlink)
  -m                     change only the modification time
  -r, --reference=FILE   use this file&#39;s times instead of current time
  -t STAMP               use [[CC]YY]MMDDhhmm[.ss] instead of current time
      --time=WORD        change the specified time:
                           WORD is access, atime, or use: equivalent to -a
                           WORD is modify or mtime: equivalent to -m
      --help     display this help and exit
      --version  output version information and exit

Note that the -d and -t options accept different time-date formats.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mtime ：modification time （默认）&lt;/p&gt;

&lt;p&gt;文件的内容被修改时会更新&lt;/p&gt;

&lt;p&gt;ctime ：status time&lt;/p&gt;

&lt;p&gt;文件的属性或权限被修改时会更新&lt;/p&gt;

&lt;p&gt;atime ： access time&lt;/p&gt;

&lt;p&gt;文件的内容被读取时会更新&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@78063f0fe2e8 etc]# ls -l login.defs
-rw-r--r-- 1 root root 2028 Nov  4  2016 login.defs
[root@78063f0fe2e8 etc]# ls -l login.defs --time=atime
-rw-r--r-- 1 root root 2028 Nov  4  2016 login.defs
[root@78063f0fe2e8 etc]# ls -l login.defs --time=ctime
-rw-r--r-- 1 root root 2028 Apr 20 14:19 login.defs
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;常用选项&#34;&gt;常用选项：&lt;/h3&gt;

&lt;p&gt;-a（access） ：仅修改访问时间&lt;/p&gt;

&lt;p&gt;-c（）：仅修改文件时间，若文件不存在则&lt;strong&gt;不&lt;/strong&gt;创建新文件&lt;/p&gt;

&lt;p&gt;-m（modification）： 仅修改 mtime&lt;/p&gt;

&lt;p&gt;-t （time）：想要修改的时间[YYMMDDhhmm]&lt;/p&gt;

&lt;p&gt;-d（date）：修改的日期&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;新建空文件&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sh-4.2# cd /tmp
sh-4.2# touch testtouch
sh-4.2# ls -l testtouch
-rw-r--r-- 1 root root 0 Apr 21 07:52 testtouch
sh-4.2# ls -l testtouch --time=atime
-rw-r--r-- 1 root root 0 Apr 21 07:52 testtouch
sh-4.2# ls -l testtouch --time=ctime
-rw-r--r-- 1 root root 0 Apr 21 07:52 testtouch
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;修改时间&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sh-4.2# cp -a ~/.bashrc bashrc
sh-4.2# ls -l bashrc
-rw-r--r-- 1 root root 176 Dec 29  2013 bashrc
sh-4.2# ls -l bashrc --time=atime
-rw-r--r-- 1 root root 176 Dec 29  2013 bashrc
sh-4.2# ls -l bashrc --time=ctime
-rw-r--r-- 1 root root 176 Apr 21 07:53 bashrc
sh-4.2# touch -d &amp;quot;2 days ago&amp;quot; bashrc
sh-4.2# ls -l bashrc
-rw-r--r-- 1 root root 176 Apr 19 07:55 bashrc
sh-4.2# ls -l bashrc --time=atime
-rw-r--r-- 1 root root 176 Apr 19 07:55 bashrc
sh-4.2# ls -l bashrc --time=ctime
-rw-r--r-- 1 root root 176 Apr 21 07:55 bashrc
sh-4.2# touch -t 1801011000 bashrc
sh-4.2# ls -l bashrc
-rw-r--r-- 1 root root 176 Jan  1 10:00 bashrc
sh-4.2# ls -l bashrc --time=ctime
-rw-r--r-- 1 root root 176 Apr 21 07:57 bashrc
sh-4.2# ls -l bashrc --time=atime
-rw-r--r-- 1 root root 176 Jan  1 10:00 bashrc
&lt;/code&gt;&lt;/pre&gt;

&lt;asciinema-player src=&#34;https://mooncaker816.github.io/asciinema/177538&#34; cols=&#34;80&#34; rows=&#34;24&#34;&gt;&lt;/asciinema-player&gt;

&lt;h2 id=&#34;cat-concatenate-浏览文件&#34;&gt;cat - concatenate 浏览文件&lt;/h2&gt;

&lt;h3 id=&#34;usage-1&#34;&gt;Usage：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Usage: cat [OPTION]... [FILE]...
Concatenate FILE(s), or standard input, to standard output.

  -A, --show-all           equivalent to -vET
  -b, --number-nonblank    number nonempty output lines, overrides -n
  -e                       equivalent to -vE
  -E, --show-ends          display $ at end of each line
  -n, --number             number all output lines
  -s, --squeeze-blank      suppress repeated empty output lines
  -t                       equivalent to -vT
  -T, --show-tabs          display TAB characters as ^I
  -u                       (ignored)
  -v, --show-nonprinting   use ^ and M- notation, except for LFD and TAB
      --help     display this help and exit
      --version  output version information and exit

With no FILE, or when FILE is -, read standard input.

Examples:
  cat f - g  Output f&#39;s contents, then standard input, then g&#39;s contents.
  cat        Copy standard input to standard output.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;常用选项-1&#34;&gt;常用选项：&lt;/h3&gt;

&lt;p&gt;-A（All）：显示所有，包括特殊字符，等价于-vET&lt;/p&gt;

&lt;p&gt;-v（verbose）：列出看不出来的特殊字符&lt;/p&gt;

&lt;p&gt;-T（Tab）：将 Tab 按键以^I 显示出来&lt;/p&gt;

&lt;p&gt;-b（blank）：列出行号，空白行不标号&lt;/p&gt;

&lt;p&gt;-n（number）：列出行号，空白行也有&lt;/p&gt;

&lt;p&gt;-E（End）：将结尾的断行字符$显示出来&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sh-4.2# cat /etc/issue
\S
Kernel \r on an \m

sh-4.2# cat -n /etc/issue
     1	\S
     2	Kernel \r on an \m
     3
sh-4.2# cat -b /etc/issue
     1	\S
     2	Kernel \r on an \m

sh-4.2# cd /tmp
sh-4.2# ls
bashrc		  mvtest2    testtouch		     yum.log
ks-script-hE5IPf  test.conf  tmpk3saal44-ascii.cast
sh-4.2# cat -A test.conf
^Ihello$
this is a test file only...$
sh-4.2# cat -An test.conf
     1	^Ihello$
     2	this is a test file only...$
&lt;/code&gt;&lt;/pre&gt;

&lt;asciinema-player src=&#34;https://mooncaker816.github.io/asciinema/177541&#34; cols=&#34;80&#34; rows=&#34;24&#34;&gt;&lt;/asciinema-player&gt;

&lt;h2 id=&#34;tac-反向-cat&#34;&gt;tac - 反向 cat&lt;/h2&gt;

&lt;h3 id=&#34;usage-2&#34;&gt;Usage：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Usage: tac [OPTION]... [FILE]...
Write each FILE to standard output, last line first.
With no FILE, or when FILE is -, read standard input.

Mandatory arguments to long options are mandatory for short options too.
  -b, --before             attach the separator before instead of after
  -r, --regex              interpret the separator as a regular expression
  -s, --separator=STRING   use STRING as the separator instead of newline
      --help     display this help and exit
      --version  output version information and exit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;tac 没有 -n 选项&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@78063f0fe2e8 ~]# tac /etc/issue

Kernel \r on an \m
\S
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;nl-添加行号显示文件&#34;&gt;nl - 添加行号显示文件&lt;/h2&gt;

&lt;h3 id=&#34;usage-3&#34;&gt;Usage：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Usage: nl [OPTION]... [FILE]...
Write each FILE to standard output, with line numbers added.
With no FILE, or when FILE is -, read standard input.

Mandatory arguments to long options are mandatory for short options too.
  -b, --body-numbering=STYLE      use STYLE for numbering body lines
  -d, --section-delimiter=CC      use CC for separating logical pages
  -f, --footer-numbering=STYLE    use STYLE for numbering footer lines
  -h, --header-numbering=STYLE    use STYLE for numbering header lines
  -i, --line-increment=NUMBER     line number increment at each line
  -l, --join-blank-lines=NUMBER   group of NUMBER empty lines counted as one
  -n, --number-format=FORMAT      insert line numbers according to FORMAT
  -p, --no-renumber               do not reset line numbers at logical pages
  -s, --number-separator=STRING   add STRING after (possible) line number
  -v, --starting-line-number=NUMBER  first line number on each logical page
  -w, --number-width=NUMBER       use NUMBER columns for line numbers
      --help     display this help and exit
      --version  output version information and exit

By default, selects -v1 -i1 -l1 -sTAB -w6 -nrn -hn -bt -fn.  CC are
two delimiter characters for separating logical pages, a missing
second character implies :.  Type \\ for \.  STYLE is one of:

  a         number all lines
  t         number only nonempty lines
  n         number no lines
  pBRE      number only lines that contain a match for the basic regular
            expression, BRE

FORMAT is one of:

  ln   left justified, no leading zeros
  rn   right justified, no leading zeros
  rz   right justified, leading zeros
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@78063f0fe2e8 ~]# nl /etc/issue
     1	\S
     2	Kernel \r on an \m

[root@78063f0fe2e8 ~]# nl /etc/issue -b a
     1	\S
     2	Kernel \r on an \m
     3
[root@78063f0fe2e8 ~]# nl /etc/issue -b a -n rz
000001	\S
000002	Kernel \r on an \m
000003
[root@78063f0fe2e8 ~]# nl /etc/issue -b a -n ln
1     	\S
2     	Kernel \r on an \m
3
[root@78063f0fe2e8 ~]# nl /etc/issue -b a -n rn
     1	\S
     2	Kernel \r on an \m
     3
[root@78063f0fe2e8 ~]# nl /etc/issue -b a -n rn -w 3
  1	\S
  2	Kernel \r on an \m
  3
[root@78063f0fe2e8 ~]# nl /etc/issue -b a -n rz -w 3
001	\S
002	Kernel \r on an \m
003
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;more-一页一页显示文件内容&#34;&gt;more - 一页一页显示文件内容&lt;/h2&gt;

&lt;h3 id=&#34;usage-4&#34;&gt;Usage：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;more: unknown option -help
Usage: more [options] file...

Options:
  -d        display help instead of ring bell
  -f        count logical, rather than screen lines
  -l        suppress pause after form feed
  -p        do not scroll, clean screen and display text
  -c        do not scroll, display text and clean line ends
  -u        suppress underlining
  -s        squeeze multiple blank lines into one
  -NUM      specify the number of lines per screenful
  +NUM      display file beginning from line number NUM
  +/STRING  display file beginning from search string match
  -V        output version information and exit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;空格：向下翻一页&lt;/p&gt;

&lt;p&gt;Enter：向下一行&lt;/p&gt;

&lt;p&gt;/字符串：向下查询字符串&lt;/p&gt;

&lt;p&gt;q：退出查看&lt;/p&gt;

&lt;p&gt;b：往回翻页&lt;/p&gt;

&lt;h2 id=&#34;less-more-的进阶&#34;&gt;less - more 的进阶&lt;/h2&gt;

&lt;p&gt;略&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Linux Centos 命令之 mkdir,rmdir,pwd,cd</title>
      <link>https://mooncaker816.github.io/2018/04/21/linux-centos-%E5%91%BD%E4%BB%A4%E4%B9%8B-mkdirrmdirpwdcd/</link>
      <pubDate>Sat, 21 Apr 2018 12:50:00 +0000</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/04/21/linux-centos-%E5%91%BD%E4%BB%A4%E4%B9%8B-mkdirrmdirpwdcd/</guid>
      <description>&lt;h2 id=&#34;mkdir-make-directory-创建目录&#34;&gt;mkdir - make directory 创建目录&lt;/h2&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;usage&#34;&gt;Usage：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Usage: mkdir [OPTION]... DIRECTORY...
Create the DIRECTORY(ies), if they do not already exist.

Mandatory arguments to long options are mandatory for short options too.
  -m, --mode=MODE   set file mode (as in chmod), not a=rwx - umask
  -p, --parents     no error if existing, make parent directories as needed
  -v, --verbose     print a message for each created directory
  -Z                   set SELinux security context of each created directory
                         to the default type
      --context[=CTX]  like -Z, or if CTX is specified then set the SELinux
                         or SMACK security context to CTX
      --help     display this help and exit
      --version  output version information and exit
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;常用选项&#34;&gt;常用选项：&lt;/h3&gt;

&lt;p&gt;-m（mode）：按指定权限创建目录，若没有该选项则按 umask 的默认设置创建&lt;/p&gt;

&lt;p&gt;-p（parent）：递归创建所有目录&lt;/p&gt;

&lt;p&gt;-v（verbose）： 打印出每个创建的目录&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;递归创建目录&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@78063f0fe2e8 ~]# mkdir -pv /tmp/test1/test2/test3
mkdir: created directory ‘/tmp/test1’
mkdir: created directory ‘/tmp/test1/test2’
mkdir: created directory ‘/tmp/test1/test2/test3’
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;目录的权限由 umask 决定&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@78063f0fe2e8 ~]# umask
0022
[root@78063f0fe2e8 ~]# umask -S
u=rwx,g=rx,o=rx
[root@78063f0fe2e8 ~]# ls /tmp/test1 -l
total 4
drwxr-xr-x 3 root root 4096 Apr 21 05:01 test2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;022是指对应三个组别分别要减去的权限分数，777-022=755=（rwxr-xr-x）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;指定创建权限为711的目录&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@78063f0fe2e8 ~]# mkdir /tmp/mingle -m 711
[root@78063f0fe2e8 ~]# ls /tmp/mingle -ld
drwx--x--x 2 root root 4096 Apr 21 05:10 /tmp/mingle
&lt;/code&gt;&lt;/pre&gt;

&lt;asciinema-player src=&#34;https://mooncaker816.github.io/asciinema/177520&#34; cols=&#34;80&#34; rows=&#34;24&#34;&gt;&lt;/asciinema-player&gt;

&lt;h2 id=&#34;rmdir-remove-empty-directory-删除空目录&#34;&gt;rmdir - remove empty directory 删除空目录&lt;/h2&gt;

&lt;h3 id=&#34;usage-1&#34;&gt;Usage：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Usage: rmdir [OPTION]... DIRECTORY...
Remove the DIRECTORY(ies), if they are empty.

      --ignore-fail-on-non-empty
                  ignore each failure that is solely because a directory
                    is non-empty
  -p, --parents   remove DIRECTORY and its ancestors; e.g., &#39;rmdir -p a/b/c&#39; is
                    similar to &#39;rmdir a/b/c a/b a&#39;
  -v, --verbose   output a diagnostic for every directory processed
      --help     display this help and exit
      --version  output version information and exit
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;常用选项-1&#34;&gt;常用选项：&lt;/h3&gt;

&lt;p&gt;-p（parent）：递归删除空目录&lt;/p&gt;

&lt;p&gt;-v（verbose）：打印出每个删除的目录&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@78063f0fe2e8 ~]# mkdir -p /tmp/test1/test2/test3
[root@78063f0fe2e8 ~]# rmdir -pv /tmp/test1/test2/test3
rmdir: removing directory, ‘/tmp/test1/test2/test3’
rmdir: removing directory, ‘/tmp/test1/test2’
rmdir: removing directory, ‘/tmp/test1’
rmdir: removing directory, ‘/tmp’
rmdir: failed to remove directory ‘/tmp’: Directory not empty
&lt;/code&gt;&lt;/pre&gt;

&lt;asciinema-player src=&#34;https://mooncaker816.github.io/asciinema/177521&#34; cols=&#34;80&#34; rows=&#34;24&#34;&gt;&lt;/asciinema-player&gt;

&lt;h2 id=&#34;pwd-print-working-directory-打印当前路径&#34;&gt;pwd - print working directory 打印当前路径&lt;/h2&gt;

&lt;h3 id=&#34;usage-2&#34;&gt;Usage：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pwd [-LP]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;常用选项-2&#34;&gt;常用选项：&lt;/h3&gt;

&lt;p&gt;-L（link）：若为软链，则显示软链路径(默认)&lt;/p&gt;

&lt;p&gt;-P（）：若为软链，则显示为实际指向路径&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@78063f0fe2e8 mail]# ls -ld /var/mail
lrwxrwxrwx 1 root root 10 Apr  2 18:38 /var/mail -&amp;gt; spool/mail
[root@78063f0fe2e8 mail]# pwd
/var/mail
[root@78063f0fe2e8 mail]# pwd -P
/var/spool/mail
[root@78063f0fe2e8 mail]# pwd -L
/var/mail
&lt;/code&gt;&lt;/pre&gt;

&lt;asciinema-player src=&#34;https://mooncaker816.github.io/asciinema/177522&#34; cols=&#34;80&#34; rows=&#34;24&#34;&gt;&lt;/asciinema-player&gt;

&lt;h2 id=&#34;cd-change-directory-切换当前路径&#34;&gt;cd - change directory 切换当前路径&lt;/h2&gt;

&lt;h3 id=&#34;常用目录&#34;&gt;常用目录：&lt;/h3&gt;

&lt;p&gt;&amp;rdquo;.&amp;rdquo; ： 当前目录&lt;/p&gt;

&lt;p&gt;&amp;rdquo;..&amp;rdquo; ：上级目录&lt;/p&gt;

&lt;p&gt;&amp;rdquo;-&amp;rdquo; ：前一个工作目录&lt;/p&gt;

&lt;p&gt;&amp;ldquo;~&amp;ldquo;,&amp;rdquo; &amp;ldquo; ：当前用户所在的主目录
&amp;ldquo;~account&amp;rdquo; ：account 这个用户所在的主目录&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@78063f0fe2e8 mail]# cd
[root@78063f0fe2e8 ~]#
[root@78063f0fe2e8 ~]# cd /tmp
[root@78063f0fe2e8 tmp]# cd
[root@78063f0fe2e8 ~]# cd ~root
[root@78063f0fe2e8 ~]# cd -
/root
[root@78063f0fe2e8 ~]# cd ..
[root@78063f0fe2e8 /]# cd -
/root
[root@78063f0fe2e8 ~]# cd /var/mail
[root@78063f0fe2e8 mail]#
&lt;/code&gt;&lt;/pre&gt;

&lt;asciinema-player src=&#34;https://mooncaker816.github.io/asciinema/177524&#34; cols=&#34;80&#34; rows=&#34;24&#34;&gt;&lt;/asciinema-player&gt;</description>
    </item>
    
    <item>
      <title>Linux Centos 命令之 ls</title>
      <link>https://mooncaker816.github.io/2018/04/21/linux-centos-%E5%91%BD%E4%BB%A4%E4%B9%8B-ls/</link>
      <pubDate>Sat, 21 Apr 2018 11:50:00 +0000</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/04/21/linux-centos-%E5%91%BD%E4%BB%A4%E4%B9%8B-ls/</guid>
      <description>&lt;h2 id=&#34;ls-list-列出文件与目录&#34;&gt;ls - list 列出文件与目录&lt;/h2&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;usage&#34;&gt;Usage：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Usage: ls [OPTION]... [FILE]...
List information about the FILEs (the current directory by default).
Sort entries alphabetically if none of -cftuvSUX nor --sort is specified.

Mandatory arguments to long options are mandatory for short options too.
  -a, --all                  do not ignore entries starting with .
  -A, --almost-all           do not list implied . and ..
      --author               with -l, print the author of each file
  -b, --escape               print C-style escapes for nongraphic characters
      --block-size=SIZE      scale sizes by SIZE before printing them; e.g.,
                               &#39;--block-size=M&#39; prints sizes in units of
                               1,048,576 bytes; see SIZE format below
  -B, --ignore-backups       do not list implied entries ending with ~
  -c                         with -lt: sort by, and show, ctime (time of last
                               modification of file status information);
                               with -l: show ctime and sort by name;
                               otherwise: sort by ctime, newest first
  -C                         list entries by columns
      --color[=WHEN]         colorize the output; WHEN can be &#39;never&#39;, &#39;auto&#39;,
                               or &#39;always&#39; (the default); more info below
  -d, --directory            list directories themselves, not their contents
  -D, --dired                generate output designed for Emacs&#39; dired mode
  -f                         do not sort, enable -aU, disable -ls --color
  -F, --classify             append indicator (one of */=&amp;gt;@|) to entries
      --file-type            likewise, except do not append &#39;*&#39;
      --format=WORD          across -x, commas -m, horizontal -x, long -l,
                               single-column -1, verbose -l, vertical -C
      --full-time            like -l --time-style=full-iso
  -g                         like -l, but do not list owner
      --group-directories-first
                             group directories before files;
                               can be augmented with a --sort option, but any
                               use of --sort=none (-U) disables grouping
  -G, --no-group             in a long listing, don&#39;t print group names
  -h, --human-readable       with -l, print sizes in human readable format
                               (e.g., 1K 234M 2G)
      --si                   likewise, but use powers of 1000 not 1024
  -H, --dereference-command-line
                             follow symbolic links listed on the command line
      --dereference-command-line-symlink-to-dir
                             follow each command line symbolic link
                               that points to a directory
      --hide=PATTERN         do not list implied entries matching shell PATTERN
                               (overridden by -a or -A)
      --indicator-style=WORD  append indicator with style WORD to entry names:
                               none (default), slash (-p),
                               file-type (--file-type), classify (-F)
  -i, --inode                print the index number of each file
  -I, --ignore=PATTERN       do not list implied entries matching shell PATTERN
  -k, --kibibytes            default to 1024-byte blocks for disk usage
  -l                         use a long listing format
  -L, --dereference          when showing file information for a symbolic
                               link, show information for the file the link
                               references rather than for the link itself
  -m                         fill width with a comma separated list of entries
  -n, --numeric-uid-gid      like -l, but list numeric user and group IDs
  -N, --literal              print raw entry names (don&#39;t treat e.g. control
                               characters specially)
  -o                         like -l, but do not list group information
  -p, --indicator-style=slash
                             append / indicator to directories
  -q, --hide-control-chars   print ? instead of nongraphic characters
      --show-control-chars   show nongraphic characters as-is (the default,
                               unless program is &#39;ls&#39; and output is a terminal)
  -Q, --quote-name           enclose entry names in double quotes
      --quoting-style=WORD   use quoting style WORD for entry names:
                               literal, locale, shell, shell-always, c, escape
  -r, --reverse              reverse order while sorting
  -R, --recursive            list subdirectories recursively
  -s, --size                 print the allocated size of each file, in blocks
  -S                         sort by file size
      --sort=WORD            sort by WORD instead of name: none (-U), size (-S),
                               time (-t), version (-v), extension (-X)
      --time=WORD            with -l, show time as WORD instead of default
                               modification time: atime or access or use (-u)
                               ctime or status (-c); also use specified time
                               as sort key if --sort=time
      --time-style=STYLE     with -l, show times using style STYLE:
                               full-iso, long-iso, iso, locale, or +FORMAT;
                               FORMAT is interpreted like in &#39;date&#39;; if FORMAT
                               is FORMAT1&amp;lt;newline&amp;gt;FORMAT2, then FORMAT1 applies
                               to non-recent files and FORMAT2 to recent files;
                               if STYLE is prefixed with &#39;posix-&#39;, STYLE
                               takes effect only outside the POSIX locale
  -t                         sort by modification time, newest first
  -T, --tabsize=COLS         assume tab stops at each COLS instead of 8
  -u                         with -lt: sort by, and show, access time;
                               with -l: show access time and sort by name;
                               otherwise: sort by access time
  -U                         do not sort; list entries in directory order
  -v                         natural sort of (version) numbers within text
  -w, --width=COLS           assume screen width instead of current value
  -x                         list entries by lines instead of by columns
  -X                         sort alphabetically by entry extension
  -1                         list one file per line

SELinux options:

  --lcontext                 Display security context.   Enable -l. Lines
                             will probably be too wide for most displays.
  -Z, --context              Display security context so it fits on most
                             displays.  Displays only mode, user, group,
                             security context and file name.
  --scontext                 Display only security context and file name.
      --help     display this help and exit
      --version  output version information and exit

SIZE is an integer and optional unit (example: 10M is 10*1024*1024).  Units
are K, M, G, T, P, E, Z, Y (powers of 1024) or KB, MB, ... (powers of 1000).

Using color to distinguish file types is disabled both by default and
with --color=never.  With --color=auto, ls emits color codes only when
standard output is connected to a terminal.  The LS_COLORS environment
variable can change the settings.  Use the dircolors command to set it.

Exit status:
 0  if OK,
 1  if minor problems (e.g., cannot access subdirectory),
 2  if serious trouble (e.g., cannot access command-line argument).
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;常用选项&#34;&gt;常用选项：&lt;/h3&gt;

&lt;p&gt;-a：列出所有文件&lt;/p&gt;

&lt;p&gt;-d：列出目录本身，而不是其内容&lt;/p&gt;

&lt;p&gt;-h：以适合人类阅读的格式输出（size 大小转为 K，M，G 等）&lt;/p&gt;

&lt;p&gt;-i：打印出每个文件的 inode编号&lt;/p&gt;

&lt;p&gt;inode 参考：&lt;a href=&#34;http://www.ruanyifeng.com/blog/2011/12/inode.html&#34; target=&#34;_blank&#34;&gt;http://www.ruanyifeng.com/blog/2011/12/inode.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;-l：以长格式显示完整信息&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;drwxr-xr-x   2 root root  4096 Nov  5  2016 srv
dr-xr-xr-x  13 root root     0 Apr 21 03:02 sys
drwxrwxrwt   1 root root  4096 Apr 20 21:17 tmp
drwxr-xr-x   1 root root  4096 Apr  2 18:38 usr
drwxr-xr-x   1 root root  4096 Apr  2 18:38 var
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;drwxr-xr-x:&lt;/p&gt;

&lt;p&gt;常用文件类型：（-普通文件，d 目录，l 软链接文件）&lt;/p&gt;

&lt;p&gt;权限设置：rwxr-xr-x (拥有者权限 rwx，所属组权限r-x，其他权限r-x)&lt;/p&gt;

&lt;asciinema-player src=&#34;https://mooncaker816.github.io/asciinema/177514&#34; cols=&#34;80&#34; rows=&#34;24&#34;&gt;&lt;/asciinema-player&gt;</description>
    </item>
    
    <item>
      <title>Go 标准库学习</title>
      <link>https://mooncaker816.github.io/2018/01/14/go-%E6%A0%87%E5%87%86%E5%BA%93%E5%AD%A6%E4%B9%A0/</link>
      <pubDate>Sun, 14 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/01/14/go-%E6%A0%87%E5%87%86%E5%BA%93%E5%AD%A6%E4%B9%A0/</guid>
      <description>&lt;h3 id=&#34;bytes和strings函数比对&#34;&gt;bytes和strings函数比对&lt;/h3&gt;

&lt;p&gt;&lt;/p&gt;

&lt;table&gt;&lt;tr&gt;&lt;td&gt;bytes&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;strings&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;函数签名&lt;/td&gt;&lt;td&gt;功能&lt;/td&gt;&lt;td&gt;函数签名&lt;/td&gt;&lt;td&gt;功能&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func explode(s []byte, n int) [][]byte&lt;/td&gt;&lt;td&gt;以每个utf8字符为单位，将前n个字符对应的[]byte型组成新的slice返回&lt;/td&gt;&lt;td&gt;func explode(s string, n int) []string&lt;/td&gt;&lt;td&gt;以每个utf8字符为单位，将前n个字符对应的string型组成新的slice返回&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func countGeneric(s, sep []byte) int&lt;/td&gt;&lt;td&gt;返回s中有几个sep，若sep为空，则返回sutf8.RuneCount(s) + 1&lt;/td&gt;&lt;td&gt;func countGeneric(s, substr string) int&lt;/td&gt;&lt;td&gt;返回s中有几个substr，若substr为空，则返回sutf8.RuneCount(s) + 1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func Contains(b, subslice []byte) bool&lt;/td&gt;&lt;td&gt;b中是否含有subslice&lt;/td&gt;&lt;td&gt;func Contains(s, substr string) bool&lt;/td&gt;&lt;td&gt;s中是否含有substr&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func ContainsAny(b []byte, chars string) bool&lt;/td&gt;&lt;td&gt;b中是否含有字符串chars&lt;/td&gt;&lt;td&gt;func ContainsAny(s, chars string) bool&lt;/td&gt;&lt;td&gt;s中是否含有字符串chars中的任意一个unicode字符&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func ContainsRune(b []byte, r rune) bool&lt;/td&gt;&lt;td&gt;b中是否含有rune r&lt;/td&gt;&lt;td&gt;func ContainsRune(s string, r rune) bool&lt;/td&gt;&lt;td&gt;s中是否含有rune r&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func indexBytePortable(s []byte, c byte) int（并没有导出也没有用于内部）&lt;/td&gt;&lt;td&gt;返回s中c的位置，若不含有c，则返回-1&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func LastIndex(s, sep []byte) int&lt;/td&gt;&lt;td&gt;返回s中最后一个sep的位置，若sep为空，返回s的长度，若不含sep，则返回-1&lt;/td&gt;&lt;td&gt;func LastIndex(s, substr string) int&lt;/td&gt;&lt;td&gt;返回s中最后一个substr的位置，若substr为空，返回s的长度，若不含substr，则返回-1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func LastIndexByte(s []byte, c byte) int&lt;/td&gt;&lt;td&gt;返回最后一个c的位置，没有则返回-1&lt;/td&gt;&lt;td&gt;func LastIndexByte(s string, c byte) int&lt;/td&gt;&lt;td&gt;返回最后一个c的位置，没有则返回-1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func IndexRune(s []byte, r rune) int&lt;/td&gt;&lt;td&gt;返回第一个r的位置，如果r无法解码为utf8又不是\uFFFD，认为没找到返回-1&lt;/td&gt;&lt;td&gt;func IndexRune(s string, r rune) int&lt;/td&gt;&lt;td&gt;返回第一个r的位置，如果r无法解码为utf8又不是\uFFFD，认为没找到返回-1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func IndexAny(s []byte, chars string) int&lt;/td&gt;&lt;td&gt;返回chars中任意一个unicode字符在s中第一次出现的位置&lt;/td&gt;&lt;td&gt;func IndexAny(s, chars string) int&lt;/td&gt;&lt;td&gt;返回chars中任意一个unicode字符在s中第一次出现的位置&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func LastIndexAny(s []byte, chars string) int&lt;/td&gt;&lt;td&gt;返回chars中任意一个unicode字符在s中最后一次出现的位置&lt;/td&gt;&lt;td&gt;func LastIndexAny(s, chars string) int&lt;/td&gt;&lt;td&gt;返回chars中任意一个unicode字符在s中最后一次出现的位置&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func genSplit(s, sep []byte, sepSave, n int) [][]byte&lt;/td&gt;&lt;td&gt;按sep划分s，返回前n个组成的slice，每个slice中sep的保留位数有sepSave决定，n小于0时，返回所有划分组成的slice&lt;/td&gt;&lt;td&gt;func genSplit(s, sep string, sepSave, n int) []string&lt;/td&gt;&lt;td&gt;按sep划分s，返回前n个组成的slice，每个slice中sep的保留位数有sepSave决定，n小于0时，返回所有划分组成的slice&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func SplitN(s, sep []byte, n int) [][]byte&lt;/td&gt;&lt;td&gt;按sep划分s，返回前n个划分的slice组成的slice，每个划分的slice不包含sep，n小于0返回所有划分组成的slice&lt;/td&gt;&lt;td&gt;func SplitN(s, sep string, n int) []string&lt;/td&gt;&lt;td&gt;按sep划分s，返回前n个划分的string组成的slice，每个划分的string不包含sep，n小于0返回所有划分组成的slice&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func SplitAfterN(s, sep []byte, n int) [][]byte&lt;/td&gt;&lt;td&gt;按sep划分s，返回前n个划分的slice组成slice，每个划分包含sep&lt;/td&gt;&lt;td&gt;func SplitAfterN(s, sep string, n int) []string&lt;/td&gt;&lt;td&gt;按sep划分s，返回前n个划分的string组成slice，每个划分包含sep&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func Split(s, sep []byte) [][]byte&lt;/td&gt;&lt;td&gt;返回所有的由sep划分的slice组成的slice，每个划分不包含sep&lt;/td&gt;&lt;td&gt;func Split(s, sep string) []string&lt;/td&gt;&lt;td&gt;返回所有的由sep划分的string组成的slice，每个划分不包含sep&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func SplitAfter(s, sep []byte) [][]byte&lt;/td&gt;&lt;td&gt;返回所有的由sep划分的slice组成的slice，每个划分包含sep&lt;/td&gt;&lt;td&gt;func SplitAfter(s, sep string) []string&lt;/td&gt;&lt;td&gt;返回所有的由sep划分的string组成的slice，每个划分包含sep&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func Fields(s []byte) [][]byte&lt;/td&gt;&lt;td&gt;按unicode.IsSpace划分s（所有连续的whitespce当成一个sep），返回所有的划分组成的slice&lt;/td&gt;&lt;td&gt;func Fields(s string) []string&lt;/td&gt;&lt;td&gt;按unicode.IsSpace划分s（所有连续的whitespce当成一个sep），返回所有的划分组成的slice&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func FieldsFunc(s []byte, f func(rune) bool) [][]byte&lt;/td&gt;&lt;td&gt;如果s中对应的一个rune满足f，则这个rune就是s的一个分隔符，返回s中所有分隔符划分的子slice的slice&lt;/td&gt;&lt;td&gt;func FieldsFunc(s string, f func(rune) bool) []string&lt;/td&gt;&lt;td&gt;如果s中对应的一个rune满足f，则这个rune就是s的一个分隔符，返回s中所有分隔符划分的子string的slice&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func Join(s [][]byte, sep []byte) []byte&lt;/td&gt;&lt;td&gt;将s中的元素用sep拼接起来，返回一个新的slice&lt;/td&gt;&lt;td&gt;func Join(a []string, sep string) string &lt;/td&gt;&lt;td&gt;将s中的元素用sep拼接起来，返回一个新的string&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func HasPrefix(s, prefix []byte) bool&lt;/td&gt;&lt;td&gt;判断s是否以prefix开头&lt;/td&gt;&lt;td&gt;func HasPrefix(s, prefix string) bool&lt;/td&gt;&lt;td&gt;判断s是否以prefix开头&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func HasSuffix(s, suffix []byte) bool&lt;/td&gt;&lt;td&gt;判断s是否以suffix结尾&lt;/td&gt;&lt;td&gt;func HasSuffix(s, suffix string) bool&lt;/td&gt;&lt;td&gt;判断s是否以suffix结尾&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func Map(mapping func(r rune) rune, s []byte) []byte&lt;/td&gt;&lt;td&gt;将s中对应的每个rune字符作用映射f得到新的字符，再将这些字符转为utf8存储在一个新的slice中返回&lt;/td&gt;&lt;td&gt;func Map(mapping func(rune) rune, s string) string&lt;/td&gt;&lt;td&gt;将s中对应的每个rune字符作用映射f得到新的字符，再将这些字符存储在一个新的string中返回&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func Repeat(b []byte, count int) []byte&lt;/td&gt;&lt;td&gt;重复b count次，返回新的slice&lt;/td&gt;&lt;td&gt;func Repeat(s string, count int) string&lt;/td&gt;&lt;td&gt;重复s count次，返回新的string&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func ToUpper(s []byte) []byte&lt;/td&gt;&lt;td&gt;转为大写&lt;/td&gt;&lt;td&gt;func ToUpper(s string) string&lt;/td&gt;&lt;td&gt;转为大写&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func ToLower(s []byte) []byte &lt;/td&gt;&lt;td&gt;转为小写&lt;/td&gt;&lt;td&gt;func ToLower(s string) string&lt;/td&gt;&lt;td&gt;转为小写&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func ToTitle(s []byte) []byte&lt;/td&gt;&lt;td&gt;转为Title&lt;/td&gt;&lt;td&gt;func ToTitle(s string) string&lt;/td&gt;&lt;td&gt;转为Title&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func ToUpperSpecial(c unicode.SpecialCase, s []byte) []byte&lt;/td&gt;&lt;td&gt;只将SpecialCase范围里的字符转为大写&lt;/td&gt;&lt;td&gt;func ToUpperSpecial(c unicode.SpecialCase, s string) string&lt;/td&gt;&lt;td&gt;只将SpecialCase范围里的字符转为大写&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func ToLowerSpecial(c unicode.SpecialCase, s []byte) []byte&lt;/td&gt;&lt;td&gt;只将SpecialCase范围里的字符转为小写&lt;/td&gt;&lt;td&gt;func ToLowerSpecial(c unicode.SpecialCase, s string) string&lt;/td&gt;&lt;td&gt;只将SpecialCase范围里的字符转为小写&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func ToTitleSpecial(c unicode.SpecialCase, s []byte) []byte&lt;/td&gt;&lt;td&gt;只将SpecialCase范围里的字符转为Title&lt;/td&gt;&lt;td&gt;func ToTitleSpecial(c unicode.SpecialCase, s string) string&lt;/td&gt;&lt;td&gt;只将SpecialCase范围里的字符转为Title&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func isSeparator(r rune) bool&lt;/td&gt;&lt;td&gt;r是否可以作为一个词（unicode）的分隔符&lt;br&gt;ascii码，数字，字母，下划线不可以&lt;br&gt;非ascii码，unicode的数字，字母不可以，剩下其他认为是unicode的space可以&lt;/td&gt;&lt;td&gt;func isSeparator(r rune) bool&lt;/td&gt;&lt;td&gt;r是否可以作为一个词（unicode）的分隔符&lt;br&gt;ascii码，数字，字母，下划线不可以&lt;br&gt;非ascii码，unicode的数字，字母不可以，剩下其他认为是unicode的space可以&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func Title(s []byte) []byte &lt;/td&gt;&lt;td&gt;调用Map，s中非词分隔符的字符转换为Title&lt;/td&gt;&lt;td&gt;func Title(s string) string&lt;/td&gt;&lt;td&gt;调用Map，s中非词分隔符的字符转换为Title&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func TrimLeftFunc(s []byte, f func(r rune) bool) []byte&lt;/td&gt;&lt;td&gt;以左边起第一个不满足f的rune对应的utf8码开始到s末尾的子slice&lt;/td&gt;&lt;td&gt;func TrimLeftFunc(s string, f func(rune) bool) string&lt;/td&gt;&lt;td&gt;以左边起第一个不满足f的rune对应的utf8码开始到s末尾的子string&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func TrimRightFunc(s []byte, f func(r rune) bool) []byte&lt;/td&gt;&lt;td&gt;以s头开始到从右边起第一个不满足f的rune对应的utf8码为终点的子slice&lt;/td&gt;&lt;td&gt;func TrimRightFunc(s string, f func(rune) bool) string&lt;/td&gt;&lt;td&gt;以s头开始到从右边起第一个不满足f的rune对应的utf8码为终点的子string&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func TrimFunc(s []byte, f func(r rune) bool) []byte &lt;/td&gt;&lt;td&gt;去掉左边和去掉右边的结合体&lt;/td&gt;&lt;td&gt;func TrimFunc(s string, f func(rune) bool) string&lt;/td&gt;&lt;td&gt;去掉左边和去掉右边的结合体&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func TrimPrefix(s, prefix []byte) []byte&lt;/td&gt;&lt;td&gt;去掉prefix后的子slice&lt;/td&gt;&lt;td&gt;func TrimPrefix(s, prefix string) string&lt;/td&gt;&lt;td&gt;去掉prefix后的子string&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func TrimSuffix(s, suffix []byte) []byte&lt;/td&gt;&lt;td&gt;去掉suffix后的子slice&lt;/td&gt;&lt;td&gt;func TrimSuffix(s, suffix string) string&lt;/td&gt;&lt;td&gt;去掉suffix后的子string&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func IndexFunc(s []byte, f func(r rune) bool) int&lt;/td&gt;&lt;td&gt;返回s中第一个满足f的rune字符对应的utf8码的起始位置&lt;/td&gt;&lt;td&gt;func IndexFunc(s string, f func(rune) bool) int&lt;/td&gt;&lt;td&gt;返回s中第一个满足f的rune字符对应的utf8码的起始位置&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func LastIndexFunc(s []byte, f func(r rune) bool) int&lt;/td&gt;&lt;td&gt;返回s中最后一个满足f的rune字符对应的utf8码的起始位置&lt;/td&gt;&lt;td&gt;func LastIndexFunc(s string, f func(rune) bool) int&lt;/td&gt;&lt;td&gt;返回s中最后一个满足f的rune字符对应的utf8码的起始位置&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func indexFunc(s []byte, f func(r rune) bool, truth bool)&lt;/td&gt;&lt;td&gt;返回s中第一个在f作用下得到truth的rune字符对应的utf8码的起始位置&lt;/td&gt;&lt;td&gt;func indexFunc(s string, f func(rune) bool, truth bool) int&lt;/td&gt;&lt;td&gt;返回s中第一个在f作用下得到truth的rune字符对应的utf8码的起始位置&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func lastIndexFunc(s []byte, f func(r rune) bool, truth bool) int&lt;/td&gt;&lt;td&gt;返回s中最后一个在f作用下得到truth的rune字符对应的utf8码的起始位置&lt;/td&gt;&lt;td&gt;func lastIndexFunc(s string, f func(rune) bool, truth bool) int&lt;/td&gt;&lt;td&gt;返回s中最后一个在f作用下得到truth的rune字符对应的utf8码的起始位置&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func makeASCIISet(chars string) (as asciiSet, ok bool)&lt;/td&gt;&lt;td&gt;返回s中碰到非ascii码之前所有ascii码的集合，以及s中是否都是ascii码&lt;br&gt;可以把asciiSet看成是一个32字节长度的值，其中低16字节共计128位表达128个ascii码[0,127]，高16字节用来比对非ascii码&lt;br&gt;具体存储：&lt;br&gt;asciiSet是一个含有8个元素的数组，每个元素有32位，共计256位，&lt;br&gt;其中元素的位置保存了该字符（uint8）对应的高3位（c&gt;&gt;5）的信息，&lt;br&gt;元素的内容保存了每个字符低5位（1 &lt;&lt; uint(c&amp;31)）的信息，5位最大是31（11111），&lt;br&gt;刚好uint32的每一位可以代表在相同高3位的情况下，所有字符的低5位情况，&lt;br&gt;这样就可以用数组的前4个元素完整表达128个ascii了&lt;/td&gt;&lt;td&gt;func makeASCIISet(chars string) (as asciiSet, ok bool)&lt;/td&gt;&lt;td&gt;返回s中碰到非ascii码之前所有ascii码的集合，以及s中是否都是ascii码&lt;br&gt;可以把asciiSet看成是一个32字节长度的值，其中低16字节共计128位表达128个ascii码[0,127]，高16字节用来比对非ascii码&lt;br&gt;具体存储：&lt;br&gt;asciiSet是一个含有8个元素的数组，每个元素有32位，共计256位，&lt;br&gt;其中元素的位置保存了该字符（uint8）对应的高3位（c&gt;&gt;5）的信息，&lt;br&gt;元素的内容保存了每个字符低5位（1 &lt;&lt; uint(c&amp;31)）的信息，5位最大是31（11111），&lt;br&gt;刚好uint32的每一位可以代表在相同高3位的情况下，所有字符的低5位情况，&lt;br&gt;这样就可以用数组的前4个元素完整表达128个ascii了&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func (as *asciiSet) contains(c byte) bool&lt;/td&gt;&lt;td&gt;c是否在as中&lt;/td&gt;&lt;td&gt;func (as *asciiSet) contains(c byte) bool&lt;/td&gt;&lt;td&gt;c是否在as中&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func makeCutsetFunc(cutset string) func(r rune) bool&lt;/td&gt;&lt;td&gt;返回一个判断r是否在cutset字符串中的函数&lt;br&gt;若为单字节字符串，则返回一个直接比较r是否和cutset相同的函数&lt;br&gt;根据cutset创建一个ascii码的集合，&lt;br&gt;如果全是ascii，则返回一个用来判断r是否在上述集合中的函数&lt;br&gt;如果含有非ascii，则返回一个逐一循环cutset中rune字符，判断r是否其中之一的函数&lt;/td&gt;&lt;td&gt;func makeCutsetFunc(cutset string) func(rune) bool&lt;/td&gt;&lt;td&gt;返回一个判断r是否在cutset字符串中的函数&lt;br&gt;若为单字节字符串，则返回一个直接比较r是否和cutset相同的函数&lt;br&gt;根据cutset创建一个ascii码的集合，&lt;br&gt;如果全是ascii，则返回一个用来判断r是否在上述集合中的函数&lt;br&gt;如果含有非ascii，则返回一个逐一循环cutset中rune字符，判断r是否其中之一的函数&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func Trim(s []byte, cutset string) []byte&lt;/td&gt;&lt;td&gt;将s左右两端连续属于cutset的rune字符去除，保留中间的子slice&lt;/td&gt;&lt;td&gt;func Trim(s string, cutset string) string&lt;/td&gt;&lt;td&gt;将s左右两端连续属于cutset的rune字符去除，保留中间的子string&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func TrimLeft(s []byte, cutset string) []byte&lt;/td&gt;&lt;td&gt;将s左边连续属于cutset的rune字符去除，返回剩下的子slice&lt;/td&gt;&lt;td&gt;func TrimLeft(s string, cutset string) string&lt;/td&gt;&lt;td&gt;将s左边连续属于cutset的rune字符去除，返回剩下的子string&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func TrimRight(s []byte, cutset string) []byte&lt;/td&gt;&lt;td&gt;将s右边连续属于cutset的rune字符去除，返回剩下的子slice&lt;/td&gt;&lt;td&gt;func TrimRight(s string, cutset string) string&lt;/td&gt;&lt;td&gt;将s右边连续属于cutset的rune字符去除，返回剩下的子string&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func TrimSpace(s []byte) []byte&lt;/td&gt;&lt;td&gt;去除s左右两端的whitespce，保留剩下的子slice&lt;/td&gt;&lt;td&gt;func TrimSpace(s string) string&lt;/td&gt;&lt;td&gt;去除s左右两端的whitespce，保留剩下的子string&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func Runes(s []byte) []rune&lt;/td&gt;&lt;td&gt;返回s对应的rune类型的slice&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func Replace(s, old, new []byte, n int) []byte&lt;/td&gt;&lt;td&gt;将s中前n个old替换成new，返回一个新的slice，n为负数或者n&gt;old个数时，替换所有old&lt;/td&gt;&lt;td&gt;func Replace(s, old, new string, n int) string&lt;/td&gt;&lt;td&gt;将s中前n个old替换成new，返回一个新的string，n为负数或者n&gt;old个数时，替换所有old&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func EqualFold(s, t []byte) bool&lt;/td&gt;&lt;td&gt;判断s和t在不区分大小写（包括unicode case）的情况下是否相等&lt;/td&gt;&lt;td&gt;func EqualFold(s, t string) bool&lt;/td&gt;&lt;td&gt;判断s和t在不区分大小写（包括unicode case）的情况下是否相等&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func indexRabinKarp(s, sep []byte) int&lt;/td&gt;&lt;td&gt;返回第一个sep在s中的位置&lt;br&gt;Rabin-Karp字符串匹配算法和前面介绍的《朴素字符串匹配算法》类似，也是对应每一个字符进行比较，不同的是Rabin-Karp采用了把字符进行预处理，也就是对每个字符进行对应进制数并取模运算，类似于通过某种函数计算其函数值，比较的是每个字符的函数值。预处理时间O(m)，匹配时间是O((n-m+1)m)。&lt;br&gt;Rabin-Karp算法的思想：&lt;br&gt;假设待匹配字符串的长度为M，目标字符串的长度为N（N&gt;M）；&lt;br&gt;首先计算待匹配字符串的hash值，计算目标字符串前M个字符的hash值；&lt;br&gt;比较前面计算的两个hash值，比较次数N-M+1：&lt;br&gt;若hash值不相等，则继续计算目标字符串的下一个长度为M的字符子串的hash值&lt;br&gt;若hash值相同，则需要使用朴素算法再次判断是否为相同的字串；&lt;/td&gt;&lt;td&gt;func indexRabinKarp(s, substr string) int&lt;/td&gt;&lt;td&gt;返回第一个sep在s中的位置&lt;br&gt;Rabin-Karp字符串匹配算法和前面介绍的《朴素字符串匹配算法》类似，也是对应每一个字符进行比较，不同的是Rabin-Karp采用了把字符进行预处理，也就是对每个字符进行对应进制数并取模运算，类似于通过某种函数计算其函数值，比较的是每个字符的函数值。预处理时间O(m)，匹配时间是O((n-m+1)m)。&lt;br&gt;Rabin-Karp算法的思想：&lt;br&gt;假设待匹配字符串的长度为M，目标字符串的长度为N（N&gt;M）；&lt;br&gt;首先计算待匹配字符串的hash值，计算目标字符串前M个字符的hash值；&lt;br&gt;比较前面计算的两个hash值，比较次数N-M+1：&lt;br&gt;若hash值不相等，则继续计算目标字符串的下一个长度为M的字符子串的hash值&lt;br&gt;若hash值相同，则需要使用朴素算法再次判断是否为相同的字串；&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func hashStr(sep []byte) (uint32, uint32)&lt;/td&gt;&lt;td&gt;计算sep的hash，用于Rabin-Karp算法&lt;/td&gt;&lt;td&gt;func hashStr(sep string) (uint32, uint32)&lt;/td&gt;&lt;td&gt;计算sep的hash，用于Rabin-Karp算法&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;func hashStrRev(sep string) (uint32, uint32)&lt;/td&gt;&lt;td&gt;计算reverse(sep)的hash，用于Rabin-Karp算法&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</description>
    </item>
    
    <item>
      <title>The Go Programming Language Ex（11）</title>
      <link>https://mooncaker816.github.io/2018/01/04/the-go-programming-language-ex11/</link>
      <pubDate>Thu, 04 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/01/04/the-go-programming-language-ex11/</guid>
      <description>&lt;h3 id=&#34;ex-9-1&#34;&gt;Ex 9.1&lt;/h3&gt;

&lt;p&gt;Add a function Withdraw(amount int) bool to the gopl.io/ch9/bank1 program. The result should indicate whether the transaction succeeded or failed due to insufﬁcient funds. The message sent to the monitor goroutine must contain both the amount to withdraw and a new channel over which the monitor goroutine can send the boolean result back to Withdraw.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Copyright © 2016 Alan A. A. Donovan &amp;amp; Brian W. Kernighan.
// License: https://creativecommons.org/licenses/by-nc-sa/4.0/

package bank_test

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;testing&amp;quot;

	&amp;quot;The_Go_Programming_Language_Exercises/CH9/ex9.1&amp;quot;
)

func TestBank(t *testing.T) {
	done := make(chan struct{})

	// Alice
	go func() {
		bank.Deposit(200)
		fmt.Println(&amp;quot;=&amp;quot;, bank.Balance())
		done &amp;lt;- struct{}{}
	}()

	// Bob
	go func() {
		bank.Deposit(100)
		done &amp;lt;- struct{}{}
	}()

	go func() {
		fmt.Println(bank.Withdraw(500))
		done &amp;lt;- struct{}{}
	}()

	// Wait for both transactions.
	&amp;lt;-done
	&amp;lt;-done
	&amp;lt;-done

	if got, want := bank.Balance(), 300; got != want {
		t.Errorf(&amp;quot;Balance = %d, want %d&amp;quot;, got, want)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ex-9-2&#34;&gt;Ex 9.2&lt;/h3&gt;

&lt;p&gt;Rewrite the PopCount example from Section 2.6.2 so that it initializes the l table using sync.Once the ﬁrst time it is needed. (Realistically, the cost of synchronization would be prohibitive for a small and highly optimized function like PopCount.)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Copyright © 2016 Alan A. A. Donovan &amp;amp; Brian W. Kernighan.
// License: https://creativecommons.org/licenses/by-nc-sa/4.0/

// See page 45.

// (Package doc comment intentionally malformed to demonstrate golint.)
//!+
package popcount

import &amp;quot;sync&amp;quot;

// pc[i] is the population count of i.
var pc [256]byte
var loadpcOnce sync.Once

//func init() {
//	for i := range pc {
//		pc[i] = pc[i/2] + byte(i&amp;amp;1)
//	}
//}

// PopCount returns the population count (number of set bits) of x.
func PopCount(x uint64) int {
	loadpcOnce.Do(loadpc)
	return int(pc[byte(x&amp;gt;&amp;gt;(0*8))] +
		pc[byte(x&amp;gt;&amp;gt;(1*8))] +
		pc[byte(x&amp;gt;&amp;gt;(2*8))] +
		pc[byte(x&amp;gt;&amp;gt;(3*8))] +
		pc[byte(x&amp;gt;&amp;gt;(4*8))] +
		pc[byte(x&amp;gt;&amp;gt;(5*8))] +
		pc[byte(x&amp;gt;&amp;gt;(6*8))] +
		pc[byte(x&amp;gt;&amp;gt;(7*8))])
}

func loadpc() {
	for i := range pc {
		pc[i] = pc[i/2] + byte(i&amp;amp;1)
	}
}

//!-

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ex-9-3&#34;&gt;Ex 9.3&lt;/h3&gt;

&lt;p&gt;Extend the Func type and the (*Memo).Get method so that callers may provide an optional done channel through which they can cancel the operation (§8.9). The results of a cancelled Func call should not be cached.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Copyright © 2016 Alan A. A. Donovan &amp;amp; Brian W. Kernighan.
// License: https://creativecommons.org/licenses/by-nc-sa/4.0/

// See page 278.

// Package memo provides a concurrency-safe non-blocking memoization
// of a function.  Requests for different keys proceed in parallel.
// Concurrent requests for the same key block until the first completes.
// This implementation uses a monitor goroutine.
package memo

import &amp;quot;errors&amp;quot;
import &amp;quot;time&amp;quot;

//!+Func

// Func is the type of the function to memoize.
type Func func(key string) (interface{}, error)

// A result is the result of calling a Func.
type result struct {
	value interface{}
	err   error
}

type entry struct {
	res   result
	ready chan struct{} // closed when res is ready
}

//!-Func

//!+get

// A request is a message requesting that the Func be applied to key.
type request struct {
	key      string
	response chan&amp;lt;- result // the client wants a single result
}

type Memo struct{ requests chan request }

// New returns a memoization of f.  Clients must subsequently call Close.
func New(f Func) *Memo {
	memo := &amp;amp;Memo{requests: make(chan request)}
	go memo.server(f)
	return memo
}

func (memo *Memo) Get(key string) (interface{}, error) {
	response := make(chan result)
	memo.requests &amp;lt;- request{key, response}
	res := &amp;lt;-response
	return res.value, res.err
}

func (memo *Memo) Close() { close(memo.requests) }

//!-get

//!+monitor

func (memo *Memo) server(f Func) {
	var done = make(chan struct{})
	// Cancel traversal when input is detected.
	go func() {
		//os.Stdin.Read(make([]byte, 1)) // read a single byte
		time.Sleep(300 * time.Millisecond)
		close(done)
	}()
	cancelled := func() bool {
		select {
		case &amp;lt;-done:
			return true
		default:
			return false
		}
	}
	cache := make(map[string]*entry)
	for req := range memo.requests {
		if cancelled() {
			//close(memo.requests)
			break
		}
		e := cache[req.key]
		if e == nil {
			// This is the first request for this key.
			e = &amp;amp;entry{ready: make(chan struct{})}
			cache[req.key] = e
			go e.call(f, req.key) // call f(key)
			if cancelled() {
				delete(cache, req.key)
			}
		}
		go e.deliver(req.response, done)
	}
}

func (e *entry) call(f Func, key string) {
	// Evaluate the function.
	e.res.value, e.res.err = f(key)
	// Broadcast the ready condition.
	close(e.ready)
}

func (e *entry) deliver(response chan&amp;lt;- result, done &amp;lt;-chan struct{}) {
	// Wait for the ready condition.
	select {
	case &amp;lt;-e.ready:
		response &amp;lt;- e.res
	case &amp;lt;-done:
		response &amp;lt;- result{nil, errors.New(&amp;quot;request cancelled&amp;quot;)}
	}
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>The Go Programming Language Ex（10）</title>
      <link>https://mooncaker816.github.io/2018/01/03/the-go-programming-language-ex10/</link>
      <pubDate>Wed, 03 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/01/03/the-go-programming-language-ex10/</guid>
      <description>&lt;h3 id=&#34;ex-8-6&#34;&gt;Ex 8.6&lt;/h3&gt;

&lt;p&gt;Add depth-limiting to the concurrent crawler. That is, if the user sets -depth=3, then only URLs reachable by at most three links will be fetched.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Copyright © 2016 Alan A. A. Donovan &amp;amp; Brian W. Kernighan.
// License: https://creativecommons.org/licenses/by-nc-sa/4.0/

// See page 241.

// Crawl2 crawls web links starting with the command-line arguments.
//
// This version uses a buffered channel as a counting semaphore
// to limit the number of concurrent calls to links.Extract.
package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;log&amp;quot;
	&amp;quot;os&amp;quot;

	&amp;quot;gopl.io/ch5/links&amp;quot;
)

//!+sema
// tokens is a counting semaphore used to
// enforce a limit of 20 concurrent requests.
var tokens = make(chan struct{}, 20)

func crawl(url string, deepth int, f *os.File) work {
	tokens &amp;lt;- struct{}{} // acquire a token
	list, err := links.Extract(url)
	fmt.Fprintln(f, deepth, &amp;quot; &amp;quot;, url, &amp;quot; &amp;quot;, len(list))
	&amp;lt;-tokens // release the token
	deepth++
	if err != nil {
		log.Print(err)
	}
	return work{list, deepth}
}

//!-sema
type work struct {
	worklist   []string
	workdeepth int
}

const DEEPTH = 2

//!+
func main() {
	wkpool := make(chan work)
	var n int // number of pending sends to worklist
	f, _ := os.Create(&amp;quot;stat&amp;quot;)
	defer f.Close()
	// Start with the command-line arguments.
	n++
	go func() { wkpool &amp;lt;- work{os.Args[1:], 0} }()

	// Crawl the web concurrently.
	seen := make(map[string]bool)
	for ; n &amp;gt; 0; n-- {
		wk := &amp;lt;-wkpool
		if wk.workdeepth &amp;gt; DEEPTH {
			continue
		}
		for _, link := range wk.worklist {
			if !seen[link] {
				seen[link] = true
				n++
				go func(link string, deepth int, f *os.File) {
					wkpool &amp;lt;- crawl(link, deepth, f)
				}(link, wk.workdeepth, f)
			}
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ex-8-8&#34;&gt;Ex 8.8&lt;/h3&gt;

&lt;p&gt;Using a select statement, add a timeout to the echo server from Section 8.3 so that it disconnects any client that shouts nothing within 10 seconds.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//client
package main

import (
	&amp;quot;io&amp;quot;
	&amp;quot;log&amp;quot;
	&amp;quot;net&amp;quot;
	&amp;quot;os&amp;quot;
)

func init() {
	log.SetFlags(log.Ldate | log.Lmicroseconds)
}

//!+
func main() {
	f, err := os.Open(&amp;quot;a&amp;quot;)
	defer f.Close()
	conn, err := net.Dial(&amp;quot;tcp&amp;quot;, &amp;quot;localhost:8000&amp;quot;)
	if err != nil {
		log.Fatal(err)
	}
	log.Println(&amp;quot;connected!&amp;quot;)
	done := make(chan struct{})
	go func() {
		io.Copy(os.Stdout, conn) // NOTE: ignoring errors
		log.Println(&amp;quot;done&amp;quot;)
		done &amp;lt;- struct{}{} // signal the main goroutine
	}()
	go func() {
		mustCopy(conn, os.Stdin)
		//conn.Close()
		err = conn.(*net.TCPConn).CloseWrite() //经实验：必须要关，否则无法通知服务端输入已结束（但不应该是服务端根据EOF来判断吗？）
		log.Println(&amp;quot;write finished in client: &amp;quot;, err)
	}()
	&amp;lt;-done // wait for background goroutine to finish
	log.Printf(&amp;quot;local in server: %#v\n&amp;quot;, conn.LocalAddr())
	log.Printf(&amp;quot;remote in server: %#v\n&amp;quot;, conn.RemoteAddr())
	log.Println(&amp;quot;finish print&amp;quot;)
	//err = conn.(*net.TCPConn).CloseRead()
	//log.Println(&amp;quot;read finished in client: &amp;quot;, err)
	err = conn.Close()
	log.Println(err)
}

//!-

func mustCopy(dst io.Writer, src io.Reader) {
	if _, err := io.Copy(dst, src); err != nil {
		log.Fatal(err)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//server
// Copyright © 2016 Alan A. A. Donovan &amp;amp; Brian W. Kernighan.
// License: https://creativecommons.org/licenses/by-nc-sa/4.0/

// See page 224.

// Reverb2 is a TCP server that simulates an echo.
package main

import (
	&amp;quot;bufio&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;log&amp;quot;
	&amp;quot;net&amp;quot;
	&amp;quot;strings&amp;quot;
	&amp;quot;sync&amp;quot;
	&amp;quot;time&amp;quot;
)

func init() {
	log.SetFlags(log.Ldate | log.Lmicroseconds)
}
func echo(c net.Conn, shout string, delay time.Duration, wg *sync.WaitGroup) {
	defer wg.Done()
	fmt.Fprintln(c, &amp;quot;\t&amp;quot;, strings.ToUpper(shout))
	time.Sleep(delay)
	fmt.Fprintln(c, &amp;quot;\t&amp;quot;, shout)
	time.Sleep(delay)
	fmt.Fprintln(c, &amp;quot;\t&amp;quot;, strings.ToLower(shout))
}

//!+
func handleConn(c net.Conn) {
	msg := make(chan string)
	go func(c net.Conn) {
		//for {
		input := bufio.NewScanner(c)
		for input.Scan() {
			fmt.Println(&amp;quot;getting: &amp;quot;, input.Text())
			msg &amp;lt;- input.Text()
		}
		msg &amp;lt;- &amp;quot;eof&amp;quot;
		//}
	}(c)
	ticker := time.NewTicker(5 * time.Second)
	var wg sync.WaitGroup
label1:
	for {
		select {
		case &amp;lt;-ticker.C:
			ticker.Stop()
			c.Close()
			fmt.Println(&amp;quot;connect closed!!&amp;quot;)
			return
		case s := &amp;lt;-msg:
			if s == &amp;quot;eof&amp;quot; {
				break label1
			}
			ticker.Stop()
			fmt.Println(s)
			wg.Add(1)
			go echo(c, s, 1*time.Second, &amp;amp;wg)
		}
	}
	// NOTE: ignoring potential errors from input.Err()
	//err := c.(*net.TCPConn).CloseRead()
	//log.Println(&amp;quot;read finished in server: &amp;quot;, err)
	log.Println(&amp;quot;finish scan&amp;quot;)
	log.Printf(&amp;quot;local in server: %#v\n&amp;quot;, c.LocalAddr())
	log.Printf(&amp;quot;remote in server: %#v\n&amp;quot;, c.RemoteAddr())
	wg.Wait()
	err := c.(*net.TCPConn).CloseWrite()
	//err := c.Close()
	log.Println(&amp;quot;finished in server: &amp;quot;, err)
}

//!-

func main() {
	l, err := net.Listen(&amp;quot;tcp&amp;quot;, &amp;quot;localhost:8000&amp;quot;)
	if err != nil {
		log.Fatal(err)
	}
	for {
		conn, err := l.Accept()
		if err != nil {
			log.Print(err) // e.g., connection aborted
			continue
		}
		go handleConn(conn)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;//client
$ ./ex8.3
2018/01/03 17:01:15.985187 connected!
2018/01/03 17:01:20.989292 done
2018/01/03 17:01:20.989515 local in server: &amp;amp;net.TCPAddr{IP:net.IP{0x7f, 0x0, 0x0, 0x1}, Port:49954, Zone:&amp;quot;&amp;quot;}
2018/01/03 17:01:20.989576 remote in server: &amp;amp;net.TCPAddr{IP:net.IP{0x7f, 0x0, 0x0, 0x1}, Port:8000, Zone:&amp;quot;&amp;quot;}
2018/01/03 17:01:20.989596 finish print
2018/01/03 17:01:20.989774 &amp;lt;nil&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;//server
./ex8.8
2018/01/03 17:01:20.989248 connect closed!! 127.0.0.1:8000 127.0.0.1:49954
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ex-8-9&#34;&gt;Ex 8.9&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Copyright © 2016 Alan A. A. Donovan &amp;amp; Brian W. Kernighan.
// License: https://creativecommons.org/licenses/by-nc-sa/4.0/

// See page 250.

// The du3 command computes the disk usage of the files in a directory.
package main

// The du3 variant traverses all directories in parallel.
// It uses a concurrency-limiting counting semaphore
// to avoid opening too many files at once.

import (
	&amp;quot;flag&amp;quot;
	&amp;quot;io/ioutil&amp;quot;
	&amp;quot;log&amp;quot;
	&amp;quot;os&amp;quot;
	&amp;quot;path/filepath&amp;quot;
	&amp;quot;sync&amp;quot;
	&amp;quot;time&amp;quot;
)

var vFlag = flag.Bool(&amp;quot;v&amp;quot;, false, &amp;quot;show verbose progress messages&amp;quot;)

func init() {
	log.SetFlags(log.Ldate | log.Lmicroseconds)
}

//!+
func main() {
	// ...determine roots...

	//!-
	flag.Parse()

	// Determine the initial directories.
	roots := flag.Args()
	if len(roots) == 0 {
		roots = []string{&amp;quot;.&amp;quot;}
	}

	//!+
	// Traverse each root of the file tree in parallel.
	//fileSizes := make(chan int64)
	var m sync.WaitGroup
	for _, root := range roots {
		var tick &amp;lt;-chan time.Time
		if *vFlag {
			tick = time.Tick(100 * time.Millisecond)
		}
		var fileSizes chan int64
		var n sync.WaitGroup
		fileSizes = make(chan int64)
		n.Add(1)
		go walkDir(root, &amp;amp;n, fileSizes)
		go func() {
			n.Wait()
			close(fileSizes)
		}()
		m.Add(1)
		go func(root string, tick &amp;lt;-chan time.Time) {
			defer m.Done()
			var nfiles, nbytes int64
		loop:
			for {
				select {
				case size, ok := &amp;lt;-fileSizes:
					if !ok {
						break loop // fileSizes was closed
					}
					nfiles++
					nbytes += size
				case &amp;lt;-tick:
					printDiskUsage(root, nfiles, nbytes)
				}
			}
			printDiskUsage(root, nfiles, nbytes) // final totals
		}(root, tick)
	}
	m.Wait()
}

//!-

func printDiskUsage(root string, nfiles, nbytes int64) {
	log.Printf(&amp;quot;%s: %d files  %.1f GB\n&amp;quot;, root, nfiles, float64(nbytes)/1e9)
}

// walkDir recursively walks the file tree rooted at dir
// and sends the size of each found file on fileSizes.
//!+walkDir
func walkDir(dir string, n *sync.WaitGroup, fileSizes chan&amp;lt;- int64) {
	defer n.Done()
	for _, entry := range dirents(dir) {
		if entry.IsDir() {
			n.Add(1)
			subdir := filepath.Join(dir, entry.Name())
			go walkDir(subdir, n, fileSizes)
		} else {
			fileSizes &amp;lt;- entry.Size()
		}
	}
}

//!-walkDir

//!+sema
// sema is a counting semaphore for limiting concurrency in dirents.
var sema = make(chan struct{}, 20)

// dirents returns the entries of directory dir.
func dirents(dir string) []os.FileInfo {
	sema &amp;lt;- struct{}{}        // acquire token
	defer func() { &amp;lt;-sema }() // release token
	// ...
	//!-sema

	entries, err := ioutil.ReadDir(dir)
	if err != nil {
		//fmt.Fprintf(os.Stderr, &amp;quot;du: %v\n&amp;quot;, err)
		return nil
	}
	return entries
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./ex8.9 -v /etc /usr /bin /var
2018/01/03 20:36:21.368337 /bin: 36 files  0.0 GB
2018/01/03 20:36:21.370797 /etc: 308 files  0.0 GB
2018/01/03 20:36:21.483464 /var: 2270 files  6.1 GB
2018/01/03 20:36:21.483846 /usr: 4322 files  1.9 GB
2018/01/03 20:36:21.571401 /var: 2449 files  6.3 GB
2018/01/03 20:36:21.599092 /usr: 9322 files  2.1 GB
2018/01/03 20:36:21.678850 /usr: 18130 files  2.6 GB
2018/01/03 20:36:21.782177 /usr: 47807 files  3.2 GB
2018/01/03 20:36:21.872339 /usr: 65859 files  3.7 GB
2018/01/03 20:36:21.920744 /usr: 89008 files  3.9 GB
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ex-8-12&#34;&gt;Ex 8.12&lt;/h3&gt;

&lt;p&gt;Make the broadcaster announce the current set of clients to each new arrival. This requires that the clients set and the entering and leaving channels record the client name too.&lt;/p&gt;

&lt;h3 id=&#34;ex-8-13&#34;&gt;Ex 8.13&lt;/h3&gt;

&lt;p&gt;Make the chat server disconnect idle clients, such as those that have sent no messages in the last ﬁve minutes. Hint: calling conn.Close() in another goroutine unblocks active Read calls such as the one done by input.Scan().&lt;/p&gt;

&lt;h3 id=&#34;ex-8-14&#34;&gt;Ex 8.14&lt;/h3&gt;

&lt;p&gt;Change the chat server’s network protocol so that each client provides its name on entering. Use that name instead of the network address when preﬁxing each message with its sender’s identity.&lt;/p&gt;

&lt;p&gt;只需要添加自定义协议，在压包解包的时候按协议进行就行，待做。。。&lt;/p&gt;

&lt;h3 id=&#34;ex-8-15&#34;&gt;Ex 8.15&lt;/h3&gt;

&lt;p&gt;Failure of any client program to read data in a timely manner ultimately causes all clients to get stuck. Modify the broadcaster to skip a message rather than wait if a client writer is not ready to accept it. Alternatively, add buffering to each client’s outgoing message channel so that most messages are not dropped; the broadcaster should use a non-blocking send to this channel.&lt;/p&gt;

&lt;p&gt;将broadcaster中向各个客户端发送消息的部分写入go routine，并将客户端发送通道定义为缓存通道&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Copyright © 2016 Alan A. A. Donovan &amp;amp; Brian W. Kernighan.
// License: https://creativecommons.org/licenses/by-nc-sa/4.0/

// See page 254.
//!+

// Chat is a server that lets clients chat with each other.
package main

import (
	&amp;quot;bufio&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;log&amp;quot;
	&amp;quot;net&amp;quot;
	&amp;quot;time&amp;quot;
)

//!+broadcaster
type client chan&amp;lt;- string // an outgoing message channel

var (
	entering = make(chan client)
	leaving  = make(chan client)
	messages = make(chan string) // all incoming client messages
)

func broadcaster() {
	clients := make(map[client]bool) // all connected clients
	for {
		select {
		case msg := &amp;lt;-messages:
			// Broadcast incoming message to all
			// clients&#39; outgoing message channels.
			for cli := range clients {
				cli &amp;lt;- msg
			}

		case cli := &amp;lt;-entering:
			clients[cli] = true

		case cli := &amp;lt;-leaving:
			delete(clients, cli)
			close(cli)
		}
	}
}

//!-broadcaster

//!+handleConn
func handleConn(conn net.Conn) {
	inittime := time.Now()
	itimestr := &amp;quot;[&amp;quot; + inittime.Format(&amp;quot;2006-01-02 15:04:05&amp;quot;) + &amp;quot;]&amp;quot;
	ch := make(chan string) // outgoing client messages
	go clientWriter(conn, ch)
	lastmsgtime := make(chan time.Time)
	who := conn.RemoteAddr().String()
	go func(t time.Time) {
		for {
			select {
			case t = &amp;lt;-lastmsgtime:
			default:
			}
			if time.Now().After(t.Add(20 * time.Second)) {
				ch &amp;lt;- fmt.Sprintf(&amp;quot;[%s] no msg in last 20 sec since %s, closing connect!&amp;quot;, time.Now().Format(&amp;quot;2006-01-02 15:04:05&amp;quot;), t.Format(&amp;quot;2006-01-02 15:04:05&amp;quot;))
				time.Sleep(1 * time.Second)
				conn.Close()
				//leaving &amp;lt;- ch
				//messages &amp;lt;- who + &amp;quot; has left&amp;quot;
				break
			}
		}
	}(inittime)
	ch &amp;lt;- itimestr + &amp;quot; &amp;quot; + &amp;quot;You are &amp;quot; + who
	messages &amp;lt;- itimestr + &amp;quot; &amp;quot; + who + &amp;quot; has arrived&amp;quot;
	entering &amp;lt;- ch

	input := bufio.NewScanner(conn)
	for input.Scan() {
		messages &amp;lt;- &amp;quot;[&amp;quot; + time.Now().Format(&amp;quot;2006-01-02 15:04:05&amp;quot;) + &amp;quot;]&amp;quot; + &amp;quot; &amp;quot; + who + &amp;quot;: &amp;quot; + input.Text()
		lastmsgtime &amp;lt;- time.Now()
	}
	// NOTE: ignoring potential errors from input.Err()

	leaving &amp;lt;- ch
	messages &amp;lt;- &amp;quot;[&amp;quot; + time.Now().Format(&amp;quot;2006-01-02 15:04:05&amp;quot;) + &amp;quot;]&amp;quot; + &amp;quot; &amp;quot; + who + &amp;quot; has left&amp;quot;
	conn.Close()
}

func clientWriter(conn net.Conn, ch &amp;lt;-chan string) {
	for msg := range ch {
		fmt.Fprintln(conn, msg) // NOTE: ignoring network errors
	}
}

//!-handleConn

//!+main
func main() {
	listener, err := net.Listen(&amp;quot;tcp&amp;quot;, &amp;quot;localhost:8000&amp;quot;)
	if err != nil {
		log.Fatal(err)
	}

	go broadcaster()
	for {
		conn, err := listener.Accept()
		if err != nil {
			log.Print(err)
			continue
		}
		go handleConn(conn)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./netcat1
[2018-01-04 01:09:14] You are 127.0.0.1:55627
[2018-01-04 01:09:18] 127.0.0.1:55630 has arrived
[2018-01-04 01:09:20] 127.0.0.1:55630: sdf
[2018-01-04 01:09:24] 127.0.0.1:55635 has arrived
[2018-01-04 01:09:28] 127.0.0.1:55635: ththth
[2018-01-04 01:09:34] no msg in last 20 sec since 2018-01-04 01:09:14, closing connect!
2018/01/04 01:09:35 done
$ ./netcat2
[2018-01-04 01:09:18] You are 127.0.0.1:55630
sdf
[2018-01-04 01:09:20] 127.0.0.1:55630: sdf
[2018-01-04 01:09:24] 127.0.0.1:55635 has arrived
[2018-01-04 01:09:28] 127.0.0.1:55635: ththth
[2018-01-04 01:09:35] 127.0.0.1:55627 has left
[2018-01-04 01:09:40] no msg in last 20 sec since 2018-01-04 01:09:20, closing connect!
2018/01/04 01:09:41 done
$ ./netcat3
[2018-01-04 01:09:24] You are 127.0.0.1:55635
ththth
[2018-01-04 01:09:28] 127.0.0.1:55635: ththth
[2018-01-04 01:09:35] 127.0.0.1:55627 has left
[2018-01-04 01:09:41] 127.0.0.1:55630 has left
[2018-01-04 01:09:48] no msg in last 20 sec since 2018-01-04 01:09:28, closing connect!
2018/01/04 01:09:49 done
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>The Go Programming Language Ex（9）</title>
      <link>https://mooncaker816.github.io/2018/01/01/the-go-programming-language-ex9/</link>
      <pubDate>Mon, 01 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/01/01/the-go-programming-language-ex9/</guid>
      <description>&lt;h3 id=&#34;ex-8-1&#34;&gt;Ex 8.1&lt;/h3&gt;

&lt;p&gt;Modify clock2 to accept a port number, and write a program, clockwall, that acts as a client of several clock servers at once, reading the times from each one and displaying the results in a table, akin to the wall of clocks seen in some business ofﬁces. If you have access to geographically distributed computers, run instances remotely ; otherwise run local instances on different ports with fake time zones.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;$ TZ=US/Eastern ./clock2 -port 8010 &amp;amp; $ TZ=Asia/Tokyo ./clock2 -port 8020 &amp;amp; $ TZ=Europe/London ./clock2 -port 8030 &amp;amp; $ clockwall NewYork=localhost:8010 London=localhost:8020 Tokyo=localhost:8030&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//clockwall
package main

import (
	&amp;quot;html/template&amp;quot;
	&amp;quot;log&amp;quot;
	&amp;quot;net&amp;quot;
	&amp;quot;net/http&amp;quot;
)

type City struct {
	Name string
	Addr string
	Time string
}

type cities []City

const templ = `
&amp;lt;h1&amp;gt;current times:&amp;lt;/h1&amp;gt;
&amp;lt;table&amp;gt;
&amp;lt;tr style=&#39;text-align: left&#39;&amp;gt;
  &amp;lt;th&amp;gt;City&amp;lt;/th&amp;gt;
  &amp;lt;th&amp;gt;Time&amp;lt;/th&amp;gt;
&amp;lt;/tr&amp;gt;
{{range . }}
&amp;lt;tr&amp;gt;
  &amp;lt;td&amp;gt;{{.Name}}&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;{{.Time}}&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;
{{end}}
&amp;lt;/table&amp;gt;
`

var report = template.Must(template.New(&amp;quot;result&amp;quot;).
	Parse(templ))
var cs = cities{
	{&amp;quot;NewYork&amp;quot;, &amp;quot;localhost:8010&amp;quot;, &amp;quot;&amp;quot;},
	{&amp;quot;Tokyo&amp;quot;, &amp;quot;localhost:8020&amp;quot;, &amp;quot;&amp;quot;},
	{&amp;quot;London&amp;quot;, &amp;quot;localhost:8030&amp;quot;, &amp;quot;&amp;quot;},
}

func main() {
	for i := range cs {
		go func(c *City) {
			conn, err := net.Dial(&amp;quot;tcp&amp;quot;, c.Addr)
			if err != nil {
				log.Fatal(err)
			}
			defer conn.Close()
			buf := make([]byte, 20)
			for {
				n, _ := conn.Read(buf)
				c.Time = string(buf[:n])
			}
		}(&amp;amp;cs[i])
	}
	http.HandleFunc(&amp;quot;/gettime&amp;quot;, cs.gettime)
	log.Fatal(http.ListenAndServe(&amp;quot;localhost:8000&amp;quot;, nil))
}

func (cs cities) gettime(w http.ResponseWriter, req *http.Request) {
	if err := report.Execute(w, cs); err != nil {
		log.Fatal(err)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//clock
package main

import (
	&amp;quot;flag&amp;quot;
	&amp;quot;io&amp;quot;
	&amp;quot;log&amp;quot;
	&amp;quot;net&amp;quot;
	&amp;quot;time&amp;quot;
)

func handleConn(c net.Conn) {
	defer c.Close()
	for {
		_, err := io.WriteString(c, time.Now().Format(&amp;quot;15:04:05\n&amp;quot;))
		if err != nil {
			return // e.g., client disconnected
		}
		time.Sleep(1 * time.Second)
	}
}

func main() {
	port := flag.String(&amp;quot;port&amp;quot;, &amp;quot;8000&amp;quot;, &amp;quot;port num&amp;quot;)
	flag.Parse()
	address := &amp;quot;localhost:&amp;quot; + *port
	listener, err := net.Listen(&amp;quot;tcp&amp;quot;, address)
	if err != nil {
		log.Fatal(err)
	}
	//!+
	for {
		conn, err := listener.Accept()
		if err != nil {
			log.Print(err) // e.g., connection aborted
			continue
		}
		go handleConn(conn) // handle connections concurrently
	}
	//!-
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;//启动服务器
TZ=US/Eastern    ./clock -port 8010 &amp;amp;
TZ=Asia/Tokyo    ./clock -port 8020 &amp;amp;
TZ=Europe/London ./clock -port 8030
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://oumnldfwl.bkt.clouddn.com/clockwall.png?imageView2/0/h/200&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;ex-8-3&#34;&gt;Ex 8.3&lt;/h3&gt;

&lt;p&gt;In netcat3, the interface value conn has the concrete type *net.TCPConn, which represents a TCP connection. A TCP connection consists of two halves that may be closed independently using its CloseRead and CloseWrite methods. Modify the main goroutine of netcat3 to close only the write half of the connection so that the program will continue to print the ﬁnal echoes from the reverb1 server even after the standard input has been closed. (Doing this for the reverb2 server is harder; see Exercise 8.4.)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;io&amp;quot;
	&amp;quot;log&amp;quot;
	&amp;quot;net&amp;quot;
	&amp;quot;os&amp;quot;
)

//!+
func main() {
	conn, err := net.Dial(&amp;quot;tcp&amp;quot;, &amp;quot;localhost:8000&amp;quot;)
	if err != nil {
		log.Fatal(err)
	}
	done := make(chan struct{})
	go func() {
		io.Copy(os.Stdout, conn) // NOTE: ignoring errors
		log.Println(&amp;quot;done&amp;quot;)
		done &amp;lt;- struct{}{} // signal the main goroutine
	}()
	mustCopy(conn, os.Stdin)
	//conn.Close()
	if conn, ok := conn.(*net.TCPConn); ok {
		conn.CloseWrite()
	}
	&amp;lt;-done // wait for background goroutine to finish
}

//!-

func mustCopy(dst io.Writer, src io.Reader) {
	if _, err := io.Copy(dst, src); err != nil {
		log.Fatal(err)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ex-8-4&#34;&gt;Ex 8.4&lt;/h3&gt;

&lt;p&gt;Modify the reverb2 server to use a sync.WaitGroup per connection to count the number of active echo goroutines. When it falls to zero, close the write half of the TCP connection as described in Exercise 8.3. Verify that your modiﬁed netcat3 client from that exercise waits for the ﬁnal echoes of multiple concurrent shouts, even after the standard input has been closed.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//client
package main

import (
	&amp;quot;io&amp;quot;
	&amp;quot;log&amp;quot;
	&amp;quot;net&amp;quot;
	&amp;quot;os&amp;quot;
)

func init() {
	log.SetFlags(log.Ldate | log.Lmicroseconds)
}

//!+
func main() {
	f, err := os.Open(&amp;quot;a&amp;quot;)
	defer f.Close()
	conn, err := net.Dial(&amp;quot;tcp&amp;quot;, &amp;quot;localhost:8000&amp;quot;)
	if err != nil {
		log.Fatal(err)
	}
	done := make(chan struct{})
	go func() {
		io.Copy(os.Stdout, conn) // NOTE: ignoring errors
		log.Println(&amp;quot;done&amp;quot;)
		done &amp;lt;- struct{}{} // signal the main goroutine
	}()
	mustCopy(conn, f)
	//conn.Close()
	log.Printf(&amp;quot;local in server: %#v\n&amp;quot;, conn.LocalAddr())
	log.Printf(&amp;quot;remote in server: %#v\n&amp;quot;, conn.RemoteAddr())
	err = conn.(*net.TCPConn).CloseWrite() //经实验：必须要关，否则无法通知服务端输入已结束（但不应该是服务端根据EOF来判断吗？）
	log.Println(&amp;quot;write finished in client: &amp;quot;, err)
	&amp;lt;-done // wait for background goroutine to finish
	log.Println(&amp;quot;finish print&amp;quot;)
	//err = conn.(*net.TCPConn).CloseRead()
	//log.Println(&amp;quot;read finished in client: &amp;quot;, err)
	err = conn.Close()
	log.Println(err)
}

//!-

func mustCopy(dst io.Writer, src io.Reader) {
	if _, err := io.Copy(dst, src); err != nil {
		log.Fatal(err)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//server
// Copyright © 2016 Alan A. A. Donovan &amp;amp; Brian W. Kernighan.
// License: https://creativecommons.org/licenses/by-nc-sa/4.0/

// See page 224.

// Reverb2 is a TCP server that simulates an echo.
package main

import (
	&amp;quot;bufio&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;log&amp;quot;
	&amp;quot;net&amp;quot;
	&amp;quot;strings&amp;quot;
	&amp;quot;sync&amp;quot;
	&amp;quot;time&amp;quot;
)

func init() {
	log.SetFlags(log.Ldate | log.Lmicroseconds)
}
func echo(c net.Conn, shout string, delay time.Duration, wg *sync.WaitGroup) {
	defer wg.Done()
	fmt.Fprintln(c, &amp;quot;\t&amp;quot;, strings.ToUpper(shout))
	time.Sleep(delay)
	fmt.Fprintln(c, &amp;quot;\t&amp;quot;, shout)
	time.Sleep(delay)
	fmt.Fprintln(c, &amp;quot;\t&amp;quot;, strings.ToLower(shout))
}

//!+
func handleConn(c net.Conn) {
	input := bufio.NewScanner(c)
	var wg sync.WaitGroup
	for input.Scan() {
		wg.Add(1)
		go echo(c, input.Text(), 1*time.Second, &amp;amp;wg)
		fmt.Println(input.Text())
	}
	// NOTE: ignoring potential errors from input.Err()
	//err := c.(*net.TCPConn).CloseRead()
	//log.Println(&amp;quot;read finished in server: &amp;quot;, err)
	log.Println(&amp;quot;finish scan&amp;quot;)
	log.Printf(&amp;quot;local in server: %#v\n&amp;quot;, c.LocalAddr())
	log.Printf(&amp;quot;remote in server: %#v\n&amp;quot;, c.RemoteAddr())
	wg.Wait()
	err := c.(*net.TCPConn).CloseWrite()
	//err := c.Close()
	log.Println(&amp;quot;finished in server: &amp;quot;, err)
}

//!-

func main() {
	l, err := net.Listen(&amp;quot;tcp&amp;quot;, &amp;quot;localhost:8000&amp;quot;)
	if err != nil {
		log.Fatal(err)
	}
	for {
		conn, err := l.Accept()
		if err != nil {
			log.Print(err) // e.g., connection aborted
			continue
		}
		go handleConn(conn)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;//client
$ ./ex8.3
2018/01/02 08:56:18.122881 local in server: &amp;amp;net.TCPAddr{IP:net.IP{0x7f, 0x0, 0x0, 0x1}, Port:59580, Zone:&amp;quot;&amp;quot;}
2018/01/02 08:56:18.123015 remote in server: &amp;amp;net.TCPAddr{IP:net.IP{0x7f, 0x0, 0x0, 0x1}, Port:8000, Zone:&amp;quot;&amp;quot;}
2018/01/02 08:56:18.123035 write finished in client:  &amp;lt;nil&amp;gt;
	 A
	 F
	 B
	 C
	 D
	 E
	 G
	 e
	 b
	 c
	 f
	 d
	 g
	 a
	 e
	 a
	 d
	 b
	 f
	 c
	 g
2018/01/02 08:56:20.125582 done
2018/01/02 08:56:20.125625 finish print
2018/01/02 08:56:20.125699 &amp;lt;nil&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;//server
$ ./ex8.4
a
b
c
d
e
f
g
2018/01/02 08:56:18.123125 finish scan
2018/01/02 08:56:18.123409 local in server: &amp;amp;net.TCPAddr{IP:net.IP{0x7f, 0x0, 0x0, 0x1}, Port:8000, Zone:&amp;quot;&amp;quot;}
2018/01/02 08:56:18.123427 remote in server: &amp;amp;net.TCPAddr{IP:net.IP{0x7f, 0x0, 0x0, 0x1}, Port:59580, Zone:&amp;quot;&amp;quot;}
2018/01/02 08:56:20.125383 finished in server:  &amp;lt;nil&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;conn是双向的（从各自local，remote属性相反可以看出），客户端本身对连接的关闭，只会影响客户端本身通过该连接的相关操作，不会影响服务器端连接；反之亦然！&lt;/li&gt;
&lt;li&gt;经过实验，客户端通过标准输入向conn写入消息时，即使写入EOF，服务器端也还会继续等待客户端输入的到来，只有当客户端CloseWrite()后，服务器端才会放弃等待输入，继续后面的逻辑；反之服务器端写，客户端读，也是这种情况。似乎与练习要达到的效果有些出入（手动ctrl-d，文件EOF都不行）~&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>The Go Programming Language Ex（8）</title>
      <link>https://mooncaker816.github.io/2017/12/31/the-go-programming-language-ex8/</link>
      <pubDate>Sun, 31 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://mooncaker816.github.io/2017/12/31/the-go-programming-language-ex8/</guid>
      <description>&lt;h3 id=&#34;ex-7-1&#34;&gt;Ex 7.1&lt;/h3&gt;

&lt;p&gt;Using the ideas from ByteCounter, implement counters for words and for lines. You will ﬁnd bufio.ScanWords useful.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;bufio&amp;quot;
	&amp;quot;bytes&amp;quot;
	&amp;quot;fmt&amp;quot;
)

func main() {
	var c ByteCounter
	c.Write([]byte(&amp;quot;hello&amp;quot;))
	fmt.Println(c) // &amp;quot;5&amp;quot;, = len(&amp;quot;hello&amp;quot;)
	c = 0          // reset the counter
	var name = &amp;quot;Dolly&amp;quot;
	fmt.Fprintf(&amp;amp;c, &amp;quot;hello, %s&amp;quot;, name)
	fmt.Println(c) // &amp;quot;12&amp;quot;, = len(&amp;quot;hello, Dolly&amp;quot;)

	var w WordCounter
	w.Write([]byte(&amp;quot;hello world, 世界&amp;quot;))
	fmt.Println(w)
	w = 0
	var str = &amp;quot;你 好&amp;quot;
	fmt.Fprintf(&amp;amp;w, &amp;quot;hello, %s&amp;quot;, str)
	fmt.Println(w)

	var l LineCounter
	l.Write([]byte(&amp;quot;hello world, 世界\nabc\nosjoij\nwefw&amp;quot;))
	fmt.Println(l)
}

type ByteCounter int

func (c *ByteCounter) Write(p []byte) (int, error) {
	*c += ByteCounter(len(p)) // convert int to ByteCounter
	return len(p), nil
}

type WordCounter int

func (w *WordCounter) Write(p []byte) (int, error) {
	scanner := bufio.NewScanner(bytes.NewReader(p))
	scanner.Split(bufio.ScanWords)
	var count int
	for scanner.Scan() {
		count++
	}
	*w += WordCounter(count)
	return count, nil
}

type LineCounter int

func (l *LineCounter) Write(p []byte) (int, error) {
	scanner := bufio.NewScanner(bytes.NewReader(p))
	scanner.Split(bufio.ScanLines)
	var count int
	for scanner.Scan() {
		count++
	}
	*l += LineCounter(count)
	return count, nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ go run counter.go
5
12
3
3
4
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ex-7-2&#34;&gt;Ex 7.2&lt;/h3&gt;

&lt;p&gt;Write a function CountingWriter with the signature below that, given an io.Writer, returns a new Writer that wraps the original, and a pointer to an int64 variable that at any moment contains the number of bytes written to the new Writer.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;func CountingWriter(w io.Writer) (io.Writer, *int64)&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;io&amp;quot;
	&amp;quot;os&amp;quot;
)

type byteCounter struct {
	n int64
	w io.Writer
}

func (c *byteCounter) Write(p []byte) (int, error) {
	c.n += int64(len(p))
	var err error
	if c.w != nil {
		_, err = c.w.Write(p)
	}
	return len(p), err
}

func CountingWriter(w io.Writer) (io.Writer, *int64) {
	var b byteCounter
	b.w = w
	return &amp;amp;b, &amp;amp;b.n
}

func main() {
	w, n := CountingWriter(os.Stdout)
	fmt.Fprintf(w, &amp;quot;hello, word!\n&amp;quot;)
	fmt.Printf(&amp;quot;writer count [%d]\n&amp;quot;, *n)
	fmt.Fprintf(w, &amp;quot;1234567890\n&amp;quot;)
	fmt.Printf(&amp;quot;writer count [%d]\n&amp;quot;, *n)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ go run counting.go
hello, word!
writer count [13]
1234567890
writer count [24]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ex-7-11&#34;&gt;Ex 7.11&lt;/h3&gt;

&lt;p&gt;Add additional handlers so that clients can create, read, update, and delete database entries. For example, a request of the form /update?item=socks&amp;amp;price=6 will update the price of an item in the inventory and report an error if the item does not exist or if the price is invalid. (Warning: this change introduces concurrent variable updates.)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;log&amp;quot;
	&amp;quot;net/http&amp;quot;
	&amp;quot;strconv&amp;quot;
	&amp;quot;sync&amp;quot;
)

var mu sync.Mutex

func main() {
	db := database{&amp;quot;shoes&amp;quot;: 50, &amp;quot;socks&amp;quot;: 5}
	http.HandleFunc(&amp;quot;/list&amp;quot;, db.list)
	http.HandleFunc(&amp;quot;/price&amp;quot;, db.price)
	http.HandleFunc(&amp;quot;/update&amp;quot;, db.update)
	http.HandleFunc(&amp;quot;/add&amp;quot;, db.add)
	http.HandleFunc(&amp;quot;/delete&amp;quot;, db.delete)
	log.Fatal(http.ListenAndServe(&amp;quot;localhost:8000&amp;quot;, nil))
}

type dollars float32

func (d dollars) String() string { return fmt.Sprintf(&amp;quot;$%.2f&amp;quot;, d) }

type database map[string]dollars

func (db database) list(w http.ResponseWriter, req *http.Request) {
	for item, price := range db {
		fmt.Fprintf(w, &amp;quot;%s: %s\n&amp;quot;, item, price)
	}
}

func (db database) price(w http.ResponseWriter, req *http.Request) {
	item := req.URL.Query().Get(&amp;quot;item&amp;quot;)
	if price, ok := db[item]; ok {
		fmt.Fprintf(w, &amp;quot;%s\n&amp;quot;, price)
	} else {
		w.WriteHeader(http.StatusNotFound) // 404
		fmt.Fprintf(w, &amp;quot;no such item: %q\n&amp;quot;, item)
	}
}

func (db database) update(w http.ResponseWriter, req *http.Request) {
	mu.Lock()
	defer mu.Unlock()
	item := req.URL.Query().Get(&amp;quot;item&amp;quot;)
	if _, ok := db[item]; ok {
		newpricestr := req.URL.Query().Get(&amp;quot;price&amp;quot;)
		newprice, err := strconv.ParseFloat(newpricestr, 32)
		if err != nil {
			w.Write([]byte(&amp;quot;price invalid!&amp;quot;))
		} else {
			db[item] = dollars(float32(newprice))
			w.Write([]byte(&amp;quot;new price updated!\n\n&amp;quot;))
			db.list(w, req)
		}
	} else {
		fmt.Fprintf(w, &amp;quot;no such item: %q\n&amp;quot;, item)
	}
}

func (db database) add(w http.ResponseWriter, req *http.Request) {
	mu.Lock()
	defer mu.Unlock()
	item := req.URL.Query().Get(&amp;quot;item&amp;quot;)
	if _, ok := db[item]; ok {
		fmt.Fprintf(w, &amp;quot;%s already exist!&amp;quot;, item)
	} else {
		newpricestr := req.URL.Query().Get(&amp;quot;price&amp;quot;)
		if len(newpricestr) &amp;lt;= 0 {
			newpricestr = &amp;quot;0&amp;quot;
		}
		newprice, err := strconv.ParseFloat(newpricestr, 32)
		if err != nil {
			w.Write([]byte(&amp;quot;price invalid!&amp;quot;))
		} else {
			db[item] = dollars(float32(newprice))
			fmt.Fprintf(w, &amp;quot;%s added!\n\n&amp;quot;, item)
			db.list(w, req)
		}
	}
}

func (db database) delete(w http.ResponseWriter, req *http.Request) {
	mu.Lock()
	defer mu.Unlock()
	item := req.URL.Query().Get(&amp;quot;item&amp;quot;)
	if _, ok := db[item]; ok {
		delete(db, item)
		fmt.Fprintf(w, &amp;quot;%s deleted!\n\n&amp;quot;, item)
		db.list(w, req)
	} else {
		fmt.Fprintf(w, &amp;quot;%s not exist!&amp;quot;, item)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://oumnldfwl.bkt.clouddn.com/list item.png?imageView2/0/h/200&#34; alt=&#34;list&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://oumnldfwl.bkt.clouddn.com/add item.png?imageView2/0/h/200&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://oumnldfwl.bkt.clouddn.com/update price.png?imageView2/0/h/200&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://oumnldfwl.bkt.clouddn.com/delete item.png?imageView2/0/h/200&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;ex-7-12&#34;&gt;Ex 7.12&lt;/h3&gt;

&lt;p&gt;Change the handler for /list to print its output as an HTML table, not text. You may ﬁnd the html/template package (§4.6) useful.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;html/template&amp;quot;
	&amp;quot;log&amp;quot;
	&amp;quot;net/http&amp;quot;
	&amp;quot;strconv&amp;quot;
	&amp;quot;sync&amp;quot;
)

var mu sync.Mutex

const templ = `
&amp;lt;h1&amp;gt;current prices:&amp;lt;/h1&amp;gt;
&amp;lt;table&amp;gt;
&amp;lt;tr style=&#39;text-align: left&#39;&amp;gt;
  &amp;lt;th&amp;gt;Item&amp;lt;/th&amp;gt;
  &amp;lt;th&amp;gt;Price&amp;lt;/th&amp;gt;
&amp;lt;/tr&amp;gt;
{{range $key, $value := . }}
&amp;lt;tr&amp;gt;
  &amp;lt;td&amp;gt;{{$key}}&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;{{$value}}&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;
{{end}}
&amp;lt;/table&amp;gt;
`

var report = template.Must(template.New(&amp;quot;result&amp;quot;).
	Parse(templ))

func main() {
	db := database{&amp;quot;shoes&amp;quot;: 50, &amp;quot;socks&amp;quot;: 5}
	http.HandleFunc(&amp;quot;/list&amp;quot;, db.list)
	http.HandleFunc(&amp;quot;/price&amp;quot;, db.price)
	http.HandleFunc(&amp;quot;/update&amp;quot;, db.update)
	http.HandleFunc(&amp;quot;/add&amp;quot;, db.add)
	http.HandleFunc(&amp;quot;/delete&amp;quot;, db.delete)
	log.Fatal(http.ListenAndServe(&amp;quot;localhost:8000&amp;quot;, nil))
}

type dollars float32

func (d dollars) String() string { return fmt.Sprintf(&amp;quot;$%.2f&amp;quot;, d) }

type database map[string]dollars

func (db database) list(w http.ResponseWriter, req *http.Request) {
	if err := report.Execute(w, db); err != nil {
		log.Fatal(err)
	}
}

func (db database) price(w http.ResponseWriter, req *http.Request) {
	item := req.URL.Query().Get(&amp;quot;item&amp;quot;)
	if price, ok := db[item]; ok {
		fmt.Fprintf(w, &amp;quot;%s\n&amp;quot;, price)
	} else {
		w.WriteHeader(http.StatusNotFound) // 404
		fmt.Fprintf(w, &amp;quot;no such item: %q\n&amp;quot;, item)
	}
}

func (db database) update(w http.ResponseWriter, req *http.Request) {
	mu.Lock()
	defer mu.Unlock()
	item := req.URL.Query().Get(&amp;quot;item&amp;quot;)
	if _, ok := db[item]; ok {
		newpricestr := req.URL.Query().Get(&amp;quot;price&amp;quot;)
		newprice, err := strconv.ParseFloat(newpricestr, 32)
		if err != nil {
			w.Write([]byte(&amp;quot;price invalid!&amp;quot;))
		} else {
			db[item] = dollars(float32(newprice))
			w.Write([]byte(&amp;quot;new price updated!\n\n&amp;quot;))
			db.list(w, req)
		}
	} else {
		fmt.Fprintf(w, &amp;quot;no such item: %q\n&amp;quot;, item)
	}
}

func (db database) add(w http.ResponseWriter, req *http.Request) {
	mu.Lock()
	defer mu.Unlock()
	item := req.URL.Query().Get(&amp;quot;item&amp;quot;)
	if _, ok := db[item]; ok {
		fmt.Fprintf(w, &amp;quot;%s already exist!&amp;quot;, item)
	} else {
		newpricestr := req.URL.Query().Get(&amp;quot;price&amp;quot;)
		if len(newpricestr) &amp;lt;= 0 {
			newpricestr = &amp;quot;0&amp;quot;
		}
		newprice, err := strconv.ParseFloat(newpricestr, 32)
		if err != nil {
			w.Write([]byte(&amp;quot;price invalid!&amp;quot;))
		} else {
			db[item] = dollars(float32(newprice))
			fmt.Fprintf(w, &amp;quot;%s added!\n\n&amp;quot;, item)
			db.list(w, req)
		}
	}
}

func (db database) delete(w http.ResponseWriter, req *http.Request) {
	mu.Lock()
	defer mu.Unlock()
	item := req.URL.Query().Get(&amp;quot;item&amp;quot;)
	if _, ok := db[item]; ok {
		delete(db, item)
		fmt.Fprintf(w, &amp;quot;%s deleted!\n\n&amp;quot;, item)
		db.list(w, req)
	} else {
		fmt.Fprintf(w, &amp;quot;%s not exist!&amp;quot;, item)
	}
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>The Go Programming Language Ex（7）</title>
      <link>https://mooncaker816.github.io/2017/12/29/the-go-programming-language-ex7/</link>
      <pubDate>Fri, 29 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://mooncaker816.github.io/2017/12/29/the-go-programming-language-ex7/</guid>
      <description>&lt;h3 id=&#34;ex-6-1&#34;&gt;Ex 6.1&lt;/h3&gt;

&lt;p&gt;Implement these additional methods:&lt;/p&gt;

&lt;p&gt;func (*IntSet) Len() int // return the number of elements&lt;/p&gt;

&lt;p&gt;func (*IntSet) Remove(x int) //remove x from the set&lt;/p&gt;

&lt;p&gt;func (*IntSet) Clear() // remove all elements from the set&lt;/p&gt;

&lt;p&gt;func (*IntSet) Copy() *IntSet // return a copy of the set&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;ex-6-2&#34;&gt;Ex 6.2&lt;/h3&gt;

&lt;p&gt;Deﬁne a variadic (*IntSet).AddAll(&amp;hellip;int) method that allows a list of values to be added, such as s.AddAll(1, 2, 3).&lt;/p&gt;

&lt;h3 id=&#34;ex-6-3&#34;&gt;Ex 6.3&lt;/h3&gt;

&lt;p&gt;(*IntSet).UnionWith computes the union of two sets using |, the word-parallel bitwise OR operator. Implement methods for IntersectWith, DifferenceWith, and SymmetricDifference for the corresponding set operations. (The symmetric difference of two sets contains the elements present in one set or the other but not both.)&lt;/p&gt;

&lt;h3 id=&#34;ex-6-4&#34;&gt;Ex 6.4&lt;/h3&gt;

&lt;p&gt;Add a method Elems that returns a slice containing the elements of the set, suitable for iterating over with a range loop.&lt;/p&gt;

&lt;h3 id=&#34;ex-6-5&#34;&gt;Ex 6.5&lt;/h3&gt;

&lt;p&gt;The type of each word used by IntSet is uint64, but 64-bit arithmetic may be inefﬁcient on a 32-bit platform. Modify the program to use the uint type, which is the most efﬁcient unsigned integer type for the platform. Instead of dividing by 64, deﬁne a constant holding the effective size of uint in bits, 32 or 64. You can use the perhaps too-clever expression 32 &amp;lt;&amp;lt; (^uint(0) &amp;gt;&amp;gt; 63) for this purpose.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;bytes&amp;quot;
	&amp;quot;fmt&amp;quot;
)

const wordlen = 32 &amp;lt;&amp;lt; (^uint(0) &amp;gt;&amp;gt; 63) //当前计算机的位数

type IntSet struct {
	words []uint
}

func (s *IntSet) Add(x int) {
	word, bit := x/wordlen, uint(x%wordlen)
	for word &amp;gt;= len(s.words) {
		s.words = append(s.words, 0)
	}
	s.words[word] |= 1 &amp;lt;&amp;lt; bit
}

func (s *IntSet) Has(x int) bool {
	word, bit := x/wordlen, uint(x%wordlen)
	return word &amp;lt; len(s.words) &amp;amp;&amp;amp; s.words[word]&amp;amp;(1&amp;lt;&amp;lt;bit) != 0
}

func (s *IntSet) UnionWith(t *IntSet) {
	for i, tword := range t.words {
		if i &amp;lt; len(s.words) {
			s.words[i] |= tword
		} else {
			s.words = append(s.words, tword)
		}
	}
}

func (s *IntSet) String() string {
	var buf bytes.Buffer
	buf.WriteByte(&#39;{&#39;)
	for i, word := range s.words {
		if word == 0 {
			continue
		}
		for j := 0; j &amp;lt; wordlen; j++ {
			if word&amp;amp;(1&amp;lt;&amp;lt;uint(j)) != 0 {
				if buf.Len() &amp;gt; len(&amp;quot;{&amp;quot;) {
					buf.WriteByte(&#39; &#39;)
				}
				fmt.Fprintf(&amp;amp;buf, &amp;quot;%d&amp;quot;, wordlen*i+j)
			}
		}
	}
	buf.WriteByte(&#39;}&#39;)
	return buf.String()
}

func (s *IntSet) Len() int {
	var count int
	for _, n := range s.words {
		for n != 0 {
			count++
			n = n &amp;amp; (n - 1)
		}
	}
	return count
}

func (s *IntSet) Remove(x int) {
	word, bit := x/wordlen, uint(x%wordlen)
	if word &amp;lt; len(s.words) {
		s.words[word] &amp;amp;= ^(1 &amp;lt;&amp;lt; bit)
	}
}

func (s *IntSet) Clear() {
	s.words = []uint{0}
}
func (s *IntSet) Copy() *IntSet {
	ns := IntSet{make([]uint, len(s.words))}
	copy(ns.words, s.words)
	return &amp;amp;ns
}

func (s *IntSet) AddAll(x ...int) {
	for _, v := range x {
		s.Add(v)
	}
}

func (s *IntSet) IntersectWith(t *IntSet) *IntSet {
	tmp := make([]uint, 0)
	for i, tword := range t.words {
		if i &amp;lt; len(s.words) {
			tmp = append(tmp, s.words[i]&amp;amp;tword)
		}
	}
	return &amp;amp;IntSet{tmp}
}
func (s *IntSet) SymmetricDifference(t *IntSet) *IntSet {
	tmp := make([]uint, 0)
	if len(t.words) &amp;gt; len(s.words) {
		for i, tword := range t.words {
			if i &amp;lt; len(s.words) {
				tmp = append(tmp, s.words[i]^tword)
			} else {
				tmp = append(tmp, tword)
			}
		}
	} else {
		for i, sword := range s.words {
			if i &amp;lt; len(t.words) {
				tmp = append(tmp, t.words[i]^sword)
			} else {
				tmp = append(tmp, sword)
			}
		}
	}
	return &amp;amp;IntSet{tmp}
}

func (s *IntSet) DifferenceWith(t *IntSet) *IntSet {
	tmp := make([]uint, 0)
	for i, sword := range s.words {
		if i &amp;lt; len(t.words) {
			tmp = append(tmp, sword&amp;amp;^t.words[i])
		} else {
			tmp = append(tmp, sword)
		}
	}
	return &amp;amp;IntSet{tmp}
}
func (s *IntSet) Elems() []int {
	tmp := make([]int, 0)
	for i, word := range s.words {
		if word == 0 {
			continue
		}
		for j := 0; j &amp;lt; wordlen; j++ {
			if word&amp;amp;(1&amp;lt;&amp;lt;uint(j)) != 0 {
				tmp = append(tmp, wordlen*i+j)
			}
		}
	}
	return tmp
}

func main() {
	var set1, set2, set3 IntSet
	set1.Add(1)
	set1.Add(22)
	set2.Add(333)
	fmt.Println(&amp;quot;set1:&amp;quot;, &amp;amp;set1)
	fmt.Println(&amp;quot;set1 是否包含1：&amp;quot;, set1.Has(1), &amp;quot;set1 是否包含333：&amp;quot;, set1.Has(333))
	fmt.Println(&amp;quot;before union with {333}: &amp;quot;, &amp;amp;set1)
	fmt.Println(&amp;quot;len: &amp;quot;, set1.Len())
	set1.UnionWith(&amp;amp;set2)
	fmt.Println(&amp;quot;after union with {333}: &amp;quot;, &amp;amp;set1)
	fmt.Println(&amp;quot;len: &amp;quot;, set1.Len())
	set1.Remove(22)
	fmt.Println(&amp;quot;after remove 22: &amp;quot;, &amp;amp;set1)
	fmt.Println(&amp;quot;len: &amp;quot;, set1.Len())
	set3 = *set1.Copy()
	fmt.Println(&amp;quot;copy set1 to set3: &amp;quot;, &amp;amp;set3)
	set1.Clear()
	fmt.Println(&amp;quot;after clear set1: &amp;quot;, &amp;amp;set1, &amp;amp;set3)
	set3.AddAll(4444, 55555)
	fmt.Println(&amp;quot;after add all set3: &amp;quot;, &amp;amp;set3)
	set2.AddAll(55555, 666666)
	fmt.Println(&amp;quot;se2:&amp;quot;, &amp;amp;set2)
	fmt.Println(&amp;quot;se3:&amp;quot;, &amp;amp;set3)
	fmt.Println(&amp;quot;set2交set3:&amp;quot;, set2.IntersectWith(&amp;amp;set3))
	fmt.Println(&amp;quot;set2 DifferenceWith set3:&amp;quot;, set2.DifferenceWith(&amp;amp;set3))
	fmt.Println(&amp;quot;set3 DifferenceWith set2:&amp;quot;, set3.DifferenceWith(&amp;amp;set2))
	fmt.Println(&amp;quot;set2 SymmetricDifference set3:&amp;quot;, set2.SymmetricDifference(&amp;amp;set3))
	fmt.Println(&amp;quot;set3 SymmetricDifference set2:&amp;quot;, set3.SymmetricDifference(&amp;amp;set2))
	fmt.Println(&amp;quot;elem slice in set2:&amp;quot;, set2.Elems())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ go run bitmap.go
set1: {1 22}
set1 是否包含1： true set1 是否包含333： false
before union with {333}:  {1 22}
len:  2
after union with {333}:  {1 22 333}
len:  3
after remove 22:  {1 333}
len:  2
copy set1 to set3:  {1 333}
after clear set1:  {} {1 333}
after add all set3:  {1 333 4444 55555}
se2: {333 55555 666666}
se3: {1 333 4444 55555}
set2交set3: {333 55555}
set2 DifferenceWith set3: {666666}
set3 DifferenceWith set2: {1 4444}
set2 SymmetricDifference set3: {1 4444 666666}
set3 SymmetricDifference set2: {1 4444 666666}
elem slice in set2: [333 55555 666666]
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>The Go Programming Language Ex（6）</title>
      <link>https://mooncaker816.github.io/2017/12/28/the-go-programming-language-ex6/</link>
      <pubDate>Thu, 28 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://mooncaker816.github.io/2017/12/28/the-go-programming-language-ex6/</guid>
      <description>&lt;h3 id=&#34;ex-5-1&#34;&gt;Ex 5.1&lt;/h3&gt;

&lt;p&gt;Change the findlinks program to traverse the n.FirstChild linked list using recursive calls to visit instead of a loop.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;os&amp;quot;

	&amp;quot;golang.org/x/net/html&amp;quot;
)

func main() {
	doc, err := html.Parse(os.Stdin)
	if err != nil {
		fmt.Fprintf(os.Stderr, &amp;quot;findlinks1: %v\n&amp;quot;, err)
		os.Exit(1)
	}
	for _, link := range visit(nil, doc) {
		fmt.Println(link)
	}
}

// visit appends to links each link found in n and returns the result.
func visit(links []string, n *html.Node) []string {

	if n == nil {
		return links
	} else {
		if n.Type == html.ElementNode &amp;amp;&amp;amp; n.Data == &amp;quot;a&amp;quot; {
			for _, a := range n.Attr {
				if a.Key == &amp;quot;href&amp;quot; {
					links = append(links, a.Val)
				}
			}
		}
		links = visit(links, n.FirstChild)
		links = visit(links, n.NextSibling)
	}
	return links
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./ex1.7 http://www.baidu.com | ./ex5.1
/
javascript:;
javascript:;
javascript:;
/
javascript:;
https://passport.baidu.com/v2/?login&amp;amp;tpl=mn&amp;amp;u=http%3A%2F%2Fwww.baidu.com%2F
http://news.baidu.com
http://www.hao123.com
http://map.baidu.com
http://v.baidu.com
http://tieba.baidu.com
http://xueshu.baidu.com
https://passport.baidu.com/v2/?login&amp;amp;tpl=mn&amp;amp;u=http%3A%2F%2Fwww.baidu.com%2F
http://www.baidu.com/gaoji/preferences.html
http://www.baidu.com/more/
http://news.baidu.com/ns?cl=2&amp;amp;rn=20&amp;amp;tn=news&amp;amp;word=
http://tieba.baidu.com/f?kw=&amp;amp;fr=wwwt
http://zhidao.baidu.com/q?ct=17&amp;amp;pn=0&amp;amp;tn=ikaslist&amp;amp;rn=10&amp;amp;word=&amp;amp;fr=wwwt
http://music.baidu.com/search?fr=ps&amp;amp;ie=utf-8&amp;amp;key=
http://image.baidu.com/search/index?tn=baiduimage&amp;amp;ps=1&amp;amp;ct=201326592&amp;amp;lm=-1&amp;amp;cl=2&amp;amp;nc=1&amp;amp;ie=utf-8&amp;amp;word=
http://v.baidu.com/v?ct=301989888&amp;amp;rn=20&amp;amp;pn=0&amp;amp;db=0&amp;amp;s=25&amp;amp;ie=utf-8&amp;amp;word=
http://map.baidu.com/m?word=&amp;amp;fr=ps01000
http://wenku.baidu.com/search?word=&amp;amp;lm=0&amp;amp;od=0&amp;amp;ie=utf-8
//www.baidu.com/more/
//www.baidu.com/cache/sethelp/help.html
http://home.baidu.com
http://ir.baidu.com
http://e.baidu.com/?refer=888
http://www.baidu.com/duty/
http://jianyi.baidu.com/
http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=11000002000001
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ex-5-2&#34;&gt;Ex 5.2&lt;/h3&gt;

&lt;p&gt;Write a function to populate a mapping from element names—p, div, span, and so on—to the number of elements with that name in an HTML document tree.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;os&amp;quot;

	&amp;quot;golang.org/x/net/html&amp;quot;
)

func main() {
	doc, err := html.Parse(os.Stdin)
	if err != nil {
		fmt.Fprintf(os.Stderr, &amp;quot;findlinks1: %v\n&amp;quot;, err)
		os.Exit(1)
	}
	m := make(map[string]int)
	for k, v := range check(m, doc) {
		fmt.Printf(&amp;quot;%s:%d\n&amp;quot;, k, v)
	}
}

func check(m map[string]int, n *html.Node) map[string]int {
	if n == nil {
		return m
	} else {
		if n.Type == html.ElementNode {
			m[n.Data]++
		}
		m = check(m, n.FirstChild)
		m = check(m, n.NextSibling)
	}
	return m
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./ex1.7 http://www.baidu.com | ./ex5.2
body:1
img:2
map:1
area:1
a:32
i:3
head:1
title:1
style:3
ul:1
meta:4
link:11
form:1
span:5
li:4
p:3
html:1
script:13
noscript:1
div:21
input:14
b:2
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ex-5-5&#34;&gt;Ex 5.5&lt;/h3&gt;

&lt;p&gt;Implement countWordsAndImages. (See Exercise 4.9 for word-splitting.)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;bufio&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;net/http&amp;quot;
	&amp;quot;strings&amp;quot;

	&amp;quot;golang.org/x/net/html&amp;quot;
)

func main() {
	url := &amp;quot;http://www.baidu.com&amp;quot;
	w, i, err := CountWordsAndImages(url)
	if err != nil {
		fmt.Println(&amp;quot;CountWordsAndImages error: &amp;quot;, err)
	}
	fmt.Printf(&amp;quot;words = %d,images = %d\n&amp;quot;, w, i)
}

func CountWordsAndImages(url string) (words, images int, err error) {
	resp, err := http.Get(url)
	if err != nil {
		return
	}
	doc, err := html.Parse(resp.Body)
	resp.Body.Close()
	if err != nil {
		err = fmt.Errorf(&amp;quot;parsing HTML: %s&amp;quot;, err)
		return
	}
	words, images = countWordsAndImages(doc)
	return
}

func countWordsAndImages(n *html.Node) (words, images int) {
	if n == nil {
		return
	} else {
		if n.Type == html.ElementNode {
			if n.Data == &amp;quot;img&amp;quot; {
				images++
			}
		} else if n.Type == html.TextNode {
			scanner := bufio.NewScanner(strings.NewReader(n.Data))
			scanner.Split(bufio.ScanWords)
			for scanner.Scan() {
				words++
			}
		}
		w1, i1 := countWordsAndImages(n.FirstChild)
		words += w1
		images += i1
		w2, i2 := countWordsAndImages(n.NextSibling)
		words += w2
		images += i2
	}
	return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ go run countwi.go
words = 2805,images = 2
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ex-5-6&#34;&gt;Ex 5.6&lt;/h3&gt;

&lt;p&gt;Modify the corner function in gopl.io/ch3/surface (§3.2) to use named results and a bare return statement.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;math&amp;quot;
	&amp;quot;os&amp;quot;
)

const (
	width, height = 600, 320            // canvas size in pixels
	cells         = 100                 // number of grid cells
	xyrange       = 30.0                // axis ranges (-xyrange..+xyrange)
	xyscale       = width / 2 / xyrange // pixels per x or y unit
	zscale        = height * 0.4        // pixels per z unit
	angle         = math.Pi / 6         // angle of x, y axes (=30°)
)

var sin30, cos30 = math.Sin(angle), math.Cos(angle) // sin(30°), cos(30°)

func main() {
	//fmt.Printf(&amp;quot;&amp;lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; &amp;quot;+
	f, err := os.Create(&amp;quot;test.svg&amp;quot;)
	if err != nil {
		fmt.Println(&amp;quot;create file error &amp;quot;, err)
		return
	}
	fmt.Fprintf(f, &amp;quot;&amp;lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; &amp;quot;+
		&amp;quot;style=&#39;stroke: grey; fill: white; stroke-width: 0.7&#39; &amp;quot;+
		&amp;quot;width=&#39;%d&#39; height=&#39;%d&#39;&amp;gt;&amp;quot;, width, height)
	for i := 0; i &amp;lt; cells; i++ {
		for j := 0; j &amp;lt; cells; j++ {
			ax, ay := corner(i+1, j)
			bx, by := corner(i, j)
			cx, cy := corner(i, j+1)
			dx, dy := corner(i+1, j+1)
			fmt.Fprintf(f, &amp;quot;&amp;lt;polygon points=&#39;%g,%g %g,%g %g,%g %g,%g&#39;/&amp;gt;\n&amp;quot;,
				ax, ay, bx, by, cx, cy, dx, dy)
		}
	}
	fmt.Fprintln(f, &amp;quot;&amp;lt;/svg&amp;gt;&amp;quot;)
}

func corner(i, j int) (sx, sy float64) {
	// Find point (x,y) at corner of cell (i,j).
	x := xyrange * (float64(i)/cells - 0.5)
	y := xyrange * (float64(j)/cells - 0.5)

	// Compute surface height z.
	z := f(x, y)

	// Project (x,y,z) isometrically onto 2-D SVG canvas (sx,sy).
	sx = width/2 + (x-y)*cos30*xyscale
	sy = height/2 + (x+y)*sin30*xyscale - z*zscale
	return
}

func f(x, y float64) float64 {
	r := math.Hypot(x, y) // distance from (0,0)
	return math.Sin(r) / r
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ex-5-7&#34;&gt;Ex 5.7&lt;/h3&gt;

&lt;p&gt;Develop startElement and endElement into a general HTML pre Print comment nodes, text nodes, and the attributes of each element (&lt;a href=&#39;...&#39;&gt;). Use short forms like &lt;img/&gt; instead of &lt;img&gt;&lt;/img&gt; when an element has no children. Write a test to ensure that the output can be parsed successfully. (See Chapter 11.)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;net/http&amp;quot;
	&amp;quot;os&amp;quot;

	&amp;quot;golang.org/x/net/html&amp;quot;
)

func main() {
	for _, url := range os.Args[1:] {
		outline(url)
	}
}

func outline(url string) error {
	resp, err := http.Get(url)
	if err != nil {
		return err
	}
	defer resp.Body.Close()
	doc, err := html.Parse(resp.Body)
	if err != nil {
		return err
	}

	forEachNode(doc, startElement, endElement)

	return nil
}

func forEachNode(n *html.Node, pre, post func(n *html.Node)) {
	if pre != nil {
		pre(n)
	}
	for c := n.FirstChild; c != nil; c = c.NextSibling {
		forEachNode(c, pre, post)
	}
	if post != nil {
		post(n)
	}
}

var depth int

func startElement(n *html.Node) {
	if n.Type == html.ElementNode ||
		n.Type == html.TextNode ||
		n.Type == html.CommentNode {
		if n.DataAtom != 0 { //去除无法识别标签的节点，如空白的textnode等
			var attr string
			for _, v := range n.Attr {
				attr += &amp;quot; &amp;quot; + v.Key + &amp;quot;=&#39;&amp;quot; + v.Val + &amp;quot;&#39;&amp;quot;
			}
			if n.FirstChild == nil {
				fmt.Printf(&amp;quot;%*s&amp;lt;%s/&amp;gt;\n&amp;quot;, depth*2, &amp;quot;&amp;quot;, n.Data)
			} else {
				fmt.Printf(&amp;quot;%*s&amp;lt;%s%s&amp;gt;\n&amp;quot;, depth*2, &amp;quot;&amp;quot;, n.Data, attr)
			}
			depth++
		}
	}
}
func endElement(n *html.Node) {
	if n.Type == html.ElementNode ||
		n.Type == html.TextNode ||
		n.Type == html.CommentNode {
		if n.DataAtom != 0 {
			depth--
			if n.FirstChild != nil {
				fmt.Printf(&amp;quot;%*s&amp;lt;/%s&amp;gt;\n&amp;quot;, depth*2, &amp;quot;&amp;quot;, n.Data)
			}
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./ex5.7 http://gopl.io
&amp;lt;html xmlns=&#39;http://www.w3.org/1999/xhtml&#39;&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;meta/&amp;gt;
    &amp;lt;title&amp;gt;
    &amp;lt;/title&amp;gt;
    &amp;lt;script&amp;gt;
    &amp;lt;/script&amp;gt;
    &amp;lt;link/&amp;gt;
    &amp;lt;style&amp;gt;
    &amp;lt;/style&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;table&amp;gt;
      &amp;lt;tbody&amp;gt;
        &amp;lt;tr&amp;gt;
          &amp;lt;td&amp;gt;
            &amp;lt;a href=&#39;http://www.informit.com/store/go-programming-language-9780134190440&#39;&amp;gt;
              &amp;lt;img/&amp;gt;
            &amp;lt;/a&amp;gt;
            &amp;lt;br/&amp;gt;
            &amp;lt;div style=&#39;text-align: center&#39;&amp;gt;
              &amp;lt;a href=&#39;http://www.amazon.com/dp/0134190440&#39;&amp;gt;
                &amp;lt;img/&amp;gt;
              &amp;lt;/a&amp;gt;
              &amp;lt;a href=&#39;http://www.informit.com/store/go-programming-language-9780134190440&#39;&amp;gt;
                &amp;lt;img/&amp;gt;
              &amp;lt;/a&amp;gt;
              &amp;lt;a href=&#39;http://www.barnesandnoble.com/w/1121601944&#39;&amp;gt;
                &amp;lt;img/&amp;gt;
              &amp;lt;/a&amp;gt;
            &amp;lt;/div&amp;gt;
            &amp;lt;br/&amp;gt;
          &amp;lt;/td&amp;gt;
          &amp;lt;td width=&#39;500&#39;&amp;gt;
            &amp;lt;h1 class=&#39;center&#39;&amp;gt;
            &amp;lt;/h1&amp;gt;
            &amp;lt;p class=&#39;biblio center&#39;&amp;gt;
              &amp;lt;br/&amp;gt;
              &amp;lt;br/&amp;gt;
              &amp;lt;br/&amp;gt;
              &amp;lt;tt&amp;gt;
              &amp;lt;/tt&amp;gt;
              &amp;lt;tt&amp;gt;
              &amp;lt;/tt&amp;gt;
              &amp;lt;tt&amp;gt;
              &amp;lt;/tt&amp;gt;
            &amp;lt;/p&amp;gt;
            &amp;lt;div id=&#39;toc&#39;&amp;gt;
              &amp;lt;table&amp;gt;
                &amp;lt;tbody&amp;gt;
                  &amp;lt;tr&amp;gt;
                    &amp;lt;td&amp;gt;
                      &amp;lt;h1&amp;gt;
                        &amp;lt;a href=&#39;ch1.pdf&#39;&amp;gt;
                        &amp;lt;/a&amp;gt;
                      &amp;lt;/h1&amp;gt;
                      &amp;lt;h1&amp;gt;
                        &amp;lt;a href=&#39;ch1.pdf&#39;&amp;gt;
                        &amp;lt;/a&amp;gt;
                      &amp;lt;/h1&amp;gt;
                      &amp;lt;h1&amp;gt;
                        &amp;lt;a href=&#39;ch1.pdf&#39;&amp;gt;
                        &amp;lt;/a&amp;gt;
                      &amp;lt;/h1&amp;gt;
                      &amp;lt;h1&amp;gt;
                      &amp;lt;/h1&amp;gt;
                      &amp;lt;h1&amp;gt;
                      &amp;lt;/h1&amp;gt;
                      &amp;lt;h1&amp;gt;
                      &amp;lt;/h1&amp;gt;
                      &amp;lt;h1&amp;gt;
                      &amp;lt;/h1&amp;gt;
                      &amp;lt;h1&amp;gt;
                      &amp;lt;/h1&amp;gt;
                    &amp;lt;/td&amp;gt;
                    &amp;lt;td&amp;gt;
                      &amp;lt;h1&amp;gt;
                      &amp;lt;/h1&amp;gt;
                      &amp;lt;h1&amp;gt;
                      &amp;lt;/h1&amp;gt;
                      &amp;lt;h1&amp;gt;
                      &amp;lt;/h1&amp;gt;
                      &amp;lt;h1&amp;gt;
                      &amp;lt;/h1&amp;gt;
                      &amp;lt;h1&amp;gt;
                      &amp;lt;/h1&amp;gt;
                      &amp;lt;h1&amp;gt;
                      &amp;lt;/h1&amp;gt;
                      &amp;lt;h1&amp;gt;
                      &amp;lt;/h1&amp;gt;
                      &amp;lt;h1&amp;gt;
                        &amp;lt;a href=&#39;ch1.pdf&#39;&amp;gt;
                        &amp;lt;/a&amp;gt;
                      &amp;lt;/h1&amp;gt;
                    &amp;lt;/td&amp;gt;
                  &amp;lt;/tr&amp;gt;
                  &amp;lt;tr&amp;gt;
                    &amp;lt;td colspan=&#39;2&#39;&amp;gt;
                      &amp;lt;h1&amp;gt;
                        &amp;lt;a href=&#39;https://github.com/adonovan/gopl.io/&#39;&amp;gt;
                        &amp;lt;/a&amp;gt;
                        &amp;lt;a href=&#39;reviews.html&#39;&amp;gt;
                        &amp;lt;/a&amp;gt;
                        &amp;lt;a href=&#39;translations.html&#39;&amp;gt;
                        &amp;lt;/a&amp;gt;
                        &amp;lt;a href=&#39;errata.html&#39;&amp;gt;
                        &amp;lt;/a&amp;gt;
                      &amp;lt;/h1&amp;gt;
                    &amp;lt;/td&amp;gt;
                  &amp;lt;/tr&amp;gt;
                &amp;lt;/tbody&amp;gt;
              &amp;lt;/table&amp;gt;
            &amp;lt;/div&amp;gt;
            &amp;lt;p class=&#39;bio&#39;&amp;gt;
              &amp;lt;a href=&#39;http://golang.org/s/oracle-user-manual&#39;&amp;gt;
                &amp;lt;code&amp;gt;
                &amp;lt;/code&amp;gt;
              &amp;lt;/a&amp;gt;
              &amp;lt;a href=&#39;http://golang.org/lib/godoc/analysis/help.html&#39;&amp;gt;
                &amp;lt;code&amp;gt;
                &amp;lt;/code&amp;gt;
              &amp;lt;/a&amp;gt;
              &amp;lt;a href=&#39;https://github.com/golang/tools/blob/master/refactor/eg/eg.go&#39;&amp;gt;
                &amp;lt;code&amp;gt;
                &amp;lt;/code&amp;gt;
              &amp;lt;/a&amp;gt;
              &amp;lt;a href=&#39;https://github.com/golang/tools/blob/master/refactor/rename/rename.go&#39;&amp;gt;
                &amp;lt;code&amp;gt;
                &amp;lt;/code&amp;gt;
              &amp;lt;/a&amp;gt;
            &amp;lt;/p&amp;gt;
            &amp;lt;p class=&#39;bio&#39;&amp;gt;
              &amp;lt;a href=&#39;http://www.amazon.com/dp/0131103628?tracking_id=disfordig-20&#39;&amp;gt;
              &amp;lt;/a&amp;gt;
              &amp;lt;a href=&#39;http://www.amazon.com/dp/020161586X?tracking_id=disfordig-20&#39;&amp;gt;
              &amp;lt;/a&amp;gt;
            &amp;lt;/p&amp;gt;
          &amp;lt;/td&amp;gt;
        &amp;lt;/tr&amp;gt;
      &amp;lt;/tbody&amp;gt;
    &amp;lt;/table&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;遍历TextNode时，含有很多空节点（其实就是空格，也当成了一个节点），或许应该在parse阶段就抛弃这些不是节点的节点。本习题中，我暂时借用了元素节点的字段&lt;code&gt;DataAtom  atom.Atom&lt;/code&gt;，若为0，则说明该节点标签无法识别。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;// A Node consists of a NodeType and some Data (tag name for element nodes,
// content for text) and are part of a tree of Nodes. Element nodes may also
// have a Namespace and contain a slice of Attributes. Data is unescaped, so
// that it looks like &amp;ldquo;a&amp;lt;b&amp;rdquo; rather than &amp;ldquo;a&amp;lt;b&amp;rdquo;. For element nodes, DataAtom
// is the atom for Data, or zero if Data is not a known tag name.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;ex-5-8&#34;&gt;Ex 5.8&lt;/h3&gt;

&lt;p&gt;Modify forEachNode so that the pre and post functions return a boolean re indicating whether to continue the traversal. Use it to write a function ElementByID with the following signature that ﬁnds the ﬁrst HTML element with the speciﬁed id attribute. The function should stop the traversal as soon as a match is found.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;func ElementByID(doc *html.Node, id string) *html.Node&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;log&amp;quot;
	&amp;quot;net/http&amp;quot;
	&amp;quot;os&amp;quot;

	&amp;quot;golang.org/x/net/html&amp;quot;
)

var custID = &amp;quot;css_index_result&amp;quot;

//var custID = &amp;quot;toc&amp;quot;

func main() {
	for _, url := range os.Args[1:] {
		outline(url)
	}
}

func outline(url string) error {
	resp, err := http.Get(url)
	if err != nil {
		return err
	}
	defer resp.Body.Close()
	doc, err := html.Parse(resp.Body)
	if err != nil {
		return err
	}
	//forEachNode(doc, &amp;quot;&amp;quot;, startElement, endElement)
	fmt.Printf(&amp;quot;%#v:\n&amp;quot;, getElementByID(doc, custID))
	return nil
}

func forEachNode(n *html.Node, id string, pre, post func(n *html.Node, id string) bool) *html.Node {
	var rtn *html.Node
	if pre != nil {
		if !pre(n, id) {
			rtn = n
		}
	}
	for c := n.FirstChild; c != nil &amp;amp;&amp;amp; rtn == nil; c = c.NextSibling {
		rtn = forEachNode(c, id, pre, post)
	}
	if post != nil {
		if !post(n, id) {
			rtn = n
		}
	}
	return rtn
}

var depth int

func startElement(n *html.Node, id string) bool {
	if n.Type == html.ElementNode ||
		n.Type == html.TextNode ||
		n.Type == html.CommentNode {
		if n.DataAtom != 0 { //去除无法识别标签的节点，如空白的textnode等
			var attr string
			for _, v := range n.Attr {
				attr += &amp;quot; &amp;quot; + v.Key + &amp;quot;=&#39;&amp;quot; + v.Val + &amp;quot;&#39;&amp;quot;
			}
			if n.FirstChild == nil {
				fmt.Printf(&amp;quot;%*s&amp;lt;%s/&amp;gt;\n&amp;quot;, depth*2, &amp;quot;&amp;quot;, n.Data)
			} else {
				fmt.Printf(&amp;quot;%*s&amp;lt;%s%s&amp;gt;\n&amp;quot;, depth*2, &amp;quot;&amp;quot;, n.Data, attr)
			}
			depth++
		}
		if n.Type == html.ElementNode {
			for _, v := range n.Attr {
				if v.Key == &amp;quot;id&amp;quot; &amp;amp;&amp;amp; v.Val == id {
					log.Printf(&amp;quot;%#v\n&amp;quot;, n)
					return false
				}
			}
		}
	}
	return true
}
func endElement(n *html.Node, id string) bool {
	if n.Type == html.ElementNode ||
		n.Type == html.TextNode ||
		n.Type == html.CommentNode {
		if n.DataAtom != 0 {
			depth--
			if n.FirstChild != nil {
				fmt.Printf(&amp;quot;%*s&amp;lt;/%s&amp;gt;\n&amp;quot;, depth*2, &amp;quot;&amp;quot;, n.Data)
			}
		}
	}
	return true
}

func getElementByID(doc *html.Node, id string) *html.Node {
	return forEachNode(doc, id, startElement, endElement)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./ex5.7 http://www.baidu.com
&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;meta/&amp;gt;
    &amp;lt;meta/&amp;gt;
    &amp;lt;meta/&amp;gt;
    &amp;lt;meta/&amp;gt;
    &amp;lt;link/&amp;gt;
    &amp;lt;link/&amp;gt;
    &amp;lt;link/&amp;gt;
    &amp;lt;link/&amp;gt;
    &amp;lt;link/&amp;gt;
    &amp;lt;link/&amp;gt;
    &amp;lt;link/&amp;gt;
    &amp;lt;link/&amp;gt;
    &amp;lt;link/&amp;gt;
    &amp;lt;link/&amp;gt;
    &amp;lt;link/&amp;gt;
    &amp;lt;title&amp;gt;
    &amp;lt;/title&amp;gt;
    &amp;lt;style id=&#39;css_index&#39; index=&#39;index&#39; type=&#39;text/css&#39;&amp;gt;
    &amp;lt;/style&amp;gt;
    &amp;lt;style data-for=&#39;debug&#39;&amp;gt;
    &amp;lt;/style&amp;gt;
    &amp;lt;style data-for=&#39;result&#39; id=&#39;css_index_result&#39; type=&#39;text/css&#39;&amp;gt;
2018/01/02 17:53:11 &amp;amp;html.Node{Parent:(*html.Node)(0xc4201322a0), FirstChild:(*html.Node)(0xc4201336c0), LastChild:(*html.Node)(0xc4201336c0), PrevSibling:(*html.Node)(0xc4201335e0), NextSibling:(*html.Node)(0xc420133730), Type:0x3, DataAtom:0x6f905, Data:&amp;quot;style&amp;quot;, Namespace:&amp;quot;&amp;quot;, Attr:[]html.Attribute{html.Attribute{Namespace:&amp;quot;&amp;quot;, Key:&amp;quot;data-for&amp;quot;, Val:&amp;quot;result&amp;quot;}, html.Attribute{Namespace:&amp;quot;&amp;quot;, Key:&amp;quot;id&amp;quot;, Val:&amp;quot;css_index_result&amp;quot;}, html.Attribute{Namespace:&amp;quot;&amp;quot;, Key:&amp;quot;type&amp;quot;, Val:&amp;quot;text/css&amp;quot;}}}
    &amp;lt;/style&amp;gt;
  &amp;lt;/head&amp;gt;
&amp;lt;/html&amp;gt;
&amp;amp;html.Node{Parent:(*html.Node)(0xc4201322a0), FirstChild:(*html.Node)(0xc4201336c0), LastChild:(*html.Node)(0xc4201336c0), PrevSibling:(*html.Node)(0xc4201335e0), NextSibling:(*html.Node)(0xc420133730), Type:0x3, DataAtom:0x6f905, Data:&amp;quot;style&amp;quot;, Namespace:&amp;quot;&amp;quot;, Attr:[]html.Attribute{html.Attribute{Namespace:&amp;quot;&amp;quot;, Key:&amp;quot;data-for&amp;quot;, Val:&amp;quot;result&amp;quot;}, html.Attribute{Namespace:&amp;quot;&amp;quot;, Key:&amp;quot;id&amp;quot;, Val:&amp;quot;css_index_result&amp;quot;}, html.Attribute{Namespace:&amp;quot;&amp;quot;, Key:&amp;quot;type&amp;quot;, Val:&amp;quot;text/css&amp;quot;}}}:
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ex-5-12&#34;&gt;Ex 5.12&lt;/h3&gt;

&lt;p&gt;The startElement and endElement functions in gopl.io/ch5/outline2 (§5.5) share a global variable, depth. Turn them into anonymous functions that share a variable local to the outline function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Copyright © 2016 Alan A. A. Donovan &amp;amp; Brian W. Kernighan.
// License: https://creativecommons.org/licenses/by-nc-sa/4.0/

// See page 133.

// Outline prints the outline of an HTML document tree.
package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;net/http&amp;quot;
	&amp;quot;os&amp;quot;

	&amp;quot;golang.org/x/net/html&amp;quot;
)

func main() {
	for _, url := range os.Args[1:] {
		outline(url)
	}
}

func outline(url string) error {
	resp, err := http.Get(url)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	doc, err := html.Parse(resp.Body)
	if err != nil {
		return err
	}
	var depth int
	startElement := func(n *html.Node) {
		if n.Type == html.ElementNode {
			fmt.Printf(&amp;quot;%*s&amp;lt;%s&amp;gt;\n&amp;quot;, depth*2, &amp;quot;&amp;quot;, n.Data)
			depth++
		}
	}

	endElement := func(n *html.Node) {
		if n.Type == html.ElementNode {
			depth--
			fmt.Printf(&amp;quot;%*s&amp;lt;/%s&amp;gt;\n&amp;quot;, depth*2, &amp;quot;&amp;quot;, n.Data)
		}
	}
	//!+call
	forEachNode(doc, startElement, endElement)
	//!-call

	return nil
}

//!+forEachNode
// forEachNode calls the functions pre(x) and post(x) for each node
// x in the tree rooted at n. Both functions are optional.
// pre is called before the children are visited (preorder) and
// post is called after (postorder).
func forEachNode(n *html.Node, pre, post func(n *html.Node)) {
	if pre != nil {
		pre(n)
	}

	for c := n.FirstChild; c != nil; c = c.NextSibling {
		forEachNode(c, pre, post)
	}

	if post != nil {
		post(n)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ex-5-13&#34;&gt;Ex 5.13&lt;/h3&gt;

&lt;p&gt;Modify crawl to make local copies of the pages it ﬁnds, creating directories as necessary. Don’t make copies of pages that come from a different domain. For example, if the original page comes from golang.org, save all ﬁles from there, but exclude ones from vimeo.com.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;io&amp;quot;
	&amp;quot;log&amp;quot;
	&amp;quot;net/http&amp;quot;
	&amp;quot;net/url&amp;quot;
	&amp;quot;os&amp;quot;
	&amp;quot;strconv&amp;quot;
	&amp;quot;strings&amp;quot;
	&amp;quot;time&amp;quot;

	&amp;quot;golang.org/x/net/html&amp;quot;
	&amp;quot;gopl.io/ch5/links&amp;quot;
)

// Extract makes an HTTP GET request to the specified URL, parses
// the response as HTML, and returns the links in the HTML document.
func Extract(urlstr string) ([]string, error) {
	resp, err := http.Get(urlstr)
	if err != nil {
		return nil, err
	}
	if resp.StatusCode != http.StatusOK {
		resp.Body.Close()
		return nil, fmt.Errorf(&amp;quot;getting %s: %s&amp;quot;, urlstr, resp.Status)
	}
	doc, err := html.Parse(resp.Body)
	resp.Body.Close()
	if err != nil {
		return nil, fmt.Errorf(&amp;quot;parsing %s as HTML: %v&amp;quot;, urlstr, err)
	}
	var links []string
	visitNode := func(n *html.Node) {
		if n.Type == html.ElementNode &amp;amp;&amp;amp; n.Data == &amp;quot;a&amp;quot; {
			for _, a := range n.Attr {
				if a.Key != &amp;quot;href&amp;quot; {
					continue
				}
				link, err := resp.Request.URL.Parse(a.Val)
				if err != nil {
					continue // ignore bad URLs
				}
				links = append(links, link.String())
			}
		}
	}
	forEachNode(doc, visitNode, nil)
	return links, nil
}

//!-Extract

// Copied from gopl.io/ch5/outline2.
func forEachNode(n *html.Node, pre, post func(n *html.Node)) {
	if pre != nil {
		pre(n)
	}
	for c := n.FirstChild; c != nil; c = c.NextSibling {
		forEachNode(c, pre, post)
	}
	if post != nil {
		post(n)
	}
}

func breadthFirst(f func(item string, host []string) []string, worklist []string) {
	seen := make(map[string]bool)
	host := make([]string, len(worklist))
	for i, v := range worklist {
		u, err := url.Parse(v)
		if err != nil {
			fmt.Println(&amp;quot;initial url parse failed&amp;quot;)
			return
		}
		host[i] = u.Host
	}
	for len(worklist) &amp;gt; 0 {
		items := worklist
		worklist = nil
		for _, item := range items {
			if !seen[item] {
				seen[item] = true
				worklist = append(worklist, f(item, host)...)
			}
		}
	}
}

//!-breadthFirst

//!+crawl
func crawl(urlstr string, sl []string) []string {
	fmt.Println(urlstr)
	copycontent(urlstr, sl)
	list, err := links.Extract(urlstr)
	if err != nil {
		log.Print(err)
	}
	return list
}

func copycontent(s string, sl []string) {
	u, err := url.Parse(s)
	if err != nil {
		fmt.Println(&amp;quot;url parse failed&amp;quot;)
		return
	}
	for _, v := range sl {
		if u.Host == v {
			resp, err := http.Get(s)
			if err != nil {
				fmt.Println(err)
				return
			}
			if resp.StatusCode != http.StatusOK {
				resp.Body.Close()
				return
			}
			//fmt.Println(path)
			dir, _ := os.Getwd() //当前的目录
			var filename, filepart, dirpart string
			ns := strings.Count(u.Path, &amp;quot;/&amp;quot;)
			if ns == 0 || ns == 1 &amp;amp;&amp;amp; len(u.Path) == 1 {
				filepart = &amp;quot;&amp;quot;
				filename = strconv.FormatInt(time.Now().Unix(), 10) + &amp;quot;.html&amp;quot;
				dirpart = &amp;quot;/&amp;quot;
			} else {
				filepart = u.Path[strings.LastIndex(u.Path, &amp;quot;/&amp;quot;)+1:]
				dirpart = u.Path[:strings.LastIndex(u.Path, &amp;quot;/&amp;quot;)+1]
				if strings.Contains(filepart, &amp;quot;.&amp;quot;) {
					filename = filepart
				} else {
					dirpart = u.Path
					filename = strconv.FormatInt(time.Now().Unix(), 10) + &amp;quot;.html&amp;quot;
				}
			}

			fullpath := dir + &amp;quot;/&amp;quot; + u.Host + dirpart
			_, err = os.Stat(fullpath)
			if err != nil {
				err = os.MkdirAll(fullpath, os.ModePerm) //在当前目录下生成md目录
				if err != nil {
					fmt.Println(&amp;quot;create folder failed! &amp;quot;, fullpath, err)
					return
				}
			}
			filename = dir + &amp;quot;/&amp;quot; + u.Host + dirpart + &amp;quot;/&amp;quot; + filename
			f, err := os.Create(filename)
			if err != nil {
				fmt.Println(&amp;quot;create file error:&amp;quot;, err, s)
				return
			}
			_, err = io.Copy(f, resp.Body)
			if err != nil {
				fmt.Println(&amp;quot;failed in copy&amp;quot;)
				return
			}
			resp.Body.Close()
		}
	}
}
func main() {
	breadthFirst(crawl, os.Args[1:])
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>The Go Programming Language Ex（5）</title>
      <link>https://mooncaker816.github.io/2017/12/24/the-go-programming-language-ex5/</link>
      <pubDate>Sun, 24 Dec 2017 19:00:00 +0000</pubDate>
      
      <guid>https://mooncaker816.github.io/2017/12/24/the-go-programming-language-ex5/</guid>
      <description>&lt;h3 id=&#34;ex-4-8&#34;&gt;Ex 4.8&lt;/h3&gt;

&lt;p&gt;Modify charcount to count letters, digits, and so on in their Unicode categories, using functions like unicode.IsLetter.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;bufio&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;io&amp;quot;
	&amp;quot;os&amp;quot;
	&amp;quot;unicode&amp;quot;
)

func main() {
	counts := make(map[string]int)                       // counts of Unicode characters
	invalid, letter, digit, mark, other := 0, 0, 0, 0, 0 // count of invalid UTF-8 characters

	in := bufio.NewReader(os.Stdin)
	for {
		r, n, err := in.ReadRune() // returns rune, nbytes, error
		if err == io.EOF {
			break
		}
		if err != nil {
			fmt.Fprintf(os.Stderr, &amp;quot;charcount: %v\n&amp;quot;, err)
			os.Exit(1)
		}
		if r == unicode.ReplacementChar &amp;amp;&amp;amp; n == 1 {
			invalid++
			continue
		} else if unicode.IsLetter(r) {
			letter++
		} else if unicode.IsDigit(r) {
			digit++
		} else if unicode.IsMark(r) {
			mark++
		} else {
			other++
			fmt.Println(r)
		}
	}
	counts[&amp;quot;invalid&amp;quot;] = invalid
	counts[&amp;quot;letter&amp;quot;] = letter
	counts[&amp;quot;digit&amp;quot;] = digit
	counts[&amp;quot;mark&amp;quot;] = mark
	counts[&amp;quot;other&amp;quot;] = other

	for c, n := range counts {
		fmt.Printf(&amp;quot;%s\t:%d\n&amp;quot;, c, n)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;./ex4.8
sdfwwer 1434jipi三是奇偶i问
32
10
invalid	:0
letter	:17
digit	:4
mark	:0
other	:2
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;显然汉字也被认为是letter&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;终端模拟EOF 为 ctrl + d&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;ex-4-9&#34;&gt;Ex 4.9&lt;/h3&gt;

&lt;p&gt;Write a program wordfreq to report the frequency of each word in an input text ﬁle. Call input.Split(bufio.ScanWords) before the ﬁrst call to Scan to break the input into words instead of lines.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;bufio&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;strings&amp;quot;
)

func main() {
	words := make(map[string]int)
	input := &amp;quot;foo  bar   baz foo 我们 foo 我们&amp;quot;
	scanner := bufio.NewScanner(strings.NewReader(input))
	scanner.Split(bufio.ScanWords)
	for scanner.Scan() {
		//fmt.Println(scanner.Text())
		words[scanner.Text()]++
	}
	for k, v := range words {
		fmt.Printf(&amp;quot;%s : %d\n&amp;quot;, k, v)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ go run wordfreq.go
baz : 1
我们 : 2
foo : 3
bar : 1
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ex4-13&#34;&gt;Ex4.13&lt;/h3&gt;

&lt;p&gt;The JSON-based web service of the Open Movie Database lets you s &lt;a href=&#34;https://omdbapi.com/&#34; target=&#34;_blank&#34;&gt;https://omdbapi.com/&lt;/a&gt; for a movie by name and download its poster image. Write a tool poster that downloads the poster image for the movie named on the command line.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;encoding/json&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;io&amp;quot;
	&amp;quot;net/http&amp;quot;
	&amp;quot;os&amp;quot;
)

const OmdbAPI = &amp;quot;http://www.omdbapi.com/?i=tt3896198&amp;amp;apikey=7b94e6bd&amp;amp;t=&amp;quot;

type Movie struct {
	Title    string
	Year     string
	Poster   string
	Response string
	Errormsg string `json:&amp;quot;Error,omitempty&amp;quot;`
}

func main() {
	for i := 1; i &amp;lt; len(os.Args); i++ {
		url := OmdbAPI + os.Args[i]
		resp, err := http.Get(url)
		if err != nil {
			fmt.Println(&amp;quot;http get error &amp;quot;, err)
			return
		}
		defer resp.Body.Close()
		var result Movie
		err = json.NewDecoder(resp.Body).Decode(&amp;amp;result)
		if err != nil {
			fmt.Println(&amp;quot;decode failed&amp;quot;)
			return
		}
		fmt.Printf(&amp;quot;%#v\n&amp;quot;, result)
		fmt.Printf(&amp;quot;%v\n&amp;quot;, result)
		if result.Response == &amp;quot;false&amp;quot; {
			fmt.Println(result.Errormsg)
		} else {
			fmt.Println(&amp;quot;starting download poster&amp;quot;)
			result.Poster = &amp;quot;https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike92%2C5%2C5%2C92%2C30/sign=5a60b1a4cf8065386fe7ac41f6b4ca21/fd039245d688d43f4ee7a518781ed21b0ff43b89.jpg&amp;quot;
			posterres, err := http.Get(result.Poster)
			if err != nil {
				fmt.Println(&amp;quot;get poster url error, download failed&amp;quot;, err)
				return
			} else {
				filename := result.Title + &amp;quot;.jpg&amp;quot;
				f, err := os.Create(filename)
				if err != nil {
					fmt.Println(&amp;quot;create file error&amp;quot;)
					return
				}
				io.Copy(f, posterres.Body)
			}
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./ex4.13 triangle triangleeeee
main.Movie{Title:&amp;quot;Triangle&amp;quot;, Year:&amp;quot;2009&amp;quot;, Poster:&amp;quot;https://images-na.ssl-images-amazon.com/images/M/MV5BY2VlODI5ZmMtZDExYS00OWI4LWJiMWItZWZkZWRkNzlmZWI2XkEyXkFqcGdeQXVyMTQxNzMzNDI@._V1_SX300.jpg&amp;quot;, Response:&amp;quot;True&amp;quot;, Errormsg:&amp;quot;&amp;quot;}
{Triangle 2009 https://images-na.ssl-images-amazon.com/images/M/MV5BY2VlODI5ZmMtZDExYS00OWI4LWJiMWItZWZkZWRkNzlmZWI2XkEyXkFqcGdeQXVyMTQxNzMzNDI@._V1_SX300.jpg True }
starting download poster
download finished
main.Movie{Title:&amp;quot;&amp;quot;, Year:&amp;quot;&amp;quot;, Poster:&amp;quot;&amp;quot;, Response:&amp;quot;False&amp;quot;, Errormsg:&amp;quot;Movie not found!&amp;quot;}
{   False Movie not found!}
Movie not found!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://oumnldfwl.bkt.clouddn.com/ex4.13.png&#34; alt=&#34;Triangle.jpg&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;ex-4-14&#34;&gt;Ex 4.14&lt;/h3&gt;

&lt;p&gt;Create a web server that queries GitHub once and then allows navigation of the list of bug reports, milestones, and users.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;encoding/json&amp;quot;
	&amp;quot;fmt&amp;quot;
	temp2 &amp;quot;html/template&amp;quot;
	&amp;quot;log&amp;quot;
	&amp;quot;net/http&amp;quot;
	&amp;quot;net/url&amp;quot;
	&amp;quot;os&amp;quot;
	&amp;quot;strings&amp;quot;
	temp1 &amp;quot;text/template&amp;quot;
	&amp;quot;time&amp;quot;
)

const IssuesURL = &amp;quot;https://api.github.com/search/issues&amp;quot;

//!+template
const templ1 = `{{.TotalCount}} issues:
{{range .Items}}----------------------------------------
Number: {{.Number}}
User:   {{.User.Login}}
Title:  {{.Title | printf &amp;quot;%.64s&amp;quot;}}
Age:    {{.CreatedAt | daysAgo}} days
Milestone: {{.Milestone.Title}}
{{end}}`
const templ2 = `
&amp;lt;h1&amp;gt;{{.TotalCount}} issues&amp;lt;/h1&amp;gt;
&amp;lt;table&amp;gt;
&amp;lt;tr style=&#39;text-align: left&#39;&amp;gt;
  &amp;lt;th&amp;gt;#&amp;lt;/th&amp;gt;
  &amp;lt;th&amp;gt;State&amp;lt;/th&amp;gt;
  &amp;lt;th&amp;gt;User&amp;lt;/th&amp;gt;
  &amp;lt;th&amp;gt;Title&amp;lt;/th&amp;gt;
  &amp;lt;th&amp;gt;Milestone&amp;lt;/th&amp;gt;
&amp;lt;/tr&amp;gt;
{{range .Items}}
&amp;lt;tr&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;{{.HTMLURL}}&#39;&amp;gt;{{.Number}}&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;{{.State}}&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;{{.User.HTMLURL}}&#39;&amp;gt;{{.User.Login}}&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;{{.HTMLURL}}&#39;&amp;gt;{{.Title}}&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;{{.Milestone.HTMLURL}}&#39;&amp;gt;{{.Milestone.Title}}&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;
{{end}}
&amp;lt;/table&amp;gt;
`

//!-template

type IssuesSearchResult struct {
	TotalCount int `json:&amp;quot;total_count&amp;quot;`
	Items      []*Issue
}

type Issue struct {
	Number    int
	HTMLURL   string `json:&amp;quot;html_url&amp;quot;`
	Title     string
	State     string
	User      *User
	CreatedAt time.Time `json:&amp;quot;created_at&amp;quot;`
	Body      string    // in Markdown format
	Milestone *Milestone
}

type User struct {
	Login   string
	HTMLURL string `json:&amp;quot;html_url&amp;quot;`
}

type Milestone struct {
	Title   string
	HTMLURL string `json:&amp;quot;html_url&amp;quot;`
}

var report1 = temp1.Must(temp1.New(&amp;quot;issuelist1&amp;quot;).
	Funcs(temp1.FuncMap{&amp;quot;daysAgo&amp;quot;: daysAgo}).
	Parse(templ1))
var report2 = temp2.Must(temp2.New(&amp;quot;issuelist2&amp;quot;).
	Funcs(temp2.FuncMap{&amp;quot;daysAgo&amp;quot;: daysAgo}).
	Parse(templ2))

func main() {
	result, err := SearchIssues(os.Args[1:])
	if err != nil {
		log.Fatal(err)
	}
	f1, err := os.Create(&amp;quot;report.txt&amp;quot;)
	if err := report1.Execute(f1, result); err != nil {
		log.Fatal(err)
	}
	f2, err := os.Create(&amp;quot;report.html&amp;quot;)
	if err := report2.Execute(f2, result); err != nil {
		log.Fatal(err)
	}
}

func daysAgo(t time.Time) int {
	return int(time.Since(t).Hours() / 24)
}

// SearchIssues queries the GitHub issue tracker.
func SearchIssues(terms []string) (*IssuesSearchResult, error) {
	q := url.QueryEscape(strings.Join(terms, &amp;quot; &amp;quot;))
	resp, err := http.Get(IssuesURL + &amp;quot;?q=&amp;quot; + q)
	if err != nil {
		return nil, err
	}
	// We must close resp.Body on all execution paths.
	// (Chapter 5 presents &#39;defer&#39;, which makes this simpler.)
	if resp.StatusCode != http.StatusOK {
		resp.Body.Close()
		return nil, fmt.Errorf(&amp;quot;search query failed: %s&amp;quot;, resp.Status)
	}
	var result IssuesSearchResult
	if err := json.NewDecoder(resp.Body).Decode(&amp;amp;result); err != nil {
		resp.Body.Close()
		return nil, err
	}
	resp.Body.Close()
	return &amp;amp;result, nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;//report.txt
41 issues:
----------------------------------------
Number: 23188
User:   ianlancetaylor
Title:  cmd/compile: incorrect order of evaluation according to spec
Age:    7 days
Milestone: Go1.11
----------------------------------------
Number: 23183
User:   terinjokes
Title:  net/http: muxer no longer redirects host patterns in go1.10
Age:    7 days
Milestone: Go1.10
----------------------------------------
Number: 23181
User:   hirochachacha
Title:  cmd/buildid: rewrite algorithm is broken
Age:    7 days
Milestone: Go1.10
----------------------------------------
Number: 23180
User:   aarzilli
Title:  cmd/go: go test -c does not apply specified gcflags to all packa
Age:    7 days
Milestone: Go1.10
----------------------------------------
Number: 23166
User:   mvdan
Title:  x/tools/go/ssa/interp: tests consistently failing on darwin
Age:    8 days
Milestone: Go1.10
----------------------------------------
Number: 23146
User:   bradfitz
Title:  cmd/vet: stderr spam during testing
Age:    12 days
Milestone: Go1.10
----------------------------------------
Number: 23122
User:   rsc
Title:  all: remove support for OS X 10.8 and 10.9
Age:    13 days
Milestone: Go1.11
----------------------------------------
Number: 23098
User:   mikioh
Title:  runtime: loop over allp causes a nil pointer dereference crash
Age:    15 days
Milestone: Go1.10
----------------------------------------
Number: 23037
User:   zolotov
Title:  cmd/go: add JSON output for building package failures while runn
Age:    19 days
Milestone: Go1.10
----------------------------------------
Number: 23036
User:   zolotov
Title:  cmd/test2json: filtering out testing service messages or mark th
Age:    19 days
Milestone: Go1.10
----------------------------------------
Number: 23011
User:   bradfitz
Title:  build: announce end of support for old macOS releases
Age:    21 days
Milestone: Go1.11
----------------------------------------
Number: 23010
User:   rsc
Title:  net/http: ResponseWriter panics in WriteHeaders that were former
Age:    21 days
Milestone: Go1.10
----------------------------------------
Number: 23009
User:   rsc
Title:  net/http/httputil: ReverseProxy change conflicts with future Rev
Age:    21 days
Milestone: Go1.10
----------------------------------------
Number: 22984
User:   rsc
Title:  cmd/go: test -json not cached
Age:    22 days
Milestone: Go1.10
----------------------------------------
Number: 22924
User:   chipaca
Title:  syscall: on linux 386 doesn&#39;t support syscalls that don&#39;t fail
Age:    27 days
Milestone: Go1.11
----------------------------------------
Number: 22781
User:   pciet
Title:  runtime: fatal error: sweep increased allocation count, go1.9.x
Age:    39 days
Milestone: Go1.9.3
----------------------------------------
Number: 22637
User:   ianlancetaylor
Title:  crypto: examine and probably remove OpenSSL derived code
Age:    48 days
Milestone: Go1.10
----------------------------------------
Number: 22487
User:   tklauser
Title:  lib/time: update tzdata before 1.10 release
Age:    58 days
Milestone: Go1.10
----------------------------------------
Number: 22475
User:   rsc
Title:  cmd/go: include GOROOT in linkActionID hash
Age:    59 days
Milestone: Go1.10
----------------------------------------
Number: 22472
User:   rsc
Title:  cmd/go: implement gccgo support for content-based staleness
Age:    60 days
Milestone: Go1.10
----------------------------------------
Number: 22444
User:   griesemer
Title:  cmd/compile: missing wrapper function for call of literal method
Age:    62 days
Milestone: Go1.11
----------------------------------------
Number: 22429
User:   TheTincho
Title:  cmd/compile: invalid instruction error for FMOVD when compiling 
Age:    63 days
Milestone: Go1.9.3
----------------------------------------
Number: 22349
User:   alexbrainman
Title:  net: ipStackCapabilities.probe creates sockets that can escape i
Age:    68 days
Milestone: Go1.10
----------------------------------------
Number: 22224
User:   siebenmann
Title:  cmd/go: build failure on amd64 Linux with an error in TestTwoGop
Age:    76 days
Milestone: Go1.10
----------------------------------------
Number: 22204
User:   tmm1
Title:  runtime: sigpanic during GC on android/arm64
Age:    77 days
Milestone: Go1.10
----------------------------------------
Number: 22155
User:   rsc
Title:  cmd/go: GOROOT override using linker -X flag is probably not rig
Age:    82 days
Milestone: Go1.10
----------------------------------------
Number: 21431
User:   josharian
Title:  runtime: stack split at a bad time on mipsle
Age:    135 days
Milestone: Go1.10
----------------------------------------
Number: 21282
User:   dsnet
Title:  cmd/compile: incorrect type assertions on conflicting package na
Age:    146 days
Milestone: Go1.11
----------------------------------------
Number: 21221
User:   vibhavp
Title:  cmd/compile: internal compiler error: constant type mismatch whe
Age:    150 days
Milestone: Go1.11
----------------------------------------
Number: 20790
User:   mikioh
Title:  net: DefaultResolver.Lookup{Host,IPAddr} and LookupHost fail to 
Age:    185 days
Milestone: Go1.11
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;//report.html

&amp;lt;h1&amp;gt;41 issues&amp;lt;/h1&amp;gt;
&amp;lt;table&amp;gt;
&amp;lt;tr style=&#39;text-align: left&#39;&amp;gt;
  &amp;lt;th&amp;gt;#&amp;lt;/th&amp;gt;
  &amp;lt;th&amp;gt;State&amp;lt;/th&amp;gt;
  &amp;lt;th&amp;gt;User&amp;lt;/th&amp;gt;
  &amp;lt;th&amp;gt;Title&amp;lt;/th&amp;gt;
  &amp;lt;th&amp;gt;Milestone&amp;lt;/th&amp;gt;
&amp;lt;/tr&amp;gt;

&amp;lt;tr&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/23188&#39;&amp;gt;23188&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;open&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/ianlancetaylor&#39;&amp;gt;ianlancetaylor&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/23188&#39;&amp;gt;cmd/compile: incorrect order of evaluation according to spec&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/milestone/62&#39;&amp;gt;Go1.11&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;

&amp;lt;tr&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/23183&#39;&amp;gt;23183&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;open&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/terinjokes&#39;&amp;gt;terinjokes&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/23183&#39;&amp;gt;net/http: muxer no longer redirects host patterns in go1.10&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/milestone/56&#39;&amp;gt;Go1.10&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;

&amp;lt;tr&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/23181&#39;&amp;gt;23181&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;open&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/hirochachacha&#39;&amp;gt;hirochachacha&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/23181&#39;&amp;gt;cmd/buildid: rewrite algorithm is broken&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/milestone/56&#39;&amp;gt;Go1.10&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;

&amp;lt;tr&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/23180&#39;&amp;gt;23180&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;open&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/aarzilli&#39;&amp;gt;aarzilli&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/23180&#39;&amp;gt;cmd/go: go test -c does not apply specified gcflags to all packages&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/milestone/56&#39;&amp;gt;Go1.10&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;

&amp;lt;tr&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/23166&#39;&amp;gt;23166&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;open&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/mvdan&#39;&amp;gt;mvdan&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/23166&#39;&amp;gt;x/tools/go/ssa/interp: tests consistently failing on darwin&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/milestone/56&#39;&amp;gt;Go1.10&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;

&amp;lt;tr&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/23146&#39;&amp;gt;23146&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;open&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/bradfitz&#39;&amp;gt;bradfitz&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/23146&#39;&amp;gt;cmd/vet: stderr spam during testing&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/milestone/56&#39;&amp;gt;Go1.10&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;

&amp;lt;tr&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/23122&#39;&amp;gt;23122&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;open&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/rsc&#39;&amp;gt;rsc&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/23122&#39;&amp;gt;all: remove support for OS X 10.8 and 10.9&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/milestone/62&#39;&amp;gt;Go1.11&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;

&amp;lt;tr&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/23098&#39;&amp;gt;23098&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;open&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/mikioh&#39;&amp;gt;mikioh&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/23098&#39;&amp;gt;runtime: loop over allp causes a nil pointer dereference crash&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/milestone/56&#39;&amp;gt;Go1.10&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;

&amp;lt;tr&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/23037&#39;&amp;gt;23037&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;open&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/zolotov&#39;&amp;gt;zolotov&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/23037&#39;&amp;gt;cmd/go: add JSON output for building package failures while running go test on directory with several packages&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/milestone/56&#39;&amp;gt;Go1.10&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;

&amp;lt;tr&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/23036&#39;&amp;gt;23036&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;open&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/zolotov&#39;&amp;gt;zolotov&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/23036&#39;&amp;gt;cmd/test2json: filtering out testing service messages or mark them in a special way&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/milestone/56&#39;&amp;gt;Go1.10&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;

&amp;lt;tr&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/23011&#39;&amp;gt;23011&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;open&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/bradfitz&#39;&amp;gt;bradfitz&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/23011&#39;&amp;gt;build: announce end of support for old macOS releases&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/milestone/62&#39;&amp;gt;Go1.11&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;

&amp;lt;tr&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/23010&#39;&amp;gt;23010&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;open&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/rsc&#39;&amp;gt;rsc&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/23010&#39;&amp;gt;net/http: ResponseWriter panics in WriteHeaders that were formerly ignored&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/milestone/56&#39;&amp;gt;Go1.10&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;

&amp;lt;tr&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/23009&#39;&amp;gt;23009&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;open&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/rsc&#39;&amp;gt;rsc&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/23009&#39;&amp;gt;net/http/httputil: ReverseProxy change conflicts with future ReverseProxy plans&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/milestone/56&#39;&amp;gt;Go1.10&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;

&amp;lt;tr&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/22984&#39;&amp;gt;22984&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;open&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/rsc&#39;&amp;gt;rsc&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/22984&#39;&amp;gt;cmd/go: test -json not cached&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/milestone/56&#39;&amp;gt;Go1.10&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;

&amp;lt;tr&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/22924&#39;&amp;gt;22924&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;open&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/chipaca&#39;&amp;gt;chipaca&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/22924&#39;&amp;gt;syscall: on linux 386 doesn&amp;amp;#39;t support syscalls that don&amp;amp;#39;t fail&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/milestone/62&#39;&amp;gt;Go1.11&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;

&amp;lt;tr&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/22781&#39;&amp;gt;22781&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;open&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/pciet&#39;&amp;gt;pciet&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/22781&#39;&amp;gt;runtime: fatal error: sweep increased allocation count, go1.9.x&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/milestone/63&#39;&amp;gt;Go1.9.3&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;

&amp;lt;tr&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/22637&#39;&amp;gt;22637&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;open&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/ianlancetaylor&#39;&amp;gt;ianlancetaylor&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/22637&#39;&amp;gt;crypto: examine and probably remove OpenSSL derived code&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/milestone/56&#39;&amp;gt;Go1.10&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;

&amp;lt;tr&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/22487&#39;&amp;gt;22487&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;open&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/tklauser&#39;&amp;gt;tklauser&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/22487&#39;&amp;gt;lib/time: update tzdata before 1.10 release&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/milestone/56&#39;&amp;gt;Go1.10&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;

&amp;lt;tr&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/22475&#39;&amp;gt;22475&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;open&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/rsc&#39;&amp;gt;rsc&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/22475&#39;&amp;gt;cmd/go: include GOROOT in linkActionID hash&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/milestone/56&#39;&amp;gt;Go1.10&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;

&amp;lt;tr&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/22472&#39;&amp;gt;22472&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;open&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/rsc&#39;&amp;gt;rsc&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/22472&#39;&amp;gt;cmd/go: implement gccgo support for content-based staleness&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/milestone/56&#39;&amp;gt;Go1.10&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;

&amp;lt;tr&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/22444&#39;&amp;gt;22444&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;open&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/griesemer&#39;&amp;gt;griesemer&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/22444&#39;&amp;gt;cmd/compile: missing wrapper function for call of literal method expression&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/milestone/62&#39;&amp;gt;Go1.11&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;

&amp;lt;tr&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/22429&#39;&amp;gt;22429&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;open&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/TheTincho&#39;&amp;gt;TheTincho&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/22429&#39;&amp;gt;cmd/compile: invalid instruction error for FMOVD when compiling for 387&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/milestone/63&#39;&amp;gt;Go1.9.3&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;

&amp;lt;tr&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/22349&#39;&amp;gt;22349&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;open&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/alexbrainman&#39;&amp;gt;alexbrainman&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/22349&#39;&amp;gt;net: ipStackCapabilities.probe creates sockets that can escape into child process&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/milestone/56&#39;&amp;gt;Go1.10&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;

&amp;lt;tr&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/22224&#39;&amp;gt;22224&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;open&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/siebenmann&#39;&amp;gt;siebenmann&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/22224&#39;&amp;gt;cmd/go: build failure on amd64 Linux with an error in TestTwoGopathShlibsGccgo from CL 69831  onward&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/milestone/56&#39;&amp;gt;Go1.10&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;

&amp;lt;tr&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/22204&#39;&amp;gt;22204&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;open&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/tmm1&#39;&amp;gt;tmm1&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/22204&#39;&amp;gt;runtime: sigpanic during GC on android/arm64&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/milestone/56&#39;&amp;gt;Go1.10&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;

&amp;lt;tr&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/22155&#39;&amp;gt;22155&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;open&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/rsc&#39;&amp;gt;rsc&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/22155&#39;&amp;gt;cmd/go: GOROOT override using linker -X flag is probably not right&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/milestone/56&#39;&amp;gt;Go1.10&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;

&amp;lt;tr&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/21431&#39;&amp;gt;21431&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;open&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/josharian&#39;&amp;gt;josharian&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/21431&#39;&amp;gt;runtime: stack split at a bad time on mipsle&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/milestone/56&#39;&amp;gt;Go1.10&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;

&amp;lt;tr&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/21282&#39;&amp;gt;21282&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;open&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/dsnet&#39;&amp;gt;dsnet&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/21282&#39;&amp;gt;cmd/compile: incorrect type assertions on conflicting package names&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/milestone/62&#39;&amp;gt;Go1.11&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;

&amp;lt;tr&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/21221&#39;&amp;gt;21221&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;open&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/vibhavp&#39;&amp;gt;vibhavp&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/21221&#39;&amp;gt;cmd/compile: internal compiler error: constant type mismatch when comparing two unsafe.Pointer rvalues&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/milestone/62&#39;&amp;gt;Go1.11&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;

&amp;lt;tr&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/20790&#39;&amp;gt;20790&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;open&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/mikioh&#39;&amp;gt;mikioh&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/issues/20790&#39;&amp;gt;net: DefaultResolver.Lookup{Host,IPAddr} and LookupHost fail to parse a literal IPv6 address w/ zone&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;&amp;lt;a href=&#39;https://github.com/golang/go/milestone/62&#39;&amp;gt;Go1.11&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;

&amp;lt;/table&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://oumnldfwl.bkt.clouddn.com/ex4.14.png&#34; alt=&#34;ex4.14 report.html&#34; /&gt;&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
