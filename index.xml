<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Mooncaker816 on Mooncaker816</title>
    <link>https://mooncaker816.github.io/</link>
    <description>Recent content in Mooncaker816 on Mooncaker816</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <copyright>&amp;copy; 2018-Present</copyright>
    <lastBuildDate>Wed, 20 Apr 2016 00:00:00 +0800</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>天文算法20</title>
      <link>https://mooncaker816.github.io/2018/05/23/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9520/</link>
      <pubDate>Wed, 23 May 2018 16:58:54 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/05/23/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9520/</guid>
      <description>&lt;h1 id=&#34;第二十二章-章动和黄赤交角-nutation-and-the-obliquity-of-the-ecliptic&#34;&gt;第二十二章 章动和黄赤交角 Nutation and the Obliquity of the Ecliptic&lt;/h1&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-名词解释&#34;&gt;1. 名词解释&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E7%AB%A0%E5%8B%95&#34; target=&#34;_blank&#34;&gt;章动&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;2-章动的分量&#34;&gt;2. 章动的分量&lt;/h2&gt;

&lt;p&gt;　　章动可以很容易的分解为黄道的水平分量和的垂直分量。黄道上的分量记为$Δψ$，称为黄经章动；它影响了天球上所有天体的经度。黄道的垂直分量记为$Δε$，称为交角章动，它影响了黄赤交角。&lt;/p&gt;

&lt;h2 id=&#34;3-较精确计算章动&#34;&gt;3. 较精确计算章动&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Nutation returns nutation in longitude (Δψ) and nutation in obliquity (Δε)
// for a given JDE.
//
// JDE = UT + ΔT, see package deltat.
//
// Computation is by 1980 IAU theory, with terms &amp;lt; .0003″ neglected.
// 计算 jde 对应的章动
func Nutation(jde float64) (Δψ, Δε unit.Angle) {
	T := base.J2000Century(jde)
	D := base.Horner(T,
		297.85036, 445267.11148, -0.0019142, 1./189474) * math.Pi / 180
	M := base.Horner(T,
		357.52772, 35999.050340, -0.0001603, -1./300000) * math.Pi / 180
	N := base.Horner(T,
		134.96298, 477198.867398, 0.0086972, 1./56250) * math.Pi / 180
	F := base.Horner(T,
		93.27191, 483202.017538, -0.0036825, 1./327270) * math.Pi / 180
	Ω := base.Horner(T,
		125.04452, -1934.136261, 0.0020708, 1./450000) * math.Pi / 180
	// sum in reverse order to accumulate smaller terms first
	var Δψs, Δεs float64
	for i := len(table22A) - 1; i &amp;gt;= 0; i-- {
		row := table22A[i]
		arg := row.d*D + row.m*M + row.n*N + row.f*F + row.ω*Ω
		s, c := math.Sincos(arg)
		Δψs += s * (row.s0 + row.s1*T)
		Δεs += c * (row.c0 + row.c1*T)
	}
	Δψ = unit.AngleFromSec(Δψs * .0001)
	Δε = unit.AngleFromSec(Δεs * .0001)
	return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;4-粗略计算章动&#34;&gt;4. 粗略计算章动&lt;/h2&gt;

&lt;p&gt;Δψ精度为0.5″,Δε精度为0.1″&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// ApproxNutation returns a fast approximation of nutation in longitude (Δψ)
// and nutation in obliquity (Δε) for a given JDE.
//
// Accuracy is 0.5″ in Δψ, 0.1″ in Δε.
// 精度要求为0.5″ in Δψ, 0.1″ in Δε
func ApproxNutation(jde float64) (Δψ, Δε unit.Angle) {
	T := (jde - base.J2000) / 36525
	Ω := (125.04452 - 1934.136261*T) * math.Pi / 180
	L := (280.4665 + 36000.7698*T) * math.Pi / 180
	N := (218.3165 + 481267.8813*T) * math.Pi / 180
	sΩ, cΩ := math.Sincos(Ω)
	s2L, c2L := math.Sincos(2 * L)
	s2N, c2N := math.Sincos(2 * N)
	s2Ω, c2Ω := math.Sincos(2 * Ω)
	Δψ = unit.AngleFromSec(-17.2*sΩ - 1.32*s2L - 0.23*s2N + 0.21*s2Ω)
	Δε = unit.AngleFromSec(9.2*cΩ + 0.57*c2L + 0.1*c2N - 0.09*c2Ω)
	return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;5-黄赤交角&#34;&gt;5. 黄赤交角&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;平黄赤交角$ε_0$：黄道与平赤道的夹角&lt;/p&gt;

&lt;p&gt;$$ε_0 = 23°26&amp;rsquo;21&amp;rdquo;.448 - 46&amp;rdquo;.8150T - 0&amp;rdquo;.00059T^2 + 0&amp;rdquo;.001813T^3$$&lt;/p&gt;

&lt;p&gt;T是J2000.0起算的儒略世纪数&lt;/p&gt;

&lt;p&gt;　　当时间范围很长，上述公式的精度并不令人满意：2000年误差1&amp;rdquo;，4000误差为10&amp;rdquo;。Laskar提供了以下改良的的公式，式中U是J2000.0起算的儒略万年数，即U=T/100：
\begin{align}
ε_0 =&amp;amp; 23°26&amp;rsquo;21&amp;rdquo;.448 - 4680&amp;rdquo;.93U - 1.55U^2 + 1999.25U^3 - 51.38U^4 - 249.67U^5 \\[2ex]
&amp;amp;-39.05U^6 + 7.12U^7 + 27.87U^8 + 5.79U^9 + 2.45U^{10}
\end{align}
　　该表达式的精度是：1000年后误差0&amp;rdquo;.01(公元 1000 到 3000)，10000年后误差数个角秒。&lt;br /&gt;
　　&lt;strong&gt;该表达式适用于|U|&amp;lt;1，即 J2000.0 起算前后各 10000 年的范围内。&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// MeanObliquity returns mean obliquity (ε₀) following the IAU 1980
// polynomial.
//
// Accuracy is 1″ over the range 1000 to 3000 years and 10″ over the range
// 0 to 4000 years.
// 平黄赤交角 - 精度一般，2000年误差 1&amp;quot;，4000年误差为 10&amp;quot;
func MeanObliquity(jde float64) unit.Angle {
    // (22.2) p. 147
    return unit.AngleFromSec(base.Horner(base.J2000Century(jde),
        unit.FromSexaSec(&#39; &#39;, 23, 26, 21.448),
        -46.815,
        -0.00059,
        0.001813))
}

// MeanObliquityLaskar returns mean obliquity (ε₀) following the Laskar
// 1986 polynomial.
//
// Accuracy over the range 1000 to 3000 years is .01″.
//
// Accuracy over the valid date range of -8000 to +12000 years is
// &amp;quot;a few seconds.&amp;quot;
// 平黄赤交角 - 精度较好，1000年后误差0&amp;quot;.01(公元 1000 到 3000)，10000年后误差数个角秒
// 适用范围：J2000.0 起算前后各10000年的范围内。
func MeanObliquityLaskar(jde float64) unit.Angle {
    // (22.3) p. 147
    return unit.AngleFromSec(base.Horner(base.J2000Century(jde)*.01,
        unit.FromSexaSec(&#39; &#39;, 23, 26, 21.448),
        -4680.93,
        -1.55,
        1999.25,
        -51.38,
        -249.67,
        -39.05,
        7.12,
        27.87,
        5.79,
        2.45))
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;真黄赤交角：黄道与真赤道的夹角&lt;/p&gt;

&lt;p&gt;$$ε = ε_0 + Δε$$&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>天文算法19</title>
      <link>https://mooncaker816.github.io/2018/05/23/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9519/</link>
      <pubDate>Wed, 23 May 2018 14:36:29 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/05/23/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9519/</guid>
      <description>&lt;h1 id=&#34;第二十一章-岁差&#34;&gt;第二十一章 岁差&lt;/h1&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-名词解释&#34;&gt;1. 名词解释&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E9%80%B2%E5%8B%95&#34; target=&#34;_blank&#34;&gt;Precession&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;2-赤道坐标岁差的近似计算&#34;&gt;2. 赤道坐标岁差的近似计算&lt;/h2&gt;

&lt;p&gt;　　当两个历元相差不远，并且如果星体没有太靠近天极，下面的公式可以用来计算在这两个历元之间的，相对于起始历元的截至历元的年度平均岁差：$$Δα = m + n\sin α\tan δ$$
其中$m = 3s.07496 + 0s.00186T, n = 1s.33621 - 0s.00057T$
$$Δδ = n*cos(α)$$
其中$n = 20&amp;rdquo;.0431 - 0&amp;rdquo;.0085T$&lt;br /&gt;
T是J2000.0起算的儒略世纪数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// ApproxAnnualPrecession returns approximate annual precision in right
// ascension and declination.
//
// The two epochs should be within a few hundred years.
// The declinations should not be too close to the poles.
// 近似计算截至历元相对于起始历元的年度平均岁差，俩历元不能相差太远，且天体不能靠近天极
func ApproxAnnualPrecession(eq *coord.Equatorial, epochFrom, epochTo float64) (Δα unit.HourAngle, Δδ unit.Angle) {
	m, nα, nδ := mn(epochFrom, epochTo)
	sα, cα := eq.RA.Sincos()
	// (21.1) p. 132
	Δα = m + nα.Mul(sα*eq.Dec.Tan())
	Δδ = nδ.Mul(cα)
	return
}

// mn as separate function for testing purposes
// 计算截至历元相对于起始历元的平均年度岁差要用的变量 m,n
func mn(epochFrom, epochTo float64) (m, nα unit.HourAngle, nδ unit.Angle) {
	T := (epochTo - epochFrom) * .01
	m = unit.HourAngleFromSec(3.07496 + 0.00186*T)
	nα = unit.HourAngleFromSec(1.33621 - 0.00057*T)
	nδ = unit.AngleFromSec(20.0431 - 0.0085*T)
	return
}

// ApproxPosition uses ApproxAnnualPrecession to compute a simple and quick
// precession while still considering proper motion.
//
// Both eqFrom and eqTo must be non-nil, although they may point to the same
// struct.  EqTo is returned for convenience.
// 两历元之间坐标的换算，考虑岁差和自行运动（mα，mδ）
func ApproxPosition(eqFrom, eqTo *coord.Equatorial, epochFrom, epochTo float64, mα unit.HourAngle, mδ unit.Angle) *coord.Equatorial {
	Δα, Δδ := ApproxAnnualPrecession(eqFrom, epochFrom, epochTo)
	dy := epochTo - epochFrom
	eqTo.RA = eqFrom.RA.Add((Δα + mα).Mul(dy))
	eqTo.Dec = eqFrom.Dec + (Δδ + mδ).Mul(dy)
	return eqTo
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;3-赤道坐标岁差的精确计算&#34;&gt;3. 赤道坐标岁差的精确计算&lt;/h2&gt;

&lt;p&gt;设T是J2000.0起算的儒略世纪数，t是某一起始历元到终止历元之间的时间差，单位也是儒略世纪数。
\begin{cases}
ζ = ( 2306&amp;rdquo;.2181 + 1&amp;rdquo;.39656T - 0&amp;rdquo;.000139T^2)t + (0&amp;rdquo;.30188 - 0&amp;rdquo;.000344T)t^2 + 0&amp;rdquo;.017998t^3\\[2ex]
z = ( 2306&amp;rdquo;.2181 + 1&amp;rdquo;.39656T - 0&amp;rdquo;.000139T^2)t + (1&amp;rdquo;.09468 + 0&amp;rdquo;.000066T)t^2 + 0&amp;rdquo;.018203t^3\\[2ex]
θ = ( 2004&amp;rdquo;.3109 - 0&amp;rdquo;.85330T - 0&amp;rdquo;.000217T^2)t - (0&amp;rdquo;.42665 + 0&amp;rdquo;.000217T)t^2 - 0&amp;rdquo;.041833t^3
\end{cases}
当T=0时，即起始历元正好就是J2000.0,
\begin{cases}
ζ = 2306&amp;rdquo;.2181t + 0&amp;rdquo;.30188t^2 + 0&amp;rdquo;.017998t^3\\[2ex]
z = 2306&amp;rdquo;.2181t + 1&amp;rdquo;.09468t^2 + 0&amp;rdquo;.018203t^3\\[2ex]
θ = 2004&amp;rdquo;.3109t - 0&amp;rdquo;.42665t^2 - 0&amp;rdquo;.041833t^3
\end{cases}
再计算
\begin{cases}
A &amp;amp;= \cos δ_0\sin(α_0 + ζ)\\[2ex]
B &amp;amp;= \cos θ\cos δ_0\cos(α_0 +ζ) - \sin θ\sin δ_0\\[2ex]
C &amp;amp;= \sin θ\cos δ_0\cos(α_0 +ζ) + \cos θ\sin δ_0
\end{cases}
则$$\tan(α-z) = A/B,\sin δ = C$$
如果星体接近天极，使用$\cos δ = \sqrt {A^2+B^2}$代替$\sin δ = C$&lt;br /&gt;
$α,δ$即为经过岁差转换后的赤道坐标&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Precessor represents precession from one epoch to another.
//
// Construct with NewPrecessor, then call method Precess.
// After construction, Precess may be called multiple times to precess
// different coordinates with the same initial and final epochs.
// 计算赤道坐标精确岁差要用到的变量
type Precessor struct {
	ζ      unit.RA
	z      unit.Angle
	sθ, cθ float64
}

const d = math.Pi / 180
const s = d / 3600

// Package variables allow these slices to be reused.  (As composite
// literals inside of NewPrecessor they would be reallocated on every
// function call.)
var (
	// coefficients from (21.2) p. 134
	ζT = []float64{2306.2181 * s, 1.39656 * s, -0.000139 * s}
	zT = []float64{2306.2181 * s, 1.39656 * s, -0.000139 * s}
	θT = []float64{2004.3109 * s, -0.8533 * s, -0.000217 * s}

	// coefficients from (21.3) p. 134
	ζt = []float64{2306.2181 * s, 0.30188 * s, 0.017998 * s}
	zt = []float64{2306.2181 * s, 1.09468 * s, 0.018203 * s}
	θt = []float64{2004.3109 * s, -0.42665 * s, -0.041833 * s}
)

// NewPrecessor constructs a Precessor object and initializes it to precess
// coordinates from epochFrom to epochTo.
// 构造赤道坐标岁差计算要素
func NewPrecessor(epochFrom, epochTo float64) *Precessor {
	// (21.2) p. 134
	ζCoeff := ζt
	zCoeff := zt
	θCoeff := θt
	if epochFrom != 2000 {
		T := (epochFrom - 2000) * .01
		ζCoeff = []float64{
			base.Horner(T, ζT...),
			0.30188*s - 0.000344*s*T,
			0.017998 * s}
		zCoeff = []float64{
			base.Horner(T, zT...),
			1.09468*s + 0.000066*s*T,
			0.018203 * s}
		θCoeff = []float64{
			base.Horner(T, θT...),
			-0.42665*s - 0.000217*s*T,
			-0.041833 * s}
	}
	t := (epochTo - epochFrom) * .01
	p := &amp;amp;Precessor{
		ζ: unit.RA(base.Horner(t, ζCoeff...) * t),
		z: unit.Angle(base.Horner(t, zCoeff...) * t),
	}
	θ := base.Horner(t, θCoeff...) * t
	p.sθ, p.cθ = math.Sincos(θ)
	return p
}

// Precess precesses coordinates eqFrom, leaving result in eqTo.
//
// The same struct may be used for eqFrom and eqTo.
// EqTo is returned for convenience.
// 赤道坐标的岁差转换计算
func (p *Precessor) Precess(eqFrom, eqTo *coord.Equatorial) *coord.Equatorial {
	// (21.4) p. 134
	sδ, cδ := eqFrom.Dec.Sincos()
	sαζ, cαζ := (eqFrom.RA + p.ζ).Sincos()
	A := cδ * sαζ
	B := p.cθ*cδ*cαζ - p.sθ*sδ
	C := p.sθ*cδ*cαζ + p.cθ*sδ
	eqTo.RA = unit.RAFromRad(math.Atan2(A, B) + p.z.Rad())
	if math.Abs(C) &amp;lt; base.CosSmallAngle {
		eqTo.Dec = unit.Angle(math.Asin(C))
	} else {
		eqTo.Dec = unit.Angle(math.Acos(math.Hypot(A, B))) // near pole
		if C &amp;lt; 0 {
			eqTo.Dec = -eqTo.Dec
		}
	}
	return eqTo
}

// Position precesses equatorial coordinates from one epoch to another,
// including proper motions.
//
// If proper motions are not to be considered or are not applicable, pass 0, 0
// for mα, mδ
//
// Both eqFrom and eqTo must be non-nil, although they may point to the same
// struct.  EqTo is returned for convenience.
// 考虑自行运动的赤道坐标的转换
func Position(eqFrom, eqTo *coord.Equatorial, epochFrom, epochTo float64, mα unit.HourAngle, mδ unit.Angle) *coord.Equatorial {
	p := NewPrecessor(epochFrom, epochTo)
	t := epochTo - epochFrom
	eqTo.RA = unit.RAFromRad(eqFrom.RA.Rad() + mα.Rad()*t)
	eqTo.Dec = eqFrom.Dec + mδ*unit.Angle(t)
	return p.Precess(eqTo, eqTo)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;4-黄道坐标岁差的精确计算&#34;&gt;4. 黄道坐标岁差的精确计算&lt;/h2&gt;

&lt;p&gt;同上，我们先计算
\begin{cases}
η = (47&amp;rdquo;.0029 - 0&amp;rdquo;.06603T + 0&amp;rdquo;.000598T^2)t + (-0&amp;rdquo;.03302 + 0&amp;rdquo;.000598T)t^2 +0&amp;rdquo;.000060t^3\\[2ex]
П = 174°.876384 + 3289&amp;rdquo;.4789T + 0&amp;rdquo;.60622T^2 (869&amp;rdquo;.8089 + 0&amp;rdquo;.50491T)t + 0&amp;rdquo;.03536t^2\\[2ex]
p = (5029&amp;rdquo;.0966 + 2&amp;rdquo;.22226T - 0&amp;rdquo;.000042T^2)t + (1&amp;rdquo;.11113 - 0&amp;rdquo;.000042T)t^2 -0&amp;rdquo;.000006t^3
\end{cases}
当$T=0$时，
\begin{cases}
η = 47&amp;rdquo;.0029t -0&amp;rdquo;.03302t^2 +0&amp;rdquo;.000060t^3\\[2ex]
П = 174°.876384 -869&amp;rdquo;.8089t +0&amp;rdquo;.03536t^2\\[2ex]
p = 5029&amp;rdquo;.0966t +1&amp;rdquo;.11113t^2 -0&amp;rdquo;.000006t^3
\end{cases}
再计算
\begin{cases}
A′ &amp;amp;= \cos η\cos β_0\sin(П-λ_0) - \sin η\sin β_0\\[2ex]
B′ &amp;amp;= \cos β_0\cos(П-λ_0)\\[2ex]
C′ &amp;amp;= \cos η\sin β_0 + \sin η\cos β_0\sin(П-λ_0)
\end{cases}
则$$\tan(p +П-λ) = A′/B′,\sin β = C′$$
如果星体接近天极，使用$\cos β = \sqrt {A′^2+B′^2}$代替$\sin β = C′$&lt;br /&gt;
$λ,β$即为经过岁差转换后的黄道坐标&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// EclipticPrecessor represents precession from one epoch to another.
//
// Construct with NewEclipticPrecessor, then call method Precess.
// After construction, Precess may be called multiple times to precess
// different coordinates with the same initial and final epochs.
// 计算黄道坐标精确岁差要用到的变量
type EclipticPrecessor struct {
	sη, cη float64
	π, p   unit.Angle
}

var (
	// coefficients from (21.5) p. 136, scaled to radians
	ηT = []float64{47.0029 * s, -0.06603 * s, 0.000598 * s}
	πT = []float64{174.876384 * d, 3289.4789 * s, 0.60622 * s}
	pT = []float64{5029.0966 * s, 2.22226 * s, -0.000042 * s}

	// coefficients from (21.6) p. 136, scaled to radians
	ηt = []float64{47.0029 * s, -0.03302 * s, 0.000060 * s}
	πt = []float64{174.876384 * d, -869.8089 * s, 0.03536 * s}
	pt = []float64{5029.0966 * s, 1.11113 * s, -0.000006 * s}
)

// NewEclipticPrecessor constructs an EclipticPrecessor object and initializes
// it to precess coordinates from epochFrom to epochTo.
// 构造黄道坐标岁差计算要素
func NewEclipticPrecessor(epochFrom, epochTo float64) *EclipticPrecessor {
	// (21.5) p. 136
	ηCoeff := ηt
	πCoeff := πt
	pCoeff := pt
	if epochFrom != 2000 {
		T := (epochFrom - 2000) * .01
		ηCoeff = []float64{
			base.Horner(T, ηT...),
			-0.03302*s + 0.000598*s*T,
			0.000060 * s}
		πCoeff = []float64{
			base.Horner(T, πT...),
			-869.8089*s - 0.50491*s*T,
			0.03536 * s}
		pCoeff = []float64{
			base.Horner(T, pT...),
			1.11113*s - 0.000042*s*T,
			-0.000006 * s}
	}
	t := (epochTo - epochFrom) * .01
	p := &amp;amp;EclipticPrecessor{
		π: unit.Angle(base.Horner(t, πCoeff...)),
		p: unit.Angle(base.Horner(t, pCoeff...) * t),
	}
	η := unit.Angle(base.Horner(t, ηCoeff...) * t)
	p.sη, p.cη = η.Sincos()
	return p
}

// EclipticPrecess precesses coordinates eclFrom, leaving result in eclTo.
//
// The same struct may be used for eclFrom and eclTo.
// EclTo is returned for convenience.
// 黄道坐标的岁差转换
func (p *EclipticPrecessor) Precess(eclFrom, eclTo *coord.Ecliptic) *coord.Ecliptic {
	// (21.7) p. 137
	sβ, cβ := eclFrom.Lat.Sincos()
	sd, cd := (p.π - eclFrom.Lon).Sincos()
	A := p.cη*cβ*sd - p.sη*sβ
	B := cβ * cd
	C := p.cη*sβ + p.sη*cβ*sd
	eclTo.Lon = p.p + p.π - unit.Angle(math.Atan2(A, B))
	if math.Abs(C) &amp;lt; base.CosSmallAngle {
		eclTo.Lat = unit.Angle(math.Asin(C))
	} else {
		eclTo.Lat = unit.Angle(math.Acos(math.Hypot(A, B))) // near pole
		if C &amp;lt; 0 {
			eclTo.Lat = -eclTo.Lat
		}
	}
	return eclTo
}

// ReduceElements reduces orbital elements of a solar system body from one
// equinox to another.
//
// This function is described in chapter 24, but is located in this
// package so it can be a method of EclipticPrecessor.
func (p *EclipticPrecessor) ReduceElements(eFrom, eTo *elementequinox.Elements) *elementequinox.Elements {
	ψ := p.π + p.p
	si, ci := eFrom.Inc.Sincos()
	snp, cnp := (eFrom.Node - p.π).Sincos()
	// (24.1) p. 159
	eTo.Inc = unit.Angle(math.Acos(ci*p.cη + si*p.sη*cnp))
	// (24.2) p. 159
	eTo.Node = ψ +
		unit.Angle(math.Atan2(si*snp, p.cη*si*cnp-p.sη*ci))
	// (24.3) p. 160
	eTo.Peri = eFrom.Peri +
		unit.Angle(math.Atan2(-p.sη*snp, si*p.cη-ci*p.sη*cnp))
	return eTo
}

// EclipticPosition precesses ecliptic coordinates from one epoch to another,
// including proper motions.
//
// While eclFrom is given as ecliptic coordinates, proper motions mα, mδ are
// still expected to be equatorial.  If proper motions are not to be considered
// or are not applicable, pass 0, 0.
//
// Both eclFrom and eclTo must be non-nil, although they may point to the same
// struct.  EclTo is returned for convenience.
// 考虑自行运动的黄道坐标的转换，
// 注意此处的mα，mδ是赤道坐标系中的数值，要先转换为黄道坐标mλ, mβ
func EclipticPosition(eclFrom, eclTo *coord.Ecliptic, epochFrom, epochTo float64, mα unit.HourAngle, mδ unit.Angle) *coord.Ecliptic {
	p := NewEclipticPrecessor(epochFrom, epochTo)
	*eclTo = *eclFrom
	if mα != 0 || mδ != 0 {
		mλ, mβ := eqProperMotionToEcl(mα, mδ, epochFrom, eclFrom)
		t := epochTo - epochFrom
		eclTo.Lon += mλ.Mul(t)
		eclTo.Lat += mβ.Mul(t)
	}
	return p.Precess(eclTo, eclTo)
}

// 将自行运动由赤道坐标转黄道坐标
func eqProperMotionToEcl(mα unit.HourAngle, mδ unit.Angle, epoch float64, pos *coord.Ecliptic) (mλ, mβ unit.Angle) {
	ε := nutation.MeanObliquity(base.JulianYearToJDE(epoch))
	sε, cε := ε.Sincos()
	α, δ := coord.EclToEq(pos.Lon, pos.Lat, sε, cε)
	sα, cα := α.Sincos()
	sδ, cδ := δ.Sincos()
	cβ := pos.Lat.Cos()
	mλ = (mδ.Mul(sε*cα) + unit.Angle(mα).Mul(cδ*(cε*cδ+sε*sδ*sα))).Div(cβ * cβ)
	mβ = (mδ.Mul(cε*cδ+sε*sδ*sα) - unit.Angle(mα).Mul(sε*cα*cδ)).Div(cβ)
	return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;5-天体自行运动导致的坐标的转换&#34;&gt;5. 天体自行运动导致的坐标的转换&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// ProperMotion3D takes the 3D equatorial coordinates of an object
// at one epoch and computes its coordinates at a new epoch, considering
// proper motion and radial velocity.
//
// Radial distance (r) must be in parsecs, radial velocitiy (mr) in
// parsecs per year.
//
// Both eqFrom and eqTo must be non-nil, although they may point to the same
// struct.  EqTo is returned for convenience.
// 自行运动导致的赤道坐标变化的精确计算(不在当成常量乘以时间间隔)
func ProperMotion3D(eqFrom, eqTo *coord.Equatorial, epochFrom, epochTo, r, mr float64, mα unit.HourAngle, mδ unit.Angle) *coord.Equatorial {
	sα, cα := eqFrom.RA.Sincos()
	sδ, cδ := eqFrom.Dec.Sincos()
	x := r * cδ * cα
	y := r * cδ * sα
	z := r * sδ
	mrr := mr / r
	zmδ := z * mδ.Rad()
	mx := x*mrr - zmδ*cα - y*mα.Rad()
	my := y*mrr - zmδ*sα + x*mα.Rad()
	mz := z*mrr + r*mδ.Rad()*cδ
	t := epochTo - epochFrom
	xp := x + t*mx
	yp := y + t*my
	zp := z + t*mz
	eqTo.RA = unit.RAFromRad(math.Atan2(yp, xp))
	eqTo.Dec = unit.Angle(math.Atan2(zp, math.Hypot(xp, yp)))
	return eqTo
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>天文算法18</title>
      <link>https://mooncaker816.github.io/2018/05/23/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9518/</link>
      <pubDate>Wed, 23 May 2018 09:01:52 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/05/23/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9518/</guid>
      <description>&lt;h1 id=&#34;第二十章-smallest-circle-containing-three-celestial-bodies&#34;&gt;第二十章 Smallest Circle containing three Celestial Bodies&lt;/h1&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-问题&#34;&gt;1. 问题&lt;/h2&gt;

&lt;p&gt;设三点为A,B,C,对应三边为a,b,c,其中a为最长边，&lt;br /&gt;
当$a&amp;gt;\sqrt {b^2+c^2}$,则包含这三点的最小圆直径为a，&lt;br /&gt;
当$a&amp;lt;\sqrt {b^2+c^2}$,则包含这三点的最小圆直径为$$\frac {2abc}{\sqrt {(a+b+c)(a+b-c)(b+c-a)(a+c-b)}}$$&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://baike.baidu.com/item/外接圆半径公式/14818938?fr=aladdin&#34; target=&#34;_blank&#34;&gt;证明&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;给定三个天体的坐标，求最小圆直径。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Smallest finds the smallest circle containing three points.
//
// Arguments should represent coordinates in right ascension and declination
// or longitude and latitude.  Result Δ is the diameter of the circle, typeI
// is true if solution is of type I.
//
//	type I   Two points on circle, one interior.
//	type II  All three points on circle.
// 根据三点坐标，求最小圆直径
func Smallest(r1, d1, r2, d2, r3, d3 unit.Angle) (Δ unit.Angle, typeI bool) {
	// Using haversine formula, but reimplementing SepHav here to reuse
	// the computed cosines.
	cd1 := d1.Cos()
	cd2 := d2.Cos()
	cd3 := d3.Cos()
	a := 2 * math.Asin(math.Sqrt(base.Hav(d2-d1)+cd1*cd2*base.Hav(r2-r1)))
	b := 2 * math.Asin(math.Sqrt(base.Hav(d3-d2)+cd2*cd3*base.Hav(r3-r2)))
	c := 2 * math.Asin(math.Sqrt(base.Hav(d1-d3)+cd3*cd1*base.Hav(r1-r3)))
	if b &amp;gt; a {
		a, b = b, a
	}
	if c &amp;gt; a {
		a, c = c, a
	}
	if a*a &amp;gt;= b*b+c*c {
		return unit.Angle(a), true
	}
	// (20.1) p. 128
	return unit.Angle(2 * a * b * c /
		math.Sqrt((a+b+c)*(a+b-c)*(b+c-a)*(a+c-b))), false
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>天文算法17</title>
      <link>https://mooncaker816.github.io/2018/05/22/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9517/</link>
      <pubDate>Tue, 22 May 2018 10:15:11 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/05/22/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9517/</guid>
      <description>&lt;h1 id=&#34;第十九章-bodies-in-straight-line&#34;&gt;第十九章 Bodies in Straight Line&lt;/h1&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-定义&#34;&gt;1. 定义&lt;/h2&gt;

&lt;p&gt;　　当天体位于同一个天球大圆时，我们称之为天体处在同一&amp;rdquo;直线&amp;rdquo;上。&lt;br /&gt;
　　假设有三个天体,赤道系坐标分别为$(α_1,δ_1),(α_2,δ_2),(α_3,δ_3)$，当它们&amp;rdquo;共线&amp;rdquo;时，有：$$\tan δ_1\sin (α_2-α_3)+\tan δ_2\sin (α_3-α_1)+\tan δ_3\sin (α_1-α_2)=0$$
　　上述公式对黄道坐标系同样适用。&lt;/p&gt;

&lt;p&gt;　　利用该公式，我们就可以插值求得共线的时间点&lt;/p&gt;

&lt;h2 id=&#34;2-计算行星与两个恒星共线的时间点&#34;&gt;2. 计算行星与两个恒星共线的时间点&lt;/h2&gt;

&lt;p&gt;　　对于恒星，我们可以认为在一定观测时间范围内是静止的。所以在进行插值计算时，应该当做常数。如$(α_1,δ_1),(α_2,δ_2)$为恒星坐标，则插值时保持不变。&lt;br /&gt;
　　对于运动的行星，考虑一段时间范围内的坐标，进行插值并求零点。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Time computes the time at which a moving body is on a straight line (great
// circle) between two fixed points, such as stars.
//
// Coordinates may be right ascensions and declinations or longitudes and
// latitudes.  Fixed points are r1, d1, r2, d2.  Moving body is an ephemeris
// of 5 rows, r3, d3, starting at time t1 and ending at time t5.  Time scale
// is arbitrary.
//
// Result is time of alignment.
// 计算一个运动的天体和另外两个在观测时间内默认为不动的天体在一条直线上的时间点
func Time(r1, d1, r2, d2 unit.Angle, r3, d3 []unit.Angle, t1, t5 float64) (float64, error) {
	if len(r3) != 5 || len(d3) != 5 {
		return 0, errors.New(&amp;quot;r3, d3 must be length 5&amp;quot;)
	}
	gc := make([]float64, 5)
	for i, r3i := range r3 {
		// (19.1) p. 121
		gc[i] = d1.Tan()*(r2-r3i).Sin() +
			d2.Tan()*(r3i-r1).Sin() +
			d3[i].Tan()*(r1-r2).Sin()
	}
	l5, err := interp.NewLen5(t1, t5, gc)
	if err != nil {
		return 0, err
	}
	return l5.Zero(false)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;3-计算3点-近似共线-时的球面角和离共线大圆的角距离&#34;&gt;3. 计算3点&amp;rdquo;近似共线&amp;rdquo;时的球面角和离共线大圆的角距离&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://mooncaker816.github.io/img/line.png&#34; alt=&#34;&#34; /&gt;
　　如上图，$S_1,S_2,S_3$为三个天体，此时它们几乎&amp;rdquo;共线&amp;rdquo;,$C_1$为球面角$\angle PS_2S_1$，$C_2$为球面角$\angle PS_2S_3$，我们所求的就是球面角$\angle S_1S_2S_3$以及$S_2$与经过$S_1,S_3$的大圆之间的角距离（可以看作离共线还差多少度）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Meeus 计算三天体球面角$\angle S_1S_2S_3$&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;\begin{cases}
\tan C_1 &amp;amp;= \frac {\sin (α_2-α_1)}{\cos δ_2\tan δ_1-\sin δ_2\cos (α_2-α_1)}\\[2ex]
\tan C_2 &amp;amp;= \frac {\sin (α_3-α_2)}{\cos δ_2\tan δ_3-\sin δ_2\cos (α_3-α_2)}
\end{cases}
　　$C_1 + C_2$即为所求&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Angle returns the angle between great circles defined by three points.
//
// Coordinates may be right ascensions and declinations or longitudes and
// latitudes.  If r1, d1, r2, d2 defines one line and r2, d2, r3, d3 defines
// another, the result is the angle between the two lines.
//
// Algorithm by Meeus.
// 计算第一点第二点经过的大圆和第二点第三点经过的大圆之间的角度
func Angle(r1, d1, r2, d2, r3, d3 unit.Angle) unit.Angle {
	sd2, cd2 := d2.Sincos()
	sr21, cr21 := (r2 - r1).Sincos()
	sr32, cr32 := (r3 - r2).Sincos()
	C1 := math.Atan2(sr21, cd2*d1.Tan()-sd2*cr21)
	C2 := math.Atan2(sr32, cd2*d3.Tan()-sd2*cr32)
	return unit.Angle(C1 + C2)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Meeus 计算$S_2$与经过$S_1,S_3$的大圆之间的角距离&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　先计算：
\begin{cases}
X_1 &amp;amp;= \cos δ_1\cos α_1\\[2ex]
Y_1 &amp;amp;= \cos δ_1\sin α_1\\[2ex]
Z_1 &amp;amp;= \sin δ_1
\end{cases}
\begin{cases}
X_2 &amp;amp;= \cos δ_2\cos α_2\\[2ex]
Y_2 &amp;amp;= \cos δ_2\sin α_2\\[2ex]
Z_2 &amp;amp;= \sin δ_2
\end{cases}
\begin{cases}
A &amp;amp;= Y_1Z_2-Z_1Y_2\\[2ex]
B &amp;amp;= Z_1X_2-X_1Z_2\\[2ex]
C &amp;amp;= X_1Y_2-Y_1X_2
\end{cases}
$$m = \tan α_0, n = \frac {\tan δ_0}{\cos α_0}$$
　　则，$$\sin ω = \frac {A+Bm+Cn}{\sqrt {A^2+B^2+C^2}\sqrt{1+m^2+n^2}}$$
　　ω即为所求&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Error returns an error angle of three nearly co-linear points.
//
// For the line defined by r1, d1, r2, d2, the result is the anglular distance
// between that line and r0, d0.
//
// Algorithm by Meeus.
// 计算一点到由另外两点组成的大圆之间的角距离
func Error(r1, d1, r2, d2, r0, d0 unit.Angle) unit.Angle {
	sr1, cr1 := r1.Sincos()
	sd1, cd1 := d1.Sincos()
	sr2, cr2 := r2.Sincos()
	sd2, cd2 := d2.Sincos()
	X1 := cd1 * cr1
	X2 := cd2 * cr2
	Y1 := cd1 * sr1
	Y2 := cd2 * sr2
	Z1 := sd1
	Z2 := sd2
	A := Y1*Z2 - Z1*Y2
	B := Z1*X2 - X1*Z2
	C := X1*Y2 - Y1*X2
	m := r0.Tan()
	n := d0.Tan() / r0.Cos()
	return unit.Angle(math.Asin((A + B*m + C*n) /
		(math.Sqrt(A*A+B*B+C*C) * math.Sqrt(1+m*m+n*n))))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Pessens 同时计算上述两个量&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;\begin{cases}
a_1 &amp;amp;= \cos δ_1\cos α_1\\[2ex]
a_2 &amp;amp;= \cos δ_2\cos α_2\\[2ex]
a_3 &amp;amp;= \cos δ_3\cos α_3\\[2ex]
\end{cases}
\begin{cases}
b_1 &amp;amp;= \cos δ_1\sin α_1\\[2ex]
b_2 &amp;amp;= \cos δ_2\sin α_2\\[2ex]
b_3 &amp;amp;= \cos δ_3\sin α_3\\[2ex]
\end{cases}
\begin{cases}
c_1 &amp;amp;= \sin δ_1\\[2ex]
c_2 &amp;amp;= \sin δ_2\\[2ex]
c_3 &amp;amp;= \sin δ_3\\[2ex]
\end{cases}
\begin{cases}
l_1 &amp;amp;= b_1c_2-b_2c_1\\[2ex]
l_2 &amp;amp;= b_2c_3-b_3c_2\\[2ex]
l_3 &amp;amp;= b_1c_3-b_3c_1\\[2ex]
\end{cases}
\begin{cases}
m_1 &amp;amp;= c_1a_2-c_2a_1\\[2ex]
m_2 &amp;amp;= c_2a_3-c_3a_2\\[2ex]
m_3 &amp;amp;= c_1a_3-c_3a_1\\[2ex]
\end{cases}
\begin{cases}
n_1 &amp;amp;= a_1b_2-a_2b_1\\[2ex]
n_2 &amp;amp;= a_2b_3-a_3b_2\\[2ex]
n_3 &amp;amp;= a_1b_3-a_3b_1\\[2ex]
\end{cases}
　　则有：
\begin{cases}
\cos ψ &amp;amp;= \frac {l_1l_2+m_1m_2+n_1n_2}{\sqrt {l_1^2+m_1^2+n_1^2}\sqrt{l_2^2+m_2^2+n_2^2}}\\[2ex]
\sin ω &amp;amp;= \frac {a_2l_3+b_2m_3+c_2n_3}{\sqrt {a_2^2+b_2^2+c_2^2}\sqrt {l_3^2+m_3^2+n_3^2}}
\end{cases}
　　ψ，ω即为所求。ψ可能与 Meeus 方法求解的值互余180°。（平面的夹角有两个，互余180°）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// AngleError returns both an angle as in the function Angle, and an error
// as in the function Error.
//
// The algorithm is by B. Pessens.
// Angle和 Error 的合体版
// Angle 的值可能和之前 Angle 中计算的值互余180°（想象一下两个面的夹角）
func AngleError(r1, d1, r2, d2, r3, d3 unit.Angle) (ψ, ω unit.Angle) {
	sr1, cr1 := r1.Sincos()
	sd1, cd1 := d1.Sincos()
	sr2, cr2 := r2.Sincos()
	sd2, cd2 := d2.Sincos()
	sr3, cr3 := r3.Sincos()
	sd3, cd3 := d3.Sincos()
	a1 := cd1 * cr1
	a2 := cd2 * cr2
	a3 := cd3 * cr3
	b1 := cd1 * sr1
	b2 := cd2 * sr2
	b3 := cd3 * sr3
	c1 := sd1
	c2 := sd2
	c3 := sd3
	l1 := b1*c2 - b2*c1
	l2 := b2*c3 - b3*c2
	l3 := b1*c3 - b3*c1
	m1 := c1*a2 - c2*a1
	m2 := c2*a3 - c3*a2
	m3 := c1*a3 - c3*a1
	n1 := a1*b2 - a2*b1
	n2 := a2*b3 - a3*b2
	n3 := a1*b3 - a3*b1
	ψ = unit.Angle(math.Acos((l1*l2 + m1*m2 + n1*n2) /
		(math.Sqrt(l1*l1+m1*m1+n1*n1) * math.Sqrt(l2*l2+m2*m2+n2*n2))))
	ω = unit.Angle(math.Asin((a2*l3 + b2*m3 + c2*n3) /
		(math.Sqrt(a2*a2+b2*b2+c2*c2) * math.Sqrt(l3*l3+m3*m3+n3*n3))))
	return
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>天文算法16</title>
      <link>https://mooncaker816.github.io/2018/05/22/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9516/</link>
      <pubDate>Tue, 22 May 2018 09:37:47 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/05/22/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9516/</guid>
      <description>&lt;h1 id=&#34;第十八章-行星会合-planetary-conjunctions&#34;&gt;第十八章 行星会合 Planetary Conjunctions&lt;/h1&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-定义&#34;&gt;1. 定义&lt;/h2&gt;

&lt;p&gt;In astronomy, a conjunction occurs when two astronomical objects or spacecraft have either the same right ascension or the same ecliptic longitude, usually as observed from Earth.&lt;br /&gt;
当两个天体位于同一赤经（黄经）时，我们称之为会合。会合并不意味着最小角距离。&lt;/p&gt;

&lt;h2 id=&#34;2-计算会合的时间点以及纬度差&#34;&gt;2. 计算会合的时间点以及纬度差&lt;/h2&gt;

&lt;p&gt;由定义可知，当两天体的经度差为0时，我们称之为会合。&lt;br /&gt;
所以只要根据观测数据对经度差进行插值，再求零值对应的时间点即为会合时间。再根据这个时间点插值计算纬度差即可。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;两个都为移动的天体（行星）&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Planetary computes a conjunction between two moving objects, such as planets.
//
// Conjunction is found with interpolation against length 5 ephemerides.
//
// T1, t5 are times of first and last rows of ephemerides.  The scale is
// arbitrary.
//
// R1, d1 is the ephemeris of the first object.  The columns may be celestial
// coordinates in right ascension and declination or ecliptic coordinates in
// longitude and latitude.
//
// R2, d2 is the ephemeris of the second object, in the same frame as the first.
//
// Return value t is time of conjunction in the scale of t1, t5.
// Δd is the amount that object 2 was &amp;quot;above&amp;quot; object 1 at the time of
// conjunction.
// 计算两个移动的天体赤经（黄经）相同的时间点 t 和该时刻的赤纬（黄纬）差
func Planetary(t1, t5 float64, r1, d1, r2, d2 []unit.Angle) (t float64, Δd unit.Angle, err error) {
	if len(r1) != 5 || len(d1) != 5 || len(r2) != 5 || len(d2) != 5 {
		err = errors.New(&amp;quot;Five rows required in ephemerides&amp;quot;)
		return
	}
	dr := make([]float64, 5, 10)
	dd := dr[5:10]
	for i, r := range r1 {
		dr[i] = (r2[i] - r).Rad()
		dd[i] = (d2[i] - d1[i]).Rad()
	}
	return conj(t1, t5, dr, dd)
}

func conj(t1, t5 float64, dr, dd []float64) (t float64, Δd unit.Angle, err error) {
	var l5 *interp.Len5
	if l5, err = interp.NewLen5(t1, t5, dr); err != nil {
		return
	}
	if t, err = l5.Zero(true); err != nil { // 计算经度重合时的时间点 t
		return
	}
	if l5, err = interp.NewLen5(t1, t5, dd); err != nil {
		return
	}
	ΔdRad, err := l5.InterpolateXStrict(t) // 插值计算经度重合时的纬度差
	return t, unit.Angle(ΔdRad), err
}

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;一个为观测时间范围内默认不动的天体（恒星）&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Stellar computes a conjunction between a moving and non-moving object.
//
// Arguments and return values same as with Planetary, except the non-moving
// object is r1, d1.  The ephemeris of the moving object is r2, d2.
// 计算一个移动的天体和一个在观测时间范围内默认为不动的天体（如恒星）赤经（黄经）相同的时间点 t 和该时刻的赤纬（黄纬）差
func Stellar(t1, t5 float64, r1, d1 unit.Angle, r2, d2 []unit.Angle) (t float64, Δd unit.Angle, err error) {
	if len(r2) != 5 || len(d2) != 5 {
		err = errors.New(&amp;quot;Five rows required in ephemeris&amp;quot;)
		return
	}
	dr := make([]float64, 5, 10)
	dd := dr[5:10]
	for i, r := range r2 {
		dr[i] = (r - r1).Rad()
		dd[i] = (d2[i] - d1).Rad()
	}
	return conj(t1, t5, dr, dd)
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>天文算法15</title>
      <link>https://mooncaker816.github.io/2018/05/21/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9515/</link>
      <pubDate>Mon, 21 May 2018 18:46:37 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/05/21/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9515/</guid>
      <description>&lt;h1 id=&#34;第十七章-角距离-angular-separation&#34;&gt;第十七章 角距离 Angular Separation&lt;/h1&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-定义&#34;&gt;1. 定义&lt;/h2&gt;

&lt;p&gt;　　角距离，也称为角分离、视距离、或视分离，在数学(特别是几何学和三角学)和自然科学(包括天文学、地质学等等)，从不同于两个点物体的位置（即第三点）观察这两个物体，由观测者指向这两个物体的直线之间所夹角度的大小。角距离(或分离)与角度本身是同义的，但意义却是对两个天体(对恒星，是当从地球观测)之间线距离的建议(通常是很大或未知的)。&lt;/p&gt;

&lt;h2 id=&#34;2-计算&#34;&gt;2. 计算&lt;/h2&gt;

&lt;h3 id=&#34;2-1-余弦公式直接计算&#34;&gt;2.1 余弦公式直接计算&lt;/h3&gt;

&lt;p&gt;$$\cos d=\sin δ_1 \sin δ_2 + \cos δ_1 \cos δ_2 \cos (α_1 -α_2)$$
式中$α_1,δ_1,α_2,δ_2$分别对应两个天体的赤经和赤纬。&lt;br /&gt;
当$d$接近于0或180度时，$\left|\cos d\right|$接近于1，并且其值随$d$变化很小，所以得到的$d$不精确。此时需用以下公式计算：$$d = \sqrt {(Δα\cos δ)^2+(Δδ)^2}$$
式中$Δα$是两个赤经的差，$Δδ$是两个赤纬的差，$δ$是两个赤纬的平均值。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Sep returns the angular separation between two celestial bodies.
//
// The algorithm is numerically naïve, and while patched up a bit for
// small separations, remains unstable for separations near π.
// 计算两天体之间的角距，r为赤经，d为赤纬
func Sep(r1, d1, r2, d2 unit.Angle) unit.Angle {
	sd1, cd1 := d1.Sincos()
	sd2, cd2 := d2.Sincos()
	cd := sd1*sd2 + cd1*cd2*(r1-r2).Cos() // (17.1) p. 109
	if cd &amp;lt; base.CosSmallAngle {
		return unit.Angle(math.Acos(cd))
	}
	// (17.2) p. 109
	dm := (d1 + d2) / 2
	return unit.Angle(math.Hypot((r2-r1).Rad()*dm.Cos(), (d2 - d1).Rad()))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-2-根据观测数据插值计算最小角距离&#34;&gt;2.2 根据观测数据插值计算最小角距离&lt;/h3&gt;

&lt;p&gt;注意，不能先计算出各组数据点的角距离，再对角距离插值计算。因为当两个天体很近时，两天体间是线性的靠近再线性的离开。此时需要先对数据点插值，再把得出的数据套用2.1的方法进行计算。或者引入 u,v 坐标，先将原始数据转为 u,v 坐标，然后对 u,v 坐标点进行插值计算，得出最小值&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// MinSep returns the minimum separation between two moving objects.
//
// The motion is represented as an ephemeris of three rows, equally spaced
// in time.  Jd1, jd3 are julian day times of the first and last rows.
// R1, d1, r2, d2 are coordinates at the three times.  They must each be
// slices of length 3.
//
// Result is obtained by computing separation at each of the three times
// and interpolating a minimum.  This may be invalid for sufficiently close
// approaches.
//
// 计算两个天体之间的最小角距
// 此方法是将数据点计算成角距，然后直接对角距3点插值，求取最小值，
// 当两个天体十分接近时，这个结果是不准确的，要使用方法MinSepRect
func MinSep(jd1, jd3 float64, r1, d1, r2, d2 []unit.Angle) (unit.Angle, error) {
	if len(r1) != 3 || len(d1) != 3 || len(r2) != 3 || len(d2) != 3 {
		return 0, interp.ErrorNot3
	}
	y := make([]float64, 3)
	for x, r := range r1 {
		y[x] = Sep(r, d1[x], r2[x], d2[x]).Rad()
	}
	d3, err := interp.NewLen3(jd1, jd3, y)
	if err != nil {
		return 0, err
	}
	_, dMin, err := d3.Extremum()
	return unit.Angle(dMin), err
}

// MinSepRect returns the minimum separation between two moving objects.
//
// Like MinSep, but using a method of rectangular coordinates that gives
// accurate results even for close approaches.
// 计算两个天体之间的最小角距
// 此方法是引入直角坐标 u,v,先将数据点转换成u,v 表达，然后对u,v插值，求取最小值，
func MinSepRect(jd1, jd3 float64, r1, d1, r2, d2 []unit.Angle) (unit.Angle, error) {
	if len(r1) != 3 || len(d1) != 3 || len(r2) != 3 || len(d2) != 3 {
		return 0, interp.ErrorNot3
	}
	uv := func(r1, d1, r2, d2 unit.Angle) (u, v float64) {
		sd1, cd1 := d1.Sincos()
		Δr := r2 - r1
		tΔr := Δr.Tan()
		thΔr := (Δr / 2).Tan()
		K := 1 / (1 + sd1*sd1*tΔr*thΔr)
		sΔd := (d2 - d1).Sin()
		u = -K * (1 - (sd1/cd1)*sΔd) * cd1 * tΔr
		v = K * (sΔd + sd1*cd1*tΔr*thΔr)
		return
	}
	us := make([]float64, 3, 6)
	vs := us[3:6]
	for x, r := range r1 {
		us[x], vs[x] = uv(r, d1[x], r2[x], d2[x])
	}
	u3, err := interp.NewLen3(-1, 1, us)
	if err != nil {
		panic(err) // bug not caller&#39;s fault.
	}
	v3, err := interp.NewLen3(-1, 1, vs)
	if err != nil {
		panic(err) // bug not caller&#39;s fault.
	}
	up0 := (us[2] - us[0]) / 2
	vp0 := (vs[2] - vs[0]) / 2
	up1 := us[0] + us[2] - 2*us[1]
	vp1 := vs[0] + vs[2] - 2*vs[1]
	up := up0
	vp := vp0
	dn := -(us[1]*up + vs[1]*vp) / (up*up + vp*vp)
	n := dn
	var u, v float64
	for limit := 0; limit &amp;lt; 10; limit++ {
		u = u3.InterpolateN(n)
		v = v3.InterpolateN(n)
		if math.Abs(dn) &amp;lt; 1e-5 {
			return unit.Angle(math.Hypot(u, v)), nil // success
		}
		up := up0 + n*up1
		vp := vp0 + n*vp1
		dn = -(u*up + v*vp) / (up*up + vp*vp)
		n += dn
	}
	return 0, errors.New(&amp;quot;MinSepRect: failure to converge&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-3-利用半正矢的特点提高当角距很小时的精确程度&#34;&gt;2.3 利用半正矢的特点提高当角距很小时的精确程度&lt;/h3&gt;

&lt;p&gt;根据半正矢公式$hav(d) = hav(Δδ) + \cos δ_1 \cos δ_2 hav(Δα)$,式中 $Δα = α_1 - α_2，Δδ = δ_1 - δ_2$，
又由$hav(d)=\frac {1-\cos d}{2}=\sin^2(\frac d2)$,可以有效的在0，180°附近提高计算机的精度。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// SepHav returns the angular separation between two celestial bodies.
//
// The algorithm uses the haversine function and is superior to the naïve
// algorithm of the Sep function.
// 利用半正矢的特点提高当角距很小时的精确程度
func SepHav(r1, d1, r2, d2 unit.Angle) unit.Angle {
	// using (17.5) p. 115
	return unit.Angle(2 * math.Asin(math.Sqrt(base.Hav(d2-d1)+
		d1.Cos()*d2.Cos()*base.Hav(r2-r1))))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-4-pauwels公式&#34;&gt;2.4 Pauwels公式&lt;/h3&gt;

&lt;p&gt;令
\begin{cases}
x &amp;amp;= \cos δ_1\sin δ_2 - \sin δ_1\cos δ_2\cos (α_2-α_1)\\[2ex]
x &amp;amp;= \cos δ_2\sin (α_2-α_1)\\[2ex]
z &amp;amp;= \sin δ_1\sin δ_2 + \cos δ_1\cos δ_2\cos (α_2-α_1)\\[2ex]
\end{cases}
则有：$$d=\arctan (\frac {\sqrt {x^2+y^2}}{z})$$&lt;/p&gt;

&lt;p&gt;数学上来说，这与余弦定理完全等价，只不过是巧妙的将余弦转化为正切，而对于计算机来说，
反正切比反正弦能获得更高的精确度&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// SepPauwels returns the angular separation between two celestial bodies.
//
// The algorithm is a numerically stable form of that used in Sep.
// 当z小于0时，返回值应该在90-180度之间
// 该方法与直接余弦定理求角距在数学上是等价的，
// 但是对于计算机来说，arctan 比 arcsin能获得更高的精度
func SepPauwels(r1, d1, r2, d2 unit.Angle) unit.Angle {
	sd1, cd1 := d1.Sincos()
	sd2, cd2 := d2.Sincos()
	cdr := (r2 - r1).Cos()
	x := cd1*sd2 - sd1*cd2*cdr
	y := cd2 * (r2 - r1).Sin()
	z := sd1*sd2 + cd1*cd2*cdr
	return unit.Angle(math.Atan2(math.Hypot(x, y), z))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-5-relative-position-angle&#34;&gt;2.5 Relative Position Angle&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Position_angle&#34; target=&#34;_blank&#34;&gt;定义即相关信息&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// RelativePosition returns the position angle of one body with respect to
// another.
//
// The position angle result is measured counter-clockwise from North.
// 1相对2的角距，从2的正北到1的角度
// https://en.wikipedia.org/wiki/Position_angle
func RelativePosition(r1, d1, r2, d2 unit.Angle) unit.Angle {
	sΔr, cΔr := (r1 - r2).Sincos()
	sd2, cd2 := d2.Sincos()
	return unit.Angle(math.Atan2(sΔr, cd2*d1.Tan()-sd2*cΔr))
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>天文算法14</title>
      <link>https://mooncaker816.github.io/2018/05/21/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9514/</link>
      <pubDate>Mon, 21 May 2018 12:29:48 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/05/21/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9514/</guid>
      <description>&lt;h1 id=&#34;第十六章-大气折射-atmospheric-refraction&#34;&gt;第十六章 大气折射 Atmospheric Refraction&lt;/h1&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-大气折射&#34;&gt;1. 大气折射&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;大气折射（又称：蒙气差（蒙气即行星的大气）、折光差）即原本直线前进的光或其它电磁波在穿越大气层时，因为空气密度随着高度变化所产生的偏折。这种折射是光通过空气时因为密度的增加使速度降低（折射率增加）。大气折射在近地面时会产生海市蜃楼，让远方的物体出现或荡漾，和非幻觉的升高或降低，伸长或缩短。这个词也适用于声音的折射。无论是天体或地面上物体位置的测量都需要考虑大气折射。&lt;/p&gt;

&lt;p&gt;对天文或天体的折射，导致天体在天空中的位置看起来比实际为高。大地折射通常导致物体出现在比实际高的位置上，然而在靠近地面的空气被加热的下午，光线的曲折向上会使物体看似出现在比实际位置低的地方。&lt;/p&gt;

&lt;p&gt;折射不仅影响可见光，还包括所有的电磁波，然而在程度上不尽相同（见光的色散）。例如在可见光，蓝色受到的影响大于红色。这会对天体光谱在展开时的高解析图像造成影响。&lt;/p&gt;

&lt;p&gt;只要有可能，天文学家会安排在天体在天空中接近高度最高的顶点时才要观测。同样的，水手也不会观测一颗高度低于20°或更低恒星的位置。如果不能避免靠近地平线的观测，有可能使用具有修正系统，以弥补这种折射造成的影响。如果色散也是一个问题（如果是宽频的高解析观测），大气折射可以使用成对的旋转玻璃棱镜处理掉。但是当大气折射的总量是温度梯度、温度、压力和湿度（特别是在中红外波长时的水蒸气总量）的函数时，成功补偿这些修正量的工作可以让人为之望而却步。另一方面，测量师经常都会将他们的工作安排在下午折射程度最低的时候。&lt;/p&gt;

&lt;p&gt;在有很强的温度梯度、大气不均匀和空气动荡的时候，大气折射会变得很严重。这是造成恒星闪烁和日出与日落时太阳各种不同变形的原因。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/5/5d/Refracci%C3%B3n.png&#34; alt=&#34;太阳在日出和日落时位移的图&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;2-真纬度-视纬度&#34;&gt;2. 真纬度，视纬度&lt;/h2&gt;

&lt;p&gt;　　真纬度即为天体的真实地平纬度(仰角)$h$，视纬度即为经过大气折射后观测到的纬度$h_0$。&lt;br /&gt;
　　当已知真纬度$h$，&lt;strong&gt;可以由该$h$推算出一个矫正量R&lt;/strong&gt;，视纬度$h_0 = h + R$&lt;br /&gt;
　　当已知视纬度$h_0$，&lt;strong&gt;可以由该$h_0$推算出一个矫正量R&lt;/strong&gt;，真纬度$h = h_0 - R$&lt;/p&gt;

&lt;h2 id=&#34;3-矫正量r-单位角分&#34;&gt;3. 矫正量R&amp;ndash;单位角分&lt;/h2&gt;

&lt;h3 id=&#34;3-1-h-0-rightarrow-r-h&#34;&gt;3.1 $h_0 \Rightarrow R,h$&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;$h_0&amp;gt;15°$时：
$$R=58&amp;rdquo;.294\tan(90-h_0)-0&amp;rdquo;.0668\tan^3(90°-h_0)$$
$$h = h_0 - R$$&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Gt15True returns refraction for obtaining true altitude when altitude
// is greater than 15 degrees (about .26 radians.)
//
// h0 must be a measured apparent altitude of a celestial body.
//
// Result is refraction to be subtracted from h0 to obtain the true altitude
// of the body.
// 纬度大于15度时，由视纬度求真纬度的矫正量R
func Gt15True(h0 unit.Angle) unit.Angle {
    // (16.1) p. 105
    t := (math.Pi/2 - h0).Tan()
    return gt15true1.Mul(t) - gt15true2.Mul(t*t*t)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Bennett公式，当$h\in [0,90°]$时：
$$R = \frac {1}{\tan(h_0 +\frac {7.31}{h_0 +4.4})}$$
$$ΔR = -0.06sin(14.7R+13)$$
对于任意$h_0$，这个公式的精度是$0.07′=4.2&amp;rdquo;$，最大误差发生在$h_0 =12°$。&lt;br /&gt;
应当注意的是：当$h_0 =90°$时，$R=-0&amp;rdquo;.08$，理论上天顶应该不受折射影响，可以加上0.0013515′，从而为0。&lt;br /&gt;
若考虑修正量，即$R=R+ΔR$，最大误差为$0.015′=0.9&amp;rdquo;$。&lt;br /&gt;
当$h_0 =90°$时，计算的结果是$R=-0.89&amp;rdquo;$，不作第二项修正反而更好。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Bennett returns refraction for obtaining true altitude.
//
// h0 must be a measured apparent altitude of a celestial body in radians.
//
// Results are accurate to .07 arc min from horizon to zenith.
//
// Result is refraction to be subtracted from h0 to obtain the true altitude
// of the body.
// Bennett 公式，由视纬度求真纬度矫正量 R
func Bennett(h0 unit.Angle) unit.Angle {
    // (16.3) p. 106
    hd := h0.Deg()
    return unit.AngleFromMin(1 / math.Tan((hd+7.31/(hd+4.4))*math.Pi/180))
}

// Bennett2 returns refraction for obtaining true altitude.
//
// Similar to Bennett, but a correction is applied to give a more accurate
// result.
//
// Results are accurate to .015 arc min.  Result unit is radians.
// 带矫正量的Bennett公式
func Bennett2(h0 unit.Angle) unit.Angle {
    R := Bennett(h0).Min()
    return unit.AngleFromMin(R - .06*math.Sin((14.7*R+13)*math.Pi/180))
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;3-2-h-rightarrow-r-h-0&#34;&gt;3.2 $h \Rightarrow R,h_0$&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;$h&amp;gt;15°$时：
$$R=58&amp;rdquo;.276\tan(90°-h) -0&amp;rdquo;.0824\tan^3(90°-h)$$
$$h_0 = h + R$$&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Gt15Apparent returns refraction for obtaining apparent altitude when
// altitude is greater than 15 degrees (about .26 radians.)
//
// h must be a computed true &amp;quot;airless&amp;quot; altitude of a celestial body.
//
// Result is refraction to be added to h to obtain the apparent altitude
// of the body.
// 纬度大于15度时，由真纬度求视纬度的矫正量R
func Gt15Apparent(h unit.Angle) unit.Angle {
    // (16.2) p. 105
    t := (math.Pi/2 - h).Tan()
    return gt15app1.Mul(t) - gt15app2.Mul(t*t*t)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;类Bennett公式
$$R = \frac {1.02}{\tan(h+\frac{10.3}{h+5.11})}$$
同样，$h=90°$时，该式算得$R$不等于零,差值是 0.0019279。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Saemundsson returns refraction for obtaining apparent altitude.
//
// h must be a computed true &amp;quot;airless&amp;quot; altitude of a celestial body in radians.
//
// Result is refraction to be added to h to obtain the apparent altitude
// of the body.
//
// Results are consistent with Bennett to within 4 arc sec.
// 由真纬度求视纬度矫正量，与Bennett公式对应
func Saemundsson(h unit.Angle) unit.Angle {
    // (16.4) p. 106
    hd := h.Deg()
    return unit.AngleFromMin(1.02 / math.Tan((hd+10.3/(hd+5.11))*math.Pi/180))
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>天文算法13</title>
      <link>https://mooncaker816.github.io/2018/05/20/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9513/</link>
      <pubDate>Sun, 20 May 2018 20:50:07 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/05/20/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9513/</guid>
      <description>&lt;h1 id=&#34;第十五章-升-中天-降-rising-transit-setting&#34;&gt;第十五章 升，中天，降 Rising,Transit,Setting&lt;/h1&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-升-中天-降的概念&#34;&gt;1. 升，中天，降的概念&lt;/h2&gt;

&lt;p&gt;　　升就是天体位于观测点地平线上即将升起的位置，由于大气的折射，当我们看到天体位于地平线上时，天体的真实位置在地平线之下 0°34′。而对于太阳，视升降一般指太阳圆盘上边缘的升与降，因此需加上16′的太阳半径进行计算。&lt;br /&gt;
　　降与升类似，只是运动方向相反。&lt;br /&gt;
　　中天是指天体位于本地子午圈上时的位置，即离天顶最近的位置。&lt;/p&gt;

&lt;h2 id=&#34;2-计算升-中天-降的时刻&#34;&gt;2. 计算升，中天，降的时刻&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;根据第十三章中计算本地仰角的公式计算时角H$$\sin h = \sin φ\sin δ+\cos φ\cos δ\cos H$$
令$h_0=0$，则$$\cos H_0=-\tan φ\tan δ$$
但这只是理想状态，由于大气折射，我们要令$h_0=-0°34′$，对于太阳，令$h_0=-0°50′$，对于月亮，这个问题更复杂，因为$h_0$不是常数。考虑半径变化及地平视差，我们得到月亮的：$h_0 = 0.7275π - 0°34′$ 式中 $π$是月亮的地平视差（不是上章所说的视差角）。如果精度要球不高，$h_0$可以取均值$h_0 = 0°.125$，则$$\cos H_0 = \frac {\sin h_0 - \sin φ\sin δ}{\cos φ\cos δ}$$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;计算格林尼治D日0h（UT时）的视恒星时$θ_0$，并转为度单位,本地恒星时$θ=θ_0-L$,$L$为观测点经度，从格林尼治测量，向西为正，向东为负&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;天体的视赤经及视赤纬（单位是度）：
\begin{cases}
α_1 和 δ_1， 在力学时 D-1 日 0h\\[2ex]
α_2 和 δ_2， 在力学时 D 日 0h\\[2ex]
α_3 和 δ_3， 在力学时 D+1 日 0h\\[2ex]
\end{cases}
我们先使用下式估算时间： $$\cos H_0 = \frac {\sin h_0 - \sin φ\sin δ_2}{\cos φ\cos δ_2}$$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;估算中天，升起，降落时间点，单位为日（带小数）&lt;/p&gt;

&lt;p&gt;$H_0$单位是度，$H_0$应转换到 0 度到 180 度。那么我们有：
\begin{cases}
中天：m_0 = (α_2 + L - θ_0)/360 \\[2ex]
升起：m_1 = m_0 - H_0 /360 \\[2ex]
降落：m_2 = m_0 + H_0 /360\\[2ex]
\end{cases}
式中$m$是$D$日的时间（即$D$日$m$时），单位是日。因此 $m$ 的值在 0 到 1，如果$m$的值超过这个范围，那么应加 1 或减 1。例如：m = 0.3744，则不用变；m = -0.1709，则应加 1 变为+0.8291；m = +1.1853 则应减 1 变 为+0.1853。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;根据上一步求得的m,分别计算三个时刻点的格林威治恒星时$θ = θ_0 + 360.985647m$，式中$m$是$m_0、m_1、m_2$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;考虑ΔT，得到一个$m_0+ΔT/86400$的时刻点，对该时刻点在所给的视赤经，视赤纬数据中插值求解得到新的中天时刻对应的天体视赤经α，视赤纬δ（单单求解中天用不着视赤纬数据，但升降需要）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;计算中天时本地时角$H= θ - L - α$，新的中天即为$m_0 = m_0-\frac{H}{360}$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;同上，对升，降估计时间考虑$ΔT$并插值求解对应的视赤经$α$，视赤纬$δ$，再根据地平坐标转换公式，求得地平仰角$h$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;再求分别对应的本地时角$H$,则新的升,降即为$$m= m + \frac {h-h_0}{360\cos δ\cos φ\sin H}$$&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// ApproxTimes computes approximate UT rise, transit and set times for
// a celestial object on a day of interest.
//
// The function argurments do not actually include the day, but do include
// values computed from the day.
//
//	p is geographic coordinates of observer. p 为地平坐标（仰角，方位角）
//	h0 is &amp;quot;standard altitude&amp;quot; of the body. h0 为天体升，降时实际地平线纬度
//	Th0 is apparent sidereal time at 0h UT at Greenwich. Th0 为格林威治0h UT视恒星时
//	α, δ are right ascension and declination of the body. α, δ为天体0h DT视赤经，视赤纬
//
// Th0 must be the time on the day of interest.
// See sidereal.Apparent0UT.
//
// α, δ must be values at 0h dynamical time for the day of interest.
// 近似计算升，中天，降时间
func ApproxTimes(p globe.Coord, h0 unit.Angle, Th0 unit.Time, α unit.RA, δ unit.Angle) (tRise, tTransit, tSet unit.Time, err error) {
	// approximate local hour angle
	sLat, cLat := p.Lat.Sincos()
	sδ1, cδ1 := δ.Sincos()
	cH0 := (h0.Sin() - sLat*sδ1) / (cLat * cδ1) // (15.1) p. 102
	if cH0 &amp;lt; -1 || cH0 &amp;gt; 1 {
		err = ErrorCircumpolar
		return
	}
	H0 := unit.TimeFromRad(math.Acos(cH0))

	// approximate transit, rise, set times.
	// (15.2) p. 102.
	mt := unit.TimeFromRad(α.Rad()+p.Lon.Rad()) - Th0
	tTransit = mt.Mod1()
	tRise = (mt - H0).Mod1()
	tSet = (mt + H0).Mod1()
	return
}

// Times computes UT rise, transit and set times for a celestial object on
// a day of interest.
//
// The function argurments do not actually include the day, but do include
// a number of values computed from the day.
//
//	p is geographic coordinates of observer.
//	ΔT is delta T.
//	h0 is &amp;quot;standard altitude&amp;quot; of the body.
//	Th0 is apparent sidereal time at 0h UT at Greenwich.
//	α3, δ3 are slices of three right ascensions and declinations.
//
// h0 unit is radians.
//
// Th0 must be the time on the day of interest, in seconds.
// See sidereal.Apparent0UT.
//
// α3, δ3 must be values at 0h dynamical time for the day before, the day of,
// and the day after the day of interest.  Units are radians.
//
// Result units are seconds of day and are in the range [0,86400).
// 对近似计算结果迭代，得到精确升，中天，降时间
func Times(p globe.Coord, ΔT unit.Time, h0 unit.Angle, Th0 unit.Time, α3 []unit.RA, δ3 []unit.Angle) (tRise, tTransit, tSet unit.Time, err error) {
	tRise, tTransit, tSet, err = ApproxTimes(p, h0, Th0, α3[1], δ3[1])
	if err != nil {
		return
	}
	αf := make([]float64, 3)
	for i, α := range α3 {
		αf[i] = α.Rad()
	}
	δf := make([]float64, 3)
	for i, δ := range δ3 {
		δf[i] = δ.Rad()
	}
	var d3α, d3δ *interp.Len3
	d3α, err = interp.NewLen3(-86400, 86400, αf)
	if err != nil {
		return
	}
	d3δ, err = interp.NewLen3(-86400, 86400, δf)
	if err != nil {
		return
	}
	// adjust tTransit
	{
		th0 := (Th0 + tTransit.Mul(360.985647/360)).Mod1()
		α := d3α.InterpolateX((tTransit + ΔT).Sec())
		// local hour angle as Time
		H := th0 - unit.TimeFromRad(p.Lon.Rad()+α)
		tTransit -= H
	}
	// adjust tRise, tSet
	sLat, cLat := p.Lat.Sincos()
	adjustRS := func(m unit.Time) (unit.Time, error) {
		th0 := (Th0 + m.Mul(360.985647/360)).Mod1()
		ut := (m + ΔT).Sec()
		α := d3α.InterpolateX(ut)
		δ := d3δ.InterpolateX(ut)
		Hrad := th0.Rad() - p.Lon.Rad() - α
		sδ, cδ := math.Sincos(δ)
		sH, cH := math.Sincos(Hrad)
		h := math.Asin(sLat*sδ + cLat*cδ*cH)
		md := (unit.TimeFromRad(h) - h0.Time()).Div(cδ * cLat * sH)
		return m + md, nil
	}
	tRise, err = adjustRS(tRise)
	if err != nil {
		return
	}
	tSet, err = adjustRS(tSet)
	return
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>天文算法12</title>
      <link>https://mooncaker816.github.io/2018/05/20/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9512/</link>
      <pubDate>Sun, 20 May 2018 10:13:34 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/05/20/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9512/</guid>
      <description>&lt;h1 id=&#34;第十四章-the-parallactic-angle&#34;&gt;第十四章 The Parallactic Angle&lt;/h1&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-什么是parallactic-angle&#34;&gt;1. 什么是Parallactic Angle&lt;/h2&gt;

&lt;p&gt;　　&lt;strong&gt;&lt;em&gt;Parallactic is NOT Parallax&lt;/em&gt;&lt;/strong&gt;&lt;br /&gt;
　　这里所说的 Parallactic Angle 并不是 Parallax，Parallax是从两个不同的视点看同一物体时这两条视线之间的夹角(或半角)，主要用来测定物体的距离，如&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E7%A7%92%E5%B7%AE%E8%B7%9D&#34; target=&#34;_blank&#34;&gt;秒差距&lt;/a&gt;这一距离单位就是利用视差角来定义的。&lt;br /&gt;
　　In spherical astronomy, the parallactic angle is the angle between the great circle through a celestial object and the zenith(&lt;strong&gt;天体与天顶所在的大圆，即天球地平经线&lt;/strong&gt;), and the hour circle of the object（&lt;strong&gt;天体的时角，即天球赤道经线&lt;/strong&gt;）.It is usually denoted q. In the triangle zenith—object—celestial pole, the parallactic angle will be the position angle of the zenith at the celestial object. Despite its name, this angle is unrelated with parallax. The parallactic angle is zero when the object crosses the meridian.&lt;br /&gt;
　　换句话说，就是天体地平经线与天体赤道经线之间的角度。&lt;/p&gt;

&lt;h2 id=&#34;2-计算parallactic-angle&#34;&gt;2. 计算Parallactic Angle&lt;/h2&gt;

&lt;p&gt;$$\tan q=\frac {\sin H}{\tan φ\cos δ -\sin δ\cos H}$$
　　式中，$φ$是观测站地理纬度,$δ$是天体的赤纬，$H$是该时刻的时角。&lt;/p&gt;

&lt;p&gt;如何推导？&lt;br /&gt;
&lt;img src=&#34;https://mooncaker816.github.io/img/triangle.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如上图，P为天球极点，Z为天顶，X为观测目标，此时观测点为球心（地平坐标系），&lt;br /&gt;
由观测站地理纬度$φ$可知，弧长
$\newcommand{arc}[1]{\stackrel{\Large\frown}{#1}}\arc{PZ}= 90°-φ$,&lt;br /&gt;
由天体的赤纬$δ$可知，弧长
$\newcommand{arc}[1]{\stackrel{\Large\frown}{#1}}\arc{PX}= 90°-δ$,&lt;br /&gt;
由天体的时角$H$可知，球面角
$\angle ZPX = H$,&lt;br /&gt;
假设 X 的仰角为$a$,则弧长
$\newcommand{arc}[1]{\stackrel{\Large\frown}{#1}}\arc{ZX}= 90°-a$,&lt;br /&gt;
根据球面余弦公式，我们有
\begin{cases}
\cos (90°-a) &amp;amp;= \cos (90°-φ)\cos (90°-δ) + \sin (90°-φ)\sin (90°-δ)\cos H\\[2ex]
\cos (90°-φ) &amp;amp;= \cos (90°-a)\cos (90°-δ) + \sin (90°-a)\sin (90°-δ)\cos q
\end{cases}
即
\begin{cases}
\sin a &amp;amp;= \sin φ\sin δ + \cos φ\cos δ\cos H, &amp;amp;(1)\\[2ex]
\sin φ &amp;amp;= \sin a\sin δ + \cos a\cos δ\cos q, &amp;amp;(2)
\end{cases}
根据正弦公式，我们有$$\frac {\sin H}{\cos a} = \frac {\sin q}{\cos φ},\ \ \ (3)$$
由(2)(3)可得
\begin{align}
\tan q &amp;amp;= \frac {\sin q}{\cos q}\\[2ex]
&amp;amp; = \frac {\frac {\sin H\cos φ}{\cos a}}{\frac {\sin φ-\sin a\sin δ}{\cos a\cos δ}}\\[2ex]
&amp;amp; = \frac {\sin H\cos φ\cos δ}{\sin φ-\sin a\sin δ}
\end{align}
再将(1)代入上式中，
\begin{align}
\tan q &amp;amp; = \frac {\sin H\cos φ\cos δ}{\sin φ-\sin δ(\sin φ\sin δ + \cos φ\cos δ\cos H)}\\[2ex]
&amp;amp; = \frac {\sin H\cos φ\cos δ}{\sin φ\cos^2δ - \cos φ\cos δ\sin δ\cos H}\\[2ex]
&amp;amp; = \frac {\sin H}{\tan φ\cos δ - \sin δ\cos H}
\end{align}
得证&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.cnblogs.com/li-hua/p/5663915.html&#34; target=&#34;_blank&#34;&gt;另一种直接证明&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　当天体位于中天时恰好与天顶重合，则有$δ=φ$，此时$\tan q = \frac 00$，没有意义，也就是说角度由-90°跳到90°。&lt;br /&gt;
　　当天体位于地平线上时，即$a=0°$时，由(2)式直接可得$$\cos q = \frac {\sin φ}{\cos δ}$$
与时角$H$无关&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// ParallacticAngle returns parallactic angle of a celestial object.
//
//	φ is geographic latitude of observer.观测点地理纬度
//	δ is declination of observed object.天体赤纬
//	H is hour angle of observed object.天体赤经（时角）
//  计算天体的Parallactic Angle
func ParallacticAngle(φ, δ unit.Angle, H unit.HourAngle) unit.Angle {
	sδ, cδ := δ.Sincos()
	sH, cH := H.Sincos()
	// (14.1) p. 98
	return unit.Angle(math.Atan2(sH, φ.Tan()*cδ-sδ*cH))
}

// ParallacticAngleOnHorizon is a special case of ParallacticAngle.
//
// The hour angle is not needed as an input and the math inside simplifies.
// 当天体位于地平线上时，计算Parallactic Angle，与时角无关
func ParallacticAngleOnHorizon(φ, δ unit.Angle) unit.Angle {
	return unit.Angle(math.Acos(φ.Sin() / δ.Cos()))
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>天文算法11</title>
      <link>https://mooncaker816.github.io/2018/05/19/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9511/</link>
      <pubDate>Sat, 19 May 2018 15:04:04 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/05/19/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9511/</guid>
      <description>&lt;h1 id=&#34;第十三章-坐标的转换-transformation-of-coordinates&#34;&gt;第十三章 坐标的转换 Transformation of Coordinates&lt;/h1&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-天球坐标系统&#34;&gt;1. 天球坐标系统&lt;/h2&gt;

&lt;p&gt;　　天球坐标系统，是天文学上用来描绘天体在天球上位置的坐标系统。有许多不同的坐标系统都使用球面坐标投影在天球上，类似于使用在地球表面的地理坐标系统。这些坐标系统的不同处只在用来将天空分割成两个相等半球的大圆，也就是基面的不同。例如，地理坐标系统的基面是地球的赤道。每个坐标系统的命名都是依据其所选择的基面。&lt;/p&gt;

&lt;p&gt;\begin{array}{c|ccc}
坐标系统 &amp;amp; 基面 &amp;amp; 极 &amp;amp; 坐标 \\&lt;br /&gt;
\hline
地平 &amp;amp; 地平面 &amp;amp; 天顶/天底 &amp;amp; 高度（也称为仰角） - 方位 - 子午圈 \\&lt;br /&gt;
赤道 &amp;amp; 天球赤道 &amp;amp; 天极 &amp;amp; 赤纬 - 赤经或时角 \\&lt;br /&gt;
黄道 &amp;amp; 黄道 &amp;amp; 黄极 &amp;amp; 黄纬 - 黄经 \\&lt;br /&gt;
银河 &amp;amp; 银河平面 &amp;amp; 银极 &amp;amp; 银经 - 银纬 \\&lt;br /&gt;
超星系 &amp;amp; 超星系平面 &amp;amp;  &amp;amp;  \\&lt;br /&gt;
\end{array}&lt;/p&gt;

&lt;h2 id=&#34;2-地平坐标系&#34;&gt;2. 地平坐标系&lt;/h2&gt;

&lt;p&gt;　　地平坐标系，又作地平座标系，是天球坐标系统中的一种，以观测者所在地为中心点，所在地的地平线作为基础平面，将天球适当的分成能看见的上半球和看不见（被地球本身遮蔽）的下半球。上半球的顶点（最高点）称为天顶，下半球的顶点（最低点）称为地底。&lt;/p&gt;

&lt;p&gt;地平坐标系统是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;高度角（Altitude, Alt）或仰角又称地平纬度，是天体和观测者所在地的地平线的夹角，有时就称为高度或海拔标高（elevation, geometric height）。&lt;/li&gt;
&lt;li&gt;方位角（Azimuth, Az）又称地平经度，是沿着地平线测量的角度（由正北方为起点向东方测量）。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因此地平坐标系有时也被称为高度/方位（Alt/Az）坐标系统。
&lt;img src=&#34;https://kotobank.jp/image/dictionary/daijisen/media/103135.jpg&#34; alt=&#34;地平坐标系&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;注：方位角的测量可以从北点向东测量，也可从南点向西测量，两者相差180°。天文学家习惯从南点开始测量。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;3-赤道坐标系&#34;&gt;3. 赤道坐标系&lt;/h2&gt;

&lt;p&gt;　　赤道坐标系统，又作赤道座标系统，大概是使用得最广泛的天球坐标系统，他的元素是:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;赤纬Declination（ $\delta$ ）&lt;/li&gt;
&lt;li&gt;赤经Right ascension（ $\alpha$ ）－也记为RA&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　他与地理坐标系统非常相似，因为两者使用相同的基准平面和相同的极点。地球的赤道在天球上的投影就称为天球赤道，相同的，地理极点在天球上的投影就是天极。&lt;/p&gt;

&lt;p&gt;他有两种变化：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;时角系统像地理坐标系统一样，被固定在地球的表面上。&lt;/li&gt;
&lt;li&gt;赤经系统被固定于恒星上(实际上并非如此，请参考岁差和章动)。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因此，在经过一夜或数个夜晚，就能看出来星星在天空中的位置移动了，当然，这并非恒星在天球上的运动，只是地球运动造成的。因为岁差和章动的影响，在相当长的时间间隔下所做的观测，就必须注明所使用的特殊历元，为行星、恒星、星系等等的位置做记录。现在使用的历元是J2000.0分点，稍早期使用的是B1950.0分点。&lt;/p&gt;

&lt;p&gt;赤道坐标系统中与纬度相似的值是赤纬(缩写为Dec.)，是天体在天球赤道上方或下方的角度。与经度对应的是赤经(缩写为RA)，是与春分点的角度距离，不同于经度的是赤经以时、分、秒为单位，而非度、分、秒。因为地球的运动造成赤道坐标系统的视运动，就会造成恒星时和时角的相对变化。将天球运转一周的时间定为24小时，所以每小时天球会转动15度(360º / 24h = 15)。&lt;/p&gt;

&lt;p&gt;赤道坐标系统也是赤道仪上很普通的设备，也就是定位圈。定位圈与星图或星历表上的位置结合，可以让赤道仪很容易的指向已知天体在天球上的位置。
&lt;img src=&#34;https://kotobank.jp/image/dictionary/daijisen/media/103123.jpg&#34; alt=&#34;赤道坐标系&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;4-黄道坐标系&#34;&gt;4. 黄道坐标系&lt;/h2&gt;

&lt;p&gt;黄道是由地球上观察太阳一年中在天球上的视运动所通过的路径，若以地球“不动”作参照的话就是太阳绕地球公转的轨道平面（黄道面）在天球上的投影。&lt;/p&gt;

&lt;p&gt;黄道与天赤道相交于两点：春分点与秋分点（这两点称二分点）；而黄道对应的两个几何极是北黄极（在天龙座）、与南黄极 (在剑鱼座)。&lt;/p&gt;

&lt;p&gt;在黄道上与黄道平行的小圆称黄纬，符号β，以由黄道面向北黄极方向为正值（0°至90°），向南黄极方向则为负值。垂直黄道的经度称黄经，符号为λ，由春分点起由西向东量度（0°至360°）。像赤道坐标系中的赤经一样，以春分点做为黄经的起点。&lt;/p&gt;

&lt;p&gt;因为地轴有进动现象，此坐标系的两个黄极亦会因岁差影响而使坐标数值逐渐移动，计算时必须说明坐标系参照的历元。现常采用的是J2000.0历元（之前的出版物多以B1950.0历元），在天文年历这类精度较高的刊物中，则参考当天或当月之瞬时分点计算。&lt;/p&gt;

&lt;p&gt;此坐标系特别适合标示太阳系内天体的位置，大多数行星（水星和冥王星除外）与许多小行星轨道平面与黄道的倾角都很小，故其黄纬值（β）都不大。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kotobank.jp/image/dictionary/daijisen/media/103079.jpg&#34; alt=&#34;黄道坐标系&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;5-坐标系转换&#34;&gt;5. 坐标系转换&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;$λ$和$β$代表黄经和黄纬&lt;/li&gt;
&lt;li&gt;$α$和$δ$代表赤经和赤纬&lt;/li&gt;
&lt;li&gt;$φ,A,h$代表观察者纬度，方位角，和仰角，其中默认A从南点向西测量&lt;/li&gt;
&lt;li&gt;$ε$黄赤交角&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;注：如果给定的为视坐标，在转换为本地地平坐标时要先将视赤经（时角）转换为本地时角。&lt;br /&gt;
例如：如果θ是本地恒星时，$θ_0$ 是格林尼治恒星时，L 是观者站经度（从格林尼治向西为正，东为负），那么本地时角为$ θ - α 或 θ_0 - L – α$&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;5-1-赤道转黄道-α-δ-rightarrow-λ-β&#34;&gt;5.1 赤道转黄道($α,δ\  \Rightarrow\  λ,β$)&lt;/h3&gt;

&lt;p&gt;\begin{align}
\sin β &amp;amp;=\cos ε\sin δ-\sin α\cos δ\sin ε\\[2ex]
\cos λ\cos β &amp;amp;=\cos α\cos δ\\[2ex]
\sin λ\cos β &amp;amp;=\sin ε\sin δ+\sin α\cos δ\cos ε
\end{align}&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Obliquity represents the obliquity of the ecliptic.
// 黄赤交角对应的 sin,cos 值
type Obliquity struct {
	S, C float64 // sine and cosine of obliquity
}

// NewObliquity constructs a new Obliquity.
//
// Struct members are initialized from the given value ε of the obliquity of
// the ecliptic.
// 计算黄赤交角对应的 sin,cos 值
func NewObliquity(ε unit.Angle) *Obliquity {
	r := &amp;amp;Obliquity{}
	r.S, r.C = ε.Sincos()
	return r
}

// Ecliptic coordinates are referenced to the plane of the ecliptic.
// 黄道坐标结构
type Ecliptic struct {
	Lon unit.Angle // Longitude (λ)黄经
	Lat unit.Angle // Latitude (β)黄纬
}

// EqToEcl converts equatorial coordinates to ecliptic coordinates.
// 赤道转黄道
func (ecl *Ecliptic) EqToEcl(eq *Equatorial, ε *Obliquity) *Ecliptic {
	ecl.Lon, ecl.Lat = EqToEcl(eq.RA, eq.Dec, ε.S, ε.C)
	return ecl
}

// EqToEcl converts equatorial coordinates to ecliptic coordinates.
//
//	α: right ascension coordinate to transform
//	δ: declination coordinate to transform
//	sε: sine of obliquity of the ecliptic
//	cε: cosine of obliquity of the ecliptic
//
// Results:
//
//	λ: ecliptic longitude黄经
//	β: ecliptic latitude黄纬
//  赤道转黄道
func EqToEcl(α unit.RA, δ unit.Angle, sε, cε float64) (λ, β unit.Angle) {
	sα, cα := α.Sincos()
	sδ, cδ := δ.Sincos()
	λ = unit.Angle(math.Atan2(sα*cε+(sδ/cδ)*sε, cα)) // (13.1) p. 93
	β = unit.Angle(math.Asin(sδ*cε - cδ*sε*sα))      // (13.2) p. 93
	return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;5-2-黄道转赤道-λ-β-rightarrow-α-δ&#34;&gt;5.2 黄道转赤道($λ,β\  \Rightarrow\  α,δ$)&lt;/h3&gt;

&lt;p&gt;\begin{align}
\sin δ &amp;amp;=\sin ε\sin λ\cos β+\cos ε\sin β\\[2ex]
\cos α\cos δ &amp;amp;=\cos λ\cos β\\[2ex]
\sin α\cos δ &amp;amp;=\cos ε\sin λ\cos β-\sin ε\sin β
\end{align}&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Equatorial coordinates are referenced to the Earth&#39;s rotational axis.
// 赤道坐标结构
type Equatorial struct {
	RA  unit.RA    // Right ascension (α)赤经（时角）
	Dec unit.Angle // Declination (δ)赤纬
}

// EclToEq converts ecliptic coordinates to equatorial coordinates.
// 黄道转赤道
func (eq *Equatorial) EclToEq(ecl *Ecliptic, ε *Obliquity) *Equatorial {
	eq.RA, eq.Dec = EclToEq(ecl.Lon, ecl.Lat, ε.S, ε.C)
	return eq
}

// EclToEq converts ecliptic coordinates to equatorial coordinates.
//
//	λ: ecliptic longitude coordinate to transform
//	β: ecliptic latitude coordinate to transform
//	sε: sine of obliquity of the ecliptic
//	cε: cosine of obliquity of the ecliptic
//
// Results:
//	α: right ascension赤经（时角）
//	δ: declination赤纬
// 黄道转赤道
func EclToEq(λ, β unit.Angle, sε, cε float64) (α unit.RA, δ unit.Angle) {
	sλ, cλ := λ.Sincos()
	sβ, cβ := β.Sincos()
	α = unit.RAFromRad(math.Atan2(sλ*cε-(sβ/cβ)*sε, cλ)) // (13.3) p. 93
	δ = unit.Angle(math.Asin(sβ*cε + cβ*sε*sλ))          // (13.4) p. 93
	return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;5-3-地平转赤道-φ-a-h-rightarrow-α-δ&#34;&gt;5.3 地平转赤道($φ,A,h\  \Rightarrow\  α,δ$)&lt;/h3&gt;

&lt;p&gt;\begin{align}
\sin δ &amp;amp;=\sin φ\sin h-\cos φ\cos h\cos A\\[2ex]
\cos δ\cos α &amp;amp;=-\cos φ\sin h-\sin φ\cos h\cos A\\[2ex]
\cos δ\sin α &amp;amp;=-\sin A\cos h
\end{align}&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// HzToEq transforms horizontal coordinates to equatorial coordinates.
//
// Sidereal time st must be consistent with the equatorial coordinates
// in the sense that if coordinates are apparent, sidereal time must be
// apparent as well.
// 地平转赤道
func (eq *Equatorial) HzToEq(hz *Horizontal, g globe.Coord, st unit.Time) *Equatorial {
	eq.RA, eq.Dec = HzToEq(hz.Az, hz.Alt, g.Lat, g.Lon, st)
	return eq
}

// HzToEq transforms horizontal coordinates to equatorial coordinates.
//
//	A: azimuth方位角
//	h: elevation仰角
//	φ: latitude of observer on Earth观测纬度
//	ψ: longitude of observer on Earth观测经度
//	st: sidereal time at Greenwich at time of observation.恒星时
//
// Sidereal time must be consistent with the equatorial coordinates
// in the sense that tf coordinates are apparent, sidereal time must be
// apparent as well.
// 恒星时必须和所给条件保持一致
//
// Results:
//
//	α: right ascension赤经（时角）
//	δ: declination赤纬
// 地平转赤道
func HzToEq(A, h, φ, ψ unit.Angle, st unit.Time) (α unit.RA, δ unit.Angle) {
	sA, cA := A.Sincos()
	sh, ch := h.Sincos()
	sφ, cφ := φ.Sincos()
	H := math.Atan2(sA, cA*sφ+sh/ch*cφ)
	α = unit.RAFromRad(st.Rad() - ψ.Rad() - H)
	δ = unit.Angle(math.Asin(sφ*sh - cφ*ch*cA))
	return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;5-4-赤道转地平-φ-α-δ-rightarrow-a-h&#34;&gt;5.4 赤道转地平($φ,α,δ\  \Rightarrow\  A,h$)&lt;/h3&gt;

&lt;p&gt;\begin{align}
\sin h &amp;amp;= \sin φ\sin δ+\cos φ\cos δ\cos α\\[2ex]
\cos A\cos h &amp;amp;=-\cos φ\sin δ+\sin φ\cos δ\cos α\\[2ex]
\sin A\cos h &amp;amp;=\cos δ\sin α
\end{align}&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Horizontal coordinates are referenced to the local horizon of an observer
// on the surface of the Earth.
// 地平坐标结构
type Horizontal struct {
	Az  unit.Angle // Azimuth (A)方位角
	Alt unit.Angle // Altitude (h)仰角
}

// EqToHz computes Horizontal coordinates from equatorial coordinates.
//
// Argument g is the location of the observer on the Earth.  Argument st
// is the sidereal time at Greenwich.
//
// Sidereal time must be consistent with the equatorial coordinates.
// If coordinates are apparent, sidereal time must be apparent as well.
// 赤道转地平
func (hz *Horizontal) EqToHz(eq *Equatorial, g *globe.Coord, st unit.Time) *Horizontal {
	hz.Az, hz.Alt = EqToHz(eq.RA, eq.Dec, g.Lat, g.Lon, st)
	return hz
}

// EqToHz computes Horizontal coordinates from equatorial coordinates.
//
//	α: right ascension coordinate to transform
//	δ: declination coordinate to transform
//	φ: latitude of observer on Earth
//	ψ: longitude of observer on Earth
//	st: sidereal time at Greenwich at time of observation.
//
// Sidereal time must be consistent with the equatorial coordinates.
// If coordinates are apparent, sidereal time must be apparent as well.
//
// Results:
//
//	A: azimuth of observed point, measured westward from the South.
//	h: elevation, or height of observed point above horizon.
// 赤道转地平
func EqToHz(α unit.RA, δ, φ, ψ unit.Angle, st unit.Time) (A, h unit.Angle) {
	H := st.Rad() - ψ.Rad() - α.Rad()
	sH, cH := math.Sincos(H)
	sφ, cφ := φ.Sincos()
	sδ, cδ := δ.Sincos()
	A = unit.Angle(math.Atan2(sH, cH*sφ-(sδ/cδ)*cφ)) // (13.5) p. 93
	h = unit.Angle(math.Asin(sφ*sδ + cφ*cδ*cH))      // (13.6) p. 93
	return
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>天文算法10</title>
      <link>https://mooncaker816.github.io/2018/05/19/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9510/</link>
      <pubDate>Sat, 19 May 2018 09:20:12 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/05/19/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9510/</guid>
      <description>&lt;h1 id=&#34;第十二章-格林威治恒星时-sidereal-time-at-greenwich&#34;&gt;第十二章 格林威治恒星时 Sidereal Time at Greenwich&lt;/h1&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-恒星时&#34;&gt;1. 恒星时&lt;/h2&gt;

&lt;p&gt;　　&lt;strong&gt;恒星时是天文学和大地测量学标示的天球子午圈值&lt;/strong&gt;，由于借用了时间的计量单位，所以常被误解为是一种时间单位。恒星时是根据地球自转来计算的，它的基础是恒星日（比地球的自转周期短约8.4毫秒）。由于地球环绕太阳的公转运动，恒星日比平太阳日（也就是日常生活中所使用的日）短约1/365（相应约四分钟或一度）。&lt;/p&gt;

&lt;p&gt;　　恒星时的定义是一个地方的子午圈与天球的春分点之间的时角，因此地球上每个地方的恒星时都与它的经度有关。&lt;/p&gt;

&lt;p&gt;　　由于地球的章动春分点在天球上并不固定，而是以18.6年的周期围绕着平均春分点摆动。因此恒星时又分真恒星时和平恒星时。真恒星时是通过直接测量子午线与实际的春分点之间的时角获得的，平恒星时则忽略了地球的章动。真恒星时与平恒星时之间的差异最大可达约0.4秒。&lt;/p&gt;

&lt;p&gt;　　一个地方的当地恒星时与格林尼治天文台的恒星时之间的差就是这个地方的经度（参见天体导航）。因此通过观测恒星时可以确定当地的经度（假如格林尼治天文台的恒星时已知的话）或者可以确定时间（假如当地的经度已知的话）。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;一颗恒星的时角$\tau$ 、它的赤经$α$和当地的恒星时$θ$之间的关系为 $\tau=\theta -\alpha$&lt;/li&gt;
&lt;li&gt;当地的恒星时等于位于天顶的恒星的赤经&lt;/li&gt;
&lt;li&gt;当地的恒星时等于正位于中天恒星的赤经&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　通过确定恒星时可以简化天文学的计算，比如通过恒星时和当地的纬度可以很方便地计算出哪些星正好在地平线以上。&lt;/p&gt;

&lt;h2 id=&#34;2-恒星时的计算&#34;&gt;2. 恒星时的计算&lt;/h2&gt;

&lt;h3 id=&#34;2-1-格林威治0h平恒星时&#34;&gt;2.1 格林威治0h平恒星时&lt;/h3&gt;

&lt;p&gt;　　一个给定的世界时日期的&lt;strong&gt;&lt;em&gt;(0h UT)&lt;/em&gt;&lt;/strong&gt;，格林尼治子午圈的平恒星时可按如下计算。&lt;br /&gt;
　　1. 先计算当天（0h UT）对应的$JD$&lt;br /&gt;
　　2. 计算$T = \frac {JD - 2451545.0}{36525}$&lt;br /&gt;
　　3. 采用 &lt;strong&gt;IAU1982&lt;/strong&gt; 的格林尼治子午圈的平恒星时表达式： $$θ_0 = 6h41m50s.54841 + 8640184s.812866T + 0s.093104T^2 - 0s.0000062T^3$$
　　4. 若以度为单位，则上式为：$$θ_0 = 100.46061837 + 36000.770053608T + 0.000387933T^2 - T^3 / 38710000$$&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;注意，上述公式只适用于(0h UT）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// jdToCFrac returns values for use in computing sidereal time at Greenwich.
//
// Cen is centuries from J2000 of the JD at 0h UT of argument jd.  This is
// the value to use for evaluating the IAU sidereal time polynomial.
// DayFrac is the fraction of jd after 0h UT.  It is used to compute the
// final value of sidereal time.
// 计算 T = cen，dayFrac 为此 jd 对应的天的小数
func jdToCFrac(jd float64) (cen, dayFrac float64) {
	j0, f := math.Modf(jd + .5)
	return base.J2000Century(j0 - .5), f
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// J2000Century returns the number of Julian centuries since J2000.
//
// The quantity appears as T in a number of time series.
func J2000Century(jde float64) float64 {
	// The formula is given in a number of places in the book, for example
	// (12.1) p. 87.
	// (22.1) p. 143.
	// (25.1) p. 163.
	return (jde - J2000) / JulianCentury
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Mean0UT returns mean sidereal time at Greenwich at 0h UT on the given JD.
//
// The result is in the range [0,86400).
// 计算格林威治 0h UT 平恒星时，并化简为单位为秒一天之内的值[0,86400).
func Mean0UT(jd float64) unit.Time {
	s, _ := mean0UT(jd)
	return s.Mod1()
}

// 计算格林威治 0h UT 平恒星时，并返回此 jd 一天中相对于0h的秒数，用于瞬时平恒星时的计算
func mean0UT(jd float64) (sidereal, dayFrac unit.Time) {
	cen, f := jdToCFrac(jd)
	// (12.2) p. 87
	return unit.Time(base.Horner(cen, iau82...)), unit.TimeFromDay(f)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-2-格林威治任意-ut-平恒星时&#34;&gt;2.2 格林威治任意 UT 平恒星时&lt;/h3&gt;

&lt;p&gt;　　1. 计算0h 平恒星时&lt;br /&gt;
　　2. UT * 1.00273790935&lt;br /&gt;
　　3. 1 + 2 的结果即为格林威治瞬时平恒星时&lt;br /&gt;
　　4. 若以度为单位，则：$$θ_0 = 280.46061837 + 360.98564736629(JD-2451545.0) + 0.000387933T^2 - T^3 / 38710000$$&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Mean returns mean sidereal time at Greenwich for a given JD.
//
// Computation is by IAU 1982 coefficients.
// The result is in the range [0,86400).
// 计算格林威治 jd 时刻的瞬时平恒星时,化简结果至一天范围之内
func Mean(jd float64) unit.Time {
	return mean(jd).Mod1()
}

// 计算格林威治 jd 时刻的瞬时平恒星时
func mean(jd float64) unit.Time {
	s, f := mean0UT(jd)
	return s + f*1.00273790935
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-3-格林威治视恒星时&#34;&gt;2.3 格林威治视恒星时&lt;/h3&gt;

&lt;p&gt;　　要取得视恒星时，即真春分点起算的格林尼治时角，应加上修正值 $Δψ\cos ε$，式中 $Δψ$ 是黄经章动，$ε$ 是真黄赤交角。这个修正值也就作赤经章动（也称作分点方程）。因为 $Δψ$ 是个小量，所以 $ε$ 误差 10&amp;rdquo;也没关系。&lt;br /&gt;
　　如果 $Δψ$ 的单位是角秒（1 度是 3600 秒），则以时秒(1 小时是 3600 秒)为单位的修正值是：$\frac {Δψ\cos ε}{15}$&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Apparent returns apparent sidereal time at Greenwich for the given JD.
//
// Apparent is mean plus the nutation in right ascension.
//
// The result is in the range [0,86400).
// 计算格林威治瞬时视恒星时
func Apparent(jd float64) unit.Time {
	s := mean(jd)                  // Time
	n := nutation.NutationInRA(jd) // HourAngle
	return (s + n.Time()).Mod1()
}

// Apparent0UT returns apparent sidereal time at Greenwich at 0h UT
// on the given JD.
//
// The result is in the range [0,86400).
// 计算格林威治0h UT视恒星时
func Apparent0UT(jd float64) unit.Time {
	j0, f := math.Modf(jd + .5)
	cen := (j0 - .5 - base.J2000) / 36525
	s := unit.Time(base.Horner(cen, iau82...)) +
		unit.TimeFromDay(f*1.00273790935)
	n := nutation.NutationInRA(j0) // HourAngle
	return (s + n.Time()).Mod1()
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>天文算法9</title>
      <link>https://mooncaker816.github.io/2018/05/18/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%959/</link>
      <pubDate>Fri, 18 May 2018 15:55:20 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/05/18/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%959/</guid>
      <description>&lt;h1 id=&#34;第十一章-地球球体-the-earth-s-globe&#34;&gt;第十一章 地球球体 The Earth&amp;rsquo;s Globe&lt;/h1&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-椭球体&#34;&gt;1. 椭球体&lt;/h2&gt;

&lt;p&gt;　　天文学上，通常我们将地球看做一个近似的椭球体。如下图，&lt;img src=&#34;http://www.tleer.cn/uploads/allimg/170224/2-1F224111032348.jpg&#34; alt=&#34;&#34; /&gt;
所以子午圈截面为一个椭圆。如下图，&lt;img src=&#34;https://mooncaker816.github.io/img/tuoyuan.png&#34; alt=&#34;&#34; /&gt;
　　假设上图中$C$为地心，$N$为北极，$S$为南极，$CF$为赤道半径，$NC = b, CF = a$,$O$为观察点，$HK$为地平面，$OP\perp HK$,$OM//SN$，$OM$与$OH$的夹角是$φ$，$CF$与$CO$的夹角是$φ&amp;rsquo;$，$CO$的长度为$\rho$&lt;br /&gt;
　　则$φ$为$O$点的&lt;strong&gt;地理纬度&lt;/strong&gt;，$\angle OPF = φ$，$φ&amp;rsquo;$为$O$点的&lt;strong&gt;地心纬度&lt;/strong&gt;,$\rho$为$O$点的&lt;strong&gt;地心半径&lt;/strong&gt;,在极点和赤道上$φ=φ′$，在其它纬度上$|φ′|&amp;lt;|φ|$&lt;br /&gt;
　　地心纬度$φ&amp;rsquo;$与地理纬度$φ$的关系为：$\tan φ′=\frac {b^2}{a^2} \tan φ，$(&lt;a href=&#34;https://baike.baidu.com/item/地心纬度&#34; target=&#34;_blank&#34;&gt;推导&lt;/a&gt;)&lt;br /&gt;
　　由椭球体扁率$f=\frac {a-b}a$,可知$b=a(1-f)$,子午圈椭圆离心率
\begin{align}
e &amp;amp;= \frac ca\\[2ex]
&amp;amp; = \frac {\sqrt {a^2-b^2}}{a}\\[2ex]
&amp;amp; = \sqrt {2f-f^2}
\end{align}
　　地心纬度$φ&amp;rsquo;$对应的归化纬度$u$,有
\begin{cases}
\tan φ&amp;rsquo; = \frac ba \tan u\\[2ex]
\tan u = \frac ba \tan φ\\[2ex]
\end{cases}
且
\begin{cases}
\rho \cos φ&amp;rsquo; = a\cos u, \ (相当于子午圈椭圆上观察点O的x坐标)\\[2ex]
\rho \sin φ&amp;rsquo; = b\sin u, \ (相当于子午圈椭圆上观察点O的y坐标)
\end{cases}
　　如果观察点的海拔高度为$H$,且$\rho$以赤道半径$a$为单位，则有
\begin{cases}
\rho \cos φ&amp;rsquo; = cos u + \frac Ha\cos φ\\[2ex]
\rho \sin φ&amp;rsquo; = \frac ba\sin u + \frac Ha\sin φ
\end{cases}&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Ellipsoid represents an ellipsoid of revolution.
//
// Typical unit for Er is Km.
// 地球椭球体
type Ellipsoid struct {
	Er float64 // equatorial radius 赤道半径
	Fl float64 // flattening 地球扁率
}

// IAU 1976 values.  Radius in Km.
var Earth76 = Ellipsoid{Er: 6378.14, Fl: 1 / 298.257}

// A returns equatorial radius in units of e.Er.
//
// A is a common identifier for equatorial radius.
// 子午圈椭圆长半轴（赤道半径）
func (e Ellipsoid) A() float64 {
	return e.Er
}

// B returns polar radius in units of e.ER.
//
// B is a common identifier for polar radius.
//
// 子午圈椭圆短半轴（地心到极点的距离）
func (e Ellipsoid) B() float64 {
	return e.Er * (1 - e.Fl)
}

// Eccentricity of a meridian.
// 子午圈椭圆离心率
func (e Ellipsoid) Eccentricity() float64 {
	return math.Sqrt((2 - e.Fl) * e.Fl)
}

// ParallaxConstants computes parallax constants ρ sin φ′ and ρ cos φ′.
//
// Arguments are geographic latitude φ and height h above the ellipsoid.
// For e.Er in Km, h must be in meters.
// 海拔为h的观察点对应的ρ sin φ′，ρ cos φ′
func (e Ellipsoid) ParallaxConstants(φ unit.Angle, h float64) (s, c float64) {
	boa := 1 - e.Fl
	su, cu := math.Sincos(math.Atan(boa * φ.Tan()))
	s, c = φ.Sincos()
	hoa := h * 1e-3 / e.Er
	return su*boa + hoa*s, cu + hoa*c
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2-其他椭球公式&#34;&gt;2. 其他椭球公式&lt;/h2&gt;

&lt;p&gt;　　在椭球上给定的一点，地理纬度与地心纬度的差值为：$φ - φ′ = 692&amp;rdquo;.73sin(2φ) - 1&amp;rdquo;.16sin(4φ)$&lt;br /&gt;
　　当$u=45°$时，$φ-φ′$达到最大值。 如果$φ_0$和$φ_0′$是此时相应的地理纬度和地心纬度，我们有：$$tan(φ_0) = a/b，tan(φ_0′) = b/a， φ_0+φ_0′=90°$$
对于&lt;strong&gt;&lt;em&gt;IAU1976&lt;/em&gt;&lt;/strong&gt;($a = 6378.14km,b = 6356.755km,f=\frac {1}{298.257}$)
有
\begin{align}
φ_0 = 45°05′46&amp;rdquo;.36,\\[2ex]
φ_0′ = 44°54′13&amp;rdquo;.64,\\[2ex]
φ_0 - φ_0′ = 11′32&amp;rdquo;.73
\end{align}
　　海平面上，$$\rho =0.9983271+0.0016764\cos {2φ}-0.0000035\cos {4φ}$$
　　同纬度$φ$的圆的半径：$$R_p = \frac {a\cos φ}{\sqrt{(1-e^2\sin^2φ)}}$$
　　因此，在同一纬度$φ$上，经度变化1度，相应的长度变化为$(π/180)R_p$,线速度为$ωR_p$,其中$ω = 7.292114992*10^{-5}(弧度/秒)$&lt;br /&gt;
　　地球子午圈的曲率半径，在纬度$φ$：$$R_m=\frac {a(1-e^2)}{(1-e^2\sin ^2 φ)^{\frac 32}}$$
且纬度变化1度，相应的长度变化：$(π/180)R_m$,在赤道时，$R_m$达到最小值，值为$a(1-e^2)=6335.44km$， 在极点时达到最大值，值为$\frac {a}{\sqrt {1-e^2}}=6399.60km$&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Rho is distance from Earth center to a point on the ellipsoid at latitude φ.
//
// Result unit is fraction of the equatorial radius.
// 海平面上，ρ值计算
func Rho(φ unit.Angle) float64 {
	// Magic numbers...
	return .9983271 + .0016764*φ.Mul(2).Cos() - .0000035*φ.Mul(4).Cos()
}

// RadiusAtLatitude returns the radius of the circle that is the parallel of
// latitude φ.
//
// Result unit is same as e.Er (typically Km.)
// 同纬度圆半径
func (e Ellipsoid) RadiusAtLatitude(φ unit.Angle) float64 {
	s, c := φ.Sincos()
	return e.A() * c / math.Sqrt(1-(2-e.Fl)*e.Fl*s*s)
}

// OneDegreeOfLongitude returns the length of one degree of longitude.
//
// Argument rp is the radius of a circle that is a parallel of latitude
// (as returned by Ellipsoid.RadiusAtLatitude.)
//
// Result is distance along one degree of the circle, in same units as rp.
// 同纬度，计算经度变化1度时长度变化的值
func OneDegreeOfLongitude(rp float64) float64 {
	return rp * math.Pi / 180
}

// RotationRate1996_5 is the rotational angular velocity of the Earth
// with respect to the stars at the epoch 1996.5.
//
// Unit is radian/second.
const RotationRate1996_5 = 7.292114992e-5

// RadiusOfCurvature of meridian at latitude φ.
//
// Result in units of e.ER, typically Km.
// 纬度为φ，子午圈曲率半径
func (e Ellipsoid) RadiusOfCurvature(φ unit.Angle) float64 {
	s := φ.Sin()
	e2 := (2 - e.Fl) * e.Fl
	return e.A() * (1 - e2) / math.Pow(1-e2*s*s, 1.5)
}

// OneDegreeOfLatitude returns the length of one degree of latitude.
//
// Argument rm is the radius of curvature along a meridian.
// (as returned by Ellipsoid.RadiusOfCurvature.)
// Result is distance in units of rm along one degree of the meridian.
// 同经度，计算纬度变化1度时长度变化的值
func OneDegreeOfLatitude(rm float64) float64 {
	return rm * math.Pi / 180
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;3-地表两点间的距离&#34;&gt;3. 地表两点间的距离&lt;/h2&gt;

&lt;p&gt;　　假设经纬度是分别是$(L_1,φ_1),(L_2,φ_2)$，且这两点在海平面。
　　如果精度要求不高，可以把地球看作球形，平均半径为6371km。使用下式可得到两点间的角距离：$$\cos d=\sin φ_1\sin φ_2 +\cos φ_1\cos φ_2\cos(L_1-L_2)$$
那么$$s = \frac {6371πd}{180}$$
　　高精度计算可使用以下方法：
$$F=\frac {φ_1+φ_2}{2},G=\frac {φ_1-φ_2}{2},\lambda = \frac {L_1-L_2}{2}$$
$$S = \sin^2G\cos^2\lambda+\cos^2F\sin^2\lambda$$
$$C = \cos^2G\cos^2\lambda+\sin^2F\sin^2\lambda$$
$$\tan ω = \sqrt{\frac SC}$$
$$R=\frac{\sqrt{SC}}{ω}$$
$$D=2ωa,H_1=\frac{3R-1}{2C},H_2=\frac{3R+1}{2S}$$
$$s=D(1+fH_1\sin^2F\cos^2G-fH_2\cos^2F\sin^2G)$$&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Distance is distance between two points measured along the surface
// of an ellipsoid.
//
// Accuracy is much better than that of ApproxAngularDistance or
// ApproxLinearDistance.
//
// Result unit is units of e.Er, typically Km.
// 地表两点距离
func (e Ellipsoid) Distance(c1, c2 Coord) float64 {
	// From AA, ch 11, p 84.
	s2f, c2f := sincos2((c1.Lat + c2.Lat) / 2)
	s2g, c2g := sincos2((c1.Lat - c2.Lat) / 2)
	s2λ, c2λ := sincos2((c1.Lon - c2.Lon) / 2)
	s := s2g*c2λ + c2f*s2λ
	c := c2g*c2λ + s2f*s2λ
	ω := math.Atan(math.Sqrt(s / c))
	r := math.Sqrt(s*c) / ω
	d := 2 * ω * e.Er
	h1 := (3*r - 1) / (2 * c)
	h2 := (3*r + 1) / (2 * s)
	return d * (1 + e.Fl*(h1*s2f*c2g-h2*c2f*s2g))
}

func sincos2(x unit.Angle) (s2, c2 float64) {
	s, c := x.Sincos()
	return s * s, c * c
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>天文算法8</title>
      <link>https://mooncaker816.github.io/2018/05/17/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%958/</link>
      <pubDate>Thu, 17 May 2018 09:56:34 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/05/17/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%958/</guid>
      <description>&lt;h1 id=&#34;第十章-力学时和世界时-dynamical-time-universal-time&#34;&gt;第十章 力学时和世界时 Dynamical Time &amp;amp; Universal Time&lt;/h1&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-力学时&#34;&gt;1. 力学时&lt;/h2&gt;

&lt;p&gt;　　力学时（Dynamical Time，简称DT）是一种从历书时(ET)到地球时(TT)过渡的时间尺度。分为地球力学时（Temps Dynamique Terrestrique，简称TDT）和质心力学时（Temps Dynamique Barycentrique，简称TDB）两种。&lt;/p&gt;

&lt;p&gt;　　1958年国际天文学联合会（IAU）决定从1960年开始使用以地球公转运动为基准的历书时（ET）代替以地球自转为基准的世界时（UT），目的是解决由于地球自转速度不均匀导致的世界时的时间尺度不均匀的问题。但是由于历书时所用的基准地球运动的理论框架是牛顿力学，根据广义相对论可知，在以太阳为中心的坐标系和以地球为中心的坐标系中时间将会不同。为解决这一问题，1976年国际天文学联合会分别定义了地球力学时（TDT）和质心力学时（TDB）。这两个时间尺度可以看作是历书时在两个坐标系中的实现。1991年，地球力学时被重新精确定义后改名为地球时（TT）。&lt;/p&gt;

&lt;p&gt;　　太阳系质心力学时（TDB）和地心力学时（TDT） 的区分。这两个系统最多相差 0.0017 秒，此种差异与地球以椭圆轨道绕日运动有关(相对论效应)。因这一差异小到可以被大多数实际应用忽略，&lt;strong&gt;&lt;em&gt;故此处我们对质心力学时和地球力学时不加区分，统称为力学时(TD)。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;/p&gt;

&lt;h2 id=&#34;2-世界时&#34;&gt;2. 世界时&lt;/h2&gt;

&lt;p&gt;　　世界时（Universal Time，简称UT）是一种以格林尼治子夜起算的平太阳时。世界时是以地球自转为基准得到的时间尺度，其精度受到地球自转不均匀变化和极移的影响，为了解决这种影响，1955年国际天文联合会定义了UT0、UT1和UT2三个系统：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;UT0系统是由一个天文台的天文观测直接测定的世界时，没有考虑极移造成的天文台地理坐标变化。该系统曾长期被认为是稳定均匀的时间计量系统，得到过广泛应用。&lt;/li&gt;
&lt;li&gt;UT1系统是在UT0的基础上加入了极移改正 Δλ，修正地轴摆动的影响。&lt;strong&gt;UT1是目前使用的世界时标准。被作为目前世界民用时间标准UTC在增减闰秒时的参照标准。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;UT2系统是UT1的平滑处理版本，在UT1基础上加入了地球自转速率的季节性改正 ΔT。&lt;/li&gt;
&lt;li&gt;它们之间的关系可以表示为：
\begin{align}
UT1 = UT0 + Δλ\\[2ex]
UT2 = UT1 + ΔT
\end{align}&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　&lt;/p&gt;

&lt;h2 id=&#34;3-协调世界时&#34;&gt;3. 协调世界时&lt;/h2&gt;

&lt;p&gt;　　协调世界时（英语：Coordinated Universal Time，法语：Temps Universel Coordonné，简称UTC）是最主要的世界时间标准，其以原子时秒长为基础，在时刻上尽量接近于格林尼治标准时间。&lt;/p&gt;

&lt;p&gt;　　协调世界时是世界上调节时钟和时间的主要时间标准，它与0度经线的平太阳时相差不超过1秒，并不遵守夏令时。协调世界时是最接近格林威治标准时间（GMT）的几个替代时间系统之一。对于大多数用途来说，UTC时间被认为能与GMT时间互换，但GMT时间已不再被科学界所确定。&lt;/p&gt;

&lt;p&gt;　　UTC基于国际原子时，并通过不规则的加入闰秒来抵消地球自转变慢的影响。闰秒在必要的时候会被插入到UTC中，以保证协调世界时（UTC）与世界时（UT1）相差不超过0.9秒。&lt;/p&gt;

&lt;p&gt;　　为了保证协调世界时很接近世界时UT1，UTC从基于TAI的线性方程转变成另一方程时，偶尔会出现不连续点。这些不连续点以闰秒的形式体现出来，这些不连续点就是造成了UTC天的长度不规则的闰秒。IERS规定不连续点仅出现在6月或12月底，但也有规定将3月或者9月作为备选。国际地球自转服务组织(IERS)跟踪并公布UTC时间和世界时的差别，即$DUT1 = UT1 - UTC$，另外，IERS也负责引入不连续的闰秒来保证它们的时间差DUT1在±0.9秒之间。&lt;/p&gt;

&lt;p&gt;　　&lt;/p&gt;

&lt;h2 id=&#34;4-计算力学时和世界时之间的差值&#34;&gt;4. 计算力学时和世界时之间的差值&lt;/h2&gt;

&lt;p&gt;　　由于地球自转一直在变缓，而且变缓规律难以预测，力学时和世界时之间的精确差值 $ΔT = TD - UT$ 只能由天文观测值推算。&lt;br /&gt;
　　书中给出了1620年至1998年的ΔT数据，所以在此之间的时间可以通过插值法来计算，其余时期的数据可以用以下方式推算：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;令 $t=\frac {year-2000}{100}$&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// c2000 returns centuries from calendar year 2000.0.
//
// Arg should be a calendar year.
// 计算年份y距离2000年的世纪数
func c2000(y float64) float64 {
    return (y - 2000) * .01
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;$ΔT = 2177 + 497t + 44.1t^2, year &amp;lt; +948 $&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// PolyBefore948 returns a polynomial approximation of ΔT valid for calendar
// years before 948.
// +948年之前的ΔT推算公式
func PolyBefore948(year float64) (ΔT unit.Time) {
    // (10.1) p. 78
    return unit.Time(base.Horner(c2000(year), 2177, 497, 44.1))
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;$ΔT = 102 + 102t + 25.3t^2, +948 \leq year \leq +1600 || year \geq +2000 $&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Poly948to1600 returns a polynomial approximation of ΔT valid for calendar
// years 948 to 1600.
// +984年至1600年的ΔT推算公式
func Poly948to1600(year float64) (ΔT unit.Time) {
    // (10.2) p. 78
    return unit.Time(base.Horner(c2000(year), 102, 102, 25.3))
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;若 $+2000 \leq year \leq +2100$, 还要在第3步的基础上加上一个修正量$+0.37(year-2100)$&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// PolyAfter2000 returns a polynomial approximation of ΔT valid for calendar
// years after 2000.
// 2000年以后的ΔT推算公式
func PolyAfter2000(year float64) (ΔT unit.Time) {
    ΔT = Poly948to1600(year)
    if year &amp;lt; 2100 {
        ΔT += unit.Time(.37 * (year - 2100))
    }
    return
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;经验公式：&lt;/p&gt;

&lt;p&gt;5.0 $\  儒略日世纪数\theta=\frac {JDE-J1900.0}{36525},J1900.0=2415020.0(1899-12-31)$&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// jc1900 returns julian centuries from the epoch J1900.0
//
// Arg should be a julian day, technically JDE.
// 计算儒略日jde距离J1900.0的世纪数
func jc1900(jde float64) float64 {
    return (jde - base.J1900) / base.JulianCentury
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5.1 $\  1800 - 1997$：(最大误差2.3秒)
    \begin{align}
    ΔT = &amp;amp;-1.02 + 91.02\theta + 265.90\theta^2 - 839.16\theta^3 - 1545.20\theta^4 \\[2ex]
    &amp;amp;+ 3603.62\theta^5 + 4385.98\theta^6 - 6993.23\theta^7 - 6090.04\theta^8 \\[2ex]
    &amp;amp;+ 6298.12\theta^9 + 4102.86\theta^{10} - 2137.64\theta^{11} - 1081.51\theta^{12}
    \end{align}&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Poly1800to1997 returns a polynomial approximation of ΔT valid for years
// 1800 to 1997.
//
// The accuracy is within 2.3 seconds.
// 1800至1997ΔT经验公式，最大误差2.3秒
func Poly1800to1997(jde float64) (ΔT unit.Time) {
    return unit.Time(base.Horner(jc1900(jde),
        -1.02, 91.02, 265.90, -839.16, -1545.20,
        3603.62, 4385.98, -6993.23, -6090.04,
        6298.12, 4102.86, -2137.64, -1081.51))
}    
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5.2 $\  1800 - 1899$：(最大误差0.9秒)
    \begin{align}
    ΔT = &amp;amp;-2.50 + 228.95\theta + 5218.61\theta^2 + 56282.84\theta^3 + 324011.78\theta^4 \\[2ex]
    &amp;amp;+ 1061660.75\theta^5 + 2087298.89\theta^6 + 2513807.78\theta^7 + 1818961.41\theta^8 \\[2ex]
    &amp;amp;+ 727058.63\theta^9 + 123563.95\theta^{10}
    \end{align}&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Poly1800to1899 returns a polynomial approximation of ΔT valid for years
// 1800 to 1899.
//
// The accuracy is within 0.9 seconds.
// 1800至1899ΔT经验公式，最大误差0.9秒
func Poly1800to1899(jde float64) (ΔT unit.Time) {
    return unit.Time(base.Horner(jc1900(jde),
        -2.50, 228.95, 5218.61, 56282.84, 324011.78,
        1061660.75, 2087298.89, 2513807.78,
        1818961.41, 727058.63, 123563.95))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5.3 $\  1900 - 1997$：(最大误差0.9秒)
    \begin{align}
    ΔT = &amp;amp;-2.44 + 87.24\theta + 815.20\theta^2 - 2637.80\theta^3 - 18756.33\theta^4 \\[2ex]
    &amp;amp;+ 124906.15\theta^5 - 303191.19\theta^6 + 372919.88\theta^7 - 232424.66\theta^8 \\[2ex]
    &amp;amp;+ 58353.42\theta^9
    \end{align}&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Poly1900to1997 returns a polynomial approximation of ΔT valid for years
// 1900 to 1997.
//
// The accuracy is within 0.9 seconds.
// 1900至1997ΔT经验公式，最大误差0.9秒
func Poly1900to1997(jde float64) (ΔT unit.Time) {
    return unit.Time(base.Horner(jc1900(jde),
        -2.44, 87.24, 815.20, -2637.80, -18756.33,
        124906.15, -303191.19, 372919.88,
        -232424.66, 58353.42))
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>天文算法7</title>
      <link>https://mooncaker816.github.io/2018/05/17/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%957/</link>
      <pubDate>Thu, 17 May 2018 08:56:34 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/05/17/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%957/</guid>
      <description>&lt;h1 id=&#34;第九章-犹太历和穆斯林历&#34;&gt;第九章 犹太历和穆斯林历&lt;/h1&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;略&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>天文算法6</title>
      <link>https://mooncaker816.github.io/2018/05/17/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%956/</link>
      <pubDate>Thu, 17 May 2018 07:40:44 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/05/17/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%956/</guid>
      <description>&lt;h1 id=&#34;第八章-复活节日-date-of-easter&#34;&gt;第八章 复活节日 Date of Easter&lt;/h1&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;　　对西方的节日没有多少了解，这里就直接给出书中的算法吧~&lt;/p&gt;

&lt;h2 id=&#34;1-格里历复活节算法&#34;&gt;1. 格里历复活节算法&lt;/h2&gt;

&lt;p&gt;\begin{array}{l|ccc}
被除数 &amp;amp; 除数 &amp;amp; 商 &amp;amp; 余数 \\&lt;br /&gt;
\hline
年份y &amp;amp; 19 &amp;amp; - &amp;amp; a \\&lt;br /&gt;
年份y &amp;amp; 100 &amp;amp; b &amp;amp; c \\&lt;br /&gt;
b &amp;amp; 4 &amp;amp; d &amp;amp; e \\&lt;br /&gt;
b+8 &amp;amp; 25 &amp;amp; f &amp;amp; - \\&lt;br /&gt;
b-f+1 &amp;amp; 3 &amp;amp; g &amp;amp; - \\&lt;br /&gt;
19a+b-d-g+15 &amp;amp; 30 &amp;amp; - &amp;amp; h \\&lt;br /&gt;
c &amp;amp; 4 &amp;amp; i &amp;amp; k \\&lt;br /&gt;
32+2e+2i-h-k &amp;amp; 7 &amp;amp; - &amp;amp; l \\&lt;br /&gt;
a+11h+22l &amp;amp; 451 &amp;amp; m &amp;amp; - \\&lt;br /&gt;
h+l-7m+114 &amp;amp; 31 &amp;amp; n &amp;amp; p \\&lt;br /&gt;
\end{array}&lt;/p&gt;

&lt;p&gt;得 $$n = 月份, \ p+1 = 日期$$&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Gregorian returns month and day of Easter in the Gregorian calendar.
// 格里历复活节日算法
func Gregorian(y int) (m, d int) {
	a := y % 19
	b, c := y/100, y%100
	d, e := b/4, b%4
	f := (b + 8) / 25
	g := (b - f + 1) / 3
	h := (19*a + b - d - g + 15) % 30
	i, k := c/4, c%4
	l := (32 + 2*e + 2*i - h - k) % 7
	m = (a + 11*h + 22*l) / 451
	n := h + l - 7*m + 114
	n, p := n/31, n%31
	return n, p + 1
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2-儒略历复活节算法&#34;&gt;2. 儒略历复活节算法&lt;/h2&gt;

&lt;p&gt;\begin{array}{l|ccc}
被除数 &amp;amp; 除数 &amp;amp; 商 &amp;amp; 余数 \\&lt;br /&gt;
\hline
年份y &amp;amp; 4 &amp;amp; - &amp;amp; a \\&lt;br /&gt;
年份y &amp;amp; 7 &amp;amp; - &amp;amp; b \\&lt;br /&gt;
年份y &amp;amp; 19 &amp;amp; - &amp;amp; c \\&lt;br /&gt;
19c+15 &amp;amp; 30 &amp;amp; - &amp;amp; d \\&lt;br /&gt;
2a+4b-d+34 &amp;amp; 7 &amp;amp; - &amp;amp; e \\&lt;br /&gt;
d+e+114 &amp;amp; 31 &amp;amp; f &amp;amp; g \\&lt;br /&gt;
\end{array}&lt;/p&gt;

&lt;p&gt;得 $$f = 月份, \ g+1 = 日期$$&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Julian returns month and day of Easter in the Julian calendar.
// 儒略历复活节日算法
func Julian(y int) (m, d int) {
	a := y % 4
	b := y % 7
	c := y % 19
	d = (19*c + 15) % 30
	e := (2*a + 4*b - d + 34) % 7
	f := d + e + 114
	f, g := f/31, f%31
	return f, g + 1
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
  </channel>
</rss>
