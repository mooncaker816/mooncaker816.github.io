<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Mooncaker816 on Mooncaker816</title>
    <link>https://mooncaker816.github.io/</link>
    <description>Recent content in Mooncaker816 on Mooncaker816</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <copyright>&amp;copy; 2018-Present</copyright>
    <lastBuildDate>Wed, 20 Apr 2016 00:00:00 +0800</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>天文算法27</title>
      <link>https://mooncaker816.github.io/2018/05/28/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9527/</link>
      <pubDate>Mon, 28 May 2018 10:35:29 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/05/28/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9527/</guid>
      <description>&lt;h1 id=&#34;第二十九章-ephemeris-for-physical-observations-of-the-sun&#34;&gt;第二十九章 Ephemeris for Physical Observations of the Sun&lt;/h1&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-日面计算&#34;&gt;1. 日面计算&lt;/h2&gt;

&lt;p&gt;$P$ 为日轴方位角，自日面北点量起的太阳自转轴北端的方位角，向东为正&lt;br /&gt;
$B_0$ 为日面中心的日面纬度&lt;br /&gt;
$L_0$ 为日面中心的日面经度&lt;/p&gt;

&lt;p&gt;根据之前章节的算法，先计算太阳视黄经$λ$(包含光行差修正)，$λ&amp;rsquo;$为$λ$的黄经章动修正值，$ε$为真黄赤交角&lt;br /&gt;
再计算
\begin{cases}
θ = (JD - 2398220)\frac {360°}{25.38}\\[2ex]
I = 7°.25,(太阳赤道与黄道的倾角)\\[2ex]
K = 73°.6667 + 1°.3958333\frac {JD - 2396758}{36525},(太阳赤道与黄道的升交点的黄经)\\[2ex]
\tan x = -\cos λ&amp;rsquo;\tan ε\\[2ex]
\tan y = -\cos (λ - K)\tan I
\end{cases}
那么
\begin{cases}
P = x+y\\[2ex]
\sin B_0 = \sin(λ - K)\sin I\\[2ex]
\tan η = \frac {-\sin(λ - K)\cos I}{-\cos (λ - K)}\\[2ex]
L_0 = η-θ
\end{cases}&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Ephemeris returns the apparent orientation of the sun at the given jd.
// 计算日面参数
//
// Results:
//	P:  Position angle of the solar north pole.
//	B0: Heliographic latitude of the center of the solar disk.
//	L0: Heliographic longitude of the center of the solar disk.
func Ephemeris(jd float64, e *pp.V87Planet) (P, B0, L0 unit.Angle) {
	θ := unit.Angle((jd - 2398220) * 2 * math.Pi / 25.38)
	I := unit.AngleFromDeg(7.25)
	K := unit.AngleFromDeg(73.6667) +
		unit.AngleFromDeg(1.3958333).Mul((jd-2396758)/base.JulianCentury)

	L, _, R := solar.TrueVSOP87(e, jd)
	Δψ, Δε := nutation.Nutation(jd)
	ε0 := nutation.MeanObliquity(jd)
	ε := ε0 + Δε
	λ := L - unit.AngleFromSec(20.4898).Div(R)
	λp := λ + Δψ

	sλK, cλK := (λ - K).Sincos()
	sI, cI := I.Sincos()

	tx := -(λp.Cos() * ε.Tan())
	ty := -(cλK * I.Tan())
	P = unit.Angle(math.Atan(tx) + math.Atan(ty))
	B0 = unit.Angle(math.Asin(sλK * sI))
	η := unit.Angle(math.Atan2(-sλK*cI, -cλK))
	L0 = (η - θ).Mod1()
	return
}

// Cycle returns the jd of the start of the given synodic rotation.
//
// Argument c is the &amp;quot;Carrington&amp;quot; cycle number.
//
// Result is a dynamical time (not UT).
func Cycle(c int) (jde float64) {
	cf := float64(c)
	jde = 2398140.227 + 27.2752316*cf
	m := 281.96*math.Pi/180 + 26.882476*math.Pi/180*cf
	s2m, c2m := math.Sincos(2 * m)
	return jde + .1454*math.Sin(m) - .0085*s2m - .0141*c2m
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>天文算法26</title>
      <link>https://mooncaker816.github.io/2018/05/28/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9526/</link>
      <pubDate>Mon, 28 May 2018 09:25:36 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/05/28/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9526/</guid>
      <description>&lt;h1 id=&#34;第二十八章-equation-of-time-均时差&#34;&gt;第二十八章 Equation of Time 均时差&lt;/h1&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-均时差的概念&#34;&gt;1. 均时差的概念&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%9D%87%E6%99%82%E5%B7%AE&#34; target=&#34;_blank&#34;&gt;均时差&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;2-计算时差&#34;&gt;2. 计算时差&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;VSOP87理论计算&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;$$E = L_0 - 0°.0057183 - α + Δψ·\cos ε$$
其中$α$为太阳地心视赤经，$Δψ$为赤经章动，$ε$为真黄赤交角，$L_0$为太阳平黄经
$$L_0 = 280.4664567 + 360007.6982779τ + 0.03032028τ^2 + τ^3 /49931 - τ^4 /15300 - τ^5 /2000000$$
$τ$为儒略日千年数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// E computes the &amp;quot;equation of time&amp;quot; for the given JDE.
// 计算时差
//
// Parameter e must be a planetposition.V87Planet object for Earth obtained
// with planetposition.LoadPlanet.
//
// Result is equation of time as an hour angle.
func E(jde float64, e *pp.V87Planet) unit.HourAngle {
	τ := base.J2000Century(jde) * .1 // J2000儒略日千年数
	L0 := l0(τ)
	// code duplicated from solar.ApparentEquatorialVSOP87 so that
	// we can keep Δψ and cε
	s, β, R := solar.TrueVSOP87(e, jde) // 真太阳黄经
	Δψ, Δε := nutation.Nutation(jde)
	a := unit.AngleFromSec(-20.4898).Div(R) //光行差
	λ := s + Δψ + a                         //视黄经
	ε := nutation.MeanObliquity(jde) + Δε   // 真黄赤交角
	sε, cε := ε.Sincos()
	α, _ := coord.EclToEq(λ, β, sε, cε) // 视赤经
	// (28.1) p. 183
	E := L0 - unit.AngleFromDeg(.0057183) - unit.Angle(α) + Δψ.Mul(cε)
	return unit.HourAngle((E + math.Pi).Mod1() - math.Pi)
}

// (28.2) p. 183
// 太阳平黄经
func l0(τ float64) unit.Angle {
	return unit.AngleFromDeg(base.Horner(τ,
		280.4664567, 360007.6982779, .03032028,
		1./49931, -1./15300, -1./2000000))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;低精度时差计算&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;$$E = y\sin 2L_0 - 2e\sin M + 4ey\sin M \cos 2L_0 - \frac 12y^2\sin 4L_0 - \frac 54 e^2\sin 2M$$
其中$y = \tan^2(ε/2)，ε是平黄赤交角,L_0为太阳平黄经，e为地球轨道离心率，M为太阳平近点角$&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// ESmart computes the &amp;quot;equation of time&amp;quot; for the given JDE.
// 低精度计算时差
//
// Result is equation of time as an hour angle.
//
// Result is less accurate that E() but the function has the advantage
// of not requiring the V87Planet object.
func ESmart(jde float64) unit.HourAngle {
	ε := nutation.MeanObliquity(jde) // 平黄赤交角
	t := ε.Mul(.5).Tan()
	y := t * t
	T := base.J2000Century(jde)
	L0 := l0(T * .1)
	e := solar.Eccentricity(T) //地球轨道离心率
	M := solar.MeanAnomaly(T)  // 太阳平近点角
	s2L0, c2L0 := L0.Mul(2).Sincos()
	sM := M.Sin()
	// (28.3) p. 185, with double angle identity
	return unit.HourAngle(y*s2L0 - 2*e*sM + 4*e*y*sM*c2L0 -
		y*y*s2L0*c2L0 - 1.25*e*e*M.Mul(2).Sin())
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>天文算法25</title>
      <link>https://mooncaker816.github.io/2018/05/26/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9525/</link>
      <pubDate>Sat, 26 May 2018 08:58:00 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/05/26/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9525/</guid>
      <description>&lt;h1 id=&#34;第二十七章-分点和至点-equinoxes-and-solstices&#34;&gt;第二十七章 分点和至点 Equinoxes and Solstices&lt;/h1&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;分点（英语：equinox，或称二分点）是想像中天球赤道在天球上的位置，是每年太阳穿过天球赤道和黄道在天球上交点的天文事件[1]，这造成地球上各地的白天和夜晚几乎等长。&lt;/p&gt;

&lt;p&gt;二至点（亦称至点）可以是太阳在一年之中离地球赤道最远的两个事件中的任何一个，英文的字源（solstice） 来自拉丁文的太阳（sol）和保持直立（sistere），因为在至点时太阳直射的地球纬度是他能抵达的最南或最北的极值，而至点所在之日是一年之中日夜长短差异最大的一天。&lt;/p&gt;

&lt;p&gt;分点和至点时刻是指：太阳的地心视黄经(含光行差和章动)为90的整数倍时对应的时刻。因太阳黄纬不是真正为零的，所以在分点时刻太阳赤纬也不是真正为零的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://garyborjesson.files.wordpress.com/2013/03/equ-schem.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-近似时刻计算-最大误差1分钟&#34;&gt;1. 近似时刻计算(最大误差1分钟)&lt;/h2&gt;

&lt;p&gt;先找到平分点或平至点$JDE_0$&lt;br /&gt;
当$year \in [-1000,1000)$时，
\begin{cases}
Y = \frac {year}{1000}\\[2ex]
春分点：JDE_0 = 1721139.29189 + 365242.13740Y + 0.06134Y^2 + 0.00111Y^3 - 0.00071Y^4\\[2ex]
夏至点：JDE_0 = 1721233.25401 + 365241.72562Y - 0.05323Y^2 + 0.00907Y^3 + 0.00025Y^4\\[2ex]
秋分点：JDE_0 = 1721325.70455 + 365242.49558Y - 0.11677Y^2 - 0.00297Y^3 + 0.00074Y^4\\[2ex]
冬至点：JDE_0 = 1721414.39987 + 365242.88257Y - 0.00769Y^2 - 0.00933Y^3 - 0.00006Y^4\\[2ex]
\end{cases}
当$year \in [1000,3000]$时，
\begin{cases}
Y = \frac {year-2000}{1000}\\[2ex]
春分点：JDE_0 = 2451623.80984 + 365242.37404Y + 0.05169Y^2 - 0.00411Y^3 - 0.00057Y^4\\[2ex]
夏至点：JDE_0 = 2451716.56767 + 365241.62603Y + 0.00325Y^2 + 0.00888Y^3 - 0.00030Y^4\\[2ex]
秋分点：JDE_0 = 2451810.21715 + 365242.01767Y - 0.11575Y^2 + 0.00337Y^3 + 0.00078Y^4\\[2ex]
冬至点：JDE_0 = 2451900.05952 + 365242.74049Y - 0.06223Y^2 - 0.00823Y^3 + 0.00032Y^4\\[2ex]
\end{cases}
再计算
\begin{cases}
T &amp;amp;= \frac {JDE_0 - 2451545.0}{36525}\\[2ex]
W &amp;amp;= 35999°.373T - 2°.47\\[2ex]
Δλ &amp;amp;= 1 + 0.0334\cos W + 0.0007\cos (2W)\\[2ex]
S &amp;amp;= \sum A\cos(B+CT)
\end{cases}
其中$A,B,C$分别为下表中的系数项&lt;img src=&#34;https://mooncaker816.github.io/img/分至点.png&#34; alt=&#34;&#34; /&gt;
那么$$JDE = JDE_0 + \frac {0.00001S}{Δλ} days$$
注意此时得到的力学时DT，可以按需再转为UT&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var (
	mc0 = []float64{1721139.29189, 365242.13740, .06134, .00111, -.00071}
	jc0 = []float64{1721233.25401, 365241.72562, -.05232, .00907, .00025}
	sc0 = []float64{1721325.70455, 365242.49558, -.11677, -.00297, .00074}
	dc0 = []float64{1721414.39987, 365242.88257, -.00769, -.00933, -.00006}

	mc2 = []float64{2451623.80984, 365242.37404, .05169, -.00411, -.00057}
	jc2 = []float64{2451716.56767, 365241.62603, .00325, .00888, -.00030}
	sc2 = []float64{2451810.21715, 365242.01767, -.11575, .00337, .00078}
	dc2 = []float64{2451900.05952, 365242.74049, -.06223, -.00823, .00032}
)

type term struct {
	a, b, c float64
}

var terms = []term{
	{485, 324.96, 1934.136},
	{203, 337.23, 32964.467},
	{199, 342.08, 20.186},
	{182, 27.85, 445267.112},
	{156, 73.14, 45036.886},
	{136, 171.52, 22518.443},
	{77, 222.54, 65928.934},
	{74, 296.72, 3034.906},
	{70, 243.58, 9037.513},
	{58, 119.81, 33718.147},
	{52, 297.17, 150.678},
	{50, 21.02, 2281.226},

	{45, 247.54, 29929.562},
	{44, 325.15, 31555.956},
	{29, 60.93, 4443.417},
	{18, 155.12, 67555.328},
	{17, 288.79, 4562.452},
	{16, 198.04, 62894.029},
	{14, 199.76, 31436.921},
	{12, 95.39, 14577.848},
	{12, 287.11, 31931.756},
	{12, 320.81, 34777.259},
	{9, 227.73, 1222.114},
	{8, 15.45, 16859.074},
}

// March returns the JDE of the March equinox for the given year.
// 计算y年春分点力学时，y∈[-1000,3000]
//
// Results are valid for the years -1000 to +3000.
//
// Accuracy is within one minute of time for the years 1951-2050.
func March(y int) float64 {
	if y &amp;lt; 1000 {
		return eq(y, mc0)
	}
	return eq(y-2000, mc2)
}

// June returns the JDE of the June solstice for the given year.
// 计算y年夏至点力学时，y∈[-1000,3000]
//
// Results are valid for the years -1000 to +3000.
//
// Accuracy is within one minute of time for the years 1951-2050.
func June(y int) float64 {
	if y &amp;lt; 1000 {
		return eq(y, jc0)
	}
	return eq(y-2000, jc2)
}

// September returns the JDE of the September equinox for the given year.
// 计算y年秋分点力学时，y∈[-1000,3000]
//
// Results are valid for the years -1000 to +3000.
//
// Accuracy is within one minute of time for the years 1951-2050.
func September(y int) float64 {
	if y &amp;lt; 1000 {
		return eq(y, sc0)
	}
	return eq(y-2000, sc2)
}

// December returns the JDE of the December solstice for a given year.
// 计算y年冬至点力学时，y∈[-1000,3000]
//
// Results are valid for the years -1000 to +3000.
//
// Accuracy is within one minute of time for the years 1951-2050.
func December(y int) float64 {
	if y &amp;lt; 1000 {
		return eq(y, dc0)
	}
	return eq(y-2000, dc2)
}

func eq(y int, c []float64) float64 {
	J0 := base.Horner(float64(y)*.001, c...)
	T := base.J2000Century(J0)
	W := 35999.373*math.Pi/180*T - 2.47*math.Pi/180
	Δλ := 1 + .0334*math.Cos(W) + .0007*math.Cos(2*W)
	S := 0.
	for i := len(terms) - 1; i &amp;gt;= 0; i-- {
		t := &amp;amp;terms[i]
		S += t.a * math.Cos((t.b+t.c*T)*math.Pi/180)
	}
	return J0 + .00001*S/Δλ
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2-高精度分至点时刻计算&#34;&gt;2. 高精度分至点时刻计算&lt;/h2&gt;

&lt;p&gt;　　先用低精度方法算出近似时刻，再采用VSOP87理论计算出该时刻的太阳视黄经$λ$，&lt;br /&gt;
　　再根据各个分至点的几何度数按以下公式求该近似时刻的修正量，循环迭代，直至满足要求。
　　$$+58\sin (k90° - λ)$$
　　其中k=0,1,2,3分别对应春夏秋冬四个分至点&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// March2 returns a more accurate JDE of the March equinox.
// 高精度计算春分点力学时
//
// Result is accurate to one second of time.
//
// Parameter e must be a V87Planet object representing Earth, obtained with
// the package planetposition and code similar to
//
//	e, err := planetposition.LoadPlanet(planetposition.Earth, &amp;quot;&amp;quot;)
//	    if err != nil {
//	        ....
//
// See example under June2.
func March2(y int, e *pp.V87Planet) float64 {
	if y &amp;lt; 1000 {
		return eq2(y, e, 0, mc0)
	}
	return eq2(y-2000, e, 0, mc2)
}

// June2 returns a more accurate JDE of the June solstice.
// 高精度计算夏至点力学时
//
// Result is accurate to one second of time.
//
// Parameter e must be a V87Planet object representing Earth, obtained with
// the package planetposition.
func June2(y int, e *pp.V87Planet) float64 {
	if y &amp;lt; 1000 {
		return eq2(y, e, math.Pi/2, jc0)
	}
	return eq2(y-2000, e, math.Pi/2, jc2)
}

// September2 returns a more accurate JDE of the September equinox.
// 高精度计算秋分点力学时
//
// Result is accurate to one second of time.
//
// Parameter e must be a V87Planet object representing Earth, obtained with
// the package planetposition and code similar to
//
//	e, err := planetposition.LoadPlanet(planetposition.Earth, &amp;quot;&amp;quot;)
//	    if err != nil {
//	        ....
//
// See example under June2.
func September2(y int, e *pp.V87Planet) float64 {
	if y &amp;lt; 1000 {
		return eq2(y, e, math.Pi, sc0)
	}
	return eq2(y-2000, e, math.Pi, sc2)
}

// December2 returns a more accurate JDE of the December solstice.
// 高精度计算冬至点力学时
//
// Result is accurate to one second of time.
//
// Parameter e must be a V87Planet object representing Earth, obtained with
// the package planetposition and code similar to
//
//	e, err := planetposition.LoadPlanet(planetposition.Earth, &amp;quot;&amp;quot;)
//	    if err != nil {
//	        ....
//
// See example under June2.
func December2(y int, e *pp.V87Planet) float64 {
	if y &amp;lt; 1000 {
		return eq2(y, e, math.Pi*3/2, dc0)
	}
	return eq2(y-2000, e, math.Pi*3/2, dc2)
}

//先用低精度方法算出近似时刻，再采用VSOP87理论计算出该时刻的太阳视黄经λ，
//再根据各个分至点的几何度数求该近似时刻的修正量，循环迭代，直至满足要求。
func eq2(y int, e *pp.V87Planet, q unit.Angle, c []float64) float64 {
	J0 := base.Horner(float64(y)*.001, c...)
	for {
		λ, _, _ := solar.ApparentVSOP87(e, J0)
		c := 58 * (q - λ).Sin() // (27.1) p. 180
		J0 += c
		if math.Abs(c) &amp;lt; .000005 {
			break
		}
	}
	return J0
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>天文算法24</title>
      <link>https://mooncaker816.github.io/2018/05/25/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9524/</link>
      <pubDate>Fri, 25 May 2018 13:59:39 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/05/25/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9524/</guid>
      <description>&lt;h1 id=&#34;第二十六章-太阳直角坐标-rectangular-coordinates-of-the-sun&#34;&gt;第二十六章 太阳直角坐标 Rectangular Coordinates of the Sun&lt;/h1&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;　　太阳的地心赤道直角坐标$X,Y,Z$。原点在地心。$X$轴的方向指向春分点（经度为0），$Y$轴平放在赤道面上， 经度是90°，$Z$轴方向是北极。&lt;/p&gt;

&lt;h2 id=&#34;1-date-平分点参考系&#34;&gt;1. Date 平分点参考系&lt;/h2&gt;

&lt;p&gt;\begin{cases}
X &amp;amp;= R\cos β\cos ☉\\[2ex]
Y &amp;amp;= R(\cos β\sin ☉\cos ε - \sin β\sin ε)\\[2ex]
Z &amp;amp;= R(\cos β\sin ☉\sin ε + \sin β\cos ε)
\end{cases}
其中$☉,β,R$是太阳的地心几何黄经,黄纬,日地距离（可由&lt;code&gt;solar.TrueVSOP87&lt;/code&gt;求出），$ε$是平黄赤交角。&lt;br /&gt;
因为 Date 黄道坐标中，太阳的纬度不超过 1.2 角秒， 所以可以看成$\cos β=1$&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Position returns rectangular coordinates referenced to the mean equinox
// of date.
// Date 平分点太阳地心直角坐标
func Position(e *pp.V87Planet, jde float64) (x, y, z float64) {
	// (26.1) p. 171
	s, β, R := solar.TrueVSOP87(e, jde)
	sε, cε := nutation.MeanObliquity(jde).Sincos()
	ss, cs := s.Sincos()
	sβ := β.Sin()
	x = R * cs
	y = R * (ss*cε - sβ*sε)
	z = R * (ss*sε + sβ*cε)
	return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2-j2000标准分点参考系和b1950平分点参考系&#34;&gt;2. J2000标准分点参考系和B1950平分点参考系&lt;/h2&gt;

&lt;p&gt;通过VSOP87计算给定时刻地球的相对于 J2000.0 分点的日心黄经$L$和黄纬$B$，及距离$R$
$$☉ = L + 180°， β = -B$$
计算
\begin{cases}
X &amp;amp;= R\cos β*cos ☉\\[2ex]
Y &amp;amp;= R\cos β*sin ☉\\[2ex]
Z &amp;amp;= R\sin β
\end{cases}&lt;/p&gt;

&lt;p&gt;上述坐标仍是黄道坐标，J2000参考系的赤道坐标为：
\begin{cases}
X_0 &amp;amp;= 1.000000000000X+0.000000440360Y-0.000000190919Z\\[2ex]
Y_0 &amp;amp;= -0.000000479966X+0.917482137087Y-0.397776982902Z\\[2ex]
Z_0 &amp;amp;= 0.000000000000X+0.397776982902Y+0.917482137087Z
\end{cases}&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// PositionJ2000 returns rectangular coordinates referenced to equinox J2000.
// J2000太阳直角坐标
func PositionJ2000(e *pp.V87Planet, jde float64) (x, y, z float64) {
	x, y, z = xyz(e, jde)
	// (26.3) p. 174
	return x + .00000044036*y - .000000190919*z,
		-.000000479966*x + .917482137087*y - .397776982902*z,
		.397776982902*y + .917482137087*z
}

func xyz(e *pp.V87Planet, jde float64) (x, y, z float64) {
	l, b, r := e.Position2000(jde)
	s := l + math.Pi
	β := -b
	ss, cs := s.Sincos()
	sβ, cβ := β.Sincos()
	// (26.2) p. 172
	x = r * cβ * cs
	y = r * cβ * ss
	z = r * sβ
	return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;B1950平分点参考系坐标：
\begin{cases}
X_0 &amp;amp;=0.999925702634X+0.012189716217Y+0.000011134016Z\\[2ex]
Y_0 &amp;amp;=-0.011179418036X+0.917413998946Y-0.397777041885Z\\[2ex]
Z_0 &amp;amp;=-0.004859003787X+0.397747363646Y+0.917482111428Z
\end{cases}&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// PositionB1950 returns rectangular coordinates referenced to B1950.
// B1950 平分点参考系太阳直角坐标
//
// Results are referenced to the mean equator and equinox of the epoch B1950
// in the FK5 system, not FK4.
func PositionB1950(e *pp.V87Planet, jde float64) (x, y, z float64) {
	x, y, z = xyz(e, jde)
	return .999925702634*x + .012189716217*y + .000011134016*z,
		-.011179418036*x + .917413998946*y - .397777041885*z,
		-.004859003787*x + .397747363646*y + .917482111428*z
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;3-任意其它平分点参考系&#34;&gt;3. 任意其它平分点参考系&lt;/h2&gt;

&lt;p&gt;　　先计算出J2000标准分点标准$X_0,Y_0,Z_0$&lt;br /&gt;
　　然后按岁差计算中的方法计算出$ζ,z,θ$,&lt;br /&gt;
\begin{cases}
X_x &amp;amp;= \cos ζ\cos z\cos θ - \sin ζ\sin z\\[2ex]
X_y &amp;amp;= \sin ζ\cos z + \cos ζ\sin z\cos θ\\[2ex]
X_z &amp;amp;= \cos ζ\sin θ\\[2ex]
\end{cases}
\begin{cases}
Y_x &amp;amp;= -\cos ζ\sin z - \sin ζ\cos z\cos θ\\[2ex]
Y_y &amp;amp;= \cos ζ\cos z - \sin ζ\sin z\cos θ\\[2ex]
Y_z &amp;amp;= -\sin ζ\sin θ\\[2ex]
\end{cases}
\begin{cases}
Z_x &amp;amp;= -\cos z\sin θ\\[2ex]
Z_y &amp;amp;= -\sin z\sin θ\\[2ex]
Z_z &amp;amp;= \cos θ
\end{cases}
　　那么
\begin{cases}
X′ &amp;amp;= X_xX_0 + Y_xY_0 + Z_xZ_0\\[2ex]
Y′ &amp;amp;= X_yX_0 + Y_yY_0 + Z_yZ_0\\[2ex]
Z′ &amp;amp;= X_zX_0 + Y_zY_0 + Z_zZ_0
\end{cases}&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// PositionEquinox returns rectangular coordinates referenced to an arbitrary epoch.
// 任意其它平分点参考系太阳直角坐标
//
// Position will be computed for given Julian day &amp;quot;jde&amp;quot; but referenced to mean
// equinox &amp;quot;epoch&amp;quot; (year).
func PositionEquinox(e *pp.V87Planet, jde, epoch float64) (xp, yp, zp float64) {
	x0, y0, z0 := PositionJ2000(e, jde)
	t := (epoch - 2000) * .01
	ζ := base.Horner(t, ζt...) * t * math.Pi / 180 / 3600
	z := base.Horner(t, zt...) * t * math.Pi / 180 / 3600
	θ := base.Horner(t, θt...) * t * math.Pi / 180 / 3600
	sζ, cζ := math.Sincos(ζ)
	sz, cz := math.Sincos(z)
	sθ, cθ := math.Sincos(θ)
	xx := cζ*cz*cθ - sζ*sz
	xy := sζ*cz + cζ*sz*cθ
	xz := cζ * sθ
	yx := -cζ*sz - sζ*cz*cθ
	yy := cζ*cz - sζ*sz*cθ
	yz := -sζ * sθ
	zx := -cz * sθ
	zy := -sz * sθ
	zz := cθ
	return xx*x0 + yx*y0 + zx*z0,
		xy*x0 + yy*y0 + zy*z0,
		xz*x0 + yz*y0 + zz*z0
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>天文算法23</title>
      <link>https://mooncaker816.github.io/2018/05/25/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9523/</link>
      <pubDate>Fri, 25 May 2018 08:06:54 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/05/25/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9523/</guid>
      <description>&lt;h1 id=&#34;第二十五章-太阳坐标-solar-coordinates&#34;&gt;第二十五章 太阳坐标 Solar Coordinates&lt;/h1&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-低精度太阳黄经&#34;&gt;1. 低精度太阳黄经&lt;/h2&gt;

&lt;p&gt;当计算精度要求为0.01度，计算太阳位置时可假设地球运动是一个纯椭圆，也就说忽略月球及行星摄动。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;太阳真黄经&lt;/p&gt;

&lt;p&gt;$T$为J2000起算的儒略世纪数&lt;br /&gt;
\begin{align}
太阳几何平黄经：L_0 &amp;amp;= 280°.46646 + 36000°.76983T + 0°.0003032T^2\\[2ex]
太阳平近点角： M &amp;amp;= 357°.52911 + 35999°.05029T - 0°.0001537T^2\\[2ex]
地球轨道离心率： e &amp;amp;= 0.016708634 - 0.000042037T - 0.0000001267T^2\\[2ex]
太阳中心方程 ： C &amp;amp;= +(1°.914602 - 0°.004817T - 0°.000014T^2)\sin M\\[2ex]
&amp;amp;+(0°.019993 - 0°.000101T)\sin 2M\\[2ex]
&amp;amp;+ 0°.000289\sin 3M
\end{align}
那么，太阳的真黄经是：$☉ = L_0 + C$ 真近点角是：$ν = M + C$&lt;br /&gt;
日地距离(AU)为：$R =\frac {1.000001018(1-e^2)}{1+e\cos ν}$&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// True returns true geometric longitude and anomaly of the sun referenced to the mean equinox of date.
// 计算太阳真黄经s，真近点角ν
//
// Argument T is the number of Julian centuries since J2000.
// See base.J2000Century.
//
// Results:
//  s = true geometric longitude, ☉
//  ν = true anomaly
func True(T float64) (s, ν unit.Angle) {
    // (25.2) p. 163
    L0 := unit.AngleFromDeg(base.Horner(T, 280.46646, 36000.76983, 0.0003032))
    M := MeanAnomaly(T)
    C := unit.AngleFromDeg(base.Horner(T, 1.914602, -0.004817, -.000014)*
        M.Sin() +
        (0.019993-.000101*T)*M.Mul(2).Sin() +
        0.000289*M.Mul(3).Sin())
    return (L0 + C).Mod1(), (M + C).Mod1()
}

// MeanAnomaly returns the mean anomaly of Earth at the given T.
// 太阳平近点角
//
// Argument T is the number of Julian centuries since J2000.
// See base.J2000Century.
//
// Result is not normalized to the range 0..2π.
func MeanAnomaly(T float64) unit.Angle {
    // (25.3) p. 163
    return unit.AngleFromDeg(base.Horner(T, 357.52911, 35999.05029, -0.0001537))
}

// Eccentricity returns eccentricity of the Earth&#39;s orbit around the sun.
// 地球轨道离心率
//
// Argument T is the number of Julian centuries since J2000.
// See base.J2000Century.
func Eccentricity(T float64) float64 {
    // (25.4) p. 163
    return base.Horner(T, 0.016708634, -0.000042037, -0.0000001267)
}

// Radius returns the Sun-Earth distance in AU.
// 日地距离，单位为 AU
//
// Argument T is the number of Julian centuries since J2000.
// See base.J2000Century.
func Radius(T float64) float64 {
    _, ν := True(T)
    e := Eccentricity(T)
    // (25.5) p. 164
    return 1.000001018 * (1 - e*e) / (1 + e*ν.Cos())
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;太阳视黄经&lt;/p&gt;

&lt;p&gt;太阳视黄经$λ$ = 太阳真黄经$☉$ + 章动修正 + 光行差修正&lt;/p&gt;

&lt;p&gt;如果精度要求不高，可以采用以下公式：
\begin{cases}
Ω &amp;amp;= 125°.04 - 1934°.136T\\[2ex]
λ &amp;amp;= ☉ - 0°.00569 -0°.00478\sin Ω
\end{cases}&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// ApparentLongitude returns apparent longitude of the Sun referenced
// to the true equinox of date.
// 太阳视黄经，考虑了章动和光行差
//
// Argument T is the number of Julian centuries since J2000.
// See base.J2000Century.
//
// Result includes correction for nutation and aberration.
func ApparentLongitude(T float64) unit.Angle {
    Ω := node(T)
    s, _ := True(T)
    return s - unit.AngleFromDeg(.00569) -
        unit.AngleFromDeg(.00478).Mul(Ω.Sin())
}

func node(T float64) unit.Angle {
    return unit.AngleFromDeg(125.04 - 1934.136*T)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;J2000的太阳真黄经$☉_2000 = ☉ - 0°.01397(year-2000), 1900\leq year \leq 2100$&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// True2000 returns true geometric longitude and anomaly of the sun referenced to equinox J2000.
//
// Argument T is the number of Julian centuries since J2000.
// See base.J2000Century.
//
// Results are accurate to .01 degree for years 1900 to 2100.
//
// Results:
//  s = true geometric longitude, ☉
//  ν = true anomaly
// J2000的太阳真黄经，真近点角
func True2000(T float64) (s, ν unit.Angle) {
    s, ν = True(T)
    s -= unit.AngleFromDeg(.01397).Mul(T * 100)
    return
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;太阳地心赤经$α$，地心赤纬$δ$&lt;/p&gt;

&lt;p&gt;\begin{cases}
\tan α = \frac {\cos ε\sin ☉}{\cos ☉}\\[2ex]
\sin δ = \sin ε\sin ☉
\end{cases}&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// TrueEquatorial returns the true geometric position of the Sun as equatorial coordinates.
// 太阳真赤经，真赤纬
func TrueEquatorial(jde float64) (α unit.RA, δ unit.Angle) {
    s, _ := True(base.J2000Century(jde))
    ε := nutation.MeanObliquity(jde)
    ss, cs := s.Sincos()
    sε, cε := ε.Sincos()
    // (25.6, 25.7) p. 165
    α = unit.RAFromRad(math.Atan2(cε*ss, cs))
    δ = unit.Angle(math.Asin(sε * ss))
    return
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;太阳地心视赤经，视赤纬&lt;/p&gt;

&lt;p&gt;$☉$补上黄经章动及光行差得到太阳视黄经$λ$，$ε$补上交角章动$+0.00256\cos Ω$
\begin{cases}
\tan α = \frac {\cos ε\sin λ}{\cos λ}\\[2ex]
\sin δ = \sin ε\sin λ
\end{cases}&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// ApparentEquatorial returns the apparent position of the Sun as equatorial coordinates.
// 太阳视赤经，视赤纬
//
//  α: right ascension in radians
//  δ: declination in radians
func ApparentEquatorial(jde float64) (α unit.RA, δ unit.Angle) {
    T := base.J2000Century(jde)
    λ := ApparentLongitude(T)
    ε := nutation.MeanObliquity(jde)
    sλ, cλ := λ.Sincos()
    // (25.8) p. 165
    ε += unit.AngleFromDeg(.00256).Mul(node(T).Cos())
    sε, cε := ε.Sincos()
    α = unit.RAFromRad(math.Atan2(cε*sλ, cλ))
    δ = unit.Angle(math.Asin(sε * sλ))
    return
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2-高精度太阳黄经&#34;&gt;2. 高精度太阳黄经&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;太阳地心黄经，地心黄纬
先采用VSOP87理论计算地球位置得到地球的日心黄经$L$，黄纬$β$，日地距离$R$
再计算地心黄经$☉ = L + 180°$,黄纬$β=-B$&lt;br /&gt;
令$λ′ = ☉ - 1°.397T - 0°.00031T^2$&lt;br /&gt;
那么
\begin{cases}
Δ☉ = -0&amp;rdquo;.09033\\[2ex]
Δβ = +0&amp;rdquo;.03916(\cos(λ′) - \sin(λ′))
\end{cases}&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// TrueVSOP87 returns the true geometric position of the sun as ecliptic coordinates.
// 根据VSOP87理论计算太阳真黄经，真黄纬，日地距离
//
// Result computed by full VSOP87 theory.  Result is at equator and equinox
// of date in the FK5 frame.  It does not include nutation or aberration.
//
//  s: ecliptic longitude
//  β: ecliptic latitude
//  R: range in AU
func TrueVSOP87(e *pp.V87Planet, jde float64) (s, β unit.Angle, R float64) {
    l, b, r := e.Position(jde) //VSOP87算出的地球的日心黄经，黄纬，日地距离
    s = l + math.Pi
    // FK5 correction.
    λp := base.Horner(base.J2000Century(jde),
        s.Rad(), -1.397*math.Pi/180, -.00031*math.Pi/180)
    sλp, cλp := math.Sincos(λp)
    Δβ := unit.AngleFromSec(.03916).Mul(cλp - sλp)
    // (25.9) p. 166
    s -= unit.AngleFromSec(.09033)
    return s.Mod1(), Δβ - b, r
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;太阳地心视黄经&lt;/p&gt;

&lt;p&gt;与日心视黄经一样，对日心黄经进行章动和光行差修正
章动可以由章动公式求得，光行差可以由以下公式求得$$-20&amp;rdquo;.4898/R$$&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// ApparentVSOP87 returns the apparent position of the sun as ecliptic coordinates.
// 根据VSOP87理论计算太阳视黄经，视黄纬，日地距离，考虑了章动和光行差
// 即真黄经+黄经章动+光行差，真黄纬，日地距离不变
//
// Result computed by VSOP87, at equator and equinox of date in the FK5 frame,
// and includes effects of nutation and aberration.
//
//  λ: ecliptic longitude
//  β: ecliptic latitude
//  R: range in AU
func ApparentVSOP87(e *pp.V87Planet, jde float64) (λ, β unit.Angle, R float64) {
    // note: see duplicated code in ApparentEquatorialVSOP87.
    s, β, R := TrueVSOP87(e, jde)
    Δψ, _ := nutation.Nutation(jde)
    a := aberration(R)
    return s + Δψ + a, β, R
}

// Low precision formula.  The high precision formula is not implemented
// because the low precision formula already gives position results to the
// accuracy given on p. 165.  The high precision formula the represents lots
// of typing with associated chance of typos, and no way to test the result.
// 低精度光行差修正项
func aberration(R float64) unit.Angle {
    // (25.10) p. 167
    return unit.AngleFromSec(-20.4898).Div(R)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;太阳地心视赤经，视赤纬&lt;/p&gt;

&lt;p&gt;算法同低精度太阳地心视赤经，视赤纬一致&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// ApparentEquatorialVSOP87 returns the apparent position of the sun as equatorial coordinates.
// 根据VSOP87理论计算太阳视赤经，视赤纬，日地距离，考虑了章动和光行差
// 即先计算视黄经，视黄纬，此时考虑交角章动，用真黄赤交角转为赤道坐标
//
// Result computed by VSOP87, at equator and equinox of date in the FK5 frame,
// and includes effects of nutation and aberration.
//
//  α: right ascension
//  δ: declination
//  R: range in AU
func ApparentEquatorialVSOP87(e *pp.V87Planet, jde float64) (α unit.RA, δ unit.Angle, R float64) {
    // note: duplicate code from ApparentVSOP87 so we can keep Δε.
    // see also duplicate code in time.E().
    s, β, R := TrueVSOP87(e, jde)
    Δψ, Δε := nutation.Nutation(jde)
    a := aberration(R)
    λ := s + Δψ + a
    ε := nutation.MeanObliquity(jde) + Δε
    sε, cε := ε.Sincos()
    α, δ = coord.EclToEq(λ, β, sε, cε)
    return
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>天文算法22</title>
      <link>https://mooncaker816.github.io/2018/05/25/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9522/</link>
      <pubDate>Fri, 25 May 2018 08:04:20 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/05/25/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9522/</guid>
      <description>&lt;h1 id=&#34;第二十四章-reduction-of-ecliptical-elements-from-one-equinox-to-another-one&#34;&gt;第二十四章 Reduction of Ecliptical Elements from one Equinox to another one&lt;/h1&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;略&#34;&gt;略&lt;/h2&gt;</description>
    </item>
    
    <item>
      <title>天文算法21</title>
      <link>https://mooncaker816.github.io/2018/05/24/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9521/</link>
      <pubDate>Thu, 24 May 2018 20:01:23 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/05/24/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9521/</guid>
      <description>&lt;h1 id=&#34;第二十三章-apparent-place-of-a-star&#34;&gt;第二十三章 Apparent Place of a Star&lt;/h1&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-平-视位置&#34;&gt;1. 平，视位置&lt;/h2&gt;

&lt;p&gt;任意时刻恒星的平位置是：当观测者站在不动的太阳上（严格的说是太阳系的质心）看到它在天球上的视位置，并且，它的位置坐标涉及 Date 黄道平分点（或 Date 赤道平分点）。&lt;/p&gt;

&lt;p&gt;任意时刻恒星的视位置是：当观测者站在移动着的地心看到它在天球上的位置，其视坐标涉及瞬时赤道、黄道及分点&lt;/p&gt;

&lt;h2 id=&#34;2-平转视的影响因素&#34;&gt;2. 平转视的影响因素&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;恒星的自行运动&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第二十一章已经给出计算方法&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;岁差&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第二十一章已经给出计算方法&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;章动&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;赤经章动和赤纬章动&lt;/p&gt;

&lt;p&gt;\begin{cases}
Δα_1=(\cos ε+\sin ε\sin α\tan δ)Δψ-\cos α\tan δΔε\\[2ex]
Δδ_1 = \sin ε\cos αΔψ + \sin αΔε
\end{cases}
其中$Δψ,Δε$可以使用章动章节给出的方法计算，$ε$是平黄赤交角&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Nutation returns corrections due to nutation for equatorial coordinates
// of an object.
//
// Results are invalid for objects very near the celestial poles.
// 章动导致的赤道坐标修正
func Nutation(α unit.RA, δ unit.Angle, jd float64) (Δα1 unit.HourAngle, Δδ1 unit.Angle) {
	ε := nutation.MeanObliquity(jd)
	sε, cε := ε.Sincos()
	Δψ, Δε := nutation.Nutation(jd)
	sα, cα := α.Sincos()
	tδ := δ.Tan()
	// (23.1) p. 151
	Δα1 = unit.HourAngle((cε+sε*sα*tδ)*Δψ.Rad() - cα*tδ*Δε.Rad())
	Δδ1 = Δψ.Mul(sε*cα) + Δε.Mul(sα)
	return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;周年光行差&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;黄道周年光行差：&lt;br /&gt;
$λ,β$是恒星的黄经和黄纬，$K$是光行差常数（20&amp;rdquo;.49552），$Θ$是太阳真黄经(也叫几何黄经)，$e$是地球 轨道的离心率，$π$轨道近日点经度&lt;br /&gt;
\begin{cases}
Θ 可使用后续章节的方法计算\\[2ex]
e = 0.016708617 - 0.000042037T - 0.0000001236T^2\\[2ex]
π = 102°.93735 + 1°.71953T + 0°.00046T^2
\end{cases}
$T$是J2000.0起算的儒略世纪数
则
\begin{cases}
Δλ &amp;amp;= \frac {-K\cos (Θ-λ)+eK\cos (π-λ)}{\cos β}\\[2ex]
Δβ &amp;amp;= -K\sin β(\sin (Θ-λ)-e\sin (π-λ))
\end{cases}&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// κ is the constnt of aberration in radians.
var κ = unit.AngleFromSec(20.49552)

// longitude of perihelian of Earth&#39;s orbit.
// 近日点经度
func perihelion(T float64) unit.Angle {
	return unit.AngleFromDeg(base.Horner(T, 102.93735, 1.71946, .00046))
}
// EclipticAberration returns corrections due to aberration for ecliptic
// coordinates of an object.
// 光行差导致的黄道坐标的修正
func EclipticAberration(λ, β unit.Angle, jd float64) (Δλ, Δβ unit.Angle) {
	T := base.J2000Century(jd)
	s, _ := solar.True(T)      //太阳真黄经
	e := solar.Eccentricity(T) //地球轨道离心率
	π := perihelion(T)         //地球近日点经度
	sβ, cβ := β.Sincos()
	ssλ, csλ := (s - λ).Sincos()
	sπλ, cπλ := (π - λ).Sincos()
	// (23.2) p. 151
	Δλ = κ.Mul((e*cπλ - csλ) / cβ)
	Δβ = -κ.Mul(sβ * (ssλ - e*sπλ))
	return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;赤道周年光行差：
\begin{cases}
Δα_2 &amp;amp;= -K\frac {\cos α\cos Θ\cos ε + \sin α\sin Θ}{\cos δ} + eK\frac {\cos α\cos π\cos ε + \sin α\sin π}{\cos δ}\\[2ex]
Δδ_2 &amp;amp;= -K(\cos Θ\cos ε(\tan ε\cos δ - \sin α\sin δ)+\cos α\sin δ\sin Θ)\\[2ex]
&amp;amp;+eK(\cos π\cos ε(\tan ε\cos δ - \sin α\sin δ)+\cos α\sin δ\sin π)
\end{cases}&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Aberration returns corrections due to aberration for equatorial
// coordinates of an object.
// 光行差导致的赤道坐标的修正
func Aberration(α unit.RA, δ unit.Angle, jd float64) (Δα2 unit.HourAngle, Δδ2 unit.Angle) {
	ε := nutation.MeanObliquity(jd)
	T := base.J2000Century(jd)
	s, _ := solar.True(T)
	e := solar.Eccentricity(T)
	π := perihelion(T)
	sα, cα := α.Sincos()
	sδ, cδ := δ.Sincos()
	ss, cs := s.Sincos()
	sπ, cπ := π.Sincos()
	cε := ε.Cos()
	tε := ε.Tan()
	q1 := cα * cε
	// (23.3) p. 152
	Δα2 = unit.HourAngle(κ.Rad() * (e*(q1*cπ+sα*sπ) - (q1*cs + sα*ss)) / cδ)
	q2 := cε * (tε*cδ - sα*sδ)
	q3 := cα * sδ
	Δδ2 = κ.Mul(e*(cπ*q2+sπ*q3) - (cs*q2 + ss*q3))
	return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ron_Vondrak法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// AberrationRonVondrak uses the Ron-Vondrák expression to compute corrections
// due to aberration for equatorial coordinates of an object.
// RonVondrak方法计算光行差引起的赤道坐标的修正
func AberrationRonVondrak(α unit.RA, δ unit.Angle, jd float64) (Δα unit.HourAngle, Δδ unit.Angle) {
	T := base.J2000Century(jd)
	r := &amp;amp;rv{
		T:  T,
		L2: 3.1761467 + 1021.3285546*T,
		L3: 1.7534703 + 628.3075849*T,
		L4: 6.2034809 + 334.0612431*T,
		L5: 0.5995465 + 52.9690965*T,
		L6: 0.8740168 + 21.3299095*T,
		L7: 5.4812939 + 7.4781599*T,
		L8: 5.3118863 + 3.8133036*T,
		Lp: 3.8103444 + 8399.6847337*T,
		D:  5.1984667 + 7771.3771486*T,
		Mp: 2.3555559 + 8328.6914289*T,
		F:  1.6279052 + 8433.4661601*T,
	}
	var Xp, Yp, Zp float64
	// sum smaller terms first
	for i := 35; i &amp;gt;= 0; i-- {
		x, y, z := rvTerm[i](r)
		Xp += x
		Yp += y
		Zp += z
	}
	sα, cα := α.Sincos()
	sδ, cδ := δ.Sincos()
	// (23.4) p. 156
	Δα = unit.HourAngle((Yp*cα - Xp*sα) / (c * cδ))
	Δδ = unit.Angle(-((Xp*cα+Yp*sα)*sδ - Zp*cδ) / c)
	return
}

const c = 17314463350 // unit is 1e-8 AU / day

type rv struct {
	T, L2, L3, L4, L5, L6, L7, L8, Lp, D, Mp, F float64
}

type rvFunc func(*rv) (x, y, z float64)

var rvTerm = [36]rvFunc{
	func(r *rv) (x, y, z float64) { // 1
		sA, cA := math.Sincos(r.L3)
		return (-1719914-2*r.T)*sA - 25*cA,
			(25-13*r.T)*sA + (1578089+156*r.T)*cA,
			(10+32*r.T)*sA + (684185-358*r.T)*cA
	},
	func(r *rv) (x, y, z float64) { // 2
		sA, cA := math.Sincos(2 * r.L3)
		return (6434+141*r.T)*sA + (28007-107*r.T)*cA,
			(25697-95*r.T)*sA + (-5904-130*r.T)*cA,
			(11141-48*r.T)*sA + (-2559-55*r.T)*cA
	},
	func(r *rv) (x, y, z float64) { // 3
		sA, cA := math.Sincos(r.L5)
		return 715 * sA, 6*sA - 657*cA, -15*sA - 282*cA
	},
	func(r *rv) (x, y, z float64) { // 4
		sA, cA := math.Sincos(r.Lp)
		return 715 * sA, -656 * cA, -285 * cA
	},
	func(r *rv) (x, y, z float64) { // 5
		sA, cA := math.Sincos(3 * r.L3)
		return (486-5*r.T)*sA + (-236-4*r.T)*cA,
			(-216-4*r.T)*sA + (-446+5*r.T)*cA,
			-94*sA - 193*cA
	},
	func(r *rv) (x, y, z float64) { // 6
		sA, cA := math.Sincos(r.L6)
		return 159 * sA, 2*sA - 147*cA, -6*sA - 61*cA
	},
	func(r *rv) (x, y, z float64) { // 7
		cA := math.Cos(r.F)
		return 0, 26 * cA, -59 * cA
	},
	func(r *rv) (x, y, z float64) { // 8
		sA, cA := math.Sincos(r.Lp + r.Mp)
		return 39 * sA, -36 * cA, -16 * cA
	},
	func(r *rv) (x, y, z float64) { // 9
		sA, cA := math.Sincos(2 * r.L5)
		return 33*sA - 10*cA, -9*sA - 30*cA, -5*sA - 13*cA
	},
	func(r *rv) (x, y, z float64) { // 10
		sA, cA := math.Sincos(2*r.L3 - r.L5)
		return 31*sA + cA, sA - 28*cA, -12 * cA
	},
	func(r *rv) (x, y, z float64) { // 11
		sA, cA := math.Sincos(3*r.L3 - 8*r.L4 + 3*r.L5)
		return 8*sA - 28*cA, 25*sA + 8*cA, 11*sA + 3*cA
	},
	func(r *rv) (x, y, z float64) { // 12
		sA, cA := math.Sincos(5*r.L3 - 8*r.L4 + 3*r.L5)
		return 8*sA - 28*cA, -25*sA - 8*cA, -11*sA + -3*cA
	},
	func(r *rv) (x, y, z float64) { // 13
		sA, cA := math.Sincos(2*r.L2 - r.L3)
		return 21 * sA, -19 * cA, -8 * cA
	},
	func(r *rv) (x, y, z float64) { // 14
		sA, cA := math.Sincos(r.L2)
		return -19 * sA, 17 * cA, 8 * cA
	},
	func(r *rv) (x, y, z float64) { // 15
		sA, cA := math.Sincos(r.L7)
		return 17 * sA, -16 * cA, -7 * cA
	},
	func(r *rv) (x, y, z float64) { // 16
		sA, cA := math.Sincos(r.L3 - 2*r.L5)
		return 16 * sA, 15 * cA, sA + 7*cA
	},
	func(r *rv) (x, y, z float64) { // 17
		sA, cA := math.Sincos(r.L8)
		return 16 * sA, sA - 15*cA, -3*sA - 6*cA
	},
	func(r *rv) (x, y, z float64) { // 18
		sA, cA := math.Sincos(r.L3 + r.L5)
		return 11*sA - cA, -sA - 10*cA, -sA - 5*cA
	},
	func(r *rv) (x, y, z float64) { // 19
		sA, cA := math.Sincos(2*r.L2 - 2*r.L3)
		return -11 * cA, -10 * sA, -4 * sA
	},
	func(r *rv) (x, y, z float64) { // 20
		sA, cA := math.Sincos(r.L3 - r.L5)
		return -11*sA - 2*cA, -2*sA + 9*cA, -sA + 4*cA
	},
	func(r *rv) (x, y, z float64) { // 21
		sA, cA := math.Sincos(4 * r.L3)
		return -7*sA - 8*cA, -8*sA + 6*cA, -3*sA + 3*cA
	},
	func(r *rv) (x, y, z float64) { // 22
		sA, cA := math.Sincos(3*r.L3 - 2*r.L5)
		return -10 * sA, 9 * cA, 4 * cA
	},
	func(r *rv) (x, y, z float64) { // 23
		sA, cA := math.Sincos(r.L2 - 2*r.L3)
		return -9 * sA, -9 * cA, -4 * cA
	},
	func(r *rv) (x, y, z float64) { // 24
		sA, cA := math.Sincos(2*r.L2 - 3*r.L3)
		return -9 * sA, -8 * cA, -4 * cA
	},
	func(r *rv) (x, y, z float64) { // 25
		sA, cA := math.Sincos(2 * r.L6)
		return -9 * cA, -8 * sA, -3 * sA
	},
	func(r *rv) (x, y, z float64) { // 26
		sA, cA := math.Sincos(2*r.L2 - 4*r.L3)
		return -9 * cA, 8 * sA, 3 * sA
	},
	func(r *rv) (x, y, z float64) { // 27
		sA, cA := math.Sincos(3*r.L3 - 2*r.L4)
		return 8 * sA, -8 * cA, -3 * cA
	},
	func(r *rv) (x, y, z float64) { // 28
		sA, cA := math.Sincos(r.Lp + 2*r.D - r.Mp)
		return 8 * sA, -7 * cA, -3 * cA
	},
	func(r *rv) (x, y, z float64) { // 29
		sA, cA := math.Sincos(8*r.L2 - 12*r.L3)
		return -4*sA - 7*cA, -6*sA + 4*cA, -3*sA + 2*cA
	},
	func(r *rv) (x, y, z float64) { // 30
		sA, cA := math.Sincos(8*r.L2 - 14*r.L3)
		return -4*sA - 7*cA, 6*sA - 4*cA, 3*sA - 2*cA
	},
	func(r *rv) (x, y, z float64) { // 31
		sA, cA := math.Sincos(2 * r.L4)
		return -6*sA - 5*cA, -4*sA + 5*cA, -2*sA + 2*cA
	},
	func(r *rv) (x, y, z float64) { // 32
		sA, cA := math.Sincos(3*r.L2 - 4*r.L3)
		return -sA - cA, -2*sA - 7*cA, sA - 4*cA
	},
	func(r *rv) (x, y, z float64) { // 33
		sA, cA := math.Sincos(2*r.L3 - 2*r.L5)
		return 4*sA - 6*cA, -5*sA - 4*cA, -2*sA - 2*cA
	},
	func(r *rv) (x, y, z float64) { // 34
		sA, cA := math.Sincos(3*r.L2 - 3*r.L3)
		return -7 * cA, -6 * sA, -3 * sA
	},
	func(r *rv) (x, y, z float64) { // 35
		sA, cA := math.Sincos(2*r.L3 - 2*r.L4)
		return 5*sA - 5*cA, -4*sA - 5*cA, -2*sA - 2*cA
	},
	func(r *rv) (x, y, z float64) { // 36
		sA, cA := math.Sincos(r.Lp - 2*r.D)
		return 5 * sA, -5 * cA, -2 * cA
	},
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;周年视差&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;该算法忽略&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>天文算法20</title>
      <link>https://mooncaker816.github.io/2018/05/23/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9520/</link>
      <pubDate>Wed, 23 May 2018 16:58:54 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/05/23/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9520/</guid>
      <description>&lt;h1 id=&#34;第二十二章-章动和黄赤交角-nutation-and-the-obliquity-of-the-ecliptic&#34;&gt;第二十二章 章动和黄赤交角 Nutation and the Obliquity of the Ecliptic&lt;/h1&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-名词解释&#34;&gt;1. 名词解释&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E7%AB%A0%E5%8B%95&#34; target=&#34;_blank&#34;&gt;章动&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;2-章动的分量&#34;&gt;2. 章动的分量&lt;/h2&gt;

&lt;p&gt;　　章动可以很容易的分解为黄道的水平分量和的垂直分量。黄道上的分量记为$Δψ$，称为黄经章动；它影响了天球上所有天体的经度。黄道的垂直分量记为$Δε$，称为交角章动，它影响了黄赤交角。&lt;/p&gt;

&lt;h2 id=&#34;3-较精确计算章动&#34;&gt;3. 较精确计算章动&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Nutation returns nutation in longitude (Δψ) and nutation in obliquity (Δε)
// for a given JDE.
//
// JDE = UT + ΔT, see package deltat.
//
// Computation is by 1980 IAU theory, with terms &amp;lt; .0003″ neglected.
// 计算 jde 对应的章动
func Nutation(jde float64) (Δψ, Δε unit.Angle) {
	T := base.J2000Century(jde)
	D := base.Horner(T,
		297.85036, 445267.11148, -0.0019142, 1./189474) * math.Pi / 180
	M := base.Horner(T,
		357.52772, 35999.050340, -0.0001603, -1./300000) * math.Pi / 180
	N := base.Horner(T,
		134.96298, 477198.867398, 0.0086972, 1./56250) * math.Pi / 180
	F := base.Horner(T,
		93.27191, 483202.017538, -0.0036825, 1./327270) * math.Pi / 180
	Ω := base.Horner(T,
		125.04452, -1934.136261, 0.0020708, 1./450000) * math.Pi / 180
	// sum in reverse order to accumulate smaller terms first
	var Δψs, Δεs float64
	for i := len(table22A) - 1; i &amp;gt;= 0; i-- {
		row := table22A[i]
		arg := row.d*D + row.m*M + row.n*N + row.f*F + row.ω*Ω
		s, c := math.Sincos(arg)
		Δψs += s * (row.s0 + row.s1*T)
		Δεs += c * (row.c0 + row.c1*T)
	}
	Δψ = unit.AngleFromSec(Δψs * .0001)
	Δε = unit.AngleFromSec(Δεs * .0001)
	return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;4-粗略计算章动&#34;&gt;4. 粗略计算章动&lt;/h2&gt;

&lt;p&gt;Δψ精度为0.5″,Δε精度为0.1″&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// ApproxNutation returns a fast approximation of nutation in longitude (Δψ)
// and nutation in obliquity (Δε) for a given JDE.
//
// Accuracy is 0.5″ in Δψ, 0.1″ in Δε.
// 精度要求为0.5″ in Δψ, 0.1″ in Δε
func ApproxNutation(jde float64) (Δψ, Δε unit.Angle) {
	T := (jde - base.J2000) / 36525
	Ω := (125.04452 - 1934.136261*T) * math.Pi / 180
	L := (280.4665 + 36000.7698*T) * math.Pi / 180
	N := (218.3165 + 481267.8813*T) * math.Pi / 180
	sΩ, cΩ := math.Sincos(Ω)
	s2L, c2L := math.Sincos(2 * L)
	s2N, c2N := math.Sincos(2 * N)
	s2Ω, c2Ω := math.Sincos(2 * Ω)
	Δψ = unit.AngleFromSec(-17.2*sΩ - 1.32*s2L - 0.23*s2N + 0.21*s2Ω)
	Δε = unit.AngleFromSec(9.2*cΩ + 0.57*c2L + 0.1*c2N - 0.09*c2Ω)
	return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;5-黄赤交角&#34;&gt;5. 黄赤交角&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;平黄赤交角$ε_0$：黄道与平赤道的夹角&lt;/p&gt;

&lt;p&gt;$$ε_0 = 23°26&amp;rsquo;21&amp;rdquo;.448 - 46&amp;rdquo;.8150T - 0&amp;rdquo;.00059T^2 + 0&amp;rdquo;.001813T^3$$&lt;/p&gt;

&lt;p&gt;T是J2000.0起算的儒略世纪数&lt;/p&gt;

&lt;p&gt;　　当时间范围很长，上述公式的精度并不令人满意：2000年误差1&amp;rdquo;，4000误差为10&amp;rdquo;。Laskar提供了以下改良的的公式，式中U是J2000.0起算的儒略万年数，即U=T/100：
\begin{align}
ε_0 =&amp;amp; 23°26&amp;rsquo;21&amp;rdquo;.448 - 4680&amp;rdquo;.93U - 1.55U^2 + 1999.25U^3 - 51.38U^4 - 249.67U^5 \\[2ex]
&amp;amp;-39.05U^6 + 7.12U^7 + 27.87U^8 + 5.79U^9 + 2.45U^{10}
\end{align}
　　该表达式的精度是：1000年后误差0&amp;rdquo;.01(公元 1000 到 3000)，10000年后误差数个角秒。&lt;br /&gt;
　　&lt;strong&gt;该表达式适用于|U|&amp;lt;1，即 J2000.0 起算前后各 10000 年的范围内。&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// MeanObliquity returns mean obliquity (ε₀) following the IAU 1980
// polynomial.
//
// Accuracy is 1″ over the range 1000 to 3000 years and 10″ over the range
// 0 to 4000 years.
// 平黄赤交角 - 精度一般，2000年误差 1&amp;quot;，4000年误差为 10&amp;quot;
func MeanObliquity(jde float64) unit.Angle {
    // (22.2) p. 147
    return unit.AngleFromSec(base.Horner(base.J2000Century(jde),
        unit.FromSexaSec(&#39; &#39;, 23, 26, 21.448),
        -46.815,
        -0.00059,
        0.001813))
}

// MeanObliquityLaskar returns mean obliquity (ε₀) following the Laskar
// 1986 polynomial.
//
// Accuracy over the range 1000 to 3000 years is .01″.
//
// Accuracy over the valid date range of -8000 to +12000 years is
// &amp;quot;a few seconds.&amp;quot;
// 平黄赤交角 - 精度较好，1000年后误差0&amp;quot;.01(公元 1000 到 3000)，10000年后误差数个角秒
// 适用范围：J2000.0 起算前后各10000年的范围内。
func MeanObliquityLaskar(jde float64) unit.Angle {
    // (22.3) p. 147
    return unit.AngleFromSec(base.Horner(base.J2000Century(jde)*.01,
        unit.FromSexaSec(&#39; &#39;, 23, 26, 21.448),
        -4680.93,
        -1.55,
        1999.25,
        -51.38,
        -249.67,
        -39.05,
        7.12,
        27.87,
        5.79,
        2.45))
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;真黄赤交角：黄道与真赤道的夹角&lt;/p&gt;

&lt;p&gt;$$ε = ε_0 + Δε$$&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>天文算法19</title>
      <link>https://mooncaker816.github.io/2018/05/23/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9519/</link>
      <pubDate>Wed, 23 May 2018 14:36:29 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/05/23/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9519/</guid>
      <description>&lt;h1 id=&#34;第二十一章-岁差&#34;&gt;第二十一章 岁差&lt;/h1&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-名词解释&#34;&gt;1. 名词解释&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E9%80%B2%E5%8B%95&#34; target=&#34;_blank&#34;&gt;Precession&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;2-赤道坐标岁差的近似计算&#34;&gt;2. 赤道坐标岁差的近似计算&lt;/h2&gt;

&lt;p&gt;　　当两个历元相差不远，并且如果星体没有太靠近天极，下面的公式可以用来计算在这两个历元之间的，相对于起始历元的截至历元的年度平均岁差：$$Δα = m + n\sin α\tan δ$$
其中$m = 3s.07496 + 0s.00186T, n = 1s.33621 - 0s.00057T$
$$Δδ = n*cos(α)$$
其中$n = 20&amp;rdquo;.0431 - 0&amp;rdquo;.0085T$&lt;br /&gt;
T是J2000.0起算的儒略世纪数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// ApproxAnnualPrecession returns approximate annual precision in right
// ascension and declination.
//
// The two epochs should be within a few hundred years.
// The declinations should not be too close to the poles.
// 近似计算截至历元相对于起始历元的年度平均岁差，俩历元不能相差太远，且天体不能靠近天极
func ApproxAnnualPrecession(eq *coord.Equatorial, epochFrom, epochTo float64) (Δα unit.HourAngle, Δδ unit.Angle) {
	m, nα, nδ := mn(epochFrom, epochTo)
	sα, cα := eq.RA.Sincos()
	// (21.1) p. 132
	Δα = m + nα.Mul(sα*eq.Dec.Tan())
	Δδ = nδ.Mul(cα)
	return
}

// mn as separate function for testing purposes
// 计算截至历元相对于起始历元的平均年度岁差要用的变量 m,n
func mn(epochFrom, epochTo float64) (m, nα unit.HourAngle, nδ unit.Angle) {
	T := (epochTo - epochFrom) * .01
	m = unit.HourAngleFromSec(3.07496 + 0.00186*T)
	nα = unit.HourAngleFromSec(1.33621 - 0.00057*T)
	nδ = unit.AngleFromSec(20.0431 - 0.0085*T)
	return
}

// ApproxPosition uses ApproxAnnualPrecession to compute a simple and quick
// precession while still considering proper motion.
//
// Both eqFrom and eqTo must be non-nil, although they may point to the same
// struct.  EqTo is returned for convenience.
// 两历元之间坐标的换算，考虑岁差和自行运动（mα，mδ）
func ApproxPosition(eqFrom, eqTo *coord.Equatorial, epochFrom, epochTo float64, mα unit.HourAngle, mδ unit.Angle) *coord.Equatorial {
	Δα, Δδ := ApproxAnnualPrecession(eqFrom, epochFrom, epochTo)
	dy := epochTo - epochFrom
	eqTo.RA = eqFrom.RA.Add((Δα + mα).Mul(dy))
	eqTo.Dec = eqFrom.Dec + (Δδ + mδ).Mul(dy)
	return eqTo
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;3-赤道坐标岁差的精确计算&#34;&gt;3. 赤道坐标岁差的精确计算&lt;/h2&gt;

&lt;p&gt;设T是J2000.0起算的儒略世纪数，t是某一起始历元到终止历元之间的时间差，单位也是儒略世纪数。
\begin{cases}
ζ = ( 2306&amp;rdquo;.2181 + 1&amp;rdquo;.39656T - 0&amp;rdquo;.000139T^2)t + (0&amp;rdquo;.30188 - 0&amp;rdquo;.000344T)t^2 + 0&amp;rdquo;.017998t^3\\[2ex]
z = ( 2306&amp;rdquo;.2181 + 1&amp;rdquo;.39656T - 0&amp;rdquo;.000139T^2)t + (1&amp;rdquo;.09468 + 0&amp;rdquo;.000066T)t^2 + 0&amp;rdquo;.018203t^3\\[2ex]
θ = ( 2004&amp;rdquo;.3109 - 0&amp;rdquo;.85330T - 0&amp;rdquo;.000217T^2)t - (0&amp;rdquo;.42665 + 0&amp;rdquo;.000217T)t^2 - 0&amp;rdquo;.041833t^3
\end{cases}
当T=0时，即起始历元正好就是J2000.0,
\begin{cases}
ζ = 2306&amp;rdquo;.2181t + 0&amp;rdquo;.30188t^2 + 0&amp;rdquo;.017998t^3\\[2ex]
z = 2306&amp;rdquo;.2181t + 1&amp;rdquo;.09468t^2 + 0&amp;rdquo;.018203t^3\\[2ex]
θ = 2004&amp;rdquo;.3109t - 0&amp;rdquo;.42665t^2 - 0&amp;rdquo;.041833t^3
\end{cases}
再计算
\begin{cases}
A &amp;amp;= \cos δ_0\sin(α_0 + ζ)\\[2ex]
B &amp;amp;= \cos θ\cos δ_0\cos(α_0 +ζ) - \sin θ\sin δ_0\\[2ex]
C &amp;amp;= \sin θ\cos δ_0\cos(α_0 +ζ) + \cos θ\sin δ_0
\end{cases}
则$$\tan(α-z) = A/B,\sin δ = C$$
如果星体接近天极，使用$\cos δ = \sqrt {A^2+B^2}$代替$\sin δ = C$&lt;br /&gt;
$α,δ$即为经过岁差转换后的赤道坐标&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Precessor represents precession from one epoch to another.
//
// Construct with NewPrecessor, then call method Precess.
// After construction, Precess may be called multiple times to precess
// different coordinates with the same initial and final epochs.
// 计算赤道坐标精确岁差要用到的变量
type Precessor struct {
	ζ      unit.RA
	z      unit.Angle
	sθ, cθ float64
}

const d = math.Pi / 180
const s = d / 3600

// Package variables allow these slices to be reused.  (As composite
// literals inside of NewPrecessor they would be reallocated on every
// function call.)
var (
	// coefficients from (21.2) p. 134
	ζT = []float64{2306.2181 * s, 1.39656 * s, -0.000139 * s}
	zT = []float64{2306.2181 * s, 1.39656 * s, -0.000139 * s}
	θT = []float64{2004.3109 * s, -0.8533 * s, -0.000217 * s}

	// coefficients from (21.3) p. 134
	ζt = []float64{2306.2181 * s, 0.30188 * s, 0.017998 * s}
	zt = []float64{2306.2181 * s, 1.09468 * s, 0.018203 * s}
	θt = []float64{2004.3109 * s, -0.42665 * s, -0.041833 * s}
)

// NewPrecessor constructs a Precessor object and initializes it to precess
// coordinates from epochFrom to epochTo.
// 构造赤道坐标岁差计算要素
func NewPrecessor(epochFrom, epochTo float64) *Precessor {
	// (21.2) p. 134
	ζCoeff := ζt
	zCoeff := zt
	θCoeff := θt
	if epochFrom != 2000 {
		T := (epochFrom - 2000) * .01
		ζCoeff = []float64{
			base.Horner(T, ζT...),
			0.30188*s - 0.000344*s*T,
			0.017998 * s}
		zCoeff = []float64{
			base.Horner(T, zT...),
			1.09468*s + 0.000066*s*T,
			0.018203 * s}
		θCoeff = []float64{
			base.Horner(T, θT...),
			-0.42665*s - 0.000217*s*T,
			-0.041833 * s}
	}
	t := (epochTo - epochFrom) * .01
	p := &amp;amp;Precessor{
		ζ: unit.RA(base.Horner(t, ζCoeff...) * t),
		z: unit.Angle(base.Horner(t, zCoeff...) * t),
	}
	θ := base.Horner(t, θCoeff...) * t
	p.sθ, p.cθ = math.Sincos(θ)
	return p
}

// Precess precesses coordinates eqFrom, leaving result in eqTo.
//
// The same struct may be used for eqFrom and eqTo.
// EqTo is returned for convenience.
// 赤道坐标的岁差转换计算
func (p *Precessor) Precess(eqFrom, eqTo *coord.Equatorial) *coord.Equatorial {
	// (21.4) p. 134
	sδ, cδ := eqFrom.Dec.Sincos()
	sαζ, cαζ := (eqFrom.RA + p.ζ).Sincos()
	A := cδ * sαζ
	B := p.cθ*cδ*cαζ - p.sθ*sδ
	C := p.sθ*cδ*cαζ + p.cθ*sδ
	eqTo.RA = unit.RAFromRad(math.Atan2(A, B) + p.z.Rad())
	if math.Abs(C) &amp;lt; base.CosSmallAngle {
		eqTo.Dec = unit.Angle(math.Asin(C))
	} else {
		eqTo.Dec = unit.Angle(math.Acos(math.Hypot(A, B))) // near pole
		if C &amp;lt; 0 {
			eqTo.Dec = -eqTo.Dec
		}
	}
	return eqTo
}

// Position precesses equatorial coordinates from one epoch to another,
// including proper motions.
//
// If proper motions are not to be considered or are not applicable, pass 0, 0
// for mα, mδ
//
// Both eqFrom and eqTo must be non-nil, although they may point to the same
// struct.  EqTo is returned for convenience.
// 考虑自行运动的赤道坐标的转换
func Position(eqFrom, eqTo *coord.Equatorial, epochFrom, epochTo float64, mα unit.HourAngle, mδ unit.Angle) *coord.Equatorial {
	p := NewPrecessor(epochFrom, epochTo)
	t := epochTo - epochFrom
	eqTo.RA = unit.RAFromRad(eqFrom.RA.Rad() + mα.Rad()*t)
	eqTo.Dec = eqFrom.Dec + mδ*unit.Angle(t)
	return p.Precess(eqTo, eqTo)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;4-黄道坐标岁差的精确计算&#34;&gt;4. 黄道坐标岁差的精确计算&lt;/h2&gt;

&lt;p&gt;同上，我们先计算
\begin{cases}
η = (47&amp;rdquo;.0029 - 0&amp;rdquo;.06603T + 0&amp;rdquo;.000598T^2)t + (-0&amp;rdquo;.03302 + 0&amp;rdquo;.000598T)t^2 +0&amp;rdquo;.000060t^3\\[2ex]
П = 174°.876384 + 3289&amp;rdquo;.4789T + 0&amp;rdquo;.60622T^2 (869&amp;rdquo;.8089 + 0&amp;rdquo;.50491T)t + 0&amp;rdquo;.03536t^2\\[2ex]
p = (5029&amp;rdquo;.0966 + 2&amp;rdquo;.22226T - 0&amp;rdquo;.000042T^2)t + (1&amp;rdquo;.11113 - 0&amp;rdquo;.000042T)t^2 -0&amp;rdquo;.000006t^3
\end{cases}
当$T=0$时，
\begin{cases}
η = 47&amp;rdquo;.0029t -0&amp;rdquo;.03302t^2 +0&amp;rdquo;.000060t^3\\[2ex]
П = 174°.876384 -869&amp;rdquo;.8089t +0&amp;rdquo;.03536t^2\\[2ex]
p = 5029&amp;rdquo;.0966t +1&amp;rdquo;.11113t^2 -0&amp;rdquo;.000006t^3
\end{cases}
再计算
\begin{cases}
A′ &amp;amp;= \cos η\cos β_0\sin(П-λ_0) - \sin η\sin β_0\\[2ex]
B′ &amp;amp;= \cos β_0\cos(П-λ_0)\\[2ex]
C′ &amp;amp;= \cos η\sin β_0 + \sin η\cos β_0\sin(П-λ_0)
\end{cases}
则$$\tan(p +П-λ) = A′/B′,\sin β = C′$$
如果星体接近天极，使用$\cos β = \sqrt {A′^2+B′^2}$代替$\sin β = C′$&lt;br /&gt;
$λ,β$即为经过岁差转换后的黄道坐标&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// EclipticPrecessor represents precession from one epoch to another.
//
// Construct with NewEclipticPrecessor, then call method Precess.
// After construction, Precess may be called multiple times to precess
// different coordinates with the same initial and final epochs.
// 计算黄道坐标精确岁差要用到的变量
type EclipticPrecessor struct {
	sη, cη float64
	π, p   unit.Angle
}

var (
	// coefficients from (21.5) p. 136, scaled to radians
	ηT = []float64{47.0029 * s, -0.06603 * s, 0.000598 * s}
	πT = []float64{174.876384 * d, 3289.4789 * s, 0.60622 * s}
	pT = []float64{5029.0966 * s, 2.22226 * s, -0.000042 * s}

	// coefficients from (21.6) p. 136, scaled to radians
	ηt = []float64{47.0029 * s, -0.03302 * s, 0.000060 * s}
	πt = []float64{174.876384 * d, -869.8089 * s, 0.03536 * s}
	pt = []float64{5029.0966 * s, 1.11113 * s, -0.000006 * s}
)

// NewEclipticPrecessor constructs an EclipticPrecessor object and initializes
// it to precess coordinates from epochFrom to epochTo.
// 构造黄道坐标岁差计算要素
func NewEclipticPrecessor(epochFrom, epochTo float64) *EclipticPrecessor {
	// (21.5) p. 136
	ηCoeff := ηt
	πCoeff := πt
	pCoeff := pt
	if epochFrom != 2000 {
		T := (epochFrom - 2000) * .01
		ηCoeff = []float64{
			base.Horner(T, ηT...),
			-0.03302*s + 0.000598*s*T,
			0.000060 * s}
		πCoeff = []float64{
			base.Horner(T, πT...),
			-869.8089*s - 0.50491*s*T,
			0.03536 * s}
		pCoeff = []float64{
			base.Horner(T, pT...),
			1.11113*s - 0.000042*s*T,
			-0.000006 * s}
	}
	t := (epochTo - epochFrom) * .01
	p := &amp;amp;EclipticPrecessor{
		π: unit.Angle(base.Horner(t, πCoeff...)),
		p: unit.Angle(base.Horner(t, pCoeff...) * t),
	}
	η := unit.Angle(base.Horner(t, ηCoeff...) * t)
	p.sη, p.cη = η.Sincos()
	return p
}

// EclipticPrecess precesses coordinates eclFrom, leaving result in eclTo.
//
// The same struct may be used for eclFrom and eclTo.
// EclTo is returned for convenience.
// 黄道坐标的岁差转换
func (p *EclipticPrecessor) Precess(eclFrom, eclTo *coord.Ecliptic) *coord.Ecliptic {
	// (21.7) p. 137
	sβ, cβ := eclFrom.Lat.Sincos()
	sd, cd := (p.π - eclFrom.Lon).Sincos()
	A := p.cη*cβ*sd - p.sη*sβ
	B := cβ * cd
	C := p.cη*sβ + p.sη*cβ*sd
	eclTo.Lon = p.p + p.π - unit.Angle(math.Atan2(A, B))
	if math.Abs(C) &amp;lt; base.CosSmallAngle {
		eclTo.Lat = unit.Angle(math.Asin(C))
	} else {
		eclTo.Lat = unit.Angle(math.Acos(math.Hypot(A, B))) // near pole
		if C &amp;lt; 0 {
			eclTo.Lat = -eclTo.Lat
		}
	}
	return eclTo
}

// ReduceElements reduces orbital elements of a solar system body from one
// equinox to another.
//
// This function is described in chapter 24, but is located in this
// package so it can be a method of EclipticPrecessor.
func (p *EclipticPrecessor) ReduceElements(eFrom, eTo *elementequinox.Elements) *elementequinox.Elements {
	ψ := p.π + p.p
	si, ci := eFrom.Inc.Sincos()
	snp, cnp := (eFrom.Node - p.π).Sincos()
	// (24.1) p. 159
	eTo.Inc = unit.Angle(math.Acos(ci*p.cη + si*p.sη*cnp))
	// (24.2) p. 159
	eTo.Node = ψ +
		unit.Angle(math.Atan2(si*snp, p.cη*si*cnp-p.sη*ci))
	// (24.3) p. 160
	eTo.Peri = eFrom.Peri +
		unit.Angle(math.Atan2(-p.sη*snp, si*p.cη-ci*p.sη*cnp))
	return eTo
}

// EclipticPosition precesses ecliptic coordinates from one epoch to another,
// including proper motions.
//
// While eclFrom is given as ecliptic coordinates, proper motions mα, mδ are
// still expected to be equatorial.  If proper motions are not to be considered
// or are not applicable, pass 0, 0.
//
// Both eclFrom and eclTo must be non-nil, although they may point to the same
// struct.  EclTo is returned for convenience.
// 考虑自行运动的黄道坐标的转换，
// 注意此处的mα，mδ是赤道坐标系中的数值，要先转换为黄道坐标mλ, mβ
func EclipticPosition(eclFrom, eclTo *coord.Ecliptic, epochFrom, epochTo float64, mα unit.HourAngle, mδ unit.Angle) *coord.Ecliptic {
	p := NewEclipticPrecessor(epochFrom, epochTo)
	*eclTo = *eclFrom
	if mα != 0 || mδ != 0 {
		mλ, mβ := eqProperMotionToEcl(mα, mδ, epochFrom, eclFrom)
		t := epochTo - epochFrom
		eclTo.Lon += mλ.Mul(t)
		eclTo.Lat += mβ.Mul(t)
	}
	return p.Precess(eclTo, eclTo)
}

// 将自行运动由赤道坐标转黄道坐标
func eqProperMotionToEcl(mα unit.HourAngle, mδ unit.Angle, epoch float64, pos *coord.Ecliptic) (mλ, mβ unit.Angle) {
	ε := nutation.MeanObliquity(base.JulianYearToJDE(epoch))
	sε, cε := ε.Sincos()
	α, δ := coord.EclToEq(pos.Lon, pos.Lat, sε, cε)
	sα, cα := α.Sincos()
	sδ, cδ := δ.Sincos()
	cβ := pos.Lat.Cos()
	mλ = (mδ.Mul(sε*cα) + unit.Angle(mα).Mul(cδ*(cε*cδ+sε*sδ*sα))).Div(cβ * cβ)
	mβ = (mδ.Mul(cε*cδ+sε*sδ*sα) - unit.Angle(mα).Mul(sε*cα*cδ)).Div(cβ)
	return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;5-天体自行运动导致的坐标的转换&#34;&gt;5. 天体自行运动导致的坐标的转换&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// ProperMotion3D takes the 3D equatorial coordinates of an object
// at one epoch and computes its coordinates at a new epoch, considering
// proper motion and radial velocity.
//
// Radial distance (r) must be in parsecs, radial velocitiy (mr) in
// parsecs per year.
//
// Both eqFrom and eqTo must be non-nil, although they may point to the same
// struct.  EqTo is returned for convenience.
// 自行运动导致的赤道坐标变化的精确计算(不在当成常量乘以时间间隔)
func ProperMotion3D(eqFrom, eqTo *coord.Equatorial, epochFrom, epochTo, r, mr float64, mα unit.HourAngle, mδ unit.Angle) *coord.Equatorial {
	sα, cα := eqFrom.RA.Sincos()
	sδ, cδ := eqFrom.Dec.Sincos()
	x := r * cδ * cα
	y := r * cδ * sα
	z := r * sδ
	mrr := mr / r
	zmδ := z * mδ.Rad()
	mx := x*mrr - zmδ*cα - y*mα.Rad()
	my := y*mrr - zmδ*sα + x*mα.Rad()
	mz := z*mrr + r*mδ.Rad()*cδ
	t := epochTo - epochFrom
	xp := x + t*mx
	yp := y + t*my
	zp := z + t*mz
	eqTo.RA = unit.RAFromRad(math.Atan2(yp, xp))
	eqTo.Dec = unit.Angle(math.Atan2(zp, math.Hypot(xp, yp)))
	return eqTo
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>天文算法18</title>
      <link>https://mooncaker816.github.io/2018/05/23/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9518/</link>
      <pubDate>Wed, 23 May 2018 09:01:52 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/05/23/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9518/</guid>
      <description>&lt;h1 id=&#34;第二十章-smallest-circle-containing-three-celestial-bodies&#34;&gt;第二十章 Smallest Circle containing three Celestial Bodies&lt;/h1&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-问题&#34;&gt;1. 问题&lt;/h2&gt;

&lt;p&gt;设三点为A,B,C,对应三边为a,b,c,其中a为最长边，&lt;br /&gt;
当$a&amp;gt;\sqrt {b^2+c^2}$,则包含这三点的最小圆直径为a，&lt;br /&gt;
当$a&amp;lt;\sqrt {b^2+c^2}$,则包含这三点的最小圆直径为$$\frac {2abc}{\sqrt {(a+b+c)(a+b-c)(b+c-a)(a+c-b)}}$$&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://baike.baidu.com/item/外接圆半径公式/14818938?fr=aladdin&#34; target=&#34;_blank&#34;&gt;证明&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;给定三个天体的坐标，求最小圆直径。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Smallest finds the smallest circle containing three points.
//
// Arguments should represent coordinates in right ascension and declination
// or longitude and latitude.  Result Δ is the diameter of the circle, typeI
// is true if solution is of type I.
//
//	type I   Two points on circle, one interior.
//	type II  All three points on circle.
// 根据三点坐标，求最小圆直径
func Smallest(r1, d1, r2, d2, r3, d3 unit.Angle) (Δ unit.Angle, typeI bool) {
	// Using haversine formula, but reimplementing SepHav here to reuse
	// the computed cosines.
	cd1 := d1.Cos()
	cd2 := d2.Cos()
	cd3 := d3.Cos()
	a := 2 * math.Asin(math.Sqrt(base.Hav(d2-d1)+cd1*cd2*base.Hav(r2-r1)))
	b := 2 * math.Asin(math.Sqrt(base.Hav(d3-d2)+cd2*cd3*base.Hav(r3-r2)))
	c := 2 * math.Asin(math.Sqrt(base.Hav(d1-d3)+cd3*cd1*base.Hav(r1-r3)))
	if b &amp;gt; a {
		a, b = b, a
	}
	if c &amp;gt; a {
		a, c = c, a
	}
	if a*a &amp;gt;= b*b+c*c {
		return unit.Angle(a), true
	}
	// (20.1) p. 128
	return unit.Angle(2 * a * b * c /
		math.Sqrt((a+b+c)*(a+b-c)*(b+c-a)*(a+c-b))), false
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>天文算法17</title>
      <link>https://mooncaker816.github.io/2018/05/22/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9517/</link>
      <pubDate>Tue, 22 May 2018 10:15:11 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/05/22/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9517/</guid>
      <description>&lt;h1 id=&#34;第十九章-bodies-in-straight-line&#34;&gt;第十九章 Bodies in Straight Line&lt;/h1&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-定义&#34;&gt;1. 定义&lt;/h2&gt;

&lt;p&gt;　　当天体位于同一个天球大圆时，我们称之为天体处在同一&amp;rdquo;直线&amp;rdquo;上。&lt;br /&gt;
　　假设有三个天体,赤道系坐标分别为$(α_1,δ_1),(α_2,δ_2),(α_3,δ_3)$，当它们&amp;rdquo;共线&amp;rdquo;时，有：$$\tan δ_1\sin (α_2-α_3)+\tan δ_2\sin (α_3-α_1)+\tan δ_3\sin (α_1-α_2)=0$$
　　上述公式对黄道坐标系同样适用。&lt;/p&gt;

&lt;p&gt;　　利用该公式，我们就可以插值求得共线的时间点&lt;/p&gt;

&lt;h2 id=&#34;2-计算行星与两个恒星共线的时间点&#34;&gt;2. 计算行星与两个恒星共线的时间点&lt;/h2&gt;

&lt;p&gt;　　对于恒星，我们可以认为在一定观测时间范围内是静止的。所以在进行插值计算时，应该当做常数。如$(α_1,δ_1),(α_2,δ_2)$为恒星坐标，则插值时保持不变。&lt;br /&gt;
　　对于运动的行星，考虑一段时间范围内的坐标，进行插值并求零点。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Time computes the time at which a moving body is on a straight line (great
// circle) between two fixed points, such as stars.
//
// Coordinates may be right ascensions and declinations or longitudes and
// latitudes.  Fixed points are r1, d1, r2, d2.  Moving body is an ephemeris
// of 5 rows, r3, d3, starting at time t1 and ending at time t5.  Time scale
// is arbitrary.
//
// Result is time of alignment.
// 计算一个运动的天体和另外两个在观测时间内默认为不动的天体在一条直线上的时间点
func Time(r1, d1, r2, d2 unit.Angle, r3, d3 []unit.Angle, t1, t5 float64) (float64, error) {
	if len(r3) != 5 || len(d3) != 5 {
		return 0, errors.New(&amp;quot;r3, d3 must be length 5&amp;quot;)
	}
	gc := make([]float64, 5)
	for i, r3i := range r3 {
		// (19.1) p. 121
		gc[i] = d1.Tan()*(r2-r3i).Sin() +
			d2.Tan()*(r3i-r1).Sin() +
			d3[i].Tan()*(r1-r2).Sin()
	}
	l5, err := interp.NewLen5(t1, t5, gc)
	if err != nil {
		return 0, err
	}
	return l5.Zero(false)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;3-计算3点-近似共线-时的球面角和离共线大圆的角距离&#34;&gt;3. 计算3点&amp;rdquo;近似共线&amp;rdquo;时的球面角和离共线大圆的角距离&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://mooncaker816.github.io/img/line.png&#34; alt=&#34;&#34; /&gt;
　　如上图，$S_1,S_2,S_3$为三个天体，此时它们几乎&amp;rdquo;共线&amp;rdquo;,$C_1$为球面角$\angle PS_2S_1$，$C_2$为球面角$\angle PS_2S_3$，我们所求的就是球面角$\angle S_1S_2S_3$以及$S_2$与经过$S_1,S_3$的大圆之间的角距离（可以看作离共线还差多少度）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Meeus 计算三天体球面角$\angle S_1S_2S_3$&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;\begin{cases}
\tan C_1 &amp;amp;= \frac {\sin (α_2-α_1)}{\cos δ_2\tan δ_1-\sin δ_2\cos (α_2-α_1)}\\[2ex]
\tan C_2 &amp;amp;= \frac {\sin (α_3-α_2)}{\cos δ_2\tan δ_3-\sin δ_2\cos (α_3-α_2)}
\end{cases}
　　$C_1 + C_2$即为所求&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Angle returns the angle between great circles defined by three points.
//
// Coordinates may be right ascensions and declinations or longitudes and
// latitudes.  If r1, d1, r2, d2 defines one line and r2, d2, r3, d3 defines
// another, the result is the angle between the two lines.
//
// Algorithm by Meeus.
// 计算第一点第二点经过的大圆和第二点第三点经过的大圆之间的角度
func Angle(r1, d1, r2, d2, r3, d3 unit.Angle) unit.Angle {
	sd2, cd2 := d2.Sincos()
	sr21, cr21 := (r2 - r1).Sincos()
	sr32, cr32 := (r3 - r2).Sincos()
	C1 := math.Atan2(sr21, cd2*d1.Tan()-sd2*cr21)
	C2 := math.Atan2(sr32, cd2*d3.Tan()-sd2*cr32)
	return unit.Angle(C1 + C2)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Meeus 计算$S_2$与经过$S_1,S_3$的大圆之间的角距离&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　先计算：
\begin{cases}
X_1 &amp;amp;= \cos δ_1\cos α_1\\[2ex]
Y_1 &amp;amp;= \cos δ_1\sin α_1\\[2ex]
Z_1 &amp;amp;= \sin δ_1
\end{cases}
\begin{cases}
X_2 &amp;amp;= \cos δ_2\cos α_2\\[2ex]
Y_2 &amp;amp;= \cos δ_2\sin α_2\\[2ex]
Z_2 &amp;amp;= \sin δ_2
\end{cases}
\begin{cases}
A &amp;amp;= Y_1Z_2-Z_1Y_2\\[2ex]
B &amp;amp;= Z_1X_2-X_1Z_2\\[2ex]
C &amp;amp;= X_1Y_2-Y_1X_2
\end{cases}
$$m = \tan α_0, n = \frac {\tan δ_0}{\cos α_0}$$
　　则，$$\sin ω = \frac {A+Bm+Cn}{\sqrt {A^2+B^2+C^2}\sqrt{1+m^2+n^2}}$$
　　ω即为所求&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Error returns an error angle of three nearly co-linear points.
//
// For the line defined by r1, d1, r2, d2, the result is the anglular distance
// between that line and r0, d0.
//
// Algorithm by Meeus.
// 计算一点到由另外两点组成的大圆之间的角距离
func Error(r1, d1, r2, d2, r0, d0 unit.Angle) unit.Angle {
	sr1, cr1 := r1.Sincos()
	sd1, cd1 := d1.Sincos()
	sr2, cr2 := r2.Sincos()
	sd2, cd2 := d2.Sincos()
	X1 := cd1 * cr1
	X2 := cd2 * cr2
	Y1 := cd1 * sr1
	Y2 := cd2 * sr2
	Z1 := sd1
	Z2 := sd2
	A := Y1*Z2 - Z1*Y2
	B := Z1*X2 - X1*Z2
	C := X1*Y2 - Y1*X2
	m := r0.Tan()
	n := d0.Tan() / r0.Cos()
	return unit.Angle(math.Asin((A + B*m + C*n) /
		(math.Sqrt(A*A+B*B+C*C) * math.Sqrt(1+m*m+n*n))))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Pessens 同时计算上述两个量&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;\begin{cases}
a_1 &amp;amp;= \cos δ_1\cos α_1\\[2ex]
a_2 &amp;amp;= \cos δ_2\cos α_2\\[2ex]
a_3 &amp;amp;= \cos δ_3\cos α_3\\[2ex]
\end{cases}
\begin{cases}
b_1 &amp;amp;= \cos δ_1\sin α_1\\[2ex]
b_2 &amp;amp;= \cos δ_2\sin α_2\\[2ex]
b_3 &amp;amp;= \cos δ_3\sin α_3\\[2ex]
\end{cases}
\begin{cases}
c_1 &amp;amp;= \sin δ_1\\[2ex]
c_2 &amp;amp;= \sin δ_2\\[2ex]
c_3 &amp;amp;= \sin δ_3\\[2ex]
\end{cases}
\begin{cases}
l_1 &amp;amp;= b_1c_2-b_2c_1\\[2ex]
l_2 &amp;amp;= b_2c_3-b_3c_2\\[2ex]
l_3 &amp;amp;= b_1c_3-b_3c_1\\[2ex]
\end{cases}
\begin{cases}
m_1 &amp;amp;= c_1a_2-c_2a_1\\[2ex]
m_2 &amp;amp;= c_2a_3-c_3a_2\\[2ex]
m_3 &amp;amp;= c_1a_3-c_3a_1\\[2ex]
\end{cases}
\begin{cases}
n_1 &amp;amp;= a_1b_2-a_2b_1\\[2ex]
n_2 &amp;amp;= a_2b_3-a_3b_2\\[2ex]
n_3 &amp;amp;= a_1b_3-a_3b_1\\[2ex]
\end{cases}
　　则有：
\begin{cases}
\cos ψ &amp;amp;= \frac {l_1l_2+m_1m_2+n_1n_2}{\sqrt {l_1^2+m_1^2+n_1^2}\sqrt{l_2^2+m_2^2+n_2^2}}\\[2ex]
\sin ω &amp;amp;= \frac {a_2l_3+b_2m_3+c_2n_3}{\sqrt {a_2^2+b_2^2+c_2^2}\sqrt {l_3^2+m_3^2+n_3^2}}
\end{cases}
　　ψ，ω即为所求。ψ可能与 Meeus 方法求解的值互余180°。（平面的夹角有两个，互余180°）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// AngleError returns both an angle as in the function Angle, and an error
// as in the function Error.
//
// The algorithm is by B. Pessens.
// Angle和 Error 的合体版
// Angle 的值可能和之前 Angle 中计算的值互余180°（想象一下两个面的夹角）
func AngleError(r1, d1, r2, d2, r3, d3 unit.Angle) (ψ, ω unit.Angle) {
	sr1, cr1 := r1.Sincos()
	sd1, cd1 := d1.Sincos()
	sr2, cr2 := r2.Sincos()
	sd2, cd2 := d2.Sincos()
	sr3, cr3 := r3.Sincos()
	sd3, cd3 := d3.Sincos()
	a1 := cd1 * cr1
	a2 := cd2 * cr2
	a3 := cd3 * cr3
	b1 := cd1 * sr1
	b2 := cd2 * sr2
	b3 := cd3 * sr3
	c1 := sd1
	c2 := sd2
	c3 := sd3
	l1 := b1*c2 - b2*c1
	l2 := b2*c3 - b3*c2
	l3 := b1*c3 - b3*c1
	m1 := c1*a2 - c2*a1
	m2 := c2*a3 - c3*a2
	m3 := c1*a3 - c3*a1
	n1 := a1*b2 - a2*b1
	n2 := a2*b3 - a3*b2
	n3 := a1*b3 - a3*b1
	ψ = unit.Angle(math.Acos((l1*l2 + m1*m2 + n1*n2) /
		(math.Sqrt(l1*l1+m1*m1+n1*n1) * math.Sqrt(l2*l2+m2*m2+n2*n2))))
	ω = unit.Angle(math.Asin((a2*l3 + b2*m3 + c2*n3) /
		(math.Sqrt(a2*a2+b2*b2+c2*c2) * math.Sqrt(l3*l3+m3*m3+n3*n3))))
	return
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>天文算法16</title>
      <link>https://mooncaker816.github.io/2018/05/22/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9516/</link>
      <pubDate>Tue, 22 May 2018 09:37:47 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/05/22/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9516/</guid>
      <description>&lt;h1 id=&#34;第十八章-行星会合-planetary-conjunctions&#34;&gt;第十八章 行星会合 Planetary Conjunctions&lt;/h1&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-定义&#34;&gt;1. 定义&lt;/h2&gt;

&lt;p&gt;In astronomy, a conjunction occurs when two astronomical objects or spacecraft have either the same right ascension or the same ecliptic longitude, usually as observed from Earth.&lt;br /&gt;
当两个天体位于同一赤经（黄经）时，我们称之为会合。会合并不意味着最小角距离。&lt;/p&gt;

&lt;h2 id=&#34;2-计算会合的时间点以及纬度差&#34;&gt;2. 计算会合的时间点以及纬度差&lt;/h2&gt;

&lt;p&gt;由定义可知，当两天体的经度差为0时，我们称之为会合。&lt;br /&gt;
所以只要根据观测数据对经度差进行插值，再求零值对应的时间点即为会合时间。再根据这个时间点插值计算纬度差即可。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;两个都为移动的天体（行星）&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Planetary computes a conjunction between two moving objects, such as planets.
//
// Conjunction is found with interpolation against length 5 ephemerides.
//
// T1, t5 are times of first and last rows of ephemerides.  The scale is
// arbitrary.
//
// R1, d1 is the ephemeris of the first object.  The columns may be celestial
// coordinates in right ascension and declination or ecliptic coordinates in
// longitude and latitude.
//
// R2, d2 is the ephemeris of the second object, in the same frame as the first.
//
// Return value t is time of conjunction in the scale of t1, t5.
// Δd is the amount that object 2 was &amp;quot;above&amp;quot; object 1 at the time of
// conjunction.
// 计算两个移动的天体赤经（黄经）相同的时间点 t 和该时刻的赤纬（黄纬）差
func Planetary(t1, t5 float64, r1, d1, r2, d2 []unit.Angle) (t float64, Δd unit.Angle, err error) {
	if len(r1) != 5 || len(d1) != 5 || len(r2) != 5 || len(d2) != 5 {
		err = errors.New(&amp;quot;Five rows required in ephemerides&amp;quot;)
		return
	}
	dr := make([]float64, 5, 10)
	dd := dr[5:10]
	for i, r := range r1 {
		dr[i] = (r2[i] - r).Rad()
		dd[i] = (d2[i] - d1[i]).Rad()
	}
	return conj(t1, t5, dr, dd)
}

func conj(t1, t5 float64, dr, dd []float64) (t float64, Δd unit.Angle, err error) {
	var l5 *interp.Len5
	if l5, err = interp.NewLen5(t1, t5, dr); err != nil {
		return
	}
	if t, err = l5.Zero(true); err != nil { // 计算经度重合时的时间点 t
		return
	}
	if l5, err = interp.NewLen5(t1, t5, dd); err != nil {
		return
	}
	ΔdRad, err := l5.InterpolateXStrict(t) // 插值计算经度重合时的纬度差
	return t, unit.Angle(ΔdRad), err
}

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;一个为观测时间范围内默认不动的天体（恒星）&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Stellar computes a conjunction between a moving and non-moving object.
//
// Arguments and return values same as with Planetary, except the non-moving
// object is r1, d1.  The ephemeris of the moving object is r2, d2.
// 计算一个移动的天体和一个在观测时间范围内默认为不动的天体（如恒星）赤经（黄经）相同的时间点 t 和该时刻的赤纬（黄纬）差
func Stellar(t1, t5 float64, r1, d1 unit.Angle, r2, d2 []unit.Angle) (t float64, Δd unit.Angle, err error) {
	if len(r2) != 5 || len(d2) != 5 {
		err = errors.New(&amp;quot;Five rows required in ephemeris&amp;quot;)
		return
	}
	dr := make([]float64, 5, 10)
	dd := dr[5:10]
	for i, r := range r2 {
		dr[i] = (r - r1).Rad()
		dd[i] = (d2[i] - d1).Rad()
	}
	return conj(t1, t5, dr, dd)
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>天文算法15</title>
      <link>https://mooncaker816.github.io/2018/05/21/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9515/</link>
      <pubDate>Mon, 21 May 2018 18:46:37 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/05/21/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9515/</guid>
      <description>&lt;h1 id=&#34;第十七章-角距离-angular-separation&#34;&gt;第十七章 角距离 Angular Separation&lt;/h1&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-定义&#34;&gt;1. 定义&lt;/h2&gt;

&lt;p&gt;　　角距离，也称为角分离、视距离、或视分离，在数学(特别是几何学和三角学)和自然科学(包括天文学、地质学等等)，从不同于两个点物体的位置（即第三点）观察这两个物体，由观测者指向这两个物体的直线之间所夹角度的大小。角距离(或分离)与角度本身是同义的，但意义却是对两个天体(对恒星，是当从地球观测)之间线距离的建议(通常是很大或未知的)。&lt;/p&gt;

&lt;h2 id=&#34;2-计算&#34;&gt;2. 计算&lt;/h2&gt;

&lt;h3 id=&#34;2-1-余弦公式直接计算&#34;&gt;2.1 余弦公式直接计算&lt;/h3&gt;

&lt;p&gt;$$\cos d=\sin δ_1 \sin δ_2 + \cos δ_1 \cos δ_2 \cos (α_1 -α_2)$$
式中$α_1,δ_1,α_2,δ_2$分别对应两个天体的赤经和赤纬。&lt;br /&gt;
当$d$接近于0或180度时，$\left|\cos d\right|$接近于1，并且其值随$d$变化很小，所以得到的$d$不精确。此时需用以下公式计算：$$d = \sqrt {(Δα\cos δ)^2+(Δδ)^2}$$
式中$Δα$是两个赤经的差，$Δδ$是两个赤纬的差，$δ$是两个赤纬的平均值。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Sep returns the angular separation between two celestial bodies.
//
// The algorithm is numerically naïve, and while patched up a bit for
// small separations, remains unstable for separations near π.
// 计算两天体之间的角距，r为赤经，d为赤纬
func Sep(r1, d1, r2, d2 unit.Angle) unit.Angle {
	sd1, cd1 := d1.Sincos()
	sd2, cd2 := d2.Sincos()
	cd := sd1*sd2 + cd1*cd2*(r1-r2).Cos() // (17.1) p. 109
	if cd &amp;lt; base.CosSmallAngle {
		return unit.Angle(math.Acos(cd))
	}
	// (17.2) p. 109
	dm := (d1 + d2) / 2
	return unit.Angle(math.Hypot((r2-r1).Rad()*dm.Cos(), (d2 - d1).Rad()))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-2-根据观测数据插值计算最小角距离&#34;&gt;2.2 根据观测数据插值计算最小角距离&lt;/h3&gt;

&lt;p&gt;注意，不能先计算出各组数据点的角距离，再对角距离插值计算。因为当两个天体很近时，两天体间是线性的靠近再线性的离开。此时需要先对数据点插值，再把得出的数据套用2.1的方法进行计算。或者引入 u,v 坐标，先将原始数据转为 u,v 坐标，然后对 u,v 坐标点进行插值计算，得出最小值&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// MinSep returns the minimum separation between two moving objects.
//
// The motion is represented as an ephemeris of three rows, equally spaced
// in time.  Jd1, jd3 are julian day times of the first and last rows.
// R1, d1, r2, d2 are coordinates at the three times.  They must each be
// slices of length 3.
//
// Result is obtained by computing separation at each of the three times
// and interpolating a minimum.  This may be invalid for sufficiently close
// approaches.
//
// 计算两个天体之间的最小角距
// 此方法是将数据点计算成角距，然后直接对角距3点插值，求取最小值，
// 当两个天体十分接近时，这个结果是不准确的，要使用方法MinSepRect
func MinSep(jd1, jd3 float64, r1, d1, r2, d2 []unit.Angle) (unit.Angle, error) {
	if len(r1) != 3 || len(d1) != 3 || len(r2) != 3 || len(d2) != 3 {
		return 0, interp.ErrorNot3
	}
	y := make([]float64, 3)
	for x, r := range r1 {
		y[x] = Sep(r, d1[x], r2[x], d2[x]).Rad()
	}
	d3, err := interp.NewLen3(jd1, jd3, y)
	if err != nil {
		return 0, err
	}
	_, dMin, err := d3.Extremum()
	return unit.Angle(dMin), err
}

// MinSepRect returns the minimum separation between two moving objects.
//
// Like MinSep, but using a method of rectangular coordinates that gives
// accurate results even for close approaches.
// 计算两个天体之间的最小角距
// 此方法是引入直角坐标 u,v,先将数据点转换成u,v 表达，然后对u,v插值，求取最小值，
func MinSepRect(jd1, jd3 float64, r1, d1, r2, d2 []unit.Angle) (unit.Angle, error) {
	if len(r1) != 3 || len(d1) != 3 || len(r2) != 3 || len(d2) != 3 {
		return 0, interp.ErrorNot3
	}
	uv := func(r1, d1, r2, d2 unit.Angle) (u, v float64) {
		sd1, cd1 := d1.Sincos()
		Δr := r2 - r1
		tΔr := Δr.Tan()
		thΔr := (Δr / 2).Tan()
		K := 1 / (1 + sd1*sd1*tΔr*thΔr)
		sΔd := (d2 - d1).Sin()
		u = -K * (1 - (sd1/cd1)*sΔd) * cd1 * tΔr
		v = K * (sΔd + sd1*cd1*tΔr*thΔr)
		return
	}
	us := make([]float64, 3, 6)
	vs := us[3:6]
	for x, r := range r1 {
		us[x], vs[x] = uv(r, d1[x], r2[x], d2[x])
	}
	u3, err := interp.NewLen3(-1, 1, us)
	if err != nil {
		panic(err) // bug not caller&#39;s fault.
	}
	v3, err := interp.NewLen3(-1, 1, vs)
	if err != nil {
		panic(err) // bug not caller&#39;s fault.
	}
	up0 := (us[2] - us[0]) / 2
	vp0 := (vs[2] - vs[0]) / 2
	up1 := us[0] + us[2] - 2*us[1]
	vp1 := vs[0] + vs[2] - 2*vs[1]
	up := up0
	vp := vp0
	dn := -(us[1]*up + vs[1]*vp) / (up*up + vp*vp)
	n := dn
	var u, v float64
	for limit := 0; limit &amp;lt; 10; limit++ {
		u = u3.InterpolateN(n)
		v = v3.InterpolateN(n)
		if math.Abs(dn) &amp;lt; 1e-5 {
			return unit.Angle(math.Hypot(u, v)), nil // success
		}
		up := up0 + n*up1
		vp := vp0 + n*vp1
		dn = -(u*up + v*vp) / (up*up + vp*vp)
		n += dn
	}
	return 0, errors.New(&amp;quot;MinSepRect: failure to converge&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-3-利用半正矢的特点提高当角距很小时的精确程度&#34;&gt;2.3 利用半正矢的特点提高当角距很小时的精确程度&lt;/h3&gt;

&lt;p&gt;根据半正矢公式$hav(d) = hav(Δδ) + \cos δ_1 \cos δ_2 hav(Δα)$,式中 $Δα = α_1 - α_2，Δδ = δ_1 - δ_2$，
又由$hav(d)=\frac {1-\cos d}{2}=\sin^2(\frac d2)$,可以有效的在0，180°附近提高计算机的精度。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// SepHav returns the angular separation between two celestial bodies.
//
// The algorithm uses the haversine function and is superior to the naïve
// algorithm of the Sep function.
// 利用半正矢的特点提高当角距很小时的精确程度
func SepHav(r1, d1, r2, d2 unit.Angle) unit.Angle {
	// using (17.5) p. 115
	return unit.Angle(2 * math.Asin(math.Sqrt(base.Hav(d2-d1)+
		d1.Cos()*d2.Cos()*base.Hav(r2-r1))))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-4-pauwels公式&#34;&gt;2.4 Pauwels公式&lt;/h3&gt;

&lt;p&gt;令
\begin{cases}
x &amp;amp;= \cos δ_1\sin δ_2 - \sin δ_1\cos δ_2\cos (α_2-α_1)\\[2ex]
x &amp;amp;= \cos δ_2\sin (α_2-α_1)\\[2ex]
z &amp;amp;= \sin δ_1\sin δ_2 + \cos δ_1\cos δ_2\cos (α_2-α_1)\\[2ex]
\end{cases}
则有：$$d=\arctan (\frac {\sqrt {x^2+y^2}}{z})$$&lt;/p&gt;

&lt;p&gt;数学上来说，这与余弦定理完全等价，只不过是巧妙的将余弦转化为正切，而对于计算机来说，
反正切比反正弦能获得更高的精确度&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// SepPauwels returns the angular separation between two celestial bodies.
//
// The algorithm is a numerically stable form of that used in Sep.
// 当z小于0时，返回值应该在90-180度之间
// 该方法与直接余弦定理求角距在数学上是等价的，
// 但是对于计算机来说，arctan 比 arcsin能获得更高的精度
func SepPauwels(r1, d1, r2, d2 unit.Angle) unit.Angle {
	sd1, cd1 := d1.Sincos()
	sd2, cd2 := d2.Sincos()
	cdr := (r2 - r1).Cos()
	x := cd1*sd2 - sd1*cd2*cdr
	y := cd2 * (r2 - r1).Sin()
	z := sd1*sd2 + cd1*cd2*cdr
	return unit.Angle(math.Atan2(math.Hypot(x, y), z))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-5-relative-position-angle&#34;&gt;2.5 Relative Position Angle&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Position_angle&#34; target=&#34;_blank&#34;&gt;定义即相关信息&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// RelativePosition returns the position angle of one body with respect to
// another.
//
// The position angle result is measured counter-clockwise from North.
// 1相对2的角距，从2的正北到1的角度
// https://en.wikipedia.org/wiki/Position_angle
func RelativePosition(r1, d1, r2, d2 unit.Angle) unit.Angle {
	sΔr, cΔr := (r1 - r2).Sincos()
	sd2, cd2 := d2.Sincos()
	return unit.Angle(math.Atan2(sΔr, cd2*d1.Tan()-sd2*cΔr))
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>天文算法14</title>
      <link>https://mooncaker816.github.io/2018/05/21/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9514/</link>
      <pubDate>Mon, 21 May 2018 12:29:48 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/05/21/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9514/</guid>
      <description>&lt;h1 id=&#34;第十六章-大气折射-atmospheric-refraction&#34;&gt;第十六章 大气折射 Atmospheric Refraction&lt;/h1&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-大气折射&#34;&gt;1. 大气折射&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;大气折射（又称：蒙气差（蒙气即行星的大气）、折光差）即原本直线前进的光或其它电磁波在穿越大气层时，因为空气密度随着高度变化所产生的偏折。这种折射是光通过空气时因为密度的增加使速度降低（折射率增加）。大气折射在近地面时会产生海市蜃楼，让远方的物体出现或荡漾，和非幻觉的升高或降低，伸长或缩短。这个词也适用于声音的折射。无论是天体或地面上物体位置的测量都需要考虑大气折射。&lt;/p&gt;

&lt;p&gt;对天文或天体的折射，导致天体在天空中的位置看起来比实际为高。大地折射通常导致物体出现在比实际高的位置上，然而在靠近地面的空气被加热的下午，光线的曲折向上会使物体看似出现在比实际位置低的地方。&lt;/p&gt;

&lt;p&gt;折射不仅影响可见光，还包括所有的电磁波，然而在程度上不尽相同（见光的色散）。例如在可见光，蓝色受到的影响大于红色。这会对天体光谱在展开时的高解析图像造成影响。&lt;/p&gt;

&lt;p&gt;只要有可能，天文学家会安排在天体在天空中接近高度最高的顶点时才要观测。同样的，水手也不会观测一颗高度低于20°或更低恒星的位置。如果不能避免靠近地平线的观测，有可能使用具有修正系统，以弥补这种折射造成的影响。如果色散也是一个问题（如果是宽频的高解析观测），大气折射可以使用成对的旋转玻璃棱镜处理掉。但是当大气折射的总量是温度梯度、温度、压力和湿度（特别是在中红外波长时的水蒸气总量）的函数时，成功补偿这些修正量的工作可以让人为之望而却步。另一方面，测量师经常都会将他们的工作安排在下午折射程度最低的时候。&lt;/p&gt;

&lt;p&gt;在有很强的温度梯度、大气不均匀和空气动荡的时候，大气折射会变得很严重。这是造成恒星闪烁和日出与日落时太阳各种不同变形的原因。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/5/5d/Refracci%C3%B3n.png&#34; alt=&#34;太阳在日出和日落时位移的图&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;2-真纬度-视纬度&#34;&gt;2. 真纬度，视纬度&lt;/h2&gt;

&lt;p&gt;　　真纬度即为天体的真实地平纬度(仰角)$h$，视纬度即为经过大气折射后观测到的纬度$h_0$。&lt;br /&gt;
　　当已知真纬度$h$，&lt;strong&gt;可以由该$h$推算出一个矫正量R&lt;/strong&gt;，视纬度$h_0 = h + R$&lt;br /&gt;
　　当已知视纬度$h_0$，&lt;strong&gt;可以由该$h_0$推算出一个矫正量R&lt;/strong&gt;，真纬度$h = h_0 - R$&lt;/p&gt;

&lt;h2 id=&#34;3-矫正量r-单位角分&#34;&gt;3. 矫正量R&amp;ndash;单位角分&lt;/h2&gt;

&lt;h3 id=&#34;3-1-h-0-rightarrow-r-h&#34;&gt;3.1 $h_0 \Rightarrow R,h$&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;$h_0&amp;gt;15°$时：
$$R=58&amp;rdquo;.294\tan(90-h_0)-0&amp;rdquo;.0668\tan^3(90°-h_0)$$
$$h = h_0 - R$$&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Gt15True returns refraction for obtaining true altitude when altitude
// is greater than 15 degrees (about .26 radians.)
//
// h0 must be a measured apparent altitude of a celestial body.
//
// Result is refraction to be subtracted from h0 to obtain the true altitude
// of the body.
// 纬度大于15度时，由视纬度求真纬度的矫正量R
func Gt15True(h0 unit.Angle) unit.Angle {
    // (16.1) p. 105
    t := (math.Pi/2 - h0).Tan()
    return gt15true1.Mul(t) - gt15true2.Mul(t*t*t)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Bennett公式，当$h\in [0,90°]$时：
$$R = \frac {1}{\tan(h_0 +\frac {7.31}{h_0 +4.4})}$$
$$ΔR = -0.06sin(14.7R+13)$$
对于任意$h_0$，这个公式的精度是$0.07′=4.2&amp;rdquo;$，最大误差发生在$h_0 =12°$。&lt;br /&gt;
应当注意的是：当$h_0 =90°$时，$R=-0&amp;rdquo;.08$，理论上天顶应该不受折射影响，可以加上0.0013515′，从而为0。&lt;br /&gt;
若考虑修正量，即$R=R+ΔR$，最大误差为$0.015′=0.9&amp;rdquo;$。&lt;br /&gt;
当$h_0 =90°$时，计算的结果是$R=-0.89&amp;rdquo;$，不作第二项修正反而更好。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Bennett returns refraction for obtaining true altitude.
//
// h0 must be a measured apparent altitude of a celestial body in radians.
//
// Results are accurate to .07 arc min from horizon to zenith.
//
// Result is refraction to be subtracted from h0 to obtain the true altitude
// of the body.
// Bennett 公式，由视纬度求真纬度矫正量 R
func Bennett(h0 unit.Angle) unit.Angle {
    // (16.3) p. 106
    hd := h0.Deg()
    return unit.AngleFromMin(1 / math.Tan((hd+7.31/(hd+4.4))*math.Pi/180))
}

// Bennett2 returns refraction for obtaining true altitude.
//
// Similar to Bennett, but a correction is applied to give a more accurate
// result.
//
// Results are accurate to .015 arc min.  Result unit is radians.
// 带矫正量的Bennett公式
func Bennett2(h0 unit.Angle) unit.Angle {
    R := Bennett(h0).Min()
    return unit.AngleFromMin(R - .06*math.Sin((14.7*R+13)*math.Pi/180))
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;3-2-h-rightarrow-r-h-0&#34;&gt;3.2 $h \Rightarrow R,h_0$&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;$h&amp;gt;15°$时：
$$R=58&amp;rdquo;.276\tan(90°-h) -0&amp;rdquo;.0824\tan^3(90°-h)$$
$$h_0 = h + R$$&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Gt15Apparent returns refraction for obtaining apparent altitude when
// altitude is greater than 15 degrees (about .26 radians.)
//
// h must be a computed true &amp;quot;airless&amp;quot; altitude of a celestial body.
//
// Result is refraction to be added to h to obtain the apparent altitude
// of the body.
// 纬度大于15度时，由真纬度求视纬度的矫正量R
func Gt15Apparent(h unit.Angle) unit.Angle {
    // (16.2) p. 105
    t := (math.Pi/2 - h).Tan()
    return gt15app1.Mul(t) - gt15app2.Mul(t*t*t)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;类Bennett公式
$$R = \frac {1.02}{\tan(h+\frac{10.3}{h+5.11})}$$
同样，$h=90°$时，该式算得$R$不等于零,差值是 0.0019279。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Saemundsson returns refraction for obtaining apparent altitude.
//
// h must be a computed true &amp;quot;airless&amp;quot; altitude of a celestial body in radians.
//
// Result is refraction to be added to h to obtain the apparent altitude
// of the body.
//
// Results are consistent with Bennett to within 4 arc sec.
// 由真纬度求视纬度矫正量，与Bennett公式对应
func Saemundsson(h unit.Angle) unit.Angle {
    // (16.4) p. 106
    hd := h.Deg()
    return unit.AngleFromMin(1.02 / math.Tan((hd+10.3/(hd+5.11))*math.Pi/180))
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>天文算法13</title>
      <link>https://mooncaker816.github.io/2018/05/20/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9513/</link>
      <pubDate>Sun, 20 May 2018 20:50:07 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/05/20/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9513/</guid>
      <description>&lt;h1 id=&#34;第十五章-升-中天-降-rising-transit-setting&#34;&gt;第十五章 升，中天，降 Rising,Transit,Setting&lt;/h1&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-升-中天-降的概念&#34;&gt;1. 升，中天，降的概念&lt;/h2&gt;

&lt;p&gt;　　升就是天体位于观测点地平线上即将升起的位置，由于大气的折射，当我们看到天体位于地平线上时，天体的真实位置在地平线之下 0°34′。而对于太阳，视升降一般指太阳圆盘上边缘的升与降，因此需加上16′的太阳半径进行计算。&lt;br /&gt;
　　降与升类似，只是运动方向相反。&lt;br /&gt;
　　中天是指天体位于本地子午圈上时的位置，即离天顶最近的位置。&lt;/p&gt;

&lt;h2 id=&#34;2-计算升-中天-降的时刻&#34;&gt;2. 计算升，中天，降的时刻&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;根据第十三章中计算本地仰角的公式计算时角H$$\sin h = \sin φ\sin δ+\cos φ\cos δ\cos H$$
令$h_0=0$，则$$\cos H_0=-\tan φ\tan δ$$
但这只是理想状态，由于大气折射，我们要令$h_0=-0°34′$，对于太阳，令$h_0=-0°50′$，对于月亮，这个问题更复杂，因为$h_0$不是常数。考虑半径变化及地平视差，我们得到月亮的：$h_0 = 0.7275π - 0°34′$ 式中 $π$是月亮的地平视差（不是上章所说的视差角）。如果精度要球不高，$h_0$可以取均值$h_0 = 0°.125$，则$$\cos H_0 = \frac {\sin h_0 - \sin φ\sin δ}{\cos φ\cos δ}$$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;计算格林尼治D日0h（UT时）的视恒星时$θ_0$，并转为度单位,本地恒星时$θ=θ_0-L$,$L$为观测点经度，从格林尼治测量，向西为正，向东为负&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;天体的视赤经及视赤纬（单位是度）：
\begin{cases}
α_1 和 δ_1， 在力学时 D-1 日 0h\\[2ex]
α_2 和 δ_2， 在力学时 D 日 0h\\[2ex]
α_3 和 δ_3， 在力学时 D+1 日 0h\\[2ex]
\end{cases}
我们先使用下式估算时间： $$\cos H_0 = \frac {\sin h_0 - \sin φ\sin δ_2}{\cos φ\cos δ_2}$$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;估算中天，升起，降落时间点，单位为日（带小数）&lt;/p&gt;

&lt;p&gt;$H_0$单位是度，$H_0$应转换到 0 度到 180 度。那么我们有：
\begin{cases}
中天：m_0 = (α_2 + L - θ_0)/360 \\[2ex]
升起：m_1 = m_0 - H_0 /360 \\[2ex]
降落：m_2 = m_0 + H_0 /360\\[2ex]
\end{cases}
式中$m$是$D$日的时间（即$D$日$m$时），单位是日。因此 $m$ 的值在 0 到 1，如果$m$的值超过这个范围，那么应加 1 或减 1。例如：m = 0.3744，则不用变；m = -0.1709，则应加 1 变为+0.8291；m = +1.1853 则应减 1 变 为+0.1853。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;根据上一步求得的m,分别计算三个时刻点的格林威治恒星时$θ = θ_0 + 360.985647m$，式中$m$是$m_0、m_1、m_2$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;考虑ΔT，得到一个$m_0+ΔT/86400$的时刻点，对该时刻点在所给的视赤经，视赤纬数据中插值求解得到新的中天时刻对应的天体视赤经α，视赤纬δ（单单求解中天用不着视赤纬数据，但升降需要）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;计算中天时本地时角$H= θ - L - α$，新的中天即为$m_0 = m_0-\frac{H}{360}$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;同上，对升，降估计时间考虑$ΔT$并插值求解对应的视赤经$α$，视赤纬$δ$，再根据地平坐标转换公式，求得地平仰角$h$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;再求分别对应的本地时角$H$,则新的升,降即为$$m= m + \frac {h-h_0}{360\cos δ\cos φ\sin H}$$&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// ApproxTimes computes approximate UT rise, transit and set times for
// a celestial object on a day of interest.
//
// The function argurments do not actually include the day, but do include
// values computed from the day.
//
//	p is geographic coordinates of observer. p 为地平坐标（仰角，方位角）
//	h0 is &amp;quot;standard altitude&amp;quot; of the body. h0 为天体升，降时实际地平线纬度
//	Th0 is apparent sidereal time at 0h UT at Greenwich. Th0 为格林威治0h UT视恒星时
//	α, δ are right ascension and declination of the body. α, δ为天体0h DT视赤经，视赤纬
//
// Th0 must be the time on the day of interest.
// See sidereal.Apparent0UT.
//
// α, δ must be values at 0h dynamical time for the day of interest.
// 近似计算升，中天，降时间
func ApproxTimes(p globe.Coord, h0 unit.Angle, Th0 unit.Time, α unit.RA, δ unit.Angle) (tRise, tTransit, tSet unit.Time, err error) {
	// approximate local hour angle
	sLat, cLat := p.Lat.Sincos()
	sδ1, cδ1 := δ.Sincos()
	cH0 := (h0.Sin() - sLat*sδ1) / (cLat * cδ1) // (15.1) p. 102
	if cH0 &amp;lt; -1 || cH0 &amp;gt; 1 {
		err = ErrorCircumpolar
		return
	}
	H0 := unit.TimeFromRad(math.Acos(cH0))

	// approximate transit, rise, set times.
	// (15.2) p. 102.
	mt := unit.TimeFromRad(α.Rad()+p.Lon.Rad()) - Th0
	tTransit = mt.Mod1()
	tRise = (mt - H0).Mod1()
	tSet = (mt + H0).Mod1()
	return
}

// Times computes UT rise, transit and set times for a celestial object on
// a day of interest.
//
// The function argurments do not actually include the day, but do include
// a number of values computed from the day.
//
//	p is geographic coordinates of observer.
//	ΔT is delta T.
//	h0 is &amp;quot;standard altitude&amp;quot; of the body.
//	Th0 is apparent sidereal time at 0h UT at Greenwich.
//	α3, δ3 are slices of three right ascensions and declinations.
//
// h0 unit is radians.
//
// Th0 must be the time on the day of interest, in seconds.
// See sidereal.Apparent0UT.
//
// α3, δ3 must be values at 0h dynamical time for the day before, the day of,
// and the day after the day of interest.  Units are radians.
//
// Result units are seconds of day and are in the range [0,86400).
// 对近似计算结果迭代，得到精确升，中天，降时间
func Times(p globe.Coord, ΔT unit.Time, h0 unit.Angle, Th0 unit.Time, α3 []unit.RA, δ3 []unit.Angle) (tRise, tTransit, tSet unit.Time, err error) {
	tRise, tTransit, tSet, err = ApproxTimes(p, h0, Th0, α3[1], δ3[1])
	if err != nil {
		return
	}
	αf := make([]float64, 3)
	for i, α := range α3 {
		αf[i] = α.Rad()
	}
	δf := make([]float64, 3)
	for i, δ := range δ3 {
		δf[i] = δ.Rad()
	}
	var d3α, d3δ *interp.Len3
	d3α, err = interp.NewLen3(-86400, 86400, αf)
	if err != nil {
		return
	}
	d3δ, err = interp.NewLen3(-86400, 86400, δf)
	if err != nil {
		return
	}
	// adjust tTransit
	{
		th0 := (Th0 + tTransit.Mul(360.985647/360)).Mod1()
		α := d3α.InterpolateX((tTransit + ΔT).Sec())
		// local hour angle as Time
		H := th0 - unit.TimeFromRad(p.Lon.Rad()+α)
		tTransit -= H
	}
	// adjust tRise, tSet
	sLat, cLat := p.Lat.Sincos()
	adjustRS := func(m unit.Time) (unit.Time, error) {
		th0 := (Th0 + m.Mul(360.985647/360)).Mod1()
		ut := (m + ΔT).Sec()
		α := d3α.InterpolateX(ut)
		δ := d3δ.InterpolateX(ut)
		Hrad := th0.Rad() - p.Lon.Rad() - α
		sδ, cδ := math.Sincos(δ)
		sH, cH := math.Sincos(Hrad)
		h := math.Asin(sLat*sδ + cLat*cδ*cH)
		md := (unit.TimeFromRad(h) - h0.Time()).Div(cδ * cLat * sH)
		return m + md, nil
	}
	tRise, err = adjustRS(tRise)
	if err != nil {
		return
	}
	tSet, err = adjustRS(tSet)
	return
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
  </channel>
</rss>
