<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Mooncaker816 on Mooncaker816</title>
    <link>https://mooncaker816.github.io/</link>
    <description>Recent content in Mooncaker816 on Mooncaker816</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <copyright>&amp;copy; 2018-Present</copyright>
    <lastBuildDate>Wed, 20 Apr 2016 00:00:00 +0800</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>TLS（一）</title>
      <link>https://mooncaker816.github.io/2018/08/03/tls%E4%B8%80/</link>
      <pubDate>Fri, 03 Aug 2018 07:24:15 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/08/03/tls%E4%B8%80/</guid>
      <description>&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;1-tls-基本概念&#34;&gt;1. TLS 基本概念&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;传输层安全性协议（英语：Transport Layer Security，缩写作 TLS），及其前身安全套接层（Secure Sockets Layer，缩写作 SSL）是一种安全协议，目的是为互联网通信，提供安全及数据完整性保障。网景公司（Netscape）在1994年推出首版网页浏览器，网景导航者时，推出HTTPS协议，以SSL进行加密，这是SSL的起源。IETF将SSL进行标准化，1999年公布第一版TLS标准文件。随后又公布RFC 5246 （2008年8月）与 RFC 6176 （2011年3月）。在浏览器、电子邮件、即时通信、VoIP、网络传真等应用程序中，广泛支持这个协议。主要的网站，如Google、Facebook等也以这个协议来创建安全连线，发送数据。目前已成为互联网上保密通信的工业标准。&lt;/p&gt;

&lt;p&gt;SSL包含记录层（Record Layer）和传输层，记录层协议确定传输层数据的封装格式。传输层安全协议使用X.509认证，之后利用非对称加密演算来对通信方做身份认证，之后交换对称密钥作为会谈密钥（Session key）。这个会谈密钥是用来将通信两方交换的数据做加密，保证两个应用间通信的保密性和可靠性，使客户与服务器应用之间的通信不被攻击者窃听。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　以上是 Wiki 对 TLS 的描述，通俗点说，TLS 就是用来在通信双方之间建立一条安全的加密的而又可靠的通道，确保双方完成数据交换。&lt;/p&gt;

&lt;p&gt;　　本文主要是结合 Go 的 TLS(&amp;lt;= 1.2) 实现来分析如何一步一步搭建起这条“通道”的。在此之前，需要理解秘钥交换算法，签名算法，密码算法，密码模式，摘要算法，它们的组合称为密码套件(CipherSuite)。例如 &lt;code&gt;TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;秘钥交换算法：ECDHE，椭圆曲线秘钥交换，用于交换公钥生成预备主密钥&lt;/li&gt;
&lt;li&gt;签名算法：ECDSA，椭圆曲线数字签名算法，用于身份认证&lt;/li&gt;
&lt;li&gt;密码算法：AES 256，秘钥为 256-bits 的 AES 加密算法，用于对数据的加密&lt;/li&gt;
&lt;li&gt;密码模式：GCM，伽罗瓦计数器模式，数据块加密的模式&lt;/li&gt;
&lt;li&gt;摘要算法：SHA384，加密算法中使用的摘要算法&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　对于上述各种算法，此处就不展开细说了，Go 的标准库&lt;code&gt;crypto&lt;/code&gt;以及&lt;code&gt;x/crypto&lt;/code&gt;都有详细的实现，以下是 Go 实现的秘钥套件。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;套件名&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;可用版本&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;伪随机数算法&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;伪随机算法中的 hash&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1.2&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;prf12&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;SHA256&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1.2&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;prf12&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;SHA256&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1.2&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;prf12&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;SHA256&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1.2&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;prf12&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;SHA256&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1.2&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;prf12&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;SHA384&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1.2&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;prf12&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;SHA384&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&amp;lt; 1.2&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;prf10/prf30&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;MD5,SHA1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&amp;lt; 1.2&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;prf10/prf30&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;MD5,SHA1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&amp;lt; 1.2&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;prf10/prf30&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;MD5,SHA1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&amp;lt; 1.2&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;prf10/prf30&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;MD5,SHA1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;TLS_RSA_WITH_AES_128_GCM_SHA256&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1.2&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;prf12&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;SHA256&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;TLS_RSA_WITH_AES_256_GCM_SHA384&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1.2&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;prf12&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;SHA384&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;TLS_RSA_WITH_AES_128_CBC_SHA&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&amp;lt; 1.2&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;prf10/prf30&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;MD5,SHA1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;TLS_RSA_WITH_AES_256_CBC_SHA&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&amp;lt; 1.2&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;prf10/prf30&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;MD5,SHA1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&amp;lt; 1.2&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;prf10/prf30&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;MD5,SHA1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;TLS_RSA_WITH_3DES_EDE_CBC_SHA&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&amp;lt; 1.2&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;prf10/prf30&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;MD5,SHA1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&#34;2-tls-握手的流程图&#34;&gt;2. TLS 握手的流程图&lt;/h1&gt;

&lt;p&gt;　　以下是以RSA秘钥交换算法为基础的双向证书握手流程图，有时可以忽略客户端证书需求。
&lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/thumb/a/ae/SSL_handshake_with_two_way_authentication_with_certificates.svg/1920px-SSL_handshake_with_two_way_authentication_with_certificates.svg.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;大致可以分为以下几步：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;客户端生成客户端随机数，协商版本，秘钥套件等信息，发起握手（clientHelloMsg）&lt;/li&gt;
&lt;li&gt;服务端收到 clientHelloMsg，同时生成服务端随机数，再同协商结果一同返回客户端（serverHelloMsg）&lt;/li&gt;
&lt;li&gt;客户端收到 serverHelloMsg&lt;/li&gt;
&lt;li&gt;服务端发送证书给客户端&lt;/li&gt;
&lt;li&gt;申请客户端发送证书&lt;/li&gt;
&lt;li&gt;客户端验证证书&lt;/li&gt;
&lt;li&gt;客户端发送证书&lt;/li&gt;
&lt;li&gt;服务端验证证书&lt;/li&gt;
&lt;li&gt;客户端对之前所有的信息计算 hash，再以证书私钥对 hash 值进行签名，发送签名给服务端&lt;/li&gt;
&lt;li&gt;服务端同样方式计算 hash ，并以客户端证书公钥对签名进行验证&lt;/li&gt;
&lt;li&gt;客户端生成随机数作为预备主密钥，用服务端公钥加密，发送给服务端&lt;/li&gt;
&lt;li&gt;服务端解密预备主密钥&lt;/li&gt;
&lt;li&gt;客户端，服务端拥有了相同的预备主密钥，客户端随机数，服务端随机数，在此基础上，使用相同的秘钥导出算法 prf 计算得到主密钥&lt;/li&gt;
&lt;li&gt;客户端以此主密钥作为后续会话的加密秘钥，转为加密模式，通知服务端切换&lt;/li&gt;
&lt;li&gt;客户端结束握手&lt;/li&gt;
&lt;li&gt;服务端收到切换通知，也转为加密模式&lt;/li&gt;
&lt;li&gt;服务端结束握手&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　实际运用中，主密钥只是用来生成一系列秘钥的起点，两端的加密秘钥不一定相同，但是由于主密钥的存在，使得双方都知道对方使用的是哪一个秘钥，这样也提高了安全性。&lt;/p&gt;

&lt;h1 id=&#34;3-go-的-tls-详细实现&#34;&gt;3. Go 的 TLS 详细实现&lt;/h1&gt;

&lt;p&gt;　　首先我们假设服务端已经开启了 TLS，客户端通过拨号的方式连接服务端，在此基础上我们来分析整个 TLS 的握手流程。&lt;/p&gt;

&lt;h2 id=&#34;3-1-clienthello-serverhello-阶段&#34;&gt;3.1 ClientHello &amp;amp; ServerHello 阶段&lt;/h2&gt;

&lt;h3 id=&#34;3-1-1-客户端从正式发送-clienthellomsg-到接收-serverhellomsg&#34;&gt;3.1.1 客户端从正式发送 ClientHelloMsg 到接收 ServerHelloMsg&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;客户端设置超时，并通过 Dial 的方式获得可用的 TCPConn，同时初始化&lt;code&gt;tls.Config&lt;/code&gt;，主要是&lt;code&gt;config.ServerName&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;timeout := dialer.Timeout

if !dialer.Deadline.IsZero() {
    deadlineTimeout := time.Until(dialer.Deadline)
    if timeout == 0 || deadlineTimeout &amp;lt; timeout {
        timeout = deadlineTimeout
    }
}

var errChannel chan error

// [Min] 如果有超时，在超时的时候，向 errChannel 发送一个超时信号
// [Min] 注意，errChannel 为2个缓存的非阻塞通道，这样就不会阻塞较慢的那个 goroutine 造成泄露
if timeout != 0 {
    errChannel = make(chan error, 2)
    time.AfterFunc(timeout, func() {
        errChannel &amp;lt;- timeoutError{}
    })
}

// [Min] 正常调用 Dial，获取底层 conn，一般为 TCPConn
rawConn, err := dialer.Dial(network, addr)
if err != nil {
    return nil, err
}

// [Min] 获取 hostname
colonPos := strings.LastIndex(addr, &amp;quot;:&amp;quot;)
if colonPos == -1 {
    colonPos = len(addr)
}
hostname := addr[:colonPos]

// [Min] 初始化 config
if config == nil {
    config = defaultConfig()
}
// If no ServerName is set, infer the ServerName
// from the hostname we&#39;re connecting to.
// [Min] 设置 ServerName，这个很重要，因为服务端需要以此来获取证书发送给客户端
if config.ServerName == &amp;quot;&amp;quot; {
    // Make a copy to avoid polluting argument or default.
    c := config.Clone()
    c.ServerName = hostname
    config = c
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;客户端封装 TCPConn 为 tls.Conn，并发起握手&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;    // [Min] 构造客户端的 tls.Conn
conn := Client(rawConn, config)

// [Min] 没有超时，直接调用 Handshake，等到 Handshake 结束
if timeout == 0 {
    err = conn.Handshake()
} else {
    // [Min] 有超时，发起一个 goroutine 调用 Handshake
    go func() {
        errChannel &amp;lt;- conn.Handshake()
    }()

    // [Min] 可能是超时返回，也可能是 Handshake 结束的返回
    err = &amp;lt;-errChannel
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func Client(conn net.Conn, config *Config) *Conn {
    return &amp;amp;Conn{conn: conn, config: config, isClient: true}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;客户端调用c.clientHandshake()&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;if c.isClient {
    c.handshakeErr = c.clientHandshake()
} else {
    c.handshakeErr = c.serverHandshake()
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;客户端调用 makeClientHello 构造 clientHelloMsg&lt;/p&gt;

&lt;p&gt;clientHelloMsg 包含以下信息:&lt;/p&gt;

&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;默认采用最新的版本 TLS 1.2&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;非压缩方法&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;要求服务端提供证书状态&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;要求服务端提供 hs.cert.SignedCertificateTimestamps&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;serverName 为 hostnameInSNI(config.ServerName)，目前只支持 DNS hostname，如果是IP 地址，serverName会设置为空&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;客户端支持的椭圆曲线 supportedCurves&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;客户端支持的点 supportedPoints，目前只支持非压缩的点&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;NPN 模式，由 len(config.NextProtos) &amp;gt; 0 确定，让服务端发送NextProtos，客户端进行选择&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;支持安全重协商&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;ALPN 模式，将客户端config.NextProtos发给服务端，让服务端选择&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;客户端可以使用的密码套件&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;客户端随机数&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&amp;gt;= TLS 1.2, 客户端支持的签名算法&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// [Min] 根据config构造clientHelloMsg
hello, err := makeClientHello(c.config)
if err != nil {
    return err
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;检查有没有可以复用的候选 session&lt;/p&gt;

&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;首先要支持 sessionTicket，且c.config.ClientSessionCache不能为空&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;根据服务端 serverName 或者 IP，从c.config.ClientSessionCache中获取有相应键值的 ClientSessionState，其中包含可以恢复 session 的 ticket&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;如果有，检查是否符合客户端的密码套件要求，是否符合 TLS 版本要求&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;如果3都 ok，将 ClientSessionState 中的 ticket 赋值给hello.sessionTicket，并随机分配一个16字节的hello.sessionId&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// [Min] 开始检查复用 Session 的可能
var session *ClientSessionState
var cacheKey string
// [Min] 首先获取 config 中的 ClientSessionCache，如果不支持重用，seesionCache 设置为 nil
sessionCache := c.config.ClientSessionCache
if c.config.SessionTicketsDisabled {
    sessionCache = nil
}

// [Min] 如果此时 sessionCache 不为 nil，说明可以支持重用 session，设置 hello.ticketSupported 为真
if sessionCache != nil {
    hello.ticketSupported = true
}

// Session resumption is not allowed if renegotiating because
// renegotiation is primarily used to allow a client to send a client
// certificate, which would be skipped if session resumption occurred.
// [Min] 只有首次握手才能重用
if sessionCache != nil &amp;amp;&amp;amp; c.handshakes == 0 {
    // Try to resume a previously negotiated TLS session, if
    // available.
    // [Min] 根据ServerName 或服务器地址获取 sessioncachekey
    cacheKey = clientSessionCacheKey(c.conn.RemoteAddr(), c.config)
    // [Min] 从 sessionCache 中获取该 session
    candidateSession, ok := sessionCache.Get(cacheKey)
    if ok {
        // Check that the ciphersuite/version used for the
        // previous session are still valid.
        // [Min] 如果找到了，再次检查该 session 使用的密码套件是否在客户端的支持列表中
        cipherSuiteOk := false
        for _, id := range hello.cipherSuites {
            if id == candidateSession.cipherSuite {
                cipherSuiteOk = true
                break
            }
        }

        // [Min] 检查该 session 使用的版本是否有效
        versOk := candidateSession.vers &amp;gt;= c.config.minVersion() &amp;amp;&amp;amp;
            candidateSession.vers &amp;lt;= c.config.maxVersion()
        if versOk &amp;amp;&amp;amp; cipherSuiteOk {
            session = candidateSession
        }
    }
}

// [Min] 如果 session 可用，将 session.sessionTicket 赋值给 hello.sessionTicket
if session != nil {
    hello.sessionTicket = session.sessionTicket
    // A random session ID is used to detect when the
    // server accepted the ticket and is resuming a session
    // (see RFC 5077).
    // [Min] 同时新建一个16字节的随机数作为该重用 session 的 id
    hello.sessionId = make([]byte, 16)
    if _, err := io.ReadFull(c.config.rand(), hello.sessionId); err != nil {
        return errors.New(&amp;quot;tls: short read from Rand: &amp;quot; + err.Error())
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;构造clientHandshakeState，并调用其handshake()&lt;/p&gt;

&lt;p&gt;clientHandshakeState 中包含了:&lt;/p&gt;

&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;该tls.Conn&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;之前构造的clientHelloMsg&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;候选复用 ClientSessionState&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// [Min] 构造 clientHandshakeState
hs := &amp;amp;clientHandshakeState{
    c:       c,       // [Min] TLS Conn
    hello:   hello,   // [Min] clientHelloMsg
    session: session, // [Min] 重用 session
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;直接发送 clientHelloMsg 到客户端（不走sendBuf），并等待读取服务端的回应 serverHelloMsg&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// send ClientHello
// [Min] 明文写入 clientHelloMsg，直接推送到服务端，没有走c.sendBuf
if _, err := c.writeRecord(recordTypeHandshake, hs.hello.marshal()); err != nil {
    return err
}

// [Min] 读取 handshake 的返回消息，并构建对应类型的消息体实例 msg
msg, err := c.readHandshake()
if err != nil {
    return err
}

var ok bool
// [Min] 期待返回的是 serverHelloMsg
if hs.serverHello, ok = msg.(*serverHelloMsg); !ok {
    c.sendAlert(alertUnexpectedMessage)
    return unexpectedMessageError(hs.serverHello, msg)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;读取到 serverHelloMsg 后，根据协商结果调用 hs.pickTLSVersion()，hs.pickCipherSuite() 设置版本，密码套件等&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// [Min] 选择 TLS 版本，设置 hs.c.vers，hs.c.haveVers
if err = hs.pickTLSVersion(); err != nil {
    return err
}

// [Min] 选择加密套件，设置 hs.c.cipherSuite
if err = hs.pickCipherSuite(); err != nil {
    return err
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// [Min] 匹配对应的 TLS 版本，更新到 hs.c.vers，hs.c.haveVers
func (hs *clientHandshakeState) pickTLSVersion() error {
    vers, ok := hs.c.config.mutualVersion(hs.serverHello.vers)
    if !ok || vers &amp;lt; VersionTLS10 {
        // TLS 1.0 is the minimum version supported as a client.
        hs.c.sendAlert(alertProtocolVersion)
        return fmt.Errorf(&amp;quot;tls: server selected unsupported protocol version %x&amp;quot;, hs.serverHello.vers)
    }

    hs.c.vers = vers
    hs.c.haveVers = true

    return nil
}    
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// [Min] 匹配加密套件，更新 hs.c.cipherSuite
func (hs *clientHandshakeState) pickCipherSuite() error {
    if hs.suite = mutualCipherSuite(hs.hello.cipherSuites, hs.serverHello.cipherSuite); hs.suite == nil {
        hs.c.sendAlert(alertHandshakeFailure)
        return errors.New(&amp;quot;tls: server chose an unconfigured cipher suite&amp;quot;)
    }

    hs.c.cipherSuite = hs.suite.id
    return nil
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;调用 hs.processServerHello() 对 serverHelloMsg 的其他处理与检查，得知是否重用 session&lt;/p&gt;

&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;压缩方法检查&lt;/li&gt;
&lt;li&gt;安全重协商检查&lt;/li&gt;
&lt;li&gt;NPN，ALPN 模式的检查&lt;/li&gt;
&lt;li&gt;scts 的处理&lt;/li&gt;
&lt;li&gt;重用 session 的判断，此处我们只要判断serverHelloMsg中的 sessionId 是否与我们之前在 clientHelloMsg 中发送的 sessionId 相同，相同就表示可以重用之前发送的 ticket&lt;/li&gt;
&lt;li&gt;如果决定重用 session 后，对重用 session 的检查&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;客户端完成 clientHelloMsg &amp;amp; serverHelloMsg&lt;/p&gt;

&lt;p&gt;　　新建客户端的 finishedHash，当我们处理完一条消息后（包括发送完毕），用来记录所有握手阶段的消息的 hash 值，如果不是重用 session，且服务端对客户端证书有要求，我们也会将所有消息记录在 finishedHash 的 buffer 中。&lt;br /&gt;
　　完成 clientHelloMsg 和 serverHelloMsg，此后再开启缓存写入模式。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;hs.finishedHash = newFinishedHash(c.vers, hs.suite)

// No signatures of the handshake are needed in a resumption.
// Otherwise, in a full handshake, if we don&#39;t have any certificates
// configured then we will never send a CertificateVerify message and
// thus no signatures are needed in that case either.
if isResume || (len(c.config.Certificates) == 0 &amp;amp;&amp;amp; c.config.GetClientCertificate == nil) {
    hs.finishedHash.discardHandshakeBuffer()
}

hs.finishedHash.Write(hs.hello.marshal())
hs.finishedHash.Write(hs.serverHello.marshal())
    
c.buffering = true
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;3-1-2-服务端从接收-clienthellomsg-到正式发送-serverhellomsg&#34;&gt;3.1.2  服务端从接收 ClientHelloMsg 到正式发送 ServerHelloMsg&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;与客户端类似，服务端也是在获得一个可用 TCPConn 之后，对其进行封装，得到tls.Conn，此时 config 已经初始化且包含了服务端的证书&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (l *listener) Accept() (net.Conn, error) {
    c, err := l.Listener.Accept()
    if err != nil {
        return nil, err
    }
    return Server(c, l.config), nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func Server(conn net.Conn, config *Config) *Conn {
    return &amp;amp;Conn{conn: conn, config: config}
}   
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;服务端发起握手&lt;/p&gt;

&lt;p&gt;　　在服务端为该 tls.Conn 发起的 goroutine 中，我们会判断是否为 tls.Conn，如果是，那么我们就会发起握手。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;if tlsConn, ok := c.rwc.(*tls.Conn); ok {
    if d := c.server.ReadTimeout; d != 0 {
        c.rwc.SetReadDeadline(time.Now().Add(d))
    }
    if d := c.server.WriteTimeout; d != 0 {
        c.rwc.SetWriteDeadline(time.Now().Add(d))
    }
    if err := tlsConn.Handshake(); err != nil {
        c.server.logf(&amp;quot;http: TLS handshake error from %s: %v&amp;quot;, c.rwc.RemoteAddr(), err)
        return
    }
    c.tlsState = new(tls.ConnectionState)
    *c.tlsState = tlsConn.ConnectionState()
    if proto := c.tlsState.NegotiatedProtocol; validNPN(proto) {
        if fn := c.server.TLSNextProto[proto]; fn != nil {
            h := initNPNRequest{tlsConn, serverHandler{c.server}}
            fn(c.server, tlsConn, h)
        }
        return
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;与客户端类似，服务端会调起 c.serverHandshake()，正式发起握手程序&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;3.1 首先会调起 c.config.serverInit(nil)，来检查并更新用于生成 SessionTicket 的 c.sessionTicketKeys&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// serverInit is run under c.serverInitOnce to do initialization of c. If c was
// returned by a GetConfigForClient callback then the argument should be the
// Config that was passed to Server, otherwise it should be nil.
// [Min] 主要是初始化c.sessionTicketKeys
// [Min] 如果不支持SessionTickets，或者已经有sessionTicketKeys，直接返回
func (c *Config) serverInit(originalConfig *Config) {
    if c.SessionTicketsDisabled || len(c.ticketKeys()) != 0 {
        return
    }

    alreadySet := false
    for _, b := range c.SessionTicketKey {
        if b != 0 {
            alreadySet = true
            break
        }
    }

    // [Min] 如果 SessionTicketKey 为0，需要先设置SessionTicketKey
    // [Min] 如果 originalConfig 不是nil，拷贝 originalConfig 的SessionTicketKey
    // [Min] 如果是nil，则随机生成32字节的SessionTicketKey
    if !alreadySet {
        if originalConfig != nil {
            copy(c.SessionTicketKey[:], originalConfig.SessionTicketKey[:])
        } else if _, err := io.ReadFull(c.rand(), c.SessionTicketKey[:]); err != nil {
            c.SessionTicketsDisabled = true
            return
        }
    }

    // [Min] 接下来设置sessionTicketKeys，如果originalConfig不为nil，直接拷贝 sessionTicketKeys
    // [Min] 否则调用 ticketKeyFromBytes 将刚才随机生成的 SessionTicketKey 转为 ticketKey 存入sessionTicketKeys
    if originalConfig != nil {
        originalConfig.mutex.RLock()
        c.sessionTicketKeys = originalConfig.sessionTicketKeys
        originalConfig.mutex.RUnlock()
    } else {
        // [Min] 对c.SessionTicketKey求SHA512，然后再按固定长度分割为 keyName，aesKey，hmacKey           
        c.sessionTicketKeys = []ticketKey{ticketKeyFromBytes(c.SessionTicketKey)}
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;3.2 其次构造serverHandshakeState，调用hs.readClientHello()&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;hs := serverHandshakeState{
    c: c,
}
// [Min] 读取客户端 helloMsg，更新相关信息，同时决定是否重用 session，如果重用，
// [Min] 那么 session 的信息就已经从 hs.clientHello.sessionTicket 中恢复到了 hs.sessionState
isResume, err := hs.readClientHello()
if err != nil {
    return err
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;读取客户端发来的 clientHelloMsg, 作以下处理：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;4.1 如果服务端配置中自定义了c.config.GetConfigForClient，那么就先执行该函数，修改配置 config&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;if c.config.GetConfigForClient != nil {
    // [Min] 根据客户端的 helloMsg 生成一个新的 config
    if newConfig, err := c.config.GetConfigForClient(hs.clientHelloInfo()); err != nil {
        c.sendAlert(alertInternalError)
        return false, err
    } else if newConfig != nil {
        // [Min] 新的 config 中
        // [Min] sessionTicketKeys 从 c.config 中拷贝
        // [Min] SessionTicketKey 如果已经设置就不变，没有设置（0），则也从 c.config 中拷贝
        newConfig.serverInitOnce.Do(func() { newConfig.serverInit(c.config) })
        c.config = newConfig
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;4.2 协商 TLS 版本，检查客户端支持的椭圆曲线，点的格式，压缩方法在服务端是否支持，同时构造 ServerHelloMsg 消息实例&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;    // [Min] 根据客户端中的版本号，协商双方都可用的版本号
    c.vers, ok = c.config.mutualVersion(hs.clientHello.vers)
    if !ok {
        c.sendAlert(alertProtocolVersion)
        return false, fmt.Errorf(&amp;quot;tls: client offered an unsupported, maximum protocol version of %x&amp;quot;, hs.clientHello.vers)
    }
    c.haveVers = true

    // [Min] 构建服务端 HelloMsg
    hs.hello = new(serverHelloMsg)

    supportedCurve := false
    preferredCurves := c.config.curvePreferences()
    // [Min] 判断客户端支持的Curve服务端是否也支持
Curves:
    for _, curve := range hs.clientHello.supportedCurves {
        for _, supported := range preferredCurves {
            if supported == curve {
                supportedCurve = true
                break Curves
            }
        }
    }

    // [Min] 判断客户端支持的PointFormat是否包含pointFormatUncompressed
    // [Min] Go标准库目前只支持pointFormatUncompressed
    supportedPointFormat := false
    for _, pointFormat := range hs.clientHello.supportedPoints {
        if pointFormat == pointFormatUncompressed {
            supportedPointFormat = true
            break
        }
    }
    // [Min] 椭圆曲线算法可用
    hs.ellipticOk = supportedCurve &amp;amp;&amp;amp; supportedPointFormat

    foundCompression := false
    // We only support null compression, so check that the client offered it.
    // [Min] Go 标准库只支持非压缩，所以客户端提供的压缩方法中必须含有非压缩的方法
    // [Min] 注：Go 实现的客户端hellomsg只设置了非压缩的方法
    for _, compression := range hs.clientHello.compressionMethods {
        if compression == compressionNone {
            foundCompression = true
            break
        }
    }

    // [Min] 如果压缩方法不一致，报警
    if !foundCompression {
        c.sendAlert(alertHandshakeFailure)
        return false, errors.New(&amp;quot;tls: client does not support uncompressed connections&amp;quot;)
    }    
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;4.3 serverHelloMsg 中设置协商版本，生成服务端随机数&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// [Min] 设置服务端版本号，随机数
hs.hello.vers = c.vers
hs.hello.random = make([]byte, 32)
_, err = io.ReadFull(c.config.rand(), hs.hello.random)
if err != nil {
    c.sendAlert(alertInternalError)
    return false, err
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;4.4 检查安全重协商，NPN，ALPN 等相关信息，并作出回应&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;    // [Min] 初次handshake 客户端 hello msg 中 secureRenegotiation必须为空
    if len(hs.clientHello.secureRenegotiation) != 0 {
        c.sendAlert(alertHandshakeFailure)
        return false, errors.New(&amp;quot;tls: initial handshake had non-empty renegotiation extension&amp;quot;)
    }

    // [Min] 服务端的安全重协商支持标志与客户端保持一致
    hs.hello.secureRenegotiationSupported = hs.clientHello.secureRenegotiationSupported
    hs.hello.compressionMethod = compressionNone
    // [Min] 将 config 中的 serverName 设置为客户端 helloMsg 中 serverName
    if len(hs.clientHello.serverName) &amp;gt; 0 {
        c.serverName = hs.clientHello.serverName
    }

    // [Min] 优先ALPN模式，服务器从客户端提供的protos中选择自己支持的返回，
    // [Min] fallback表示是否因为没有匹配成功而选择了客户端提供的第一个proto
    if len(hs.clientHello.alpnProtocols) &amp;gt; 0 {
        if selectedProto, fallback := mutualProtocol(hs.clientHello.alpnProtocols, c.config.NextProtos); !fallback {
            hs.hello.alpnProtocol = selectedProto
            c.clientProtocol = selectedProto
        }
    } else {
        // [Min] NPN 模式，服务端返回自己支持的protos，让客户端自己去选择
        // Although sending an empty NPN extension is reasonable, Firefox has
        // had a bug around this. Best to send nothing at all if
        // c.config.NextProtos is empty. See
        // https://golang.org/issue/5445.
        if hs.clientHello.nextProtoNeg &amp;amp;&amp;amp; len(c.config.NextProtos) &amp;gt; 0 {
            hs.hello.nextProtoNeg = true
            hs.hello.nextProtos = c.config.NextProtos
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;4.5 从服务端 config 中获取符合客户端要求的证书，并按需返回scts，同时判断证书的签名算法以及解密算法&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;    // [Min] 获取最适合 clientHelloMsg 的证书
    hs.cert, err = c.config.getCertificate(hs.clientHelloInfo())
    if err != nil {
        c.sendAlert(alertInternalError)
        return false, err
    }
    // [Min] 如果客户端提出需要 scts，则返回 hs.cert.SignedCertificateTimestamps
    if hs.clientHello.scts {
        hs.hello.scts = hs.cert.SignedCertificateTimestamps
    }

    // [Min] 根据选择的证书，判断公钥支持的签名算法
    if priv, ok := hs.cert.PrivateKey.(crypto.Signer); ok {
        switch priv.Public().(type) {
        case *ecdsa.PublicKey:
            hs.ecdsaOk = true
        case *rsa.PublicKey:
            hs.rsaSignOk = true
        default:
            c.sendAlert(alertInternalError)
            return false, fmt.Errorf(&amp;quot;tls: unsupported signing key type (%T)&amp;quot;, priv.Public())
        }
    }
    // [Min] 根据选择的证书，判断公钥支持的解密算法
    if priv, ok := hs.cert.PrivateKey.(crypto.Decrypter); ok {
        switch priv.Public().(type) {
        case *rsa.PublicKey:
            hs.rsaDecryptOk = true
        default:
            c.sendAlert(alertInternalError)
            return false, fmt.Errorf(&amp;quot;tls: unsupported decryption key type (%T)&amp;quot;, priv.Public())
        }
    }    
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;4.6 判断 clientHelloMsg 中的 sessionTicket 是否可以重用，若重用，结束 readClientHello&lt;br /&gt;
  　　a) 调用 decryptTicket 对 sessionTicket 进行解密获得 hs.sessionState，sessionTicket 格式为：keyName + iv + 加密的序列化流 + HMAC(SHA256)&lt;br /&gt;
　　　　a.1) 解密的时候首先根据 keyName 从 config 的 sessionTicketKeys 中找到用于生成此 ticket 的 key&lt;br /&gt;
　　　　a.2) 然后扣去 HMAC，用 key.hmacKey 计算 HMAC，验证完整性&lt;br /&gt;
　　　　a.3) 再利用iv,key.aesKey采取 CTR 模式对加密部分解密得到明文的序列化流&lt;br /&gt;
　　　　a.4) 再反序列化明文即得到 sessionState&lt;br /&gt;
  　　b) 检查 sessionState 中的版本，密码套件，证书是否符合双方要求&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// checkForResumption reports whether we should perform resumption on this connection.
// [Min] 根据客户端提供的 sessionTicket，检查是否重用 session
func (hs *serverHandshakeState) checkForResumption() bool {
    c := hs.c

    // [Min] 首先 SessionTicketsDisabled 不能为禁用
    if c.config.SessionTicketsDisabled {
        return false
    }

    var ok bool
    // [Min] 拷贝客户端 helloMsg 中的 sessionTicket
    var sessionTicket = append([]uint8{}, hs.clientHello.sessionTicket...)
    // [Min] 对 ticket 解密，还原为 sessionState，如果无法还原，不重用
    if hs.sessionState, ok = c.decryptTicket(sessionTicket); !ok {
        return false
    }

    // Never resume a session for a different TLS version.
    // [Min] 如果 TLS 版本不同，不重用
    if c.vers != hs.sessionState.vers {
        return false
    }

    cipherSuiteOk := false
    // Check that the client is still offering the ciphersuite in the session.
    // [Min] 检查客户端对该重用 session 的加密套件仍然支持
    for _, id := range hs.clientHello.cipherSuites {
        if id == hs.sessionState.cipherSuite {
            cipherSuiteOk = true
            break
        }
    }
    if !cipherSuiteOk {
        return false
    }

    // Check that we also support the ciphersuite from the session.
    // [Min] 检查服务端仍然支持该套件，并设置套件
    if !hs.setCipherSuite(hs.sessionState.cipherSuite, c.config.cipherSuites(), hs.sessionState.vers) {
        return false
    }

    sessionHasClientCerts := len(hs.sessionState.certificates) != 0
    needClientCerts := c.config.ClientAuth == RequireAnyClientCert || c.config.ClientAuth == RequireAndVerifyClientCert
    // [Min] 如果服务端需要客户端提供证书（验证），但重用 session 中没有任何证书，则不能重用
    if needClientCerts &amp;amp;&amp;amp; !sessionHasClientCerts {
        return false
    }
    // [Min] 如果 session 有证书，但服务端不要求客户端提供证书，也不能重用
    if sessionHasClientCerts &amp;amp;&amp;amp; c.config.ClientAuth == NoClientCert {
        return false
    }

    return true
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;4.7 如果非重用 session，则继续协商密码套件&lt;br /&gt;
　　根据 config 配置，如果是服务器密码套件优先，则以服务器支持的密码套件为基准，去匹配客户端支持的套件，匹配成功，就设置密码套件，都不成功，则报警。反之亦然&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;    // [Min] 以下为非重用 session 的情况，我们仍需继续协商套件
    var preferenceList, supportedList []uint16
    // [Min] 如果优先服务器加密套件，则将服务器加密套件作为优先选择的列表，客户端发送的列表作为支持的列表
    // [Min] 否则，相反
    if c.config.PreferServerCipherSuites {
        preferenceList = c.config.cipherSuites()
        supportedList = hs.clientHello.cipherSuites
    } else {
        preferenceList = hs.clientHello.cipherSuites
        supportedList = c.config.cipherSuites()
    }

    // [Min] 从优先选择列表中依次判断套件是否在支持列表中，且双方实现该套件的参数都可用，
    // [Min] 是就协商成功，设置hs.suite，否就继续协商，直到preferenceList完结
    for _, id := range preferenceList {
        if hs.setCipherSuite(id, supportedList, c.vers) {
            break
        }
    }

    // [Min] 如果没有协商出双方都可以的套件，报警
    if hs.suite == nil {
        c.sendAlert(alertHandshakeFailure)
        return false, errors.New(&amp;quot;tls: no cipher suite supported by both client and server&amp;quot;)
    }

    // See https://tools.ietf.org/html/rfc7507.
    for _, id := range hs.clientHello.cipherSuites {
        if id == TLS_FALLBACK_SCSV {
            // The client is doing a fallback connection.
            if hs.clientHello.vers &amp;lt; c.config.maxVersion() {
                c.sendAlert(alertInappropriateFallback)
                return false, errors.New(&amp;quot;tls: client using inappropriate protocol fallback&amp;quot;)
            }
            break
        }
    }

    return false, nil
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;接下来分为两种情况，一种是非重用 session 的完整握手，一种是重用 session，此时均已经开启了缓存写入的模式&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;5.1 完整握手&lt;br /&gt;
　　5.1.1 调用 hs.doFullHandshake()&lt;br /&gt;
　　　　5.1.1.1 设置协商好的密码套件等信息&lt;br /&gt;
　　　　5.1.1.2 与客户端类似，新建服务端 finishedHash&lt;br /&gt;
　　　　5.1.1.3 完成 clientHelloMsg 和 serverHelloMsg&lt;br /&gt;
　　　　5.1.1.4 将 serverHelloMsg 写入 c.sendBuf 中等待正式发送&lt;br /&gt;
　　　　5.1.1.5 构造服务端证书消息 certificateMsg，完成该消息并写入 c.sendBuf 中等待正式发送&lt;br /&gt;
　　　　5.1.1.6 按需构造服务端证书状态消息 certificateStatusMsg，完成该消息并写入 c.sendBuf 中等待正式发送&lt;br /&gt;
　　　　5.1.1.7 根据密码套件获取 keyAgreement，调用 generateServerKeyExchange 生成服务端秘钥交换消息                serverKeyExchangeMsg，完成该消息并写入 c.sendBuf 中等待正式发送&lt;br /&gt;
　　　　5.1.1.8 根据自身需求，向客户端发送验证客户端证书的请求，构造请求消息 certificateRequestMsg，完成该消息并写入 c.sendBuf 中等待正式发送&lt;br /&gt;
　　　　5.1.1.9 至此，serverHello 完成，完成 serverHelloDoneMsg 消息，并写入 c.sendBuf 中等待正式发送&lt;br /&gt;
　　　　5.1.1.10 正式推送 c.sendBuf 中累积的消息给客户端，依次包括 serverHelloMsg，certificateMsg，certificateStatusMsg（可选），serverKeyExchangeMsg，certificateRequestMsg（可选），serverHelloDoneMsg&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;```go
// [Min] 完整的 handshake
func (hs *serverHandshakeState) doFullHandshake() error {
    c := hs.c

    // [Min] 如果客户端要求 ocspStapling，且证书状态不为空，设置 hs.hello.ocspStapling 为真
    if hs.clientHello.ocspStapling &amp;amp;&amp;amp; len(hs.cert.OCSPStaple) &amp;gt; 0 {
        hs.hello.ocspStapling = true
    }

    // [Min] 设置是否支持 ticket，套件 id
    hs.hello.ticketSupported = hs.clientHello.ticketSupported &amp;amp;&amp;amp; !c.config.SessionTicketsDisabled
    hs.hello.cipherSuite = hs.suite.id

    // [Min] 根据版本和套件新建 finishedHash
    hs.finishedHash = newFinishedHash(hs.c.vers, hs.suite)
    // [Min] 如果不需要客户端证书，直接将 finishedHash.buffer 置为 nil
    if c.config.ClientAuth == NoClientCert {
        // No need to keep a full record of the handshake if client
        // certificates won&#39;t be used.
        hs.finishedHash.discardHandshakeBuffer()
    }
    // [Min] 计算 clientHelloMsg 和 serverHelloMsg 的 hash
    hs.finishedHash.Write(hs.clientHello.marshal())
    hs.finishedHash.Write(hs.hello.marshal())
    // [Min] 将 serverHelloMsg 写入 tls.Conn 的缓存 sendBuf 中
    if _, err := c.writeRecord(recordTypeHandshake, hs.hello.marshal()); err != nil {
        return err
    }

    // [Min] 构造certificateMsg，将服务端证书写入缓存 c.sendBuf 中，并完成该消息
    certMsg := new(certificateMsg)
    certMsg.certificates = hs.cert.Certificate
    hs.finishedHash.Write(certMsg.marshal())
    if _, err := c.writeRecord(recordTypeHandshake, certMsg.marshal()); err != nil {
        return err
    }

    // [Min] 如果需要 ocspStapling，构造 certificateStatusMsg，写入缓存 c.sendBuf 中，并完成该消息
    if hs.hello.ocspStapling {
        certStatus := new(certificateStatusMsg)
        certStatus.statusType = statusTypeOCSP
        certStatus.response = hs.cert.OCSPStaple
        hs.finishedHash.Write(certStatus.marshal())
        if _, err := c.writeRecord(recordTypeHandshake, certStatus.marshal()); err != nil {
            return err
        }
    }

    // [Min] 获得该套件的 keyAgreement 实例
    keyAgreement := hs.suite.ka(c.vers)
    // [Min] 生成交换的公钥和签名，组成 serverKeyExchangeMsg
    // [Min] 也可能不需要交换公钥，如 RSA 秘钥交换
    skx, err := keyAgreement.generateServerKeyExchange(c.config, hs.cert, hs.clientHello, hs.hello)
    if err != nil {
        c.sendAlert(alertHandshakeFailure)
        return err
    }
    // [Min] 如果 skx 不为 nil，说明不是 RSA，
    // [Min] 再把 serverKeyExchangeMsg 写入缓存 c.sendBuf 中，并完成该消息
    if skx != nil {
        hs.finishedHash.Write(skx.marshal())
        if _, err := c.writeRecord(recordTypeHandshake, skx.marshal()); err != nil {
            return err
        }
    }

    // [Min] 如果服务端需要验证客户端的证书，则要发送验证请求
    if c.config.ClientAuth &amp;gt;= RequestClientCert {
        // Request a client certificate
        certReq := new(certificateRequestMsg)
        // [Min] 要求证书为 RSASign 或 ECDSASign
        certReq.certificateTypes = []byte{
            byte(certTypeRSASign),
            byte(certTypeECDSASign),
        }
        // [Min] &amp;gt;= TLS 1.2，提供服务端支持的签名算法
        if c.vers &amp;gt;= VersionTLS12 {
            certReq.hasSignatureAndHash = true
            certReq.supportedSignatureAlgorithms = supportedSignatureAlgorithms
        }

        // An empty list of certificateAuthorities signals to
        // the client that it may send any certificate in response
        // to our request. When we know the CAs we trust, then
        // we can send them down, so that the client can choose
        // an appropriate certificate to give to us.
        // [Min] 限定证书的授权组织
        if c.config.ClientCAs != nil {
            certReq.certificateAuthorities = c.config.ClientCAs.Subjects()
        }
        // [Min] 累计计算 hash 并写入 conn 的缓存
        hs.finishedHash.Write(certReq.marshal())
        if _, err := c.writeRecord(recordTypeHandshake, certReq.marshal()); err != nil {
            return err
        }
    }

    // [Min] 至此，hello 阶段完成，发送 helloDone 消息
    helloDone := new(serverHelloDoneMsg)
    hs.finishedHash.Write(helloDone.marshal())
    if _, err := c.writeRecord(recordTypeHandshake, helloDone.marshal()); err != nil {
        return err
    }

    // [Min] 从缓存中将累积的消息推送到客户端，依次包括 serverHelloMsg，certificateMsg，certificateStatusMsg（可选），serverKeyExchangeMsg，certificateRequestMsg（可选），serverHelloDoneMsg
    if _, err := c.flush(); err != nil {
        return err
    }
```
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;5.2 重用 Session&lt;br /&gt;
　　5.2.1 调用 hs.doResumeHandshake()&lt;br /&gt;
　　　　5.2.1.1 设置协商好的密码套件，重用 sessionId 等信息，客户端需根据 sessionId 来判断是否可以重用&lt;br /&gt;
　　　　5.2.1.2 与客户端类似，新建服务端 finishedHash，由于是重用，将 finishedHash 中的 buffer 置为 nil&lt;br /&gt;
　　　　5.2.1.3 完成 clientHelloMsg 和 serverHelloMsg&lt;br /&gt;
　　　　5.2.1.4 将 serverHelloMsg 写入 c.sendBuf 中等待正式发送&lt;br /&gt;
　　　　5.2.1.5 如果重用 sessionState 中有客户端的证书信息，则对证书进行验证并更新相关字段，同时提取出客户端证书的公钥
　　　　5.2.1.6 将重用 sessionState 中的主密钥恢复到 hs.masterSecret&lt;br /&gt;
　　5.2.2 调用 hs.establishKeys()&lt;br /&gt;
　　　　5.2.2.1 通过主密钥生成一系列计算 hmac，加解密需要使用到的 key，和初始化向量，客户端服务端各不相同&lt;br /&gt;
　　　　5.2.2.2 根据密码套件，将这些 key，iv 组合成客户端，服务端各自用于加密和计算 hmac 的 cipher，hmac&lt;br /&gt;
　　　　5.2.2.3 更新到对应的 halfConn 中的预备字段中，等待正式切换&lt;br /&gt;
　　5.2.3 如果 ticket 需要重制（加密 ticket 的 key 不是最新的，sessionState实际内容不变），调用 hs.sendSessionTicket() 重制 ticket 并发送给客户端让其刷新&lt;br /&gt;
　　　　5.2.3.1 sessionState 内容保持不变，调用 encryptTicket，生成 ticket（encrytTicket 始终会使用最新的 sessionTicketKey 来加密）&lt;br /&gt;
　　　　5.2.3.2 构造 newSessionTicketMsg，完成该消息并写入 c.sendBuf 中等待正式发送&lt;br /&gt;
　　5.2.4 调用hs.sendFinished 发送finishedMsg&lt;br /&gt;
　　　　5.2.4.1 发送切换信号，通知客户端此信号之后的消息都为加密消息，服务端将 c.out 切换为加密模式。注意，此信号不写入 finishedHash。&lt;br /&gt;
　　　　5.2.4.2 构造 finishedMsg，finishedMsg.verifyData 是通过密码套件决定的伪随机数算法计算的伪随机数（func(result, secret, label, seed []byte)），其中secret为主密钥，label是固定的字符串，seed是到目前为止，双方所有的发送以及接收到的消息按先后顺序累积计算的 hash 值。然后完成该消息并写入 c.sendBuf 中等待正式发送，最后将 verifyData 写入c.serverFinished。&lt;br /&gt;
　　　　5.2.4.3 正式推送 c.sendBuf 中累积的消息给客户端，依次包括 serverHelloMsg，newSessionTicketMsg（可选），切换信号，finishedMsg。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;if isResume {
    // The client has included a session ticket and so we do an abbreviated handshake.
    // [Min] 告知重用 session，验证客户端证书，恢复主密钥 hs.masterSecret = hs.sessionState.masterSecret
    if err := hs.doResumeHandshake(); err != nil {
        return err
    }
    // [Min] 根据主密钥建立加密通讯需要的 cipher，hash，更新到客户端和服务端各自对应的 halfConn 的预备字段中，等待切换
    if err := hs.establishKeys(); err != nil {
        return err
    }
    // ticketSupported is set in a resumption handshake if the
    // ticket from the client was encrypted with an old session
    // ticket key and thus a refreshed ticket should be sent.
    // [Min] 如果重用的 sessionState 是使用老的 ticketKey 解密而得，
    // [Min] 需要用最新的 key 重新加密生成新的 ticket，并返回给客户端让其同步刷新
    if hs.hello.ticketSupported {
        if err := hs.sendSessionTicket(); err != nil {
            return err
        }
    }
    // [Min] 发送finishedMsg，并将 fishishedMsg 中的 verifyData 写入 c.serverFinished[:]
    // [Min] 切换 c.out 为加密模式
    if err := hs.sendFinished(c.serverFinished[:]); err != nil {
        return err
    }
    // [Min] 推送 c.sendBuf 中累积的消息到客户端，依次包括：serverHelloMsg，newSessionTicketMsg（可选），finishedMsg。
    if _, err := c.flush(); err != nil {
        return err
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// [Min] 重用 session 的 handshake，返回 helloMsg，告知 session 重用，验证客户端证书并恢复主密钥
func (hs *serverHandshakeState) doResumeHandshake() error {
    c := hs.c

    hs.hello.cipherSuite = hs.suite.id
    // We echo the client&#39;s session ID in the ServerHello to let it know
    // that we&#39;re doing a resumption.
    // [Min] 重用 session 的情况下，sessionId 和客户端发过来的保持一致，
    // [Min] 这样客户端就可以通过 sessionId 没有变化来判断 session 的重用
    hs.hello.sessionId = hs.clientHello.sessionId
    // [Min] 表明客户端提供的 ticket 是否可以恢复成 sessionState 使用
    // [Min] 同时也记录 sessionTicket 是否需要以最新的 key 重制生成 ticket 来刷新（实际内容不变）
    hs.hello.ticketSupported = hs.sessionState.usedOldKey
    hs.finishedHash = newFinishedHash(c.vers, hs.suite)
    hs.finishedHash.discardHandshakeBuffer()
    hs.finishedHash.Write(hs.clientHello.marshal())
    hs.finishedHash.Write(hs.hello.marshal())
    // [Min] 将服务端 helloMsg 写入缓存
    if _, err := c.writeRecord(recordTypeHandshake, hs.hello.marshal()); err != nil {
        return err
    }

    // [Min] 验证客户端的证书链
    if len(hs.sessionState.certificates) &amp;gt; 0 {
        if _, err := hs.processCertsFromClient(hs.sessionState.certificates); err != nil {
            return err
        }
    }

    // [Min] 客户端证书没问题，再从 sessionState 中恢复主密钥
    hs.masterSecret = hs.sessionState.masterSecret

    return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// [Min] 根据主密钥建立加密通讯需要的 cipher，hash，更新到客户端和服务端各自对应的 halfConn 的预备字段中，等待切换
func (hs *serverHandshakeState) establishKeys() error {
    c := hs.c

    // [Min] 通过主密钥生成一系列计算 mac，加解密需要使用到的 key，和初始化向量
    clientMAC, serverMAC, clientKey, serverKey, clientIV, serverIV :=
        keysFromMasterSecret(c.vers, hs.suite, hs.masterSecret, hs.clientHello.random, hs.hello.random,    hs.suite.macLen, hs.suite.keyLen, hs.suite.ivLen)

    var clientCipher, serverCipher interface{}
    var clientHash, serverHash macFunction

    if hs.suite.aead == nil {
        clientCipher = hs.suite.cipher(clientKey, clientIV, true /* for reading */)
        clientHash = hs.suite.mac(c.vers, clientMAC)
        serverCipher = hs.suite.cipher(serverKey, serverIV, false /* not for reading */)
        serverHash = hs.suite.mac(c.vers, serverMAC)
    } else {
        clientCipher = hs.suite.aead(clientKey, clientIV)
        serverCipher = hs.suite.aead(serverKey, serverIV)
    }

    // [Min] 将 client 的 cipher，hash 算法更新到 in 的预备字段中，等待正式切换
    // [Min] 将 server 的 cipher，hash 算法更新到 out 的预备字段中，等待正式切换
    c.in.prepareCipherSpec(c.vers, clientCipher, clientHash)
    c.out.prepareCipherSpec(c.vers, serverCipher, serverHash)

    return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// [Min] 根据当前协商好的信息，制作 sessionTicket，并返回给客户端
func (hs *serverHandshakeState) sendSessionTicket() error {
    if !hs.hello.ticketSupported {
        return nil
    }

    c := hs.c
    m := new(newSessionTicketMsg)

    var err error
    // [Min] sessionState 的内容
    state := sessionState{
        vers:         c.vers,
        cipherSuite:  hs.suite.id,
        masterSecret: hs.masterSecret,
        certificates: hs.certsFromClient,
    }
    m.ticket, err = c.encryptTicket(&amp;amp;state)
    if err != nil {
        return err
    }

    hs.finishedHash.Write(m.marshal())
    if _, err := c.writeRecord(recordTypeHandshake, m.marshal()); err != nil {
        return err
    }

    return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// [Min] 发送 finshedMsg
func (hs *serverHandshakeState) sendFinished(out []byte) error {
    c := hs.c

    // [Min] 发送切换信号，此时会将 c.out 中的 cipher 和 mac 切换，转为加密模式
    if _, err := c.writeRecord(recordTypeChangeCipherSpec, []byte{1}); err != nil {
        return err
    }

    // [Min] 构造 finishedMsg，并序列化，然后完成该消息并写入 c.sendBuf 中等待正式发送
    finished := new(finishedMsg)
    finished.verifyData = hs.finishedHash.serverSum(hs.masterSecret)
    hs.finishedHash.Write(finished.marshal())
    if _, err := c.writeRecord(recordTypeHandshake, finished.marshal()); err != nil {
        return err
    }

    // [Min] 同步 config 中 cipherSuite
    c.cipherSuite = hs.suite.id
    // [Min] 将 verifyData 拷贝至 out
    copy(out, finished.verifyData)

    return nil
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;4-小结&#34;&gt;4. 小结&lt;/h1&gt;

&lt;p&gt;　　至此，我们完成了：&lt;br /&gt;
    1. 客户端从正式发送 clinetHelloMsg 到正式接收 serverHelloMsg（第一次正式发送，第一次正式接收）&lt;br /&gt;
    2. 服务端从正式收到 clinetHelloMsg 到正式发送 serverHelloMsg（第一次正式接收，第一次正式发送）&lt;/p&gt;

&lt;p&gt;正常情况下非重用 session 消息发送序列：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;批次-序号&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;客户端&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;服务端&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;1-1&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;clientHelloMsg&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;serverHelloMsg&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;1-2&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;certificateMsg&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;1-3&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;certificateStatusMsg（可选）&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;1-4&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;serverKeyExchangeMsg&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;1-5&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;certificateRequestMsg（可选）&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;1-6&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;serverHelloDoneMsg&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;正常情况下重用 session 消息发送序列：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;批次-序号&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;客户端&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;服务端&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;1-1&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;clientHelloMsg&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;serverHelloMsg&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;1-2&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;newSessionTicketMsg（可选）&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;1-3&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;切换信号&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;1-4&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;finishedMsg&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;未完待续&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>分组密码模式</title>
      <link>https://mooncaker816.github.io/2018/07/24/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 24 Jul 2018 08:49:59 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/07/24/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;1-概念&#34;&gt;1 概念&lt;/h1&gt;

&lt;p&gt;　　分组密码的模式主要是指对每一个分组明文（密文）进行迭代加（解）密的过程。主要的分组模式有以下几种：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ECB 电子密码本（Electronic CodeBook mode）&lt;/li&gt;
&lt;li&gt;CBC 密码块链接（Cipher Block Chaining mode）&lt;/li&gt;
&lt;li&gt;CFB 密文反馈（Cipher FeedBack mode）&lt;/li&gt;
&lt;li&gt;OFB 输出反馈（Output FeedBack mode）&lt;/li&gt;
&lt;li&gt;CTR 计数器模式（CounTeR mode）&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;2-ecb&#34;&gt;2 ECB&lt;/h1&gt;

&lt;p&gt;　　ECB模式中，明文分组加密后的结果直接记为密文分组，依次按顺序连接这些密文分组就是最终的密文。&lt;/p&gt;

&lt;p&gt;ECB 加密过程:
&lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/c/c4/Ecb_encryption.png&#34; alt=&#34;ECB 加密过程&#34; /&gt;
ECB 解密过程:
&lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/6/66/Ecb_decryption.png&#34; alt=&#34;ECB 解密过程&#34; /&gt;&lt;/p&gt;

&lt;p&gt;　　ECB是所有模式中最简单的一种模式，明文分组和密文分组是一一对应的关系，因此如果明文中存在多个相同的分组，那么他们就会被加密成相同的密文分组。在密文中通过观察这一重复性特点，就能知道明文中存在重复的组合，从而增大了被破译的风险。&lt;br /&gt;
　　再有，由于各个明文分组是独立加密的，所以如果我们将加密后的密文分组的顺序打乱，组成一个新的密文，解密者同样可以根据秘钥来解密每一个分组，但是呈现在解密者面前的信息却已经被改变。&lt;strong&gt;也就是说，在已知分组大小的前提下，攻击者可以不用破译密码，而通过操纵密文分组（颠倒顺序，覆盖分组等），来达到攻击的效果。&lt;/strong&gt;&lt;br /&gt;
　　所以，ECB并不是一个安全的分组模式。&lt;/p&gt;

&lt;h1 id=&#34;3-cbc&#34;&gt;3 CBC&lt;/h1&gt;

&lt;h2 id=&#34;3-1-cbc的流程&#34;&gt;3.1 CBC的流程&lt;/h2&gt;

&lt;p&gt;　　在CBC加密流程中，首先将当前明文分组与上一密文分组（初始向量）异或，再对该值进行加密得到当前组的密文。
&lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/d/d3/Cbc_encryption.png&#34; alt=&#34;CBC加密流程&#34; /&gt;&lt;/p&gt;

&lt;p&gt;　　在CBC解密流程中，首先对当前密文执行解密函数，然后与上一密文分组（初始向量）异或，得到当前明文分组。
&lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/6/66/Cbc_decryption.png&#34; alt=&#34;CBC解密流程&#34; /&gt;&lt;/p&gt;

&lt;p&gt;　　与ECB模式相比，在进行加密之前，CBC多了一步与上一密文分组（初始向量）异或的操作。&lt;/p&gt;

&lt;h2 id=&#34;3-2-cbc的特点&#34;&gt;3.2 CBC的特点&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;由于加密之前会与上一密文分组（初始向量）进行异或，即便两个明文分组相同，得到的密文分组也不同。&lt;/li&gt;
&lt;li&gt;分组的加密必须按顺序依次执行，无法并行&lt;/li&gt;
&lt;li&gt;如果某一密文分组损坏（密文分组长度不变），在解密时，只会影响到当前和下一密文分组的解密，其他分组不受影响&lt;/li&gt;
&lt;li&gt;如果某一密文分组长度被破坏，则该分组以及之后的所有分组都无法解密&lt;/li&gt;
&lt;li&gt;需要填充&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;3-3-cbc-go的实现&#34;&gt;3.3 CBC Go的实现&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Cipher block chaining (CBC) mode.

// CBC provides confidentiality by xoring (chaining) each plaintext block
// with the previous ciphertext block before applying the block cipher.

// See NIST SP 800-38A, pp 10-11

package cipher

// [Min] 分组密码之CBC模式，模式用来明确各个分组的迭代方式
// [Min] 更像是在Block外部套一层迭代方式，以及用于驱动这个迭代方式的初始向量
type cbc struct {
	b         Block  // [Min] 承载了具体的对单一分组的加解密函数，以及秘钥
	blockSize int    // [Min] 分组大小
	iv        []byte // [Min] 初始向量
	tmp       []byte // [Min] 临时存储空间，长度为blockSize
}

// [Min] 根据初始向量和确定的算法实例，新建cbc实例
func newCBC(b Block, iv []byte) *cbc {
	return &amp;amp;cbc{
		b:         b,
		blockSize: b.BlockSize(),
		iv:        dup(iv),                     // [Min] 初始化向量的副本
		tmp:       make([]byte, b.BlockSize()), // [Min] 与分组大小相同
	}
}

// [Min] 分组密码加密
type cbcEncrypter cbc

// cbcEncAble is an interface implemented by ciphers that have a specific
// optimized implementation of CBC encryption, like crypto/aes.
// NewCBCEncrypter will check for this interface and return the specific
// BlockMode if found.
type cbcEncAble interface {
	NewCBCEncrypter(iv []byte) BlockMode
}

// NewCBCEncrypter returns a BlockMode which encrypts in cipher block chaining
// mode, using the given Block. The length of iv must be the same as the
// Block&#39;s block size.
// [Min] 构造一个CBC分组加密模式，
// [Min] 如果 block 本身实现了NewCBCEncrypter接口，直接调用即可，否则调用newCBC
func NewCBCEncrypter(b Block, iv []byte) BlockMode {
	if len(iv) != b.BlockSize() {
		panic(&amp;quot;cipher.NewCBCEncrypter: IV length must equal block size&amp;quot;)
	}
	if cbc, ok := b.(cbcEncAble); ok {
		return cbc.NewCBCEncrypter(iv)
	}
	return (*cbcEncrypter)(newCBC(b, iv))
}

func (x *cbcEncrypter) BlockSize() int { return x.blockSize }

// [Min] 迭代分组，此处明文数据已经经过填充，大小恰好为分组大小的整数倍
func (x *cbcEncrypter) CryptBlocks(dst, src []byte) {
	// [Min] 明文数据的大小必须是分组大小的整数倍
	if len(src)%x.blockSize != 0 {
		panic(&amp;quot;crypto/cipher: input not full blocks&amp;quot;)
	}
	// [Min] 输出容量必须比明文长
	if len(dst) &amp;lt; len(src) {
		panic(&amp;quot;crypto/cipher: output smaller than input&amp;quot;)
	}

	iv := x.iv

	// [Min] 循环处理每一组明文
	for len(src) &amp;gt; 0 {
		// Write the xor to dst, then encrypt in place.
		// [Min] 首先异或前一组密文（初始向量）和分组明文
		xorBytes(dst[:x.blockSize], src[:x.blockSize], iv)
		// [Min] 调用Block的Encrypt方法对该组明文进行加密
		x.b.Encrypt(dst[:x.blockSize], dst[:x.blockSize])

		// Move to the next block with this block as the next iv.
		// [Min] 将该组密文作为下一组明文的异或对象
		iv = dst[:x.blockSize]
		// [Min] 调整下一组明文，密文位置
		src = src[x.blockSize:]
		dst = dst[x.blockSize:]
	}

	// Save the iv for the next CryptBlocks call.
	// [Min] 保存当前最后一组密文作为下一次调用的初始向量
	copy(x.iv, iv)
}

// [Min] 设置初始向量
func (x *cbcEncrypter) SetIV(iv []byte) {
	if len(iv) != len(x.iv) {
		panic(&amp;quot;cipher: incorrect length IV&amp;quot;)
	}
	copy(x.iv, iv)
}

// [Min] 分组密码解密
type cbcDecrypter cbc

// cbcDecAble is an interface implemented by ciphers that have a specific
// optimized implementation of CBC decryption, like crypto/aes.
// NewCBCDecrypter will check for this interface and return the specific
// BlockMode if found.
type cbcDecAble interface {
	NewCBCDecrypter(iv []byte) BlockMode
}

// NewCBCDecrypter returns a BlockMode which decrypts in cipher block chaining
// mode, using the given Block. The length of iv must be the same as the
// Block&#39;s block size and must match the iv used to encrypt the data.
func NewCBCDecrypter(b Block, iv []byte) BlockMode {
	if len(iv) != b.BlockSize() {
		panic(&amp;quot;cipher.NewCBCDecrypter: IV length must equal block size&amp;quot;)
	}
	if cbc, ok := b.(cbcDecAble); ok {
		return cbc.NewCBCDecrypter(iv)
	}
	return (*cbcDecrypter)(newCBC(b, iv))
}

func (x *cbcDecrypter) BlockSize() int { return x.blockSize }

func (x *cbcDecrypter) CryptBlocks(dst, src []byte) {
	if len(src)%x.blockSize != 0 {
		panic(&amp;quot;crypto/cipher: input not full blocks&amp;quot;)
	}
	if len(dst) &amp;lt; len(src) {
		panic(&amp;quot;crypto/cipher: output smaller than input&amp;quot;)
	}
	if len(src) == 0 {
		return
	}

	// [Min] 从最后一个分组开始处理，先解密，再异或前一组密文，得到该组的明文
	// For each block, we need to xor the decrypted data with the previous block&#39;s ciphertext (the iv).
	// To avoid making a copy each time, we loop over the blocks BACKWARDS.
	end := len(src)
	start := end - x.blockSize
	prev := start - x.blockSize

	// Copy the last block of ciphertext in preparation as the new iv.
	// [Min] 保持最后一组密文作为最后返回时的初始向量
	copy(x.tmp, src[start:end])

	// Loop over all but the first block.
	// [Min] 从后往前循环处理每一个分组
	for start &amp;gt; 0 {
		// [Min] 先解密当前分组的密文
		x.b.Decrypt(dst[start:end], src[start:end])
		// [Min] 再与前一分组的密文异或得到明文
		xorBytes(dst[start:end], dst[start:end], src[prev:start])

		// [Min] 调整前一个分组的位置
		end = start
		start = prev
		prev -= x.blockSize
	}

	// The first block is special because it uses the saved iv.
	// [Min] 解密第一分组
	x.b.Decrypt(dst[start:end], src[start:end])
	// [Min] 对于第一个分组，没有了前一个分组的密文，其异或的向量为初始向量
	xorBytes(dst[start:end], dst[start:end], x.iv)

	// Set the new iv to the first block we copied earlier.
	// [Min] 设置初始向量为最后一个分组的密文
	x.iv, x.tmp = x.tmp, x.iv
}

// [Min] 设置初始向量
func (x *cbcDecrypter) SetIV(iv []byte) {
	if len(iv) != len(x.iv) {
		panic(&amp;quot;cipher: incorrect length IV&amp;quot;)
	}
	copy(x.iv, iv)
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;4-cfb&#34;&gt;4 CFB&lt;/h1&gt;

&lt;h2 id=&#34;4-1-cfb的流程&#34;&gt;4.1 CFB的流程&lt;/h2&gt;

&lt;p&gt;　　在CFB模式中，前一个密文分组（初始向量）会被送到密码算法的输入端，这就是密文反馈这个名字的由来。&lt;/p&gt;

&lt;p&gt;CFB加密流程：
&lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/f/fd/Cfb_encryption.png&#34; alt=&#34;CFB加密流程&#34; /&gt;
CFB解密流程：
&lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/7/75/Cfb_decryption.png&#34; alt=&#34;CFB解密流程&#34; /&gt;&lt;/p&gt;

&lt;p&gt;　　需要注意的是，对于CFB来说，最终的密文分组是由明文分组直接和密码算法输出X异或得到的，由异或的特性可知，只需要对该密文分组再次异或相同的X即可得到对应的明文分组。换句话说，对于解密来说，我们使用的函数和加密时使用的函数是同一个函数，没有加解密之分。这一点和CBC不同。&lt;/p&gt;

&lt;h2 id=&#34;4-2-cfb的特点&#34;&gt;4.2 CFB的特点&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;在ECB，CBC中，明文分组都是通过密码算法进行加密的，而CFB中，明文分组并没有直接用密码算法进行加密，密码算法只是用来对上一密文分组（初始向量）进行加密，获得一个mask，用来对该组的明密文进行加解密。&lt;/li&gt;
&lt;li&gt;明文和密文之间没有加密步骤，只有异或步骤&lt;/li&gt;
&lt;li&gt;CFB中由密码算法输出的比特流称为密钥流，它直接影响到该分组的加解密&lt;/li&gt;
&lt;li&gt;在CFB解密过程中，所有密文分组是已知的，所以每一个分组对应的密钥流就可以通过密码算法预先确定。换句话说，解密过程可以并行处理，而加密只能按分组顺序执行。&lt;/li&gt;
&lt;li&gt;CFB不能抵御重放攻击。如果从某一密文分组开始，被另一组相同数量的密文分组所替代，那么只有被替换的头一个分组无法解密，后续分组不受影响。这一特性，使得重放攻击成为可能。&lt;/li&gt;
&lt;li&gt;不需要填充&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;4-3-cfb-go的实现&#34;&gt;4.3 CFB Go的实现&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Copyright 2010 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// CFB (Cipher Feedback) Mode.

package cipher

/* [Min]
1. 对CFB来说，我们要做的核心工作是为每个分组生成密钥流，再使用这个密钥流来加解密该分组
2. 对于加，解密，生成密钥流的方法都是一样的，可以看成是对某一数据的加密，
而这个某一数据就是前一分组的密文（初始向量）
3. 加密时，先利用加密算法对前一分组的密文进行加密，得到秘钥流，再和该分组明文异或得到该组的密文
4. 解密时，先利用加密算法对前一分组的密文进行加密，得到秘钥流，再和该分组密文异或得到该组的明文
*/
// [Min] 分组密码之CFB模式
type cfb struct {
	b       Block  // [Min] 用来对密文（初始向量）加密生成下一分组的秘钥流
	next    []byte // [Min] 存储当前分组的密文（初始向量）
	out     []byte // [Min] 存储对当前分组密文加密后的密钥流
	outUsed int

	decrypt bool
}

// [Min] 循环处理每一个分组，加解密都是从第一个分组开始
func (x *cfb) XORKeyStream(dst, src []byte) {
	for len(src) &amp;gt; 0 {
		// [Min] 处理第一个分组的时候，next中为初始向量，
		// [Min] 后续分组 next 中为前一分组的密文，用于生成密钥流到out中
		// [Min] x.outUsed == len(x.out)，说明上轮循环成功加密或解密了一个分组的数据，
		// [Min] 需要为后续分组创建密钥流
		if x.outUsed == len(x.out) {
			// [Min] 加解密调用的都是Encrypt，用来生成密钥流
			x.b.Encrypt(x.out, x.next)
			x.outUsed = 0
		}

		// [Min] 如果是解密，则从src中取出该分组密文存入next中
		// [Min] 理论上，如果是解密的话，可以像OFB模式一样一次计算出多个密钥流，
		// [Min] 但是这里并没有实现，next的长度还是blockSize
		if x.decrypt {
			// We can precompute a larger segment of the
			// keystream on decryption. This will allow
			// larger batches for xor, and we should be
			// able to match CTR/OFB performance.
			copy(x.next[x.outUsed:], src)
		}
		// [Min] 将当前分组和密钥流异或，得到当前分组的密文
		n := xorBytes(dst, src, x.out[x.outUsed:])
		// [Min] 如果是加密，则从dst中将该分组密文存入next中
		if !x.decrypt {
			copy(x.next[x.outUsed:], dst)
		}
		// [Min] 设置下一分组位置
		dst = dst[n:]
		src = src[n:]
		x.outUsed += n
	}
}

// NewCFBEncrypter returns a Stream which encrypts with cipher feedback mode,
// using the given Block. The iv must be the same length as the Block&#39;s block
// size.
func NewCFBEncrypter(block Block, iv []byte) Stream {
	return newCFB(block, iv, false)
}

// NewCFBDecrypter returns a Stream which decrypts with cipher feedback mode,
// using the given Block. The iv must be the same length as the Block&#39;s block
// size.
func NewCFBDecrypter(block Block, iv []byte) Stream {
	return newCFB(block, iv, true)
}

// [Min] 新建CFB秘钥流模式
func newCFB(block Block, iv []byte, decrypt bool) Stream {
	blockSize := block.BlockSize()
	if len(iv) != blockSize {
		// stack trace will indicate whether it was de or encryption
		panic(&amp;quot;cipher.newCFB: IV length must equal block size&amp;quot;)
	}
	x := &amp;amp;cfb{
		b:       block,
		out:     make([]byte, blockSize),
		next:    make([]byte, blockSize),
		outUsed: blockSize,
		decrypt: decrypt,
	}
	copy(x.next, iv)

	return x
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;5-ofb&#34;&gt;5 OFB&lt;/h1&gt;

&lt;h2 id=&#34;5-1-ofb的流程&#34;&gt;5.1 OFB的流程&lt;/h2&gt;

&lt;p&gt;　　OFB模式中，密码算法的输出（某一分组的密钥流）会反馈到密码算法的输入中。和CFB一样，密码算法不直接对明密文进行计算，只是用来生成分组的密钥流。&lt;/p&gt;

&lt;p&gt;OFB加密流程：
&lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/a/a9/Ofb_encryption.png&#34; alt=&#34;OFB加密流程&#34; /&gt;
OFB解密流程：
&lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/8/82/Ofb_decryption.png&#34; alt=&#34;OFB解密流程&#34; /&gt;&lt;/p&gt;

&lt;p&gt;　　OFB模式和CFB模式极其相似，分组的加解密都是依赖于该分组的密钥流。只是生成密钥流的输入来源不同，OFB是上一组的密钥流，CFB是上一密文分组。&lt;/p&gt;

&lt;h2 id=&#34;5-2-ofb的特点&#34;&gt;5.2 OFB的特点&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;与CFB类似，OFB模式的关键是分组对应的密钥流&lt;/li&gt;
&lt;li&gt;OFB分组秘钥流与初始化向量和分组的序号有关，各个分组的密钥流可以提前生成，这也就意味着OFB模式的分组加解密可以并行，CFB只有解密可以并行&lt;/li&gt;
&lt;li&gt;如果对于某一个密钥流加密后还是该密钥流，那么该分组后续所有分组的秘钥流都相同，这可能是OFB的一个弱点&lt;/li&gt;
&lt;li&gt;不需要填充&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;5-3-ofb-go的实现&#34;&gt;5.3 OFB Go的实现&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Copyright 2011 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// OFB (Output Feedback) Mode.

package cipher

/* [Min]
1. 对OFB来说，与CFB类似，我们要做的核心工作是为每个分组生成密钥流，再使用这个密钥流来加解密该分组
2. 对于加，解密，生成密钥流的方法都是一样的，可以看成是对某一数据的加密，
而这个某一数据就是前一分组的密钥流（初始向量），
即对初始向量不断加密，如果加密函数为f的话，那么第i组的密钥流就是f...(f(f(iv))),i=1,2,3...
3. 与CFB略有不同的是，密钥流可以提前计算好，因为每一组对应的秘钥流只与组的索引有关，
所以我们可以提前按顺序计算好若干个组的密钥流，然后一次性对这若干个组进行加解密，提高效率
4. 如果在完成这若干个秘钥流的加解密后，还有数据，继续3中的操作，直到完成所有数据的加解密
*/
// [Min] 分组密码之OFB模式
type ofb struct {
	b       Block  // [Min] 用来对本组密钥流（初始向量）加密生成下一分组的秘钥流
	cipher  []byte // [Min] 前一组密钥流(初始向量)
	out     []byte // [Min] 一系列按顺序通过refill计算好的密钥流
	outUsed int    // [Min] out中已经使用过的密钥流的总长度
}

// NewOFB returns a Stream that encrypts or decrypts using the block cipher b
// in output feedback mode. The initialization vector iv&#39;s length must be equal
// to b&#39;s block size.
// [Min] 新建OFB密钥流模式
func NewOFB(b Block, iv []byte) Stream {
	blockSize := b.BlockSize()
	if len(iv) != blockSize {
		panic(&amp;quot;cipher.NewOFB: IV length must equal block size&amp;quot;)
	}
	// [Min] out的容量最低取512字节，如果blockSize超过512，按blockSize计算
	bufSize := streamBufferSize
	if bufSize &amp;lt; blockSize {
		bufSize = blockSize
	}
	x := &amp;amp;ofb{
		b:       b,
		cipher:  make([]byte, blockSize),
		out:     make([]byte, 0, bufSize),
		outUsed: 0,
	}

	copy(x.cipher, iv)
	return x
}

// [Min] 根据outUsed，移去out中已使用过的密钥流，并计算后续密钥流
func (x *ofb) refill() {
	bs := x.b.BlockSize()
	remain := len(x.out) - x.outUsed
	// [Min] 如果剩余的大于已使用的，说明剩余的至少还有一个完整的密钥流未使用，直接返回
	if remain &amp;gt; x.outUsed {
		return
	}
	// [Min] 从out中移去已使用的密钥流
	copy(x.out, x.out[x.outUsed:])
	// [Min] 保留remain的部分，并初始化后续数据
	x.out = x.out[:cap(x.out)]
	// [Min] 累计计算密钥流，并添加到remain中，直到无法再次添加一个完整的密钥流为止
	for remain &amp;lt; len(x.out)-bs {
		x.b.Encrypt(x.cipher, x.cipher)
		copy(x.out[remain:], x.cipher)
		remain += bs
	}
	// [Min] 保留当前所有未使用的秘钥流，置outUsed为0
	x.out = x.out[:remain]
	x.outUsed = 0
}

// [Min] 通过out中的密钥流，对明文，密文加解密
func (x *ofb) XORKeyStream(dst, src []byte) {
	for len(src) &amp;gt; 0 {
		// [Min] 如果out中剩余未使用的部分不够一个密钥流的长度，
		// [Min] 则需要从out中移去已使用过的密钥流，并且计算后续的密钥流
		if x.outUsed &amp;gt;= len(x.out)-x.b.BlockSize() {
			x.refill()
		}
		// [Min] 一次性从src中加解密与out中未使用的秘钥流对应的相同数量的明文或密文
		n := xorBytes(dst, src, x.out[x.outUsed:])
		// [Min] 设置下一次加解密的起点位置
		dst = dst[n:]
		src = src[n:]
		x.outUsed += n
	}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;6-ctr&#34;&gt;6 CTR&lt;/h1&gt;

&lt;h2 id=&#34;6-1-ctr的流程&#34;&gt;6.1 CTR的流程&lt;/h2&gt;

&lt;p&gt;　　与OFB相似，CTR模式是一种通过将逐次累加的计数器进行加密来生成密钥流的流密码。每一个分组对应一个逐次累加的计数，该计数用于生成该分组的秘钥流。&lt;/p&gt;

&lt;p&gt;CTR加密流程：
&lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/3/3f/Ctr_encryption.png&#34; alt=&#34;CTR加密流程&#34; /&gt;
CTR解密流程：
&lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/3/34/Ctr_decryption.png&#34; alt=&#34;CTR解密流程&#34; /&gt;&lt;/p&gt;

&lt;p&gt;　　计数器一般由一个随机数nonce确定，nonce + 一定位数的计数空间构成了该计数器。&lt;/p&gt;

&lt;h2 id=&#34;6-2-ctr的特点&#34;&gt;6.2 CTR的特点&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;和OFB类似，CTR也是利用秘钥流进行加解密&lt;/li&gt;
&lt;li&gt;生成CTR秘钥流的来源是该分组的计数&lt;/li&gt;
&lt;li&gt;CTR加解密可以并行&lt;/li&gt;
&lt;li&gt;由于密码算法的输入是各组对应的不同的计数，分组的秘钥流就不同，因此CTR没有OFB中提到的弱点&lt;/li&gt;
&lt;li&gt;不需要填充&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;6-3-ctr-go的实现&#34;&gt;6.3 CTR Go的实现&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Counter (CTR) mode.

// CTR converts a block cipher into a stream cipher by
// repeatedly encrypting an incrementing counter and
// xoring the resulting stream of data with the input.

// See NIST SP 800-38A, pp 13-15

package cipher

/* [Min]
1. 对CTR来说，与OFB极其类似，我们要做的核心工作也是为每个分组生成密钥流，再使用这个密钥流来加解密该分组
2. 对于加，解密，生成密钥流的方法都是一样的，可以看成是对某一数据的加密，
而这个某一数据就是当前分组的计数值，
如果加密函数为f的话，初始计数为A，那么第i组的密钥流就是f(A+i-1),i=1,2,3...
3. 同样，密钥流也可以提前计算好，因为每一组对应的秘钥流只与组的索引有关，（初始计数已确定）
所以我们可以提前按顺序计算好若干个组的密钥流，然后一次性对这若干个组进行加解密，提高效率
4. 如果在完成这若干个秘钥流的加解密后，还有数据，继续3中的操作，直到完成所有数据的加解密
*/
// [Min] 分组密码之CTR模式
type ctr struct {
	b       Block  // [Min] 用来对本组计数加密生成下一分组的秘钥流
	ctr     []byte // [Min] 分组计数器，长度与blockSize相同，可以把byte切片看成一个连起来的大数
	out     []byte // [Min] 一系列密钥流
	outUsed int    // [Min] out中已使用的密钥流
}

const streamBufferSize = 512

// ctrAble is an interface implemented by ciphers that have a specific optimized
// implementation of CTR, like crypto/aes. NewCTR will check for this interface
// and return the specific Stream if found.
type ctrAble interface {
	NewCTR(iv []byte) Stream
}

// NewCTR returns a Stream which encrypts/decrypts using the given Block in
// counter mode. The length of iv must be the same as the Block&#39;s block size.
func NewCTR(block Block, iv []byte) Stream {
	if ctr, ok := block.(ctrAble); ok {
		return ctr.NewCTR(iv)
	}
	if len(iv) != block.BlockSize() {
		panic(&amp;quot;cipher.NewCTR: IV length must equal block size&amp;quot;)
	}
	bufSize := streamBufferSize
	if bufSize &amp;lt; block.BlockSize() {
		bufSize = block.BlockSize()
	}
	return &amp;amp;ctr{
		b:       block,
		ctr:     dup(iv),
		out:     make([]byte, 0, bufSize),
		outUsed: 0,
	}
}

// [Min] 尽可能多地在out中计算密钥流
func (x *ctr) refill() {
	remain := len(x.out) - x.outUsed
	copy(x.out, x.out[x.outUsed:])
	x.out = x.out[:cap(x.out)]
	bs := x.b.BlockSize()
	for remain &amp;lt;= len(x.out)-bs {
		x.b.Encrypt(x.out[remain:], x.ctr)
		remain += bs

		// Increment counter
		// [Min] 从最后一个字节开始尝试加1，如果没有溢出，跳出循环
		// [Min] 否则高一个字节进一位
		for i := len(x.ctr) - 1; i &amp;gt;= 0; i-- {
			x.ctr[i]++
			if x.ctr[i] != 0 {
				break
			}
		}
	}
	x.out = x.out[:remain]
	x.outUsed = 0
}

// [Min] 与OFB类似
func (x *ctr) XORKeyStream(dst, src []byte) {
	for len(src) &amp;gt; 0 {
		if x.outUsed &amp;gt;= len(x.out)-x.b.BlockSize() {
			x.refill()
		}
		n := xorBytes(dst, src, x.out[x.outUsed:])
		dst = dst[n:]
		src = src[n:]
		x.outUsed += n
	}
}

&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>SHA3</title>
      <link>https://mooncaker816.github.io/2018/07/21/sha3/</link>
      <pubDate>Sat, 21 Jul 2018 08:52:27 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/07/21/sha3/</guid>
      <description>&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;1-什么是sha-3&#34;&gt;1 什么是SHA-3&lt;/h1&gt;

&lt;p&gt;　　SHA-3是一种作为新标准发布的单向散列函数算法，用来替代在理论上已被找出攻击方法的SHA-1算法。全世界的企业和密码学家提交了很多SHA-3的候选方案，经过长达5年的选拔，最终于2012年正式确定将Kececak算法作为SHA-3标准。&lt;br /&gt;
　　Keccak的以下几大特点，是其成为SHA-3标准的重要原因：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;采用了与SHA-2完全不同的结构&lt;/li&gt;
&lt;li&gt;结构清晰，易于分析&lt;/li&gt;
&lt;li&gt;能够适用于各种设备，也适用于嵌入式应用&lt;/li&gt;
&lt;li&gt;在硬件上的实现显示出了很高的性能&lt;/li&gt;
&lt;li&gt;比其他最终候选算法安全性边际更大&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　Keccak可以生成任意长度的散列值，但为了配合SHA-2的散列值长度，SHA-3标准中共规定了SHA3-224，SHA3-256，SHA3-384，SHA3-512这4种版本。在输入数据的长度上限方面，SHA-1为2^64 - 1，SHA-2为2^128 - 1，而SHA-3则没有长度限制。&lt;br /&gt;
　　此外，SHA3还有两个可以输出任意长度散列值的函数：SHAKE128,SHAKE256，在 Go 的SHA3文档中，推荐使用SHAKE256。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;// Guidance&lt;br /&gt;
//&lt;br /&gt;
// If you aren&amp;rsquo;t sure what function you need, use SHAKE256 with at least 64&lt;br /&gt;
// bytes of output. The SHAKE instances are faster than the SHA3 instances;&lt;br /&gt;
// the latter have to allocate memory to conform to the hash.Hash interface.&lt;br /&gt;
//&lt;br /&gt;
// If you need a secret-key MAC (message authentication code), prepend the&lt;br /&gt;
// secret key to the input, hash with SHAKE256 and read at least 32 bytes of&lt;br /&gt;
// output.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;2-keccak&#34;&gt;2 Keccak&lt;/h1&gt;

&lt;h2 id=&#34;2-1-keccak的结构&#34;&gt;2.1 Keccak的结构&lt;/h2&gt;

&lt;p&gt;　　Keccak采用了与SHA-1，SHA-2完全不同的海绵结构。顾名思义，海绵最大的特点就是其吸水性，用在此处想必也是有此寓意。在Keccak的海绵结构中，输入数据在进行分组以及相应的填充之后，要经过吸收阶段和挤出阶段，最终生成输出的散列值。&lt;br /&gt;
　　吸收阶段中，源数据按一定大小分组，最后一组会进行填充补足。依次将每一分组的数据与Keccak中内部状态作XOR操作，从而将分组数据吸收入Keccak结构中，再将XOR之后的数据按一定算法进行搅拌，此时内部状态中的数据为该分组数据搅拌后的数据，再在此状态下用相同的方法吸入下一组数据并再次搅拌，循环往复，直至最后一组数据搅拌成功，完成吸收阶段。&lt;br /&gt;
　　挤出阶段中，在完成对最后一组数据的搅拌后，直接按分组大小将内部状态中的数据输出到最终输出中，如果达不到输出的长度要求，则再次执行同样的搅拌，每次从内部状态中挤出最多分组大小的数据，循环往复，直至达到输出长度的要求。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://oumnldfwl.bkt.clouddn.com/keccak结构流程图.png&#34; alt=&#34;Keccak 结构流程图&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;2-2-keccak的内部状态&#34;&gt;2.2 Keccak的内部状态&lt;/h2&gt;

&lt;p&gt;　　Keccak的内部状态可以看成是一个5*5*w的三维立方体，每一个单位元素代表一个比特位。根据设计规格，Keccak的内部状态大小可以为25，50，100，200，400，800，1600共7种，分别对应的w为1，2，4，8，16，32，64。SHA3 采用了最大的规格，用以提升安全等级，所以SHA3的内部状态实际是一个5*5*64大小的比特流。将这个比特流映射到具体的数据结构上，可以表述为一个由25个无符号64位整数组成的数组。&lt;br /&gt;
　　更具体的内部状态信息，可以参考以下官方文档中的3.1小节。
&lt;a href=&#34;https://csrc.nist.gov/csrc/media/publications/fips/202/final/documents/fips_202_draft.pdf&#34; target=&#34;_blank&#34;&gt;https://csrc.nist.gov/csrc/media/publications/fips/202/final/documents/fips_202_draft.pdf&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;2-3-搅拌方法&#34;&gt;2.3 搅拌方法&lt;/h2&gt;

&lt;p&gt;　　Keccak最重要的就是他的“搅拌函数”，用来在原数据的基础上对其进行一系列复杂的运算，最后生成摘要信息。搅拌的过程一共可以分为5个步骤，θ，ρ，π，χ，ι，共计24轮计算。每一个步骤都是对这个5*5*64的状态矩阵进行相应的计算，移位，旋转等操作。
　　具体步骤可以参考上文链接中的3.2小节，此处不再赘述。&lt;/p&gt;

&lt;h2 id=&#34;2-4-搅拌方法的实现&#34;&gt;2.4 搅拌方法的实现&lt;/h2&gt;

&lt;p&gt;　　在Keccak官网上，给出了许多有趣的实现方法，以下是参考链接：
&lt;a href=&#34;https://keccak.team/files/Keccak-implementation-3.2.pdf&#34; target=&#34;_blank&#34;&gt;https://keccak.team/files/Keccak-implementation-3.2.pdf&lt;/a&gt;&lt;br /&gt;
而 Go 的 x/crypto/sha3 包采用的是其中的 Efficient in-place implementations。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Copyright 2014 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//  +build !amd64 appengine gccgo

package sha3

// rc stores the round constants for use in the ι step.
var rc = [24]uint64{
	0x0000000000000001,
	0x0000000000008082,
	0x800000000000808A,
	0x8000000080008000,
	0x000000000000808B,
	0x0000000080000001,
	0x8000000080008081,
	0x8000000000008009,
	0x000000000000008A,
	0x0000000000000088,
	0x0000000080008009,
	0x000000008000000A,
	0x000000008000808B,
	0x800000000000008B,
	0x8000000000008089,
	0x8000000000008003,
	0x8000000000008002,
	0x8000000000000080,
	0x000000000000800A,
	0x800000008000000A,
	0x8000000080008081,
	0x8000000000008080,
	0x0000000080000001,
	0x8000000080008008,
}

// keccakF1600 applies the Keccak permutation to a 1600b-wide
// state represented as a slice of 25 uint64s.
// [Min] 对已经吸收到 a 中的一个分组的数据进行处理
func keccakF1600(a *[25]uint64) {
	// Implementation translated from Keccak-inplace.c
	// in the keccak reference code.
	var t, bc0, bc1, bc2, bc3, bc4, d0, d1, d2, d3, d4 uint64

	/* [Min]
		共计24轮计算，每四轮一循环，所有涉及A,B,C,D索引的计算都是mod 5，对a的索引计算都是 mod 25
	已知	N = 1 0
				1 2
	N^i的值每4轮一循环（元素值 mod5 相同）
	A[x,y] = a[5y+x], 此处小a就是函数的输入
	r[x,y] 值如下表，代表循环左移的位数
		x=3 x=4 x=0 x=1 x=2
	y=2 25	39  3   10  43
	y=1 55  20  36  44  6
	y=0 28  27  0   1   62
	y=4 56  14  18  2   61
	y=3 21  8   41  45  15

		对第i轮进行计算：
		1. C[x] = A[N^i(x,0)T]⊕A[N^i(x,1)T]⊕A[N^i(x,2)T]⊕A[N^i(x,3)T]⊕A[N^i(x,4)T], x = 0...4
		2. D[x] = C[x−1]⊕ROT(C[x+1],1), x = 0...4
		for y=0...4
		3. B[x+2y] = ROT((A[N^(i+1)(x,y)T]⊕D[x]),r[N(x,y)T]), x=0...4
		4. A[N^(i+1)(x,y)T]=B[x]⊕((NOT B[x+1]) AND B[x+2]), x=0...4
		end
		5. A[0,0] = A[0,0] ⊕ RC[i]
	*/
	for i := 0; i &amp;lt; 24; i += 4 {
		// Combines the 5 steps in each round into 2 steps.
		// Unrolls 4 rounds per loop and spreads some steps across rounds.

		// Round 1
		/* [Min]
		i = 0, N^0 = 单位矩阵
		C[0] = A[0,0]⊕A[0,1]⊕A[0,2]⊕A[0,3]⊕A[0,4]
		     = a[0] ^ a[5] ^ a[10] ^ a[15] ^ a[20]
		C[1] = A[1,0]⊕A[1,1]⊕A[1,2]⊕A[1,3]⊕A[1,4]
			 = a[1] ^ a[6] ^ a[11] ^ a[16] ^ a[21]
		...
		*/
		// [Min] C[x] = A[N^i(x,0)T]⊕A[N^i(x,1)T]⊕A[N^i(x,2)T]⊕A[N^i(x,3)T]⊕A[N^i(x,4)T]
		bc0 = a[0] ^ a[5] ^ a[10] ^ a[15] ^ a[20]
		bc1 = a[1] ^ a[6] ^ a[11] ^ a[16] ^ a[21]
		bc2 = a[2] ^ a[7] ^ a[12] ^ a[17] ^ a[22]
		bc3 = a[3] ^ a[8] ^ a[13] ^ a[18] ^ a[23]
		bc4 = a[4] ^ a[9] ^ a[14] ^ a[19] ^ a[24]
		// [Min] D[x] = C[x−1]⊕ROT(C[x+1],1), x = 0...4
		d0 = bc4 ^ (bc1&amp;lt;&amp;lt;1 | bc1&amp;gt;&amp;gt;63)
		d1 = bc0 ^ (bc2&amp;lt;&amp;lt;1 | bc2&amp;gt;&amp;gt;63)
		d2 = bc1 ^ (bc3&amp;lt;&amp;lt;1 | bc3&amp;gt;&amp;gt;63)
		d3 = bc2 ^ (bc4&amp;lt;&amp;lt;1 | bc4&amp;gt;&amp;gt;63)
		d4 = bc3 ^ (bc0&amp;lt;&amp;lt;1 | bc0&amp;gt;&amp;gt;63)

		// [Min] y = 0
		// [Min]    B[x+2y] = ROT((A[N^(i+1)(x,y)T]⊕D[x]),r[N(x,y)T]), x=0...4
		// [Min]    A[N^(i+1)(x,y)T]=B[x]⊕((NOT B[x+1]) AND B[x+2]), x=0...4
		// [Min] A[0,0] = A[0,0] ⊕ RC[i]
		bc0 = a[0] ^ d0
		t = a[6] ^ d1
		bc1 = t&amp;lt;&amp;lt;44 | t&amp;gt;&amp;gt;(64-44)
		t = a[12] ^ d2
		bc2 = t&amp;lt;&amp;lt;43 | t&amp;gt;&amp;gt;(64-43)
		t = a[18] ^ d3
		bc3 = t&amp;lt;&amp;lt;21 | t&amp;gt;&amp;gt;(64-21)
		t = a[24] ^ d4
		bc4 = t&amp;lt;&amp;lt;14 | t&amp;gt;&amp;gt;(64-14)
		a[0] = bc0 ^ (bc2 &amp;amp;^ bc1) ^ rc[i]
		a[6] = bc1 ^ (bc3 &amp;amp;^ bc2)
		a[12] = bc2 ^ (bc4 &amp;amp;^ bc3)
		a[18] = bc3 ^ (bc0 &amp;amp;^ bc4)
		a[24] = bc4 ^ (bc1 &amp;amp;^ bc0)

		// [Min] y = 1
		// [Min]    B[x+2y] = ROT((A[N^(i+1)(x,y)T]⊕D[x]),r[N(x,y)T]), x=0...4
		// [Min]    A[N^(i+1)(x,y)T]=B[x]⊕((NOT B[x+1]) AND B[x+2]), x=0...4
		t = a[10] ^ d0
		bc2 = t&amp;lt;&amp;lt;3 | t&amp;gt;&amp;gt;(64-3)
		t = a[16] ^ d1
		bc3 = t&amp;lt;&amp;lt;45 | t&amp;gt;&amp;gt;(64-45)
		t = a[22] ^ d2
		bc4 = t&amp;lt;&amp;lt;61 | t&amp;gt;&amp;gt;(64-61)
		t = a[3] ^ d3
		bc0 = t&amp;lt;&amp;lt;28 | t&amp;gt;&amp;gt;(64-28)
		t = a[9] ^ d4
		bc1 = t&amp;lt;&amp;lt;20 | t&amp;gt;&amp;gt;(64-20)
		a[10] = bc0 ^ (bc2 &amp;amp;^ bc1)
		a[16] = bc1 ^ (bc3 &amp;amp;^ bc2)
		a[22] = bc2 ^ (bc4 &amp;amp;^ bc3)
		a[3] = bc3 ^ (bc0 &amp;amp;^ bc4)
		a[9] = bc4 ^ (bc1 &amp;amp;^ bc0)

		// [Min] y = 2
		// [Min]    B[x+2y] = ROT((A[N^(i+1)(x,y)T]⊕D[x]),r[N(x,y)T]), x=0...4
		// [Min]    A[N^(i+1)(x,y)T]=B[x]⊕((NOT B[x+1]) AND B[x+2]), x=0...4
		t = a[20] ^ d0
		bc4 = t&amp;lt;&amp;lt;18 | t&amp;gt;&amp;gt;(64-18)
		t = a[1] ^ d1
		bc0 = t&amp;lt;&amp;lt;1 | t&amp;gt;&amp;gt;(64-1)
		t = a[7] ^ d2
		bc1 = t&amp;lt;&amp;lt;6 | t&amp;gt;&amp;gt;(64-6)
		t = a[13] ^ d3
		bc2 = t&amp;lt;&amp;lt;25 | t&amp;gt;&amp;gt;(64-25)
		t = a[19] ^ d4
		bc3 = t&amp;lt;&amp;lt;8 | t&amp;gt;&amp;gt;(64-8)
		a[20] = bc0 ^ (bc2 &amp;amp;^ bc1)
		a[1] = bc1 ^ (bc3 &amp;amp;^ bc2)
		a[7] = bc2 ^ (bc4 &amp;amp;^ bc3)
		a[13] = bc3 ^ (bc0 &amp;amp;^ bc4)
		a[19] = bc4 ^ (bc1 &amp;amp;^ bc0)

		// [Min] y = 3
		// [Min]    B[x+2y] = ROT((A[N^(i+1)(x,y)T]⊕D[x]),r[N(x,y)T]), x=0...4
		// [Min]    A[N^(i+1)(x,y)T]=B[x]⊕((NOT B[x+1]) AND B[x+2]), x=0...4
		t = a[5] ^ d0
		bc1 = t&amp;lt;&amp;lt;36 | t&amp;gt;&amp;gt;(64-36)
		t = a[11] ^ d1
		bc2 = t&amp;lt;&amp;lt;10 | t&amp;gt;&amp;gt;(64-10)
		t = a[17] ^ d2
		bc3 = t&amp;lt;&amp;lt;15 | t&amp;gt;&amp;gt;(64-15)
		t = a[23] ^ d3
		bc4 = t&amp;lt;&amp;lt;56 | t&amp;gt;&amp;gt;(64-56)
		t = a[4] ^ d4
		bc0 = t&amp;lt;&amp;lt;27 | t&amp;gt;&amp;gt;(64-27)
		a[5] = bc0 ^ (bc2 &amp;amp;^ bc1)
		a[11] = bc1 ^ (bc3 &amp;amp;^ bc2)
		a[17] = bc2 ^ (bc4 &amp;amp;^ bc3)
		a[23] = bc3 ^ (bc0 &amp;amp;^ bc4)
		a[4] = bc4 ^ (bc1 &amp;amp;^ bc0)

		// [Min] y = 4
		// [Min]    B[x+2y] = ROT((A[N^(i+1)(x,y)T]⊕D[x]),r[N(x,y)T]), x=0...4
		// [Min]    A[N^(i+1)(x,y)T]=B[x]⊕((NOT B[x+1]) AND B[x+2]), x=0...4
		t = a[15] ^ d0
		bc3 = t&amp;lt;&amp;lt;41 | t&amp;gt;&amp;gt;(64-41)
		t = a[21] ^ d1
		bc4 = t&amp;lt;&amp;lt;2 | t&amp;gt;&amp;gt;(64-2)
		t = a[2] ^ d2
		bc0 = t&amp;lt;&amp;lt;62 | t&amp;gt;&amp;gt;(64-62)
		t = a[8] ^ d3
		bc1 = t&amp;lt;&amp;lt;55 | t&amp;gt;&amp;gt;(64-55)
		t = a[14] ^ d4
		bc2 = t&amp;lt;&amp;lt;39 | t&amp;gt;&amp;gt;(64-39)
		a[15] = bc0 ^ (bc2 &amp;amp;^ bc1)
		a[21] = bc1 ^ (bc3 &amp;amp;^ bc2)
		a[2] = bc2 ^ (bc4 &amp;amp;^ bc3)
		a[8] = bc3 ^ (bc0 &amp;amp;^ bc4)
		a[14] = bc4 ^ (bc1 &amp;amp;^ bc0)

		// Round 2
		/* [Min]
		i = 1, N^i将 (x,y) 映射成 (x,x+2y)
		C[0] = A[0,0]⊕A[0,2]⊕A[0,4]⊕A[0,1]⊕A[0,3]
		     = a[0] ^ a[10] ^ a[20] ^ a[5] ^ a[15]
		C[1] = A[1,1]⊕A[1,3]⊕A[1,0]⊕A[1,2]⊕A[1,4]
			 = a[6] ^ a[16] ^ a[1] ^ a[11] ^ a[21]
		...
		*/
		// [Min] C[x] = A[N^i(x,0)T]⊕A[N^i(x,1)T]⊕A[N^i(x,2)T]⊕A[N^i(x,3)T]⊕A[N^i(x,4)T]
		bc0 = a[0] ^ a[5] ^ a[10] ^ a[15] ^ a[20]
		bc1 = a[1] ^ a[6] ^ a[11] ^ a[16] ^ a[21]
		bc2 = a[2] ^ a[7] ^ a[12] ^ a[17] ^ a[22]
		bc3 = a[3] ^ a[8] ^ a[13] ^ a[18] ^ a[23]
		bc4 = a[4] ^ a[9] ^ a[14] ^ a[19] ^ a[24]
		// [Min] D[x] = C[x−1]⊕ROT(C[x+1],1), x = 0...4
		d0 = bc4 ^ (bc1&amp;lt;&amp;lt;1 | bc1&amp;gt;&amp;gt;63)
		d1 = bc0 ^ (bc2&amp;lt;&amp;lt;1 | bc2&amp;gt;&amp;gt;63)
		d2 = bc1 ^ (bc3&amp;lt;&amp;lt;1 | bc3&amp;gt;&amp;gt;63)
		d3 = bc2 ^ (bc4&amp;lt;&amp;lt;1 | bc4&amp;gt;&amp;gt;63)
		d4 = bc3 ^ (bc0&amp;lt;&amp;lt;1 | bc0&amp;gt;&amp;gt;63)

		// [Min] y = 0
		// [Min]    B[x+2y] = ROT((A[N^(i+1)(x,y)T]⊕D[x]),r[N(x,y)T]), x=0...4
		// [Min]    A[N^(i+1)(x,y)T]=B[x]⊕((NOT B[x+1]) AND B[x+2]), x=0...4
		// [Min] A[0,0] = A[0,0] ⊕ RC[i]
		bc0 = a[0] ^ d0
		t = a[16] ^ d1
		bc1 = t&amp;lt;&amp;lt;44 | t&amp;gt;&amp;gt;(64-44)
		t = a[7] ^ d2
		bc2 = t&amp;lt;&amp;lt;43 | t&amp;gt;&amp;gt;(64-43)
		t = a[23] ^ d3
		bc3 = t&amp;lt;&amp;lt;21 | t&amp;gt;&amp;gt;(64-21)
		t = a[14] ^ d4
		bc4 = t&amp;lt;&amp;lt;14 | t&amp;gt;&amp;gt;(64-14)
		a[0] = bc0 ^ (bc2 &amp;amp;^ bc1) ^ rc[i+1]
		a[16] = bc1 ^ (bc3 &amp;amp;^ bc2)
		a[7] = bc2 ^ (bc4 &amp;amp;^ bc3)
		a[23] = bc3 ^ (bc0 &amp;amp;^ bc4)
		a[14] = bc4 ^ (bc1 &amp;amp;^ bc0)

		// [Min] y = 1
		// [Min]    B[x+2y] = ROT((A[N^(i+1)(x,y)T]⊕D[x]),r[N(x,y)T]), x=0...4
		// [Min]    A[N^(i+1)(x,y)T]=B[x]⊕((NOT B[x+1]) AND B[x+2]), x=0...4
		t = a[20] ^ d0
		bc2 = t&amp;lt;&amp;lt;3 | t&amp;gt;&amp;gt;(64-3)
		t = a[11] ^ d1
		bc3 = t&amp;lt;&amp;lt;45 | t&amp;gt;&amp;gt;(64-45)
		t = a[2] ^ d2
		bc4 = t&amp;lt;&amp;lt;61 | t&amp;gt;&amp;gt;(64-61)
		t = a[18] ^ d3
		bc0 = t&amp;lt;&amp;lt;28 | t&amp;gt;&amp;gt;(64-28)
		t = a[9] ^ d4
		bc1 = t&amp;lt;&amp;lt;20 | t&amp;gt;&amp;gt;(64-20)
		a[20] = bc0 ^ (bc2 &amp;amp;^ bc1)
		a[11] = bc1 ^ (bc3 &amp;amp;^ bc2)
		a[2] = bc2 ^ (bc4 &amp;amp;^ bc3)
		a[18] = bc3 ^ (bc0 &amp;amp;^ bc4)
		a[9] = bc4 ^ (bc1 &amp;amp;^ bc0)

		// [Min] y = 2
		// [Min]    B[x+2y] = ROT((A[N^(i+1)(x,y)T]⊕D[x]),r[N(x,y)T]), x=0...4
		// [Min]    A[N^(i+1)(x,y)T]=B[x]⊕((NOT B[x+1]) AND B[x+2]), x=0...4
		t = a[15] ^ d0
		bc4 = t&amp;lt;&amp;lt;18 | t&amp;gt;&amp;gt;(64-18)
		t = a[6] ^ d1
		bc0 = t&amp;lt;&amp;lt;1 | t&amp;gt;&amp;gt;(64-1)
		t = a[22] ^ d2
		bc1 = t&amp;lt;&amp;lt;6 | t&amp;gt;&amp;gt;(64-6)
		t = a[13] ^ d3
		bc2 = t&amp;lt;&amp;lt;25 | t&amp;gt;&amp;gt;(64-25)
		t = a[4] ^ d4
		bc3 = t&amp;lt;&amp;lt;8 | t&amp;gt;&amp;gt;(64-8)
		a[15] = bc0 ^ (bc2 &amp;amp;^ bc1)
		a[6] = bc1 ^ (bc3 &amp;amp;^ bc2)
		a[22] = bc2 ^ (bc4 &amp;amp;^ bc3)
		a[13] = bc3 ^ (bc0 &amp;amp;^ bc4)
		a[4] = bc4 ^ (bc1 &amp;amp;^ bc0)

		// [Min] y = 3
		// [Min]    B[x+2y] = ROT((A[N^(i+1)(x,y)T]⊕D[x]),r[N(x,y)T]), x=0...4
		// [Min]    A[N^(i+1)(x,y)T]=B[x]⊕((NOT B[x+1]) AND B[x+2]), x=0...4
		t = a[10] ^ d0
		bc1 = t&amp;lt;&amp;lt;36 | t&amp;gt;&amp;gt;(64-36)
		t = a[1] ^ d1
		bc2 = t&amp;lt;&amp;lt;10 | t&amp;gt;&amp;gt;(64-10)
		t = a[17] ^ d2
		bc3 = t&amp;lt;&amp;lt;15 | t&amp;gt;&amp;gt;(64-15)
		t = a[8] ^ d3
		bc4 = t&amp;lt;&amp;lt;56 | t&amp;gt;&amp;gt;(64-56)
		t = a[24] ^ d4
		bc0 = t&amp;lt;&amp;lt;27 | t&amp;gt;&amp;gt;(64-27)
		a[10] = bc0 ^ (bc2 &amp;amp;^ bc1)
		a[1] = bc1 ^ (bc3 &amp;amp;^ bc2)
		a[17] = bc2 ^ (bc4 &amp;amp;^ bc3)
		a[8] = bc3 ^ (bc0 &amp;amp;^ bc4)
		a[24] = bc4 ^ (bc1 &amp;amp;^ bc0)

		// [Min] y = 4
		// [Min]    B[x+2y] = ROT((A[N^(i+1)(x,y)T]⊕D[x]),r[N(x,y)T]), x=0...4
		// [Min]    A[N^(i+1)(x,y)T]=B[x]⊕((NOT B[x+1]) AND B[x+2]), x=0...4
		t = a[5] ^ d0
		bc3 = t&amp;lt;&amp;lt;41 | t&amp;gt;&amp;gt;(64-41)
		t = a[21] ^ d1
		bc4 = t&amp;lt;&amp;lt;2 | t&amp;gt;&amp;gt;(64-2)
		t = a[12] ^ d2
		bc0 = t&amp;lt;&amp;lt;62 | t&amp;gt;&amp;gt;(64-62)
		t = a[3] ^ d3
		bc1 = t&amp;lt;&amp;lt;55 | t&amp;gt;&amp;gt;(64-55)
		t = a[19] ^ d4
		bc2 = t&amp;lt;&amp;lt;39 | t&amp;gt;&amp;gt;(64-39)
		a[5] = bc0 ^ (bc2 &amp;amp;^ bc1)
		a[21] = bc1 ^ (bc3 &amp;amp;^ bc2)
		a[12] = bc2 ^ (bc4 &amp;amp;^ bc3)
		a[3] = bc3 ^ (bc0 &amp;amp;^ bc4)
		a[19] = bc4 ^ (bc1 &amp;amp;^ bc0)

		// Round 3
		/* [Min]
		i = 2, N^i将 (x,y) 映射成 (x,3x+4y)
		C[0] = A[0,0]⊕A[0,4]⊕A[0,3]⊕A[0,2]⊕A[0,1]
		     = a[0] ^ a[20] ^ a[15] ^ a[10] ^ a[5]
		C[1] = A[1,3]⊕A[1,2]⊕A[1,1]⊕A[1,0]⊕A[1,4]
			 = a[16] ^ a[11] ^ a[6] ^ a[1] ^ a[21]
		...
		*/
		// [Min] C[x] = A[N^i(x,0)T]⊕A[N^i(x,1)T]⊕A[N^i(x,2)T]⊕A[N^i(x,3)T]⊕A[N^i(x,4)T]
		bc0 = a[0] ^ a[5] ^ a[10] ^ a[15] ^ a[20]
		bc1 = a[1] ^ a[6] ^ a[11] ^ a[16] ^ a[21]
		bc2 = a[2] ^ a[7] ^ a[12] ^ a[17] ^ a[22]
		bc3 = a[3] ^ a[8] ^ a[13] ^ a[18] ^ a[23]
		bc4 = a[4] ^ a[9] ^ a[14] ^ a[19] ^ a[24]
		// [Min] D[x] = C[x−1]⊕ROT(C[x+1],1), x = 0...4
		d0 = bc4 ^ (bc1&amp;lt;&amp;lt;1 | bc1&amp;gt;&amp;gt;63)
		d1 = bc0 ^ (bc2&amp;lt;&amp;lt;1 | bc2&amp;gt;&amp;gt;63)
		d2 = bc1 ^ (bc3&amp;lt;&amp;lt;1 | bc3&amp;gt;&amp;gt;63)
		d3 = bc2 ^ (bc4&amp;lt;&amp;lt;1 | bc4&amp;gt;&amp;gt;63)
		d4 = bc3 ^ (bc0&amp;lt;&amp;lt;1 | bc0&amp;gt;&amp;gt;63)

		// [Min] y = 0
		// [Min]    B[x+2y] = ROT((A[N^(i+1)(x,y)T]⊕D[x]),r[N(x,y)T]), x=0...4
		// [Min]    A[N^(i+1)(x,y)T]=B[x]⊕((NOT B[x+1]) AND B[x+2]), x=0...4
		// [Min] A[0,0] = A[0,0] ⊕ RC[i]
		bc0 = a[0] ^ d0
		t = a[11] ^ d1
		bc1 = t&amp;lt;&amp;lt;44 | t&amp;gt;&amp;gt;(64-44)
		t = a[22] ^ d2
		bc2 = t&amp;lt;&amp;lt;43 | t&amp;gt;&amp;gt;(64-43)
		t = a[8] ^ d3
		bc3 = t&amp;lt;&amp;lt;21 | t&amp;gt;&amp;gt;(64-21)
		t = a[19] ^ d4
		bc4 = t&amp;lt;&amp;lt;14 | t&amp;gt;&amp;gt;(64-14)
		a[0] = bc0 ^ (bc2 &amp;amp;^ bc1) ^ rc[i+2]
		a[11] = bc1 ^ (bc3 &amp;amp;^ bc2)
		a[22] = bc2 ^ (bc4 &amp;amp;^ bc3)
		a[8] = bc3 ^ (bc0 &amp;amp;^ bc4)
		a[19] = bc4 ^ (bc1 &amp;amp;^ bc0)

		// [Min] y = 1
		// [Min]    B[x+2y] = ROT((A[N^(i+1)(x,y)T]⊕D[x]),r[N(x,y)T]), x=0...4
		// [Min]    A[N^(i+1)(x,y)T]=B[x]⊕((NOT B[x+1]) AND B[x+2]), x=0...4
		t = a[15] ^ d0
		bc2 = t&amp;lt;&amp;lt;3 | t&amp;gt;&amp;gt;(64-3)
		t = a[1] ^ d1
		bc3 = t&amp;lt;&amp;lt;45 | t&amp;gt;&amp;gt;(64-45)
		t = a[12] ^ d2
		bc4 = t&amp;lt;&amp;lt;61 | t&amp;gt;&amp;gt;(64-61)
		t = a[23] ^ d3
		bc0 = t&amp;lt;&amp;lt;28 | t&amp;gt;&amp;gt;(64-28)
		t = a[9] ^ d4
		bc1 = t&amp;lt;&amp;lt;20 | t&amp;gt;&amp;gt;(64-20)
		a[15] = bc0 ^ (bc2 &amp;amp;^ bc1)
		a[1] = bc1 ^ (bc3 &amp;amp;^ bc2)
		a[12] = bc2 ^ (bc4 &amp;amp;^ bc3)
		a[23] = bc3 ^ (bc0 &amp;amp;^ bc4)
		a[9] = bc4 ^ (bc1 &amp;amp;^ bc0)

		// [Min] y = 2
		// [Min]    B[x+2y] = ROT((A[N^(i+1)(x,y)T]⊕D[x]),r[N(x,y)T]), x=0...4
		// [Min]    A[N^(i+1)(x,y)T]=B[x]⊕((NOT B[x+1]) AND B[x+2]), x=0...4
		t = a[5] ^ d0
		bc4 = t&amp;lt;&amp;lt;18 | t&amp;gt;&amp;gt;(64-18)
		t = a[16] ^ d1
		bc0 = t&amp;lt;&amp;lt;1 | t&amp;gt;&amp;gt;(64-1)
		t = a[2] ^ d2
		bc1 = t&amp;lt;&amp;lt;6 | t&amp;gt;&amp;gt;(64-6)
		t = a[13] ^ d3
		bc2 = t&amp;lt;&amp;lt;25 | t&amp;gt;&amp;gt;(64-25)
		t = a[24] ^ d4
		bc3 = t&amp;lt;&amp;lt;8 | t&amp;gt;&amp;gt;(64-8)
		a[5] = bc0 ^ (bc2 &amp;amp;^ bc1)
		a[16] = bc1 ^ (bc3 &amp;amp;^ bc2)
		a[2] = bc2 ^ (bc4 &amp;amp;^ bc3)
		a[13] = bc3 ^ (bc0 &amp;amp;^ bc4)
		a[24] = bc4 ^ (bc1 &amp;amp;^ bc0)

		// [Min] y = 3
		// [Min]    B[x+2y] = ROT((A[N^(i+1)(x,y)T]⊕D[x]),r[N(x,y)T]), x=0...4
		// [Min]    A[N^(i+1)(x,y)T]=B[x]⊕((NOT B[x+1]) AND B[x+2]), x=0...4
		t = a[20] ^ d0
		bc1 = t&amp;lt;&amp;lt;36 | t&amp;gt;&amp;gt;(64-36)
		t = a[6] ^ d1
		bc2 = t&amp;lt;&amp;lt;10 | t&amp;gt;&amp;gt;(64-10)
		t = a[17] ^ d2
		bc3 = t&amp;lt;&amp;lt;15 | t&amp;gt;&amp;gt;(64-15)
		t = a[3] ^ d3
		bc4 = t&amp;lt;&amp;lt;56 | t&amp;gt;&amp;gt;(64-56)
		t = a[14] ^ d4
		bc0 = t&amp;lt;&amp;lt;27 | t&amp;gt;&amp;gt;(64-27)
		a[20] = bc0 ^ (bc2 &amp;amp;^ bc1)
		a[6] = bc1 ^ (bc3 &amp;amp;^ bc2)
		a[17] = bc2 ^ (bc4 &amp;amp;^ bc3)
		a[3] = bc3 ^ (bc0 &amp;amp;^ bc4)
		a[14] = bc4 ^ (bc1 &amp;amp;^ bc0)

		// [Min] y = 4
		// [Min]    B[x+2y] = ROT((A[N^(i+1)(x,y)T]⊕D[x]),r[N(x,y)T]), x=0...4
		// [Min]    A[N^(i+1)(x,y)T]=B[x]⊕((NOT B[x+1]) AND B[x+2]), x=0...4
		t = a[10] ^ d0
		bc3 = t&amp;lt;&amp;lt;41 | t&amp;gt;&amp;gt;(64-41)
		t = a[21] ^ d1
		bc4 = t&amp;lt;&amp;lt;2 | t&amp;gt;&amp;gt;(64-2)
		t = a[7] ^ d2
		bc0 = t&amp;lt;&amp;lt;62 | t&amp;gt;&amp;gt;(64-62)
		t = a[18] ^ d3
		bc1 = t&amp;lt;&amp;lt;55 | t&amp;gt;&amp;gt;(64-55)
		t = a[4] ^ d4
		bc2 = t&amp;lt;&amp;lt;39 | t&amp;gt;&amp;gt;(64-39)
		a[10] = bc0 ^ (bc2 &amp;amp;^ bc1)
		a[21] = bc1 ^ (bc3 &amp;amp;^ bc2)
		a[7] = bc2 ^ (bc4 &amp;amp;^ bc3)
		a[18] = bc3 ^ (bc0 &amp;amp;^ bc4)
		a[4] = bc4 ^ (bc1 &amp;amp;^ bc0)

		// Round 4
		/* [Min]
		i = 3, N^i将 (x,y) 映射成 (x,7x+8y)
		C[0] = A[0,0]⊕A[0,3]⊕A[0,1]⊕A[0,4]⊕A[0,2]
		     = a[0] ^ a[15] ^ a[5] ^ a[20] ^ a[10]
		C[1] = A[1,2]⊕A[1,0]⊕A[1,3]⊕A[1,1]⊕A[1,4]
			 = a[11] ^ a[1] ^ a[16] ^ a[6] ^ a[21]
		...
		*/
		// [Min] C[x] = A[N^i(x,0)T]⊕A[N^i(x,1)T]⊕A[N^i(x,2)T]⊕A[N^i(x,3)T]⊕A[N^i(x,4)T]
		bc0 = a[0] ^ a[5] ^ a[10] ^ a[15] ^ a[20]
		bc1 = a[1] ^ a[6] ^ a[11] ^ a[16] ^ a[21]
		bc2 = a[2] ^ a[7] ^ a[12] ^ a[17] ^ a[22]
		bc3 = a[3] ^ a[8] ^ a[13] ^ a[18] ^ a[23]
		bc4 = a[4] ^ a[9] ^ a[14] ^ a[19] ^ a[24]
		// [Min] D[x] = C[x−1]⊕ROT(C[x+1],1), x = 0...4
		d0 = bc4 ^ (bc1&amp;lt;&amp;lt;1 | bc1&amp;gt;&amp;gt;63)
		d1 = bc0 ^ (bc2&amp;lt;&amp;lt;1 | bc2&amp;gt;&amp;gt;63)
		d2 = bc1 ^ (bc3&amp;lt;&amp;lt;1 | bc3&amp;gt;&amp;gt;63)
		d3 = bc2 ^ (bc4&amp;lt;&amp;lt;1 | bc4&amp;gt;&amp;gt;63)
		d4 = bc3 ^ (bc0&amp;lt;&amp;lt;1 | bc0&amp;gt;&amp;gt;63)

		// [Min] y = 0
		// [Min]    B[x+2y] = ROT((A[N^(i+1)(x,y)T]⊕D[x]),r[N(x,y)T]), x=0...4
		// [Min]    A[N^(i+1)(x,y)T]=B[x]⊕((NOT B[x+1]) AND B[x+2]), x=0...4
		// [Min] A[0,0] = A[0,0] ⊕ RC[i]
		bc0 = a[0] ^ d0
		t = a[1] ^ d1
		bc1 = t&amp;lt;&amp;lt;44 | t&amp;gt;&amp;gt;(64-44)
		t = a[2] ^ d2
		bc2 = t&amp;lt;&amp;lt;43 | t&amp;gt;&amp;gt;(64-43)
		t = a[3] ^ d3
		bc3 = t&amp;lt;&amp;lt;21 | t&amp;gt;&amp;gt;(64-21)
		t = a[4] ^ d4
		bc4 = t&amp;lt;&amp;lt;14 | t&amp;gt;&amp;gt;(64-14)
		a[0] = bc0 ^ (bc2 &amp;amp;^ bc1) ^ rc[i+3]
		a[1] = bc1 ^ (bc3 &amp;amp;^ bc2)
		a[2] = bc2 ^ (bc4 &amp;amp;^ bc3)
		a[3] = bc3 ^ (bc0 &amp;amp;^ bc4)
		a[4] = bc4 ^ (bc1 &amp;amp;^ bc0)

		// [Min] y = 1
		// [Min]    B[x+2y] = ROT((A[N^(i+1)(x,y)T]⊕D[x]),r[N(x,y)T]), x=0...4
		// [Min]    A[N^(i+1)(x,y)T]=B[x]⊕((NOT B[x+1]) AND B[x+2]), x=0...4
		t = a[5] ^ d0
		bc2 = t&amp;lt;&amp;lt;3 | t&amp;gt;&amp;gt;(64-3)
		t = a[6] ^ d1
		bc3 = t&amp;lt;&amp;lt;45 | t&amp;gt;&amp;gt;(64-45)
		t = a[7] ^ d2
		bc4 = t&amp;lt;&amp;lt;61 | t&amp;gt;&amp;gt;(64-61)
		t = a[8] ^ d3
		bc0 = t&amp;lt;&amp;lt;28 | t&amp;gt;&amp;gt;(64-28)
		t = a[9] ^ d4
		bc1 = t&amp;lt;&amp;lt;20 | t&amp;gt;&amp;gt;(64-20)
		a[5] = bc0 ^ (bc2 &amp;amp;^ bc1)
		a[6] = bc1 ^ (bc3 &amp;amp;^ bc2)
		a[7] = bc2 ^ (bc4 &amp;amp;^ bc3)
		a[8] = bc3 ^ (bc0 &amp;amp;^ bc4)
		a[9] = bc4 ^ (bc1 &amp;amp;^ bc0)

		// [Min] y = 2
		// [Min]    B[x+2y] = ROT((A[N^(i+1)(x,y)T]⊕D[x]),r[N(x,y)T]), x=0...4
		// [Min]    A[N^(i+1)(x,y)T]=B[x]⊕((NOT B[x+1]) AND B[x+2]), x=0...4
		t = a[10] ^ d0
		bc4 = t&amp;lt;&amp;lt;18 | t&amp;gt;&amp;gt;(64-18)
		t = a[11] ^ d1
		bc0 = t&amp;lt;&amp;lt;1 | t&amp;gt;&amp;gt;(64-1)
		t = a[12] ^ d2
		bc1 = t&amp;lt;&amp;lt;6 | t&amp;gt;&amp;gt;(64-6)
		t = a[13] ^ d3
		bc2 = t&amp;lt;&amp;lt;25 | t&amp;gt;&amp;gt;(64-25)
		t = a[14] ^ d4
		bc3 = t&amp;lt;&amp;lt;8 | t&amp;gt;&amp;gt;(64-8)
		a[10] = bc0 ^ (bc2 &amp;amp;^ bc1)
		a[11] = bc1 ^ (bc3 &amp;amp;^ bc2)
		a[12] = bc2 ^ (bc4 &amp;amp;^ bc3)
		a[13] = bc3 ^ (bc0 &amp;amp;^ bc4)
		a[14] = bc4 ^ (bc1 &amp;amp;^ bc0)

		// [Min] y = 3
		// [Min]    B[x+2y] = ROT((A[N^(i+1)(x,y)T]⊕D[x]),r[N(x,y)T]), x=0...4
		// [Min]    A[N^(i+1)(x,y)T]=B[x]⊕((NOT B[x+1]) AND B[x+2]), x=0...4
		t = a[15] ^ d0
		bc1 = t&amp;lt;&amp;lt;36 | t&amp;gt;&amp;gt;(64-36)
		t = a[16] ^ d1
		bc2 = t&amp;lt;&amp;lt;10 | t&amp;gt;&amp;gt;(64-10)
		t = a[17] ^ d2
		bc3 = t&amp;lt;&amp;lt;15 | t&amp;gt;&amp;gt;(64-15)
		t = a[18] ^ d3
		bc4 = t&amp;lt;&amp;lt;56 | t&amp;gt;&amp;gt;(64-56)
		t = a[19] ^ d4
		bc0 = t&amp;lt;&amp;lt;27 | t&amp;gt;&amp;gt;(64-27)
		a[15] = bc0 ^ (bc2 &amp;amp;^ bc1)
		a[16] = bc1 ^ (bc3 &amp;amp;^ bc2)
		a[17] = bc2 ^ (bc4 &amp;amp;^ bc3)
		a[18] = bc3 ^ (bc0 &amp;amp;^ bc4)
		a[19] = bc4 ^ (bc1 &amp;amp;^ bc0)

		// [Min] y = 4
		// [Min]    B[x+2y] = ROT((A[N^(i+1)(x,y)T]⊕D[x]),r[N(x,y)T]), x=0...4
		// [Min]    A[N^(i+1)(x,y)T]=B[x]⊕((NOT B[x+1]) AND B[x+2]), x=0...4
		t = a[20] ^ d0
		bc3 = t&amp;lt;&amp;lt;41 | t&amp;gt;&amp;gt;(64-41)
		t = a[21] ^ d1
		bc4 = t&amp;lt;&amp;lt;2 | t&amp;gt;&amp;gt;(64-2)
		t = a[22] ^ d2
		bc0 = t&amp;lt;&amp;lt;62 | t&amp;gt;&amp;gt;(64-62)
		t = a[23] ^ d3
		bc1 = t&amp;lt;&amp;lt;55 | t&amp;gt;&amp;gt;(64-55)
		t = a[24] ^ d4
		bc2 = t&amp;lt;&amp;lt;39 | t&amp;gt;&amp;gt;(64-39)
		a[20] = bc0 ^ (bc2 &amp;amp;^ bc1)
		a[21] = bc1 ^ (bc3 &amp;amp;^ bc2)
		a[22] = bc2 ^ (bc4 &amp;amp;^ bc3)
		a[23] = bc3 ^ (bc0 &amp;amp;^ bc4)
		a[24] = bc4 ^ (bc1 &amp;amp;^ bc0)
	}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;3-go-具体运用&#34;&gt;3 Go 具体运用&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;

	&amp;quot;golang.org/x/crypto/sha3&amp;quot;
)

func main() {
	h := sha3.New512()
	// [Min] 连续写入并即时计算当前SHA3
	h.Write([]byte{&#39;a&#39;})
	ha := h.Sum(nil)
	h.Write([]byte{&#39;b&#39;})
	hab := h.Sum(nil)
	h.Write([]byte{&#39;c&#39;})
	habc := h.Sum(nil)
	// [Min] 阶段性SHA3和直接计算对应数据的SHA3完全相同
	fmt.Printf(&amp;quot;%x\n&amp;quot;, ha)
	fmt.Printf(&amp;quot;%x\n&amp;quot;, sha3.Sum512([]byte{&#39;a&#39;}))
	fmt.Printf(&amp;quot;%x\n&amp;quot;, hab)
	fmt.Printf(&amp;quot;%x\n&amp;quot;, sha3.Sum512([]byte{&#39;a&#39;, &#39;b&#39;}))
	fmt.Printf(&amp;quot;%x\n&amp;quot;, habc)
	fmt.Printf(&amp;quot;%x\n&amp;quot;, sha3.Sum512([]byte{&#39;a&#39;, &#39;b&#39;, &#39;c&#39;}))

	// [Min] Sum256和ShakeSum256在相同输出长度情况下，摘要是不同的，因为他们的填充首字节不同
	s256 := sha3.Sum256([]byte{&#39;a&#39;})
	shake256 := make([]byte, 32)
	sha3.ShakeSum256(shake256, []byte{&#39;a&#39;})
	fmt.Printf(&amp;quot;%x\n&amp;quot;, s256)
	fmt.Printf(&amp;quot;%x\n&amp;quot;, shake256)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ go run main.go
697f2d856172cb8309d6b8b97dac4de344b549d4dee61edfb4962d8698b7fa803f4f93ff24393586e28b5b957ac3d1d369420ce53332712f997bd336d09ab02a
697f2d856172cb8309d6b8b97dac4de344b549d4dee61edfb4962d8698b7fa803f4f93ff24393586e28b5b957ac3d1d369420ce53332712f997bd336d09ab02a
01c87b5e8f094d8725ed47be35430de40f6ab6bd7c6641a4ecf0d046c55cb468453796bb61724306a5fb3d90fbe3726a970e5630ae6a9cf9f30d2aa062a0175e
01c87b5e8f094d8725ed47be35430de40f6ab6bd7c6641a4ecf0d046c55cb468453796bb61724306a5fb3d90fbe3726a970e5630ae6a9cf9f30d2aa062a0175e
b751850b1a57168a5693cd924b6b096e08f621827444f70d884f5d0240d2712e10e116e9192af3c91a7ec57647e3934057340b4cf408d5a56592f8274eec53f0
b751850b1a57168a5693cd924b6b096e08f621827444f70d884f5d0240d2712e10e116e9192af3c91a7ec57647e3934057340b4cf408d5a56592f8274eec53f0
80084bf2fba02475726feb2cab2d8215eab14bc6bdd8bfb2c8151257032ecd8b
867e2cb04f5a04dcbd592501a5e8fe9ceaafca50255626ca736c138042530ba4
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>单向散列函数</title>
      <link>https://mooncaker816.github.io/2018/07/19/%E5%8D%95%E5%90%91%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0/</link>
      <pubDate>Thu, 19 Jul 2018 19:29:32 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/07/19/%E5%8D%95%E5%90%91%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0/</guid>
      <description>&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;1-概念&#34;&gt;1 概念&lt;/h1&gt;

&lt;p&gt;　　单向散列函数，又称单向Hash函数、杂凑函数，就是把任意长的输入消息串变化成固定长的输出串且由输出串难以得到输入串的一种函数。这个输出串称为该消息的散列值。一般用于产生消息摘要，密钥加密，常见的如 MD5，SHAx，HMAC 等。&lt;br /&gt;
　　具体来说，单向散列函数有一个输入，一个输出，其中输入称为消息，输出称为散列值。这里的消息可以是任何类型的数据，对于散列函数来说，它们只不过是一大串比特流。&lt;br /&gt;
　　散列值的长度与消息的长度无关，其值由选择的散列函数决定。下表是常见散列函数对应的散列值长度。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;散列类型&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;最大消息长度&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;散列值长度&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;分块大小&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;块内分组&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;单值字节序&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;MD5&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;无限制&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;16 bytes(128 bits)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;64 bytes(512 bits)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;16 * uint32&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;littleEndian&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;SHA1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;2^64-1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;20 bytes(160 bits)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;64 bytes(512 bits)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;16 * uint32&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;bigEndian&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;SHA-224&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;2^64-1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;28 bytes(224 bits)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;64 bytes(512 bits)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;(16 + 48) * uint32&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;bigEndian&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;SHA-256&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;2^64-1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32 bytes(256 bits)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;64 bytes(512 bits)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;(16 + 48) * uint32&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;bigEndian&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;SHA-384&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;2^128-1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;48 bytes(384 bits)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;128 bytes(1024 bits)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;(16 + 64) * uint64&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;bigEndian&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;SHA-512&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;2^128-1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;64 bytes(512 bits)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;128 bytes(1024 bits)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;(16 + 64) * uint64&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;bigEndian&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;SHA-&lt;sup&gt;512&lt;/sup&gt;&amp;frasl;&lt;sub&gt;224&lt;/sub&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;2^128-1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;28 bytes(224 bits)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;128 bytes(1024 bits)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;(16 + 64) * uint64&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;bigEndian&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;SHA-&lt;sup&gt;512&lt;/sup&gt;&amp;frasl;&lt;sub&gt;256&lt;/sub&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;2^128-1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32 bytes(256 bits)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;128 bytes(1024 bits)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;(16 + 64) * uint64&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;bigEndian&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;SHA3-224&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;无限制&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;28 bytes(224 bits)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;144 bytes(1152 bits)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;SHA3-256&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;无限制&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32 bytes(256 bits)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;136 bytes(1088 bits)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;SHA3-384&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;无限制&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;48 bytes(384 bits)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;104 bytes(832 bits)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;SHA3-512&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;无限制&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;64 bytes(512 bits)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;72 bytes(576 bits)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;SHAKE128&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;无限制&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;变长&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;168 bytes(1344 bits)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;SHAKE256&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;无限制&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;变长&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;136 bytes(1088 bits)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;注：对于 MD5 来说，如果根据最后一个分块末尾用来记录源数据字节长度的空间大小（8个字节）来看，其最大输入长度应该为2^64 - 1，但是在 MD5 的算法中，指明了此处的值是对 2^64 取余,所以 MD5 的输入没有限制。（但是 Go 中并没有取余）&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The remaining bits are filled up with 64 bits representing the length of the original message, modulo 264.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;2-md5&#34;&gt;2 MD5&lt;/h1&gt;

&lt;h2 id=&#34;2-1-预备函数&#34;&gt;2.1 预备函数&lt;/h2&gt;

&lt;p&gt;\begin{align}
F(B,C,D) &amp;amp;= (B \land C) | (\lnot B \land D) \\[2ex]
G(B,C,D) &amp;amp;= (B \land D) | (C \land \lnot D) \\[2ex]
H(B,C,D) &amp;amp;= B \oplus C \oplus D \\[2ex]
I(B,C,D) &amp;amp;= C \oplus (B \lor \lnot D)
\end{align}&lt;/p&gt;

&lt;p&gt;F,G 更高效的表达：
\begin{align}
F(B,C,D) &amp;amp;= D \oplus (B \land (C \oplus D)) \\[2ex]
G(B,C,D) &amp;amp;= C \oplus (D \land (B \oplus C))
\end{align}&lt;/p&gt;

&lt;p&gt;\begin{align}
FF(a,b,c,d,Mj,s,ti) 表示&amp;amp;a=b+((a+F(b,c,d)+Mj+ti)\lll s) \\[2ex]
GG(a,b,c,d,Mj,s,ti) 表示&amp;amp;a=b+((a+G(b,c,d)+Mj+ti)\lll s) \\[2ex]
HH(a,b,c,d,Mj,s,ti) 表示&amp;amp;a=b+((a+H(b,c,d)+Mj+ti)\lll s) \\[2ex]
II(a,b,c,d,Mj,s,ti) 表示&amp;amp;a=b+((a+I(b,c,d)+Mj+ti)\lll s)
\end{align}&lt;/p&gt;

&lt;h2 id=&#34;2-2-具体实现&#34;&gt;2.2 具体实现&lt;/h2&gt;

&lt;p&gt;　　假设我们有一串消息 data，长度位 n 个字节，以下是获取其 MD5 信息摘要的步骤：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;以64字节为单位，对 n 个字节进行分块，$$n = k*64 + r, k = 0,1,2&amp;hellip;,r \in [0,64) $$&lt;/li&gt;
&lt;li&gt;对这 k 个分块中的数据依次调用 MD5 HASH 函数，计算出这 k 个分块对应的散列值&lt;/li&gt;
&lt;li&gt;对剩下的 r 个字节进行填充，&lt;br /&gt;
如果 r &amp;gt;= 56，先填充至64个字节，第一位填充1，后续填充0，即填满一个分块&lt;br /&gt;
如果 r &amp;lt; 56，先填充至56个字节，第一位填充1，后续填充0，再将原始数据对应的字节长度信息以 uint64 为类型，按小字节序填入该分块的最末尾8个字节&lt;/li&gt;
&lt;li&gt;处理填充分块，可能只有一个填充分块，也可能有两个&lt;/li&gt;
&lt;li&gt;块内按小字节序将64字节数据分为16组uint32，对这16组数据进行共计4轮64次循环计算&lt;/li&gt;
&lt;li&gt;整合最终散列值&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2-3-go-源码分析&#34;&gt;2.3 Go 源码分析&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//go:generate go run gen.go -full -output md5block.go

// Package md5 implements the MD5 hash algorithm as defined in RFC 1321.
//
// MD5 is cryptographically broken and should not be used for secure
// applications.
package md5

import (
	&amp;quot;crypto&amp;quot;
	&amp;quot;errors&amp;quot;
	&amp;quot;hash&amp;quot;
)

func init() {
	crypto.RegisterHash(crypto.MD5, New)
}

// The size of an MD5 checksum in bytes.
// [Min] MD5 消息摘要的字节数，16 字节，128 bits
const Size = 16

// The blocksize of MD5 in bytes.
// [Min] 分块的大小 64 字节
const BlockSize = 64

const (
	chunk = 64         // [Min] 一个分块的字节长度，64 字节，512 位
	init0 = 0x67452301 // [Min] 初始摘要中0-3字节的值
	init1 = 0xEFCDAB89 // [Min] 初始摘要中4-7字节的值
	init2 = 0x98BADCFE // [Min] 初始摘要中8-11字节的值
	init3 = 0x10325476 // [Min] 初始摘要中12-15字节的值
)

/* [Min]
1. 先将源数据以64字节为单位分块，留出不够一个分块的部分 B ，其余部分 A 为64字节的整数倍
2. 将 A 中的数据依次按分块处理
3. 对 B 进行以下填充，使得 B % 64 = 56， 单位为字节
如果 B 不满 56 字节（448位），第一位填充1，后续填充 0 至448位即可，等待最终长度的填充
如果 B &amp;gt;= 56 字节，则需填充 (64 - B)*8 + 448 位，第一位为1，后续为0，
并且此时会形成一个满的分块，对此分块处理，剩余 448 位等待最终长度填充后达到512位后一起处理
4. 最后将源数据和所有填充数据的长度以 uint64 的类型填充到上述 448 位后，形成最后一个分块
对此分块进行处理
*/
// digest represents the partial evaluation of a checksum.
// [Min] 消息摘要
type digest struct {
	s   [4]uint32   // [Min] 存储摘要的实际载体
	x   [chunk]byte // [Min] 填充分块
	nx  int         // [Min] 当前填充分块中未处理数据的字节长度
	len uint64      // [Min] 源消息的长度
}

// [Min] 重置摘要，将载体中的值按初始值初始化
func (d *digest) Reset() {
	d.s[0] = init0
	d.s[1] = init1
	d.s[2] = init2
	d.s[3] = init3
	d.nx = 0
	d.len = 0
}

const (
	magic = &amp;quot;md5\x01&amp;quot;
	// [Min] MarshalBinary 返回的字节长度 ：
	// [Min] magic 头长度 + 16 字节消息摘要长度 + 64 字节最后一个分块长度 + 8 字节源消息大小的长度
	marshaledSize = len(magic) + 4*4 + chunk + 8
)

// [Min] 调用 Write 方法后，将当前 d 中数据格式化，用于反应 hash 过程中的状态
func (d *digest) MarshalBinary() ([]byte, error) {
	b := make([]byte, 0, marshaledSize)
	// [Min] 头
	b = append(b, magic...)
	// [Min] 当前已处理分块的消息摘要
	b = appendUint32(b, d.s[0])
	b = appendUint32(b, d.s[1])
	b = appendUint32(b, d.s[2])
	b = appendUint32(b, d.s[3])
	// [Min] 将填充分块中的还在等待填充的数据写入 b
	b = append(b, d.x[:d.nx]...)
	// [Min] 撑满一个分块的大小
	b = b[:len(b)+len(d.x)-int(d.nx)] // already zero
	// [Min] 当前已处理的数据的长度（可能包括填充数据）写入 b
	b = appendUint64(b, d.len)
	return b, nil
}

// [Min] 根据 digest 的状态（marshal 后的字节流），还原 digest
func (d *digest) UnmarshalBinary(b []byte) error {
	// [Min] 必须有 magic 头
	if len(b) &amp;lt; len(magic) || string(b[:len(magic)]) != magic {
		return errors.New(&amp;quot;crypto/md5: invalid hash state identifier&amp;quot;)
	}
	// [Min] b 的长度是固定的 marshaledSize
	if len(b) != marshaledSize {
		return errors.New(&amp;quot;crypto/md5: invalid hash state size&amp;quot;)
	}
	b = b[len(magic):]
	// [Min] 还原当前的消息摘要
	b, d.s[0] = consumeUint32(b)
	b, d.s[1] = consumeUint32(b)
	b, d.s[2] = consumeUint32(b)
	b, d.s[3] = consumeUint32(b)
	// [Min] 还原填充分块数据
	b = b[copy(d.x[:], b):]
	// [Min] 还原已处理数据（可能包括填充数据）长度
	b, d.len = consumeUint64(b)
	// [Min] 还原填充分块中待填充的数据的长度
	d.nx = int(d.len) % chunk
	return nil
}

// [Min] 将 x 对应的8个字节由高到低依次存入 b 中
func appendUint64(b []byte, x uint64) []byte {
	a := [8]byte{
		byte(x &amp;gt;&amp;gt; 56),
		byte(x &amp;gt;&amp;gt; 48),
		byte(x &amp;gt;&amp;gt; 40),
		byte(x &amp;gt;&amp;gt; 32),
		byte(x &amp;gt;&amp;gt; 24),
		byte(x &amp;gt;&amp;gt; 16),
		byte(x &amp;gt;&amp;gt; 8),
		byte(x),
	}
	return append(b, a[:]...)
}

// [Min] 将 x 对应的4个字节由高到低依次存入 b 中
func appendUint32(b []byte, x uint32) []byte {
	a := [4]byte{
		byte(x &amp;gt;&amp;gt; 24),
		byte(x &amp;gt;&amp;gt; 16),
		byte(x &amp;gt;&amp;gt; 8),
		byte(x),
	}
	return append(b, a[:]...)
}

// [Min] 将 b 中前8个字节当成一个 uint64 数值，返回剩余部分和该数值
func consumeUint64(b []byte) ([]byte, uint64) {
	_ = b[7]
	x := uint64(b[7]) | uint64(b[6])&amp;lt;&amp;lt;8 | uint64(b[5])&amp;lt;&amp;lt;16 | uint64(b[4])&amp;lt;&amp;lt;24 |
		uint64(b[3])&amp;lt;&amp;lt;32 | uint64(b[2])&amp;lt;&amp;lt;40 | uint64(b[1])&amp;lt;&amp;lt;48 | uint64(b[0])&amp;lt;&amp;lt;56
	return b[8:], x
}

// [Min] 将 b 中前4个字节当成一个 uint32 数值，返回剩余部分和该数值
func consumeUint32(b []byte) ([]byte, uint32) {
	_ = b[3]
	x := uint32(b[3]) | uint32(b[2])&amp;lt;&amp;lt;8 | uint32(b[1])&amp;lt;&amp;lt;16 | uint32(b[0])&amp;lt;&amp;lt;24
	return b[4:], x
}

// New returns a new hash.Hash computing the MD5 checksum. The Hash also
// implements encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to
// marshal and unmarshal the internal state of the hash.
// [Min] 构造一个 MD5 类型的 hash 载体
func New() hash.Hash {
	d := new(digest)
	d.Reset()
	return d
}

// [Min] 返回 MD5 摘要的字节长度16
func (d *digest) Size() int { return Size }

// [Min] 返回 MD5 的 BlockSize 64
func (d *digest) BlockSize() int { return BlockSize }

func (d *digest) Write(p []byte) (nn int, err error) {
	nn = len(p)
	d.len += uint64(nn)
	// [Min] 如果 d.nx &amp;gt;0, 说明 d.x 中含有遗留的未处理的尾部源数据（不够一个分块的部分）
	// [Min] 此时 p 中的数据为填充数据，
	// [Min] 如果填满了一个分块，就进行处理
	// [Min] 如果没满，说明还在等待最后的长度填充（届时一定能恰好填满一个分块）
	if d.nx &amp;gt; 0 {
		n := copy(d.x[d.nx:], p)
		d.nx += n
		if d.nx == chunk {
			block(d, d.x[:])
			d.nx = 0
		}
		p = p[n:]
	}
	// [Min] 源数据超过一个分块的大小，此处的 p 为源数据
	if len(p) &amp;gt;= chunk {
		// [Min] 计算出 p 中最大整数倍分块大小的字节长度 n，
		// [Min] 对这 n 个字节先处理，剩余部分比分块大小小，存入 p 中
		n := len(p) &amp;amp;^ (chunk - 1)
		block(d, p[:n])
		p = p[n:]
	}
	// [Min] p 中数据不够一个分块，存入 d.x 中，待后续调用 Write 时再处理
	if len(p) &amp;gt; 0 {
		d.nx = copy(d.x[:], p)
	}
	return
}

func (d0 *digest) Sum(in []byte) []byte {
	// Make a copy of d0 so that caller can keep writing and summing.
	d := *d0
	hash := d.checkSum()
	return append(in, hash[:]...)
}

func (d *digest) checkSum() [Size]byte {
	// Padding. Add a 1 bit and 0 bits until 56 bytes mod 64.
	// [Min] 获得填充前的源消息字节长度
	len := d.len
	var tmp [64]byte
	// [Min] 填充信息，最高位为1，后续全为0
	tmp[0] = 0x80
	// [Min] 如果不满56字节（448位），填充至56字节即可
	// [Min] 如果超过或等于56字节，需填满一个分块64字节，再填56字节
	if len%64 &amp;lt; 56 {
		d.Write(tmp[0 : 56-len%64])
	} else {
		d.Write(tmp[0 : 64+56-len%64])
	}

	// Length in bits.
	// [Min] 将字节长度转为 bit 位长，再将其存入8个字节中，代表一个 uint64 值
	// [Min] 再将这8个字节填入剩余部分，构成最后一个分块（小字节序）
	len &amp;lt;&amp;lt;= 3
	for i := uint(0); i &amp;lt; 8; i++ {
		tmp[i] = byte(len &amp;gt;&amp;gt; (8 * i))
	}
	d.Write(tmp[0:8])

	// [Min] 此时 d.nx 必须为0， 代表 d.x 中的分块已处理
	if d.nx != 0 {
		panic(&amp;quot;d.nx != 0&amp;quot;)
	}

	// [Min] 所有分块都处理完后，将最终128位摘要信息按小字节序写入对应的16个字节的变量返回
	var digest [Size]byte
	for i, s := range d.s {
		digest[i*4] = byte(s)
		digest[i*4+1] = byte(s &amp;gt;&amp;gt; 8)
		digest[i*4+2] = byte(s &amp;gt;&amp;gt; 16)
		digest[i*4+3] = byte(s &amp;gt;&amp;gt; 24)
	}

	return digest
}

// Sum returns the MD5 checksum of the data.
// [Min] 计算 data 的 MD5 摘要信息
func Sum(data []byte) [Size]byte {
	var d digest
	d.Reset()
	// [Min] 先把能构成分块的数据处理，留下剩余不够分块的数据待处理
	d.Write(data)
	// [Min] 填充分块，处理数据，最后返回消息摘要
	return d.checkSum()
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Copyright 2013 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// DO NOT EDIT.
// Generate with: go run gen.go -full -output md5block.go

package md5

import (
	&amp;quot;runtime&amp;quot;
	&amp;quot;unsafe&amp;quot;
)

const x86 = runtime.GOARCH == &amp;quot;amd64&amp;quot; || runtime.GOARCH == &amp;quot;386&amp;quot;

var littleEndian bool

// [Min] 判断当前系统的字节序
func init() {
	x := uint32(0x04030201)
	y := [4]byte{0x1, 0x2, 0x3, 0x4}
	littleEndian = *(*[4]byte)(unsafe.Pointer(&amp;amp;x)) == y
}

// [Min] 消息摘要处理函数
func blockGeneric(dig *digest, p []byte) {
	a := dig.s[0]
	b := dig.s[1]
	c := dig.s[2]
	d := dig.s[3]
	var X *[16]uint32
	var xbuf [16]uint32
	// [Min] 这里 p 一定是分块大小的整数倍
	for len(p) &amp;gt;= chunk {
		// [Min] 备份未处理当前分块前的值
		aa, bb, cc, dd := a, b, c, d

		// [Min] 首先根据系统，都按小字节序从 p 中获取一个分块的数据（64字节512位）存入 X
		// [Min] 分成16个小组，每个小组32位
		// This is a constant condition - it is not evaluated on each iteration.
		if x86 {
			// MD5 was designed so that x86 processors can just iterate
			// over the block data directly as uint32s, and we generate
			// less code and run 1.3x faster if we take advantage of that.
			// My apologies.
			X = (*[16]uint32)(unsafe.Pointer(&amp;amp;p[0]))
		} else if littleEndian &amp;amp;&amp;amp; uintptr(unsafe.Pointer(&amp;amp;p[0]))&amp;amp;(unsafe.Alignof(uint32(0))-1) == 0 {
			X = (*[16]uint32)(unsafe.Pointer(&amp;amp;p[0]))
		} else {
			X = &amp;amp;xbuf
			j := 0
			for i := 0; i &amp;lt; 16; i++ {
				X[i&amp;amp;15] = uint32(p[j]) | uint32(p[j+1])&amp;lt;&amp;lt;8 | uint32(p[j+2])&amp;lt;&amp;lt;16 | uint32(p[j+3])&amp;lt;&amp;lt;24
				j += 4
			}
        }
            
        // [Min] F(X,Y,Z)=(X&amp;amp;Y)|((~X)&amp;amp;Z) &amp;lt;=&amp;gt;  Z xor (X and (Y xor Z)) 后者更高效
        // [Min] G(X,Y,Z)=(X&amp;amp;Z)|(Y&amp;amp;(~Z)) &amp;lt;=&amp;gt;  Y xor (Z and (X xor Y)) 后者更高效
        // [Min] H(X,Y,Z)=X^Y^Z
        // [Min] I(X,Y,Z)=Y^(X|(~Z))

		// [Min] 设Mj表示消息的第j个子分组（从0到15），&amp;lt;&amp;lt;&amp;lt;s表示循环左移s位，则四种操作为：
		// [Min] FF(a,b,c,d,Mj,s,ti)表示a=b+((a+F(b,c,d)+Mj+ti)&amp;lt;&amp;lt;&amp;lt;s)
		// [Min] GG(a,b,c,d,Mj,s,ti)表示a=b+((a+G(b,c,d)+Mj+ti)&amp;lt;&amp;lt;&amp;lt;s)
		// [Min] HH(a,b,c,d,Mj,s,ti)表示a=b+((a+H(b,c,d)+Mj+ti)&amp;lt;&amp;lt;&amp;lt;s)
		// [Min] II(a,b,c,d,Mj,s,ti)表示a=b+((a+I(b,c,d)+Mj+ti)&amp;lt;&amp;lt;&amp;lt;s)
        
		// [Min] 对每一个分块进行以下4轮计算，每一轮中会对每一小组进行处理
		// Round 1.

		// [Min] FF(a ,b ,c ,d,M0 ,7 ,0xd76aa478 )
		a += (((c ^ d) &amp;amp; b) ^ d) + X[0] + 3614090360
		a = a&amp;lt;&amp;lt;7 | a&amp;gt;&amp;gt;(32-7) + b

		// [Min] FF(d ,a ,b ,c,M1 ,12 ,0xe8c7b756 )
		d += (((b ^ c) &amp;amp; a) ^ c) + X[1] + 3905402710
		d = d&amp;lt;&amp;lt;12 | d&amp;gt;&amp;gt;(32-12) + a

		// [Min] FF(c ,d ,a ,b,M2 ,17 ,0x242070db )
		c += (((a ^ b) &amp;amp; d) ^ b) + X[2] + 606105819
		c = c&amp;lt;&amp;lt;17 | c&amp;gt;&amp;gt;(32-17) + d

		// [Min] FF(b ,c ,d ,a,M3 ,22 ,0xc1bdceee )
		b += (((d ^ a) &amp;amp; c) ^ a) + X[3] + 3250441966
		b = b&amp;lt;&amp;lt;22 | b&amp;gt;&amp;gt;(32-22) + c

		// [Min] FF(a ,b ,c ,d,M4 ,7 ,0xf57c0faf )
		a += (((c ^ d) &amp;amp; b) ^ d) + X[4] + 4118548399
		a = a&amp;lt;&amp;lt;7 | a&amp;gt;&amp;gt;(32-7) + b

		// [Min] b=FF(d,a,b,c,M5,12,0x4787c62a)
		d += (((b ^ c) &amp;amp; a) ^ c) + X[5] + 1200080426
		d = d&amp;lt;&amp;lt;12 | d&amp;gt;&amp;gt;(32-12) + a

		// [Min] c=FF(c,d,a,b,M6,17,0xa8304613)
		c += (((a ^ b) &amp;amp; d) ^ b) + X[6] + 2821735955
		c = c&amp;lt;&amp;lt;17 | c&amp;gt;&amp;gt;(32-17) + d

		// [Min] d=FF(b,c,d,a,M7,22,0xfd469501)
		b += (((d ^ a) &amp;amp; c) ^ a) + X[7] + 4249261313
		b = b&amp;lt;&amp;lt;22 | b&amp;gt;&amp;gt;(32-22) + c

		// [Min] a=FF(a,b,c,d,M8,7,0x698098d8)
		a += (((c ^ d) &amp;amp; b) ^ d) + X[8] + 1770035416
		a = a&amp;lt;&amp;lt;7 | a&amp;gt;&amp;gt;(32-7) + b

		// [Min] b=FF(d,a,b,c,M9,12,0x8b44f7af)
		d += (((b ^ c) &amp;amp; a) ^ c) + X[9] + 2336552879
		d = d&amp;lt;&amp;lt;12 | d&amp;gt;&amp;gt;(32-12) + a

		// [Min] c=FF(c,d,a,b,M10,17,0xffff5bb1)
		c += (((a ^ b) &amp;amp; d) ^ b) + X[10] + 4294925233
		c = c&amp;lt;&amp;lt;17 | c&amp;gt;&amp;gt;(32-17) + d

		// [Min] d=FF(b,c,d,a,M11,22,0x895cd7be)
		b += (((d ^ a) &amp;amp; c) ^ a) + X[11] + 2304563134
		b = b&amp;lt;&amp;lt;22 | b&amp;gt;&amp;gt;(32-22) + c

		// [Min] a=FF(a,b,c,d,M12,7,0x6b901122)
		a += (((c ^ d) &amp;amp; b) ^ d) + X[12] + 1804603682
		a = a&amp;lt;&amp;lt;7 | a&amp;gt;&amp;gt;(32-7) + b

		// [Min] b=FF(d,a,b,c,M13,12,0xfd987193)
		d += (((b ^ c) &amp;amp; a) ^ c) + X[13] + 4254626195
		d = d&amp;lt;&amp;lt;12 | d&amp;gt;&amp;gt;(32-12) + a

		// [Min] c=FF(c,d,a,b,M14,17,0xa679438e)
		c += (((a ^ b) &amp;amp; d) ^ b) + X[14] + 2792965006
		c = c&amp;lt;&amp;lt;17 | c&amp;gt;&amp;gt;(32-17) + d

		// [Min] d=FF(b,c,d,a,M15,22,0x49b40821)
		b += (((d ^ a) &amp;amp; c) ^ a) + X[15] + 1236535329
		b = b&amp;lt;&amp;lt;22 | b&amp;gt;&amp;gt;(32-22) + c

		// Round 2.
		// [Min] a=GG(a,b,c,d,M1,5,0xf61e2562)
		a += (((b ^ c) &amp;amp; d) ^ c) + X[(1+5*0)&amp;amp;15] + 4129170786
		a = a&amp;lt;&amp;lt;5 | a&amp;gt;&amp;gt;(32-5) + b

		// [Min] b=GG(d,a,b,c,M6,9,0xc040b340)
		d += (((a ^ b) &amp;amp; c) ^ b) + X[(1+5*1)&amp;amp;15] + 3225465664
		d = d&amp;lt;&amp;lt;9 | d&amp;gt;&amp;gt;(32-9) + a

		// [Min] c=GG(c,d,a,b,M11,14,0x265e5a51)
		c += (((d ^ a) &amp;amp; b) ^ a) + X[(1+5*2)&amp;amp;15] + 643717713
		c = c&amp;lt;&amp;lt;14 | c&amp;gt;&amp;gt;(32-14) + d

		// [Min] d=GG(b,c,d,a,M0,20,0xe9b6c7aa)
		b += (((c ^ d) &amp;amp; a) ^ d) + X[(1+5*3)&amp;amp;15] + 3921069994
		b = b&amp;lt;&amp;lt;20 | b&amp;gt;&amp;gt;(32-20) + c

		// [Min] a=GG(a,b,c,d,M5,5,0xd62f105d)
		a += (((b ^ c) &amp;amp; d) ^ c) + X[(1+5*4)&amp;amp;15] + 3593408605
		a = a&amp;lt;&amp;lt;5 | a&amp;gt;&amp;gt;(32-5) + b

		// [Min] b=GG(d,a,b,c,M10,9,0x02441453)
		d += (((a ^ b) &amp;amp; c) ^ b) + X[(1+5*5)&amp;amp;15] + 38016083
		d = d&amp;lt;&amp;lt;9 | d&amp;gt;&amp;gt;(32-9) + a

		// [Min] c=GG(c,d,a,b,M15,14,0xd8a1e681)
		c += (((d ^ a) &amp;amp; b) ^ a) + X[(1+5*6)&amp;amp;15] + 3634488961
		c = c&amp;lt;&amp;lt;14 | c&amp;gt;&amp;gt;(32-14) + d

		// [Min] d=GG(b,c,d,a,M4,20,0xe7d3fbc8)
		b += (((c ^ d) &amp;amp; a) ^ d) + X[(1+5*7)&amp;amp;15] + 3889429448
		b = b&amp;lt;&amp;lt;20 | b&amp;gt;&amp;gt;(32-20) + c

		// [Min] a=GG(a,b,c,d,M9,5,0x21e1cde6)
		a += (((b ^ c) &amp;amp; d) ^ c) + X[(1+5*8)&amp;amp;15] + 568446438
		a = a&amp;lt;&amp;lt;5 | a&amp;gt;&amp;gt;(32-5) + b

		// [Min] b=GG(d,a,b,c,M14,9,0xc33707d6)
		d += (((a ^ b) &amp;amp; c) ^ b) + X[(1+5*9)&amp;amp;15] + 3275163606
		d = d&amp;lt;&amp;lt;9 | d&amp;gt;&amp;gt;(32-9) + a

		// [Min] c=GG(c,d,a,b,M3,14,0xf4d50d87)
		c += (((d ^ a) &amp;amp; b) ^ a) + X[(1+5*10)&amp;amp;15] + 4107603335
		c = c&amp;lt;&amp;lt;14 | c&amp;gt;&amp;gt;(32-14) + d

		// [Min] d=GG(b,c,d,a,M8,20,0x455a14ed)
		b += (((c ^ d) &amp;amp; a) ^ d) + X[(1+5*11)&amp;amp;15] + 1163531501
		b = b&amp;lt;&amp;lt;20 | b&amp;gt;&amp;gt;(32-20) + c

		// [Min] a=GG(a,b,c,d,M13,5,0xa9e3e905)
		a += (((b ^ c) &amp;amp; d) ^ c) + X[(1+5*12)&amp;amp;15] + 2850285829
		a = a&amp;lt;&amp;lt;5 | a&amp;gt;&amp;gt;(32-5) + b

		// [Min] b=GG(d,a,b,c,M2,9,0xfcefa3f8)
		d += (((a ^ b) &amp;amp; c) ^ b) + X[(1+5*13)&amp;amp;15] + 4243563512
		d = d&amp;lt;&amp;lt;9 | d&amp;gt;&amp;gt;(32-9) + a

		// [Min] c=GG(c,d,a,b,M7,14,0x676f02d9)
		c += (((d ^ a) &amp;amp; b) ^ a) + X[(1+5*14)&amp;amp;15] + 1735328473
		c = c&amp;lt;&amp;lt;14 | c&amp;gt;&amp;gt;(32-14) + d

		// [Min] d=GG(b,c,d,a,M12,20,0x8d2a4c8a)
		b += (((c ^ d) &amp;amp; a) ^ d) + X[(1+5*15)&amp;amp;15] + 2368359562
		b = b&amp;lt;&amp;lt;20 | b&amp;gt;&amp;gt;(32-20) + c

		// Round 3.
		// [Min] a=HH(a,b,c,d,M5,4,0xfffa3942)
		a += (b ^ c ^ d) + X[(5+3*0)&amp;amp;15] + 4294588738
		a = a&amp;lt;&amp;lt;4 | a&amp;gt;&amp;gt;(32-4) + b

		// [Min] b=HH(d,a,b,c,M8,11,0x8771f681)
		d += (a ^ b ^ c) + X[(5+3*1)&amp;amp;15] + 2272392833
		d = d&amp;lt;&amp;lt;11 | d&amp;gt;&amp;gt;(32-11) + a

		// [Min] c=HH(c,d,a,b,M11,16,0x6d9d6122)
		c += (d ^ a ^ b) + X[(5+3*2)&amp;amp;15] + 1839030562
		c = c&amp;lt;&amp;lt;16 | c&amp;gt;&amp;gt;(32-16) + d

		// [Min] d=HH(b,c,d,a,M14,23,0xfde5380c)
		b += (c ^ d ^ a) + X[(5+3*3)&amp;amp;15] + 4259657740
		b = b&amp;lt;&amp;lt;23 | b&amp;gt;&amp;gt;(32-23) + c

		// [Min] a=HH(a,b,c,d,M1,4,0xa4beea44)
		a += (b ^ c ^ d) + X[(5+3*4)&amp;amp;15] + 2763975236
		a = a&amp;lt;&amp;lt;4 | a&amp;gt;&amp;gt;(32-4) + b

		// [Min] b=HH(d,a,b,c,M4,11,0x4bdecfa9)
		d += (a ^ b ^ c) + X[(5+3*5)&amp;amp;15] + 1272893353
		d = d&amp;lt;&amp;lt;11 | d&amp;gt;&amp;gt;(32-11) + a

		// [Min] c=HH(c,d,a,b,M7,16,0xf6bb4b60)
		c += (d ^ a ^ b) + X[(5+3*6)&amp;amp;15] + 4139469664
		c = c&amp;lt;&amp;lt;16 | c&amp;gt;&amp;gt;(32-16) + d

		// [Min] d=HH(b,c,d,a,M10,23,0xbebfbc70)
		b += (c ^ d ^ a) + X[(5+3*7)&amp;amp;15] + 3200236656
		b = b&amp;lt;&amp;lt;23 | b&amp;gt;&amp;gt;(32-23) + c

		// [Min] a=HH(a,b,c,d,M13,4,0x289b7ec6)
		a += (b ^ c ^ d) + X[(5+3*8)&amp;amp;15] + 681279174
		a = a&amp;lt;&amp;lt;4 | a&amp;gt;&amp;gt;(32-4) + b

		// [Min] b=HH(d,a,b,c,M0,11,0xeaa127fa)
		d += (a ^ b ^ c) + X[(5+3*9)&amp;amp;15] + 3936430074
		d = d&amp;lt;&amp;lt;11 | d&amp;gt;&amp;gt;(32-11) + a

		// [Min] c=HH(c,d,a,b,M3,16,0xd4ef3085)
		c += (d ^ a ^ b) + X[(5+3*10)&amp;amp;15] + 3572445317
		c = c&amp;lt;&amp;lt;16 | c&amp;gt;&amp;gt;(32-16) + d

		// [Min] d=HH(b,c,d,a,M6,23,0x04881d05)
		b += (c ^ d ^ a) + X[(5+3*11)&amp;amp;15] + 76029189
		b = b&amp;lt;&amp;lt;23 | b&amp;gt;&amp;gt;(32-23) + c

		// [Min] a=HH(a,b,c,d,M9,4,0xd9d4d039)
		a += (b ^ c ^ d) + X[(5+3*12)&amp;amp;15] + 3654602809
		a = a&amp;lt;&amp;lt;4 | a&amp;gt;&amp;gt;(32-4) + b

		// [Min] b=HH(d,a,b,c,M12,11,0xe6db99e5)
		d += (a ^ b ^ c) + X[(5+3*13)&amp;amp;15] + 3873151461
		d = d&amp;lt;&amp;lt;11 | d&amp;gt;&amp;gt;(32-11) + a

		// [Min] c=HH(c,d,a,b,M15,16,0x1fa27cf8)
		c += (d ^ a ^ b) + X[(5+3*14)&amp;amp;15] + 530742520
		c = c&amp;lt;&amp;lt;16 | c&amp;gt;&amp;gt;(32-16) + d

		// [Min] d=HH(b,c,d,a,M2,23,0xc4ac5665)
		b += (c ^ d ^ a) + X[(5+3*15)&amp;amp;15] + 3299628645
		b = b&amp;lt;&amp;lt;23 | b&amp;gt;&amp;gt;(32-23) + c

		// Round 4.

		// [Min] a=II(a,b,c,d,M0,6,0xf4292244)

		a += (c ^ (b | ^d)) + X[(7*0)&amp;amp;15] + 4096336452
		a = a&amp;lt;&amp;lt;6 | a&amp;gt;&amp;gt;(32-6) + b

		// [Min] b=II(d,a,b,c,M7,10,0x432aff97)
		d += (b ^ (a | ^c)) + X[(7*1)&amp;amp;15] + 1126891415
		d = d&amp;lt;&amp;lt;10 | d&amp;gt;&amp;gt;(32-10) + a

		// [Min] c=II(c,d,a,b,M14,15,0xab9423a7)
		c += (a ^ (d | ^b)) + X[(7*2)&amp;amp;15] + 2878612391
		c = c&amp;lt;&amp;lt;15 | c&amp;gt;&amp;gt;(32-15) + d

		// [Min] d=II(b,c,d,a,M5,21,0xfc93a039)
		b += (d ^ (c | ^a)) + X[(7*3)&amp;amp;15] + 4237533241
		b = b&amp;lt;&amp;lt;21 | b&amp;gt;&amp;gt;(32-21) + c

		// [Min] a=II(a,b,c,d,M12,6,0x655b59c3)
		a += (c ^ (b | ^d)) + X[(7*4)&amp;amp;15] + 1700485571
		a = a&amp;lt;&amp;lt;6 | a&amp;gt;&amp;gt;(32-6) + b

		// [Min] b=II(d,a,b,c,M3,10,0x8f0ccc92)
		d += (b ^ (a | ^c)) + X[(7*5)&amp;amp;15] + 2399980690
		d = d&amp;lt;&amp;lt;10 | d&amp;gt;&amp;gt;(32-10) + a

		// [Min] c=II(c,d,a,b,M10,15,0xffeff47d)
		c += (a ^ (d | ^b)) + X[(7*6)&amp;amp;15] + 4293915773
		c = c&amp;lt;&amp;lt;15 | c&amp;gt;&amp;gt;(32-15) + d

		// [Min] d=II(b,c,d,a,M1,21,0x85845dd1)
		b += (d ^ (c | ^a)) + X[(7*7)&amp;amp;15] + 2240044497
		b = b&amp;lt;&amp;lt;21 | b&amp;gt;&amp;gt;(32-21) + c

		// [Min] a=II(a,b,c,d,M8,6,0x6fa87e4f)
		a += (c ^ (b | ^d)) + X[(7*8)&amp;amp;15] + 1873313359
		a = a&amp;lt;&amp;lt;6 | a&amp;gt;&amp;gt;(32-6) + b

		// [Min] b=II(d,a,b,c,M15,10,0xfe2ce6e0)
		d += (b ^ (a | ^c)) + X[(7*9)&amp;amp;15] + 4264355552
		d = d&amp;lt;&amp;lt;10 | d&amp;gt;&amp;gt;(32-10) + a

		// [Min] c=II(c,d,a,b,M6,15,0xa3014314)
		c += (a ^ (d | ^b)) + X[(7*10)&amp;amp;15] + 2734768916
		c = c&amp;lt;&amp;lt;15 | c&amp;gt;&amp;gt;(32-15) + d

		// [Min] d=II(b,c,d,a,M13,21,0x4e0811a1)
		b += (d ^ (c | ^a)) + X[(7*11)&amp;amp;15] + 1309151649
		b = b&amp;lt;&amp;lt;21 | b&amp;gt;&amp;gt;(32-21) + c

		// [Min] a=II(a,b,c,d,M4,6,0xf7537e82)
		a += (c ^ (b | ^d)) + X[(7*12)&amp;amp;15] + 4149444226
		a = a&amp;lt;&amp;lt;6 | a&amp;gt;&amp;gt;(32-6) + b

		// [Min] b=II(d,a,b,c,M11,10,0xbd3af235)
		d += (b ^ (a | ^c)) + X[(7*13)&amp;amp;15] + 3174756917
		d = d&amp;lt;&amp;lt;10 | d&amp;gt;&amp;gt;(32-10) + a

		// [Min] c=II(c,d,a,b,M2,15,0x2ad7d2bb)
		c += (a ^ (d | ^b)) + X[(7*14)&amp;amp;15] + 718787259
		c = c&amp;lt;&amp;lt;15 | c&amp;gt;&amp;gt;(32-15) + d

		// [Min] d=II(b,c,d,a,M9,21,0xeb86d391)
		b += (d ^ (c | ^a)) + X[(7*15)&amp;amp;15] + 3951481745
		b = b&amp;lt;&amp;lt;21 | b&amp;gt;&amp;gt;(32-21) + c

		// [Min] 在原来的基础上加上经过4轮计算后的值
		a += aa
		b += bb
		c += cc
		d += dd

		// [Min] 处理下一分块
		p = p[chunk:]
	}

	// [Min] 设置最终摘要
	dig.s[0] = a
	dig.s[1] = b
	dig.s[2] = c
	dig.s[3] = d
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;3-sha1&#34;&gt;3. SHA1&lt;/h1&gt;

&lt;h2 id=&#34;3-1-与-md5-的比较&#34;&gt;3.1 与 MD5 的比较&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;SHA1 摘要长度为20字节160位长&lt;/li&gt;
&lt;li&gt;SHA1 与 MD5 相反，采用大字节序存储数值&lt;/li&gt;
&lt;li&gt;SHA1 采用与 MD5 完全一致的分块方式&lt;/li&gt;
&lt;li&gt;SHA1 块内按大字节序分为16组 uint32，再进行共计80次循环计算&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;3-2-sha1-分块处理算法&#34;&gt;3.2 SHA1 分块处理算法&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/SHA-1&#34; target=&#34;_blank&#34;&gt;https://en.wikipedia.org/wiki/SHA-1&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;3-3-go源码分析&#34;&gt;3.3 Go源码分析&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;a href=&#34;https://github.com/mooncaker816/LearningGoStandardLib/blob/master/crypto/sha1/sha1.go&#34; target=&#34;_blank&#34;&gt;sha1.go&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;a href=&#34;https://github.com/mooncaker816/LearningGoStandardLib/blob/master/crypto/sha1/sha1block.go&#34; target=&#34;_blank&#34;&gt;sha1block.go&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&#34;4-sha2&#34;&gt;4. SHA2&lt;/h1&gt;

&lt;p&gt;　　1. SHA2 是 SHA256，SHA224，SHA512，SHA384，SHA512-256，SHA512-224 的统称&lt;/p&gt;

&lt;p&gt;　　2. SHA224 可以看成是以不同初始摘要计算的 SHA256 的截取&lt;/p&gt;

&lt;p&gt;　　3. 同样，SHA384，SHA512-256，SHA512-224 可以看成是以不同初始摘要计算的 SHA512 的截取　&lt;/p&gt;

&lt;h2 id=&#34;4-1-sha256-sha224&#34;&gt;4.1 SHA256，SHA224&lt;/h2&gt;

&lt;h3 id=&#34;4-1-1-与-md5-的比较&#34;&gt;4.1.1 与 MD5 的比较&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;SHA256 摘要长度为32字节256位长&lt;/li&gt;
&lt;li&gt;SHA256 与 MD5 相反，采用大字节序存储数值&lt;/li&gt;
&lt;li&gt;SHA256 采用与 MD5 完全一致的分块方式&lt;/li&gt;
&lt;li&gt;SHA256 块内按大字节序分为16组 uint32，再以这16组数据为基础，按一定算法扩充至64组，最后再进行共计64次循环计算&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;4-1-2-sha256-分块处理算法&#34;&gt;4.1.2 SHA256 分块处理算法&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/SHA-2&#34; target=&#34;_blank&#34;&gt;https://en.wikipedia.org/wiki/SHA-2&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;4-1-3-go源码分析&#34;&gt;4.1.3 Go源码分析&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;a href=&#34;https://github.com/mooncaker816/LearningGoStandardLib/blob/master/crypto/sha256/sha256.go&#34; target=&#34;_blank&#34;&gt;sha256.go&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;a href=&#34;https://github.com/mooncaker816/LearningGoStandardLib/blob/master/crypto/sha256/sha256block.go&#34; target=&#34;_blank&#34;&gt;sha256block.go&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;4-2-sha512-sha384-sha512-256-sha512-224&#34;&gt;4.2 SHA512，SHA384，SHA512-256，SHA512-224&lt;/h2&gt;

&lt;h3 id=&#34;4-2-1-与-md5-的比较&#34;&gt;4.2.1 与 MD5 的比较&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;SHA512 摘要长度为64字节512位长&lt;/li&gt;
&lt;li&gt;SHA512 与 MD5 相反，采用大字节序存储数值&lt;/li&gt;
&lt;li&gt;SHA512 采用与 MD5 基本一致的分块方式，分块大小略有调整
分块大小由64字节512位变为128字节1024位，
最后一个分块末尾用来记录源数据字节长度的部分由8字节改为16字节
因为分块的长度改成了128字节，所以填充临界点位128-16=112字节&lt;/li&gt;
&lt;li&gt;SHA512 块内按大字节序分为16组 uint64，再以这16组数据为基础，按一定算法扩充至80组，最后再进行共计80次循环计算&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;4-2-2-sha512-分块处理算法&#34;&gt;4.2.2 SHA512 分块处理算法&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/SHA-2&#34; target=&#34;_blank&#34;&gt;https://en.wikipedia.org/wiki/SHA-2&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;4-2-3-go源码分析&#34;&gt;4.2.3 Go源码分析&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;a href=&#34;https://github.com/mooncaker816/LearningGoStandardLib/blob/master/crypto/sha512/sha512.go&#34; target=&#34;_blank&#34;&gt;sha512.go&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;a href=&#34;https://github.com/mooncaker816/LearningGoStandardLib/blob/master/crypto/sha512/sha512block.go&#34; target=&#34;_blank&#34;&gt;sha512block.go&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</description>
    </item>
    
    <item>
      <title>Filepath</title>
      <link>https://mooncaker816.github.io/2018/06/26/filepath/</link>
      <pubDate>Tue, 26 Jun 2018 15:39:18 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/06/26/filepath/</guid>
      <description>&lt;h1 id=&#34;1-filepath包概要&#34;&gt;1. Filepath包概要&lt;/h1&gt;

&lt;h2 id=&#34;1-1-概述&#34;&gt;1.1 概述&lt;/h2&gt;

&lt;p&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Package filepath implements utility routines for manipulating filename paths
in a way compatible with the target operating system-defined file paths.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　&lt;code&gt;filepath&lt;/code&gt;包实现了对不同操作系统的文件路径的统一操作&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The filepath package uses either forward slashes or backslashes,
depending on the operating system. To process paths such as URLs
that always use forward slashes regardless of the operating
system, see the path package.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　根据不同的操作系统，该包既可以处理以正斜杠&lt;code&gt;/&lt;/code&gt;为分隔的路径，也可以处理以反斜杠&lt;code&gt;\&lt;/code&gt;为分隔的路径。对于 URL 的处理，总是使用正斜杠&lt;code&gt;/&lt;/code&gt;，无关操作系统。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&#34;1-2-包结构&#34;&gt;1.2 包结构&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;├── example_test.go
├── example_unix_test.go
├── export_test.go
├── export_windows_test.go
├── match.go
├── match_test.go
├── path.go
├── path_plan9.go
├── path_test.go
├── path_unix.go
├── path_windows.go
├── path_windows_test.go
├── symlink.go
├── symlink_unix.go
└── symlink_windows.go
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;2-深入-filepath-包&#34;&gt;2. 深入&lt;code&gt;filepath&lt;/code&gt;包&lt;/h1&gt;

&lt;h2 id=&#34;2-1-path-go-path-test-go&#34;&gt;2.1 &lt;code&gt;path.go&lt;/code&gt; &amp;amp; &lt;code&gt;path_test.go&lt;/code&gt;&lt;/h2&gt;

&lt;h3 id=&#34;2-1-1-clean&#34;&gt;2.1.1 &lt;code&gt;Clean&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;签名：&lt;code&gt;func Clean(path string) string&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;用途：对路径进行格式化，与&lt;code&gt;path.Clean&lt;/code&gt;基本一致，windows 系统的根目录为&lt;code&gt;C:\&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;示例：&lt;a href=&#34;https://play.golang.org/p/UZqq84JBFet&#34; target=&#34;_blank&#34;&gt;https://play.golang.org/p/UZqq84JBFet&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;	// Already clean
	{&amp;quot;abc&amp;quot; =&amp;gt; &amp;quot;abc&amp;quot;},
	{&amp;quot;abc/def&amp;quot; =&amp;gt; &amp;quot;abc/def&amp;quot;},
	{&amp;quot;a/b/c&amp;quot; =&amp;gt; &amp;quot;a/b/c&amp;quot;},
	{&amp;quot;.&amp;quot; =&amp;gt; &amp;quot;.&amp;quot;},
	{&amp;quot;..&amp;quot; =&amp;gt; &amp;quot;..&amp;quot;},
	{&amp;quot;../..&amp;quot; =&amp;gt; &amp;quot;../..&amp;quot;},
	{&amp;quot;../../abc&amp;quot; =&amp;gt; &amp;quot;../../abc&amp;quot;},
	{&amp;quot;/abc&amp;quot; =&amp;gt; &amp;quot;/abc&amp;quot;},
	{&amp;quot;/&amp;quot; =&amp;gt; &amp;quot;/&amp;quot;},

	// Empty is current dir
	{&amp;quot;&amp;quot; =&amp;gt; &amp;quot;.&amp;quot;},

	// Remove trailing slash
	{&amp;quot;abc/&amp;quot; =&amp;gt; &amp;quot;abc&amp;quot;},
	{&amp;quot;abc/def/&amp;quot; =&amp;gt; &amp;quot;abc/def&amp;quot;},
	{&amp;quot;a/b/c/&amp;quot; =&amp;gt; &amp;quot;a/b/c&amp;quot;},
	{&amp;quot;./&amp;quot; =&amp;gt; &amp;quot;.&amp;quot;},
	{&amp;quot;../&amp;quot; =&amp;gt; &amp;quot;..&amp;quot;},
	{&amp;quot;../../&amp;quot; =&amp;gt; &amp;quot;../..&amp;quot;},
	{&amp;quot;/abc/&amp;quot; =&amp;gt; &amp;quot;/abc&amp;quot;},

	// Remove doubled slash
	{&amp;quot;abc//def//ghi&amp;quot; =&amp;gt; &amp;quot;abc/def/ghi&amp;quot;},
	{&amp;quot;//abc&amp;quot; =&amp;gt; &amp;quot;/abc&amp;quot;},
	{&amp;quot;///abc&amp;quot; =&amp;gt; &amp;quot;/abc&amp;quot;},
	{&amp;quot;//abc//&amp;quot; =&amp;gt; &amp;quot;/abc&amp;quot;},
	{&amp;quot;abc//&amp;quot; =&amp;gt; &amp;quot;abc&amp;quot;},

	// Remove . elements
	{&amp;quot;abc/./def&amp;quot; =&amp;gt; &amp;quot;abc/def&amp;quot;},
	{&amp;quot;/./abc/def&amp;quot; =&amp;gt; &amp;quot;/abc/def&amp;quot;},
	{&amp;quot;abc/.&amp;quot; =&amp;gt; &amp;quot;abc&amp;quot;},

	// Remove .. elements
	{&amp;quot;abc/def/ghi/../jkl&amp;quot; =&amp;gt; &amp;quot;abc/def/jkl&amp;quot;},
	{&amp;quot;abc/def/../ghi/../jkl&amp;quot; =&amp;gt; &amp;quot;abc/jkl&amp;quot;},
	{&amp;quot;abc/def/..&amp;quot; =&amp;gt; &amp;quot;abc&amp;quot;},
	{&amp;quot;abc/def/../..&amp;quot; =&amp;gt; &amp;quot;.&amp;quot;},
	{&amp;quot;/abc/def/../..&amp;quot; =&amp;gt; &amp;quot;/&amp;quot;},
	{&amp;quot;abc/def/../../..&amp;quot; =&amp;gt; &amp;quot;..&amp;quot;},
	{&amp;quot;/abc/def/../../..&amp;quot; =&amp;gt; &amp;quot;/&amp;quot;},
	{&amp;quot;abc/def/../../../ghi/jkl/../../../mno&amp;quot; =&amp;gt; &amp;quot;../../mno&amp;quot;},
	{&amp;quot;/../abc&amp;quot; =&amp;gt; &amp;quot;/abc&amp;quot;},

	// Combinations
	{&amp;quot;abc/./../def&amp;quot; =&amp;gt; &amp;quot;def&amp;quot;},
	{&amp;quot;abc//./../def&amp;quot; =&amp;gt; &amp;quot;def&amp;quot;},
	{&amp;quot;abc/../../././../def&amp;quot; =&amp;gt; &amp;quot;../../def&amp;quot;},

	{`c:` =&amp;gt; `c:.`},
	{`c:\` =&amp;gt; `c:\`},
	{`c:\abc` =&amp;gt; `c:\abc`},
	{`c:abc\..\..\.\.\..\def` =&amp;gt; `c:..\..\def`},
	{`c:\abc\def\..\..` =&amp;gt; `c:\`},
	{`c:\..\abc` =&amp;gt; `c:\abc`},
	{`c:..\abc` =&amp;gt; `c:..\abc`},
	{`\` =&amp;gt; `\`},
	{`/` =&amp;gt; `\`},
	{`\\i\..\c$` =&amp;gt; `\c$`},
	{`\\i\..\i\c$` =&amp;gt; `\i\c$`},
	{`\\i\..\I\c$` =&amp;gt; `\I\c$`},
	{`\\host\share\foo\..\bar` =&amp;gt; `\\host\share\bar`},
	{`//host/share/foo/../baz` =&amp;gt; `\\host\share\baz`},
	{`\\a\b\..\c` =&amp;gt; `\\a\b\c`},
	{`\\a\b` =&amp;gt; `\\a\b`},
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-1-2-toslash-fromslash&#34;&gt;2.1.2 &lt;code&gt;ToSlash&lt;/code&gt; &amp;amp; &lt;code&gt;FromSlash&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;签名：&lt;code&gt;func ToSlash(path string) string&lt;/code&gt; &amp;amp; &lt;code&gt;func FromSlash(path string) string&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;用途：将路径中的分隔符替换为&lt;code&gt;/&lt;/code&gt; &amp;amp; 将路径中的&lt;code&gt;/&lt;/code&gt;分隔符替换为系统对应的分隔符&lt;/p&gt;

&lt;p&gt;示例：&lt;a href=&#34;https://play.golang.org/p/FB-HZSqbuSd&#34; target=&#34;_blank&#34;&gt;https://play.golang.org/p/FB-HZSqbuSd&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;	{&amp;quot;&amp;quot;, &amp;quot;&amp;quot;},
	{&amp;quot;/&amp;quot;, string(sep)},
	{&amp;quot;/a/b&amp;quot;, string([]byte{sep, &#39;a&#39;, sep, &#39;b&#39;})},
	{&amp;quot;a//b&amp;quot;, string([]byte{&#39;a&#39;, sep, sep, &#39;b&#39;})},
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-1-3-splitlist&#34;&gt;2.1.3 &lt;code&gt;SplitList&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;签名：&lt;code&gt;func SplitList(path string) []string&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;用途：根据系统的 List分隔符（如环境变量&lt;code&gt;PATH&lt;/code&gt;中包含的多个路径之间的&lt;code&gt;:&lt;/code&gt; &lt;code&gt;;&lt;/code&gt;）,将List路径拆分成单个路径组成的 slice，若List路径为空，则返回空 slice&lt;/p&gt;

&lt;p&gt;示例：&lt;a href=&#34;https://play.golang.org/p/bQOhCR4kvFq&#34; target=&#34;_blank&#34;&gt;https://play.golang.org/p/bQOhCR4kvFq&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;	{&amp;quot;&amp;quot;, []string{}},
	{string([]byte{&#39;a&#39;, lsep, &#39;b&#39;}), []string{&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;}},
	{string([]byte{lsep, &#39;a&#39;, lsep, &#39;b&#39;}), []string{&amp;quot;&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;}},
    
	// quoted
	{`&amp;quot;a&amp;quot;`, []string{`a`}},

	// semicolon
	{`&amp;quot;;&amp;quot;`, []string{`;`}},
	{`&amp;quot;a;b&amp;quot;`, []string{`a;b`}},
	{`&amp;quot;;&amp;quot;;`, []string{`;`, ``}},
	{`;&amp;quot;;&amp;quot;`, []string{``, `;`}},

	// partially quoted
	{`a&amp;quot;;&amp;quot;b`, []string{`a;b`}},
	{`a; &amp;quot;&amp;quot;b`, []string{`a`, ` b`}},
	{`&amp;quot;a;b`, []string{`a;b`}},
	{`&amp;quot;&amp;quot;a;b`, []string{`a`, `b`}},
	{`&amp;quot;&amp;quot;&amp;quot;a;b`, []string{`a;b`}},
	{`&amp;quot;&amp;quot;&amp;quot;&amp;quot;a;b`, []string{`a`, `b`}},
	{`a&amp;quot;;b`, []string{`a;b`}},
	{`a;b&amp;quot;;c`, []string{`a`, `b;c`}},
	{`&amp;quot;a&amp;quot;;b&amp;quot;;c`, []string{`a`, `b;c`}},
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-1-4-split&#34;&gt;2.1.4 &lt;code&gt;Split&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;签名：&lt;code&gt;func Split(path string) (dir, file string)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;用途：拆分路径为目录+文件名&lt;/p&gt;

&lt;p&gt;示例：&lt;a href=&#34;https://play.golang.org/p/ABl-Ph464rW&#34; target=&#34;_blank&#34;&gt;https://play.golang.org/p/ABl-Ph464rW&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;	{&amp;quot;a/b&amp;quot;, &amp;quot;a/&amp;quot;, &amp;quot;b&amp;quot;},
	{&amp;quot;a/b/&amp;quot;, &amp;quot;a/b/&amp;quot;, &amp;quot;&amp;quot;},
	{&amp;quot;a/&amp;quot;, &amp;quot;a/&amp;quot;, &amp;quot;&amp;quot;},
	{&amp;quot;a&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;a&amp;quot;},
	{&amp;quot;/&amp;quot;, &amp;quot;/&amp;quot;, &amp;quot;&amp;quot;},

	{`c:`, `c:`, ``},
	{`c:/`, `c:/`, ``},
	{`c:/foo`, `c:/`, `foo`},
	{`c:/foo/bar`, `c:/foo/`, `bar`},
	{`//host/share`, `//host/share`, ``},
	{`//host/share/`, `//host/share/`, ``},
	{`//host/share/foo`, `//host/share/`, `foo`},
	{`\\host\share`, `\\host\share`, ``},
	{`\\host\share\`, `\\host\share\`, ``},
	{`\\host\share\foo`, `\\host\share\`, `foo`},
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-1-5-join&#34;&gt;2.1.5 &lt;code&gt;Join&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;签名：&lt;code&gt;func Join(elem ...string) string&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;用途：拼接路径&lt;/p&gt;

&lt;p&gt;示例：&lt;a href=&#34;https://play.golang.org/p/RRhT3gH_SCJ&#34; target=&#34;_blank&#34;&gt;https://play.golang.org/p/RRhT3gH_SCJ&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;	// zero parameters
	{[]string{}, &amp;quot;&amp;quot;},

	// one parameter
	{[]string{&amp;quot;&amp;quot;}, &amp;quot;&amp;quot;},
	{[]string{&amp;quot;/&amp;quot;}, &amp;quot;/&amp;quot;},
	{[]string{&amp;quot;a&amp;quot;}, &amp;quot;a&amp;quot;},

	// two parameters
	{[]string{&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;}, &amp;quot;a/b&amp;quot;},
	{[]string{&amp;quot;a&amp;quot;, &amp;quot;&amp;quot;}, &amp;quot;a&amp;quot;},
	{[]string{&amp;quot;&amp;quot;, &amp;quot;b&amp;quot;}, &amp;quot;b&amp;quot;},
	{[]string{&amp;quot;/&amp;quot;, &amp;quot;a&amp;quot;}, &amp;quot;/a&amp;quot;},
	{[]string{&amp;quot;/&amp;quot;, &amp;quot;a/b&amp;quot;}, &amp;quot;/a/b&amp;quot;},
	{[]string{&amp;quot;/&amp;quot;, &amp;quot;&amp;quot;}, &amp;quot;/&amp;quot;},
	{[]string{&amp;quot;//&amp;quot;, &amp;quot;a&amp;quot;}, &amp;quot;/a&amp;quot;},
	{[]string{&amp;quot;/a&amp;quot;, &amp;quot;b&amp;quot;}, &amp;quot;/a/b&amp;quot;},
	{[]string{&amp;quot;a/&amp;quot;, &amp;quot;b&amp;quot;}, &amp;quot;a/b&amp;quot;},
	{[]string{&amp;quot;a/&amp;quot;, &amp;quot;&amp;quot;}, &amp;quot;a&amp;quot;},
	{[]string{&amp;quot;&amp;quot;, &amp;quot;&amp;quot;}, &amp;quot;&amp;quot;},

	// three parameters
	{[]string{&amp;quot;/&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;}, &amp;quot;/a/b&amp;quot;},

	{[]string{`directory`, `file`}, `directory\file`},
	{[]string{`C:\Windows\`, `System32`}, `C:\Windows\System32`},
	{[]string{`C:\Windows\`, ``}, `C:\Windows`},
	{[]string{`C:\`, `Windows`}, `C:\Windows`},
	{[]string{`C:`, `a`}, `C:a`},
	{[]string{`C:`, `a\b`}, `C:a\b`},
	{[]string{`C:`, `a`, `b`}, `C:a\b`},
	{[]string{`C:.`, `a`}, `C:a`},
	{[]string{`C:a`, `b`}, `C:a\b`},
	{[]string{`C:a`, `b`, `d`}, `C:a\b\d`},
	{[]string{`\\host\share`, `foo`}, `\\host\share\foo`},
	{[]string{`\\host\share\foo`}, `\\host\share\foo`},
	{[]string{`//host/share`, `foo/bar`}, `\\host\share\foo\bar`},
	{[]string{`\`}, `\`},
	{[]string{`\`, ``}, `\`},
	{[]string{`\`, `a`}, `\a`},
	{[]string{`\\`, `a`}, `\a`},
	{[]string{`\`, `a`, `b`}, `\a\b`},
	{[]string{`\\`, `a`, `b`}, `\a\b`},
	{[]string{`\`, `\\a\b`, `c`}, `\a\b\c`},
	{[]string{`\\a`, `b`, `c`}, `\a\b\c`},
	{[]string{`\\a\`, `b`, `c`}, `\a\b\c`},
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-1-6-ext&#34;&gt;2.1.6 &lt;code&gt;Ext&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;签名：&lt;code&gt;func Ext(path string) string&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;用途：根据最后一个元素中的最后一个&lt;code&gt;.&lt;/code&gt;，返回路径中文件的扩展名，若没有&lt;code&gt;.&lt;/code&gt;，返回空&lt;/p&gt;

&lt;p&gt;示例：&lt;a href=&#34;https://play.golang.org/p/K5TZl6W-ByS&#34; target=&#34;_blank&#34;&gt;https://play.golang.org/p/K5TZl6W-ByS&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;	{&amp;quot;path.go&amp;quot;, &amp;quot;.go&amp;quot;},
	{&amp;quot;path.pb.go&amp;quot;, &amp;quot;.go&amp;quot;},
	{&amp;quot;a.dir/b&amp;quot;, &amp;quot;&amp;quot;},
	{&amp;quot;a.dir/b.go&amp;quot;, &amp;quot;.go&amp;quot;},
	{&amp;quot;a.dir/&amp;quot;, &amp;quot;&amp;quot;},
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-1-7-evalsymlinks&#34;&gt;2.1.7 &lt;code&gt;EvalSymlinks&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;签名：&lt;code&gt;func EvalSymlinks(path string) (string, error)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;用途：对symlink文件解引用，并对结果路径格式化&lt;/p&gt;

&lt;p&gt;示例：&lt;a href=&#34;https://play.golang.org/p/3RwUZ9tfHos&#34; target=&#34;_blank&#34;&gt;https://play.golang.org/p/3RwUZ9tfHos&lt;/a&gt; (run local)&lt;/p&gt;

&lt;h3 id=&#34;2-1-8-abs&#34;&gt;2.1.8 &lt;code&gt;Abs&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;签名：&lt;code&gt;func Abs(path string) (string, error)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;用途：返回绝对路径并格式化，如果给定的路径不是绝对路径，则会加上当前目录形成绝对路径&lt;/p&gt;

&lt;p&gt;示例：&lt;a href=&#34;https://play.golang.org/p/UMr9_z4AsWR&#34; target=&#34;_blank&#34;&gt;https://play.golang.org/p/UMr9_z4AsWR&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;2-1-9-rel&#34;&gt;2.1.9 &lt;code&gt;Rel&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;签名：&lt;code&gt;func Rel(basepath, targpath string) (string, error)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;用途：根据 basepath 将 targpath 以相对路径的方式返回，并格式化&lt;/p&gt;

&lt;p&gt;示例：&lt;a href=&#34;https://play.golang.org/p/KFoNtsbW68D&#34; target=&#34;_blank&#34;&gt;https://play.golang.org/p/KFoNtsbW68D&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;	{&amp;quot;a/b&amp;quot;, &amp;quot;a/b&amp;quot;, &amp;quot;.&amp;quot;},
	{&amp;quot;a/b/.&amp;quot;, &amp;quot;a/b&amp;quot;, &amp;quot;.&amp;quot;},
	{&amp;quot;a/b&amp;quot;, &amp;quot;a/b/.&amp;quot;, &amp;quot;.&amp;quot;},
	{&amp;quot;./a/b&amp;quot;, &amp;quot;a/b&amp;quot;, &amp;quot;.&amp;quot;},
	{&amp;quot;a/b&amp;quot;, &amp;quot;./a/b&amp;quot;, &amp;quot;.&amp;quot;},
	{&amp;quot;ab/cd&amp;quot;, &amp;quot;ab/cde&amp;quot;, &amp;quot;../cde&amp;quot;},
	{&amp;quot;ab/cd&amp;quot;, &amp;quot;ab/c&amp;quot;, &amp;quot;../c&amp;quot;},
	{&amp;quot;a/b&amp;quot;, &amp;quot;a/b/c/d&amp;quot;, &amp;quot;c/d&amp;quot;},
	{&amp;quot;a/b&amp;quot;, &amp;quot;a/b/../c&amp;quot;, &amp;quot;../c&amp;quot;},
	{&amp;quot;a/b/../c&amp;quot;, &amp;quot;a/b&amp;quot;, &amp;quot;../b&amp;quot;},
	{&amp;quot;a/b/c&amp;quot;, &amp;quot;a/c/d&amp;quot;, &amp;quot;../../c/d&amp;quot;},
	{&amp;quot;a/b&amp;quot;, &amp;quot;c/d&amp;quot;, &amp;quot;../../c/d&amp;quot;},
	{&amp;quot;a/b/c/d&amp;quot;, &amp;quot;a/b&amp;quot;, &amp;quot;../..&amp;quot;},
	{&amp;quot;a/b/c/d&amp;quot;, &amp;quot;a/b/&amp;quot;, &amp;quot;../..&amp;quot;},
	{&amp;quot;a/b/c/d/&amp;quot;, &amp;quot;a/b&amp;quot;, &amp;quot;../..&amp;quot;},
	{&amp;quot;a/b/c/d/&amp;quot;, &amp;quot;a/b/&amp;quot;, &amp;quot;../..&amp;quot;},
	{&amp;quot;../../a/b&amp;quot;, &amp;quot;../../a/b/c/d&amp;quot;, &amp;quot;c/d&amp;quot;},
	{&amp;quot;/a/b&amp;quot;, &amp;quot;/a/b&amp;quot;, &amp;quot;.&amp;quot;},
	{&amp;quot;/a/b/.&amp;quot;, &amp;quot;/a/b&amp;quot;, &amp;quot;.&amp;quot;},
	{&amp;quot;/a/b&amp;quot;, &amp;quot;/a/b/.&amp;quot;, &amp;quot;.&amp;quot;},
	{&amp;quot;/ab/cd&amp;quot;, &amp;quot;/ab/cde&amp;quot;, &amp;quot;../cde&amp;quot;},
	{&amp;quot;/ab/cd&amp;quot;, &amp;quot;/ab/c&amp;quot;, &amp;quot;../c&amp;quot;},
	{&amp;quot;/a/b&amp;quot;, &amp;quot;/a/b/c/d&amp;quot;, &amp;quot;c/d&amp;quot;},
	{&amp;quot;/a/b&amp;quot;, &amp;quot;/a/b/../c&amp;quot;, &amp;quot;../c&amp;quot;},
	{&amp;quot;/a/b/../c&amp;quot;, &amp;quot;/a/b&amp;quot;, &amp;quot;../b&amp;quot;},
	{&amp;quot;/a/b/c&amp;quot;, &amp;quot;/a/c/d&amp;quot;, &amp;quot;../../c/d&amp;quot;},
	{&amp;quot;/a/b&amp;quot;, &amp;quot;/c/d&amp;quot;, &amp;quot;../../c/d&amp;quot;},
	{&amp;quot;/a/b/c/d&amp;quot;, &amp;quot;/a/b&amp;quot;, &amp;quot;../..&amp;quot;},
	{&amp;quot;/a/b/c/d&amp;quot;, &amp;quot;/a/b/&amp;quot;, &amp;quot;../..&amp;quot;},
	{&amp;quot;/a/b/c/d/&amp;quot;, &amp;quot;/a/b&amp;quot;, &amp;quot;../..&amp;quot;},
	{&amp;quot;/a/b/c/d/&amp;quot;, &amp;quot;/a/b/&amp;quot;, &amp;quot;../..&amp;quot;},
	{&amp;quot;/../../a/b&amp;quot;, &amp;quot;/../../a/b/c/d&amp;quot;, &amp;quot;c/d&amp;quot;},
	{&amp;quot;.&amp;quot;, &amp;quot;a/b&amp;quot;, &amp;quot;a/b&amp;quot;},
	{&amp;quot;.&amp;quot;, &amp;quot;..&amp;quot;, &amp;quot;..&amp;quot;},

	// can&#39;t do purely lexically
	{&amp;quot;..&amp;quot;, &amp;quot;.&amp;quot;, &amp;quot;err&amp;quot;},
	{&amp;quot;..&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;err&amp;quot;},
	{&amp;quot;../..&amp;quot;, &amp;quot;..&amp;quot;, &amp;quot;err&amp;quot;},
	{&amp;quot;a&amp;quot;, &amp;quot;/a&amp;quot;, &amp;quot;err&amp;quot;},
	{&amp;quot;/a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;err&amp;quot;},

	{`C:a\b\c`, `C:a/b/d`, `..\d`},
	{`C:\`, `D:\`, `err`},
	{`C:`, `D:`, `err`},
	{`C:\Projects`, `c:\projects\src`, `src`},
	{`C:\Projects`, `c:\projects`, `.`},
	{`C:\Projects\a\..`, `c:\projects`, `.`},
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-1-10-walk&#34;&gt;2.1.10 &lt;code&gt;Walk&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;签名：&lt;code&gt;func Walk(root string, walkFn WalkFunc) error&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;用途：用于遍历目录树&lt;/p&gt;

&lt;p&gt;示例：&lt;a href=&#34;https://play.golang.org/p/1fYRtezNBX-&#34; target=&#34;_blank&#34;&gt;https://play.golang.org/p/1fYRtezNBX-&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;type WalkFunc func(path string, info os.FileInfo, err error) error&lt;/code&gt;
&lt;code&gt;WalkFunc&lt;/code&gt; 函数一般是一个闭包，用于处理目录树中的每个文件/目录，如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;	errors := make([]error, 0, 10)
	clear := true
	markFn := func(path string, info os.FileInfo, err error) error {
		return mark(info, err, &amp;amp;errors, clear)
	}
	// Expect no errors.
	err := filepath.Walk(tree.name, markFn)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-1-11-base&#34;&gt;2.1.11 &lt;code&gt;Base&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;签名：&lt;code&gt;func Base(path string) string&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;用途：返回最后一个元素，如果路径为空，则返回&lt;code&gt;.&lt;/code&gt;，如果路径全是分隔符，则返回单个分隔符&lt;/p&gt;

&lt;p&gt;示例：&lt;a href=&#34;https://play.golang.org/p/0F6PSQjwOTX&#34; target=&#34;_blank&#34;&gt;https://play.golang.org/p/0F6PSQjwOTX&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;	{&amp;quot;&amp;quot;, &amp;quot;.&amp;quot;},
	{&amp;quot;.&amp;quot;, &amp;quot;.&amp;quot;},
	{&amp;quot;/.&amp;quot;, &amp;quot;.&amp;quot;},
	{&amp;quot;/&amp;quot;, &amp;quot;/&amp;quot;},
	{&amp;quot;////&amp;quot;, &amp;quot;/&amp;quot;},
	{&amp;quot;x/&amp;quot;, &amp;quot;x&amp;quot;},
	{&amp;quot;abc&amp;quot;, &amp;quot;abc&amp;quot;},
	{&amp;quot;abc/def&amp;quot;, &amp;quot;def&amp;quot;},
	{&amp;quot;a/b/.x&amp;quot;, &amp;quot;.x&amp;quot;},
	{&amp;quot;a/b/c.&amp;quot;, &amp;quot;c.&amp;quot;},
	{&amp;quot;a/b/c.x&amp;quot;, &amp;quot;c.x&amp;quot;},

	{`c:\`, `\`},
	{`c:.`, `.`},
	{`c:\a\b`, `b`},
	{`c:a\b`, `b`},
	{`c:a\b\c`, `c`},
	{`\\host\share\`, `\`},
	{`\\host\share\a`, `a`},
	{`\\host\share\a\b`, `b`},
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-1-12-dir&#34;&gt;2.1.12 &lt;code&gt;Dir&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;签名：&lt;code&gt;func Dir(path string) string&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;用途：返回除去最后一个元素的路径，并格式化。如果路径为空，返回.，如果路径全是分隔符，返回单个分隔符，返回的路径不以分隔符结尾，除非该路径为根目录&lt;/p&gt;

&lt;p&gt;示例：&lt;a href=&#34;https://play.golang.org/p/-6CrUtV9_CO&#34; target=&#34;_blank&#34;&gt;https://play.golang.org/p/-6CrUtV9_CO&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;	{&amp;quot;&amp;quot;, &amp;quot;.&amp;quot;},
	{&amp;quot;.&amp;quot;, &amp;quot;.&amp;quot;},
	{&amp;quot;/.&amp;quot;, &amp;quot;/&amp;quot;},
	{&amp;quot;/&amp;quot;, &amp;quot;/&amp;quot;},
	{&amp;quot;////&amp;quot;, &amp;quot;/&amp;quot;},
	{&amp;quot;/foo&amp;quot;, &amp;quot;/&amp;quot;},
	{&amp;quot;x/&amp;quot;, &amp;quot;x&amp;quot;},
	{&amp;quot;abc&amp;quot;, &amp;quot;.&amp;quot;},
	{&amp;quot;abc/def&amp;quot;, &amp;quot;abc&amp;quot;},
	{&amp;quot;a/b/.x&amp;quot;, &amp;quot;a/b&amp;quot;},
	{&amp;quot;a/b/c.&amp;quot;, &amp;quot;a/b&amp;quot;},
	{&amp;quot;a/b/c.x&amp;quot;, &amp;quot;a/b&amp;quot;},

	{`c:\`, `c:\`},
	{`c:.`, `c:.`},
	{`c:\a\b`, `c:\a`},
	{`c:a\b`, `c:a`},
	{`c:a\b\c`, `c:a\b`},
	{`\\host\share`, `\\host\share`},
	{`\\host\share\`, `\\host\share\`},
	{`\\host\share\a`, `\\host\share\`},
	{`\\host\share\a\b`, `\\host\share\a`},
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-1-13-volumename&#34;&gt;2.1.13 &lt;code&gt;VolumeName&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;签名：&lt;code&gt;func VolumeName(path string) string&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;用途：Windows系统返回卷名，其他系统返回空&lt;/p&gt;

&lt;p&gt;示例：&lt;a href=&#34;https://play.golang.org/p/uxvpRgAy9Lg&#34; target=&#34;_blank&#34;&gt;https://play.golang.org/p/uxvpRgAy9Lg&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;    	{`c:/foo/bar`, `c:`},
    	{`c:`, `c:`},
    	{`2:`, ``},
    	{``, ``},
    	{`\\\host`, ``},
    	{`\\\host\`, ``},
    	{`\\\host\share`, ``},
    	{`\\\host\\share`, ``},
    	{`\\host`, ``},
    	{`//host`, ``},
        {`\\host\`, ``},
        {`//host/`, ``},
        {`\\host\share`, `\\host\share`},
        {`//host/share`, `//host/share`},
        {`\\host\share\`, `\\host\share`},
        {`//host/share/`, `//host/share`},
        {`\\host\share\foo`, `\\host\share`},
        {`//host/share/foo`, `//host/share`},
        {`\\host\share\\foo\\\bar\\\\baz`, `\\host\share`},
        {`//host/share//foo///bar////baz`, `//host/share`},
        {`\\host\share\foo\..\bar`, `\\host\share`},
        {`//host/share/foo/../bar`, `//host/share`},
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-1-14-isabs&#34;&gt;2.1.14 &lt;code&gt;IsAbs&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;签名：&lt;code&gt;func IsAbs(path string) bool&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;用途：判断是否为绝对路径，在 Unix 中，以&lt;code&gt;/&lt;/code&gt;开始；在 Windows 中以某个盘符开始&lt;/p&gt;

&lt;p&gt;示例：&lt;a href=&#34;https://play.golang.org/p/JV2dVvYUaYP&#34; target=&#34;_blank&#34;&gt;https://play.golang.org/p/JV2dVvYUaYP&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;	{&amp;quot;&amp;quot;, false},
	{&amp;quot;/&amp;quot;, true},
	{&amp;quot;/usr/bin/gcc&amp;quot;, true},
	{&amp;quot;..&amp;quot;, false},
	{&amp;quot;/a/../bb&amp;quot;, true},
	{&amp;quot;.&amp;quot;, false},
	{&amp;quot;./&amp;quot;, false},
	{&amp;quot;lala&amp;quot;, false},
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2-2-match-go-match-test-go&#34;&gt;2.2 &lt;code&gt;match.go&lt;/code&gt; &amp;amp; &lt;code&gt;match_test.go&lt;/code&gt;&lt;/h2&gt;

&lt;h3 id=&#34;2-2-1-match&#34;&gt;2.2.1 &lt;code&gt;Match&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;签名：&lt;code&gt;func Match(pattern, name string) (matched bool, err error)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;用途：同&lt;code&gt;path.Match&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;示例：&lt;a href=&#34;https://play.golang.org/p/N5knl-o3yWM&#34; target=&#34;_blank&#34;&gt;https://play.golang.org/p/N5knl-o3yWM&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;	{&amp;quot;abc&amp;quot;, &amp;quot;abc&amp;quot;, true, nil},
	{&amp;quot;*&amp;quot;, &amp;quot;abc&amp;quot;, true, nil},
	{&amp;quot;*c&amp;quot;, &amp;quot;abc&amp;quot;, true, nil},
	{&amp;quot;a*&amp;quot;, &amp;quot;a&amp;quot;, true, nil},
	{&amp;quot;a*&amp;quot;, &amp;quot;abc&amp;quot;, true, nil},
	{&amp;quot;a*&amp;quot;, &amp;quot;ab/c&amp;quot;, false, nil},
	{&amp;quot;a*/b&amp;quot;, &amp;quot;abc/b&amp;quot;, true, nil},
	{&amp;quot;a*/b&amp;quot;, &amp;quot;a/c/b&amp;quot;, false, nil},
	{&amp;quot;a*b*c*d*e*/f&amp;quot;, &amp;quot;axbxcxdxe/f&amp;quot;, true, nil},
	{&amp;quot;a*b*c*d*e*/f&amp;quot;, &amp;quot;axbxcxdxexxx/f&amp;quot;, true, nil},
	{&amp;quot;a*b*c*d*e*/f&amp;quot;, &amp;quot;axbxcxdxe/xxx/f&amp;quot;, false, nil},
	{&amp;quot;a*b*c*d*e*/f&amp;quot;, &amp;quot;axbxcxdxexxx/fff&amp;quot;, false, nil},
	{&amp;quot;a*b?c*x&amp;quot;, &amp;quot;abxbbxdbxebxczzx&amp;quot;, true, nil},
	{&amp;quot;a*b?c*x&amp;quot;, &amp;quot;abxbbxdbxebxczzy&amp;quot;, false, nil},
	{&amp;quot;ab[c]&amp;quot;, &amp;quot;abc&amp;quot;, true, nil},
	{&amp;quot;ab[b-d]&amp;quot;, &amp;quot;abc&amp;quot;, true, nil},
	{&amp;quot;ab[e-g]&amp;quot;, &amp;quot;abc&amp;quot;, false, nil},
	{&amp;quot;ab[^c]&amp;quot;, &amp;quot;abc&amp;quot;, false, nil},
	{&amp;quot;ab[^b-d]&amp;quot;, &amp;quot;abc&amp;quot;, false, nil},
	{&amp;quot;ab[^e-g]&amp;quot;, &amp;quot;abc&amp;quot;, true, nil},
	{&amp;quot;a\\*b&amp;quot;, &amp;quot;a*b&amp;quot;, true, nil},
	{&amp;quot;a\\*b&amp;quot;, &amp;quot;ab&amp;quot;, false, nil},
	{&amp;quot;a?b&amp;quot;, &amp;quot;a☺b&amp;quot;, true, nil},
	{&amp;quot;a[^a]b&amp;quot;, &amp;quot;a☺b&amp;quot;, true, nil},
	{&amp;quot;a???b&amp;quot;, &amp;quot;a☺b&amp;quot;, false, nil},
	{&amp;quot;a[^a][^a][^a]b&amp;quot;, &amp;quot;a☺b&amp;quot;, false, nil},
	{&amp;quot;[a-ζ]*&amp;quot;, &amp;quot;α&amp;quot;, true, nil},
	{&amp;quot;*[a-ζ]&amp;quot;, &amp;quot;A&amp;quot;, false, nil},
	{&amp;quot;a?b&amp;quot;, &amp;quot;a/b&amp;quot;, false, nil},
	{&amp;quot;a*b&amp;quot;, &amp;quot;a/b&amp;quot;, false, nil},
	{&amp;quot;[\\]a]&amp;quot;, &amp;quot;]&amp;quot;, true, nil},
	{&amp;quot;[\\-]&amp;quot;, &amp;quot;-&amp;quot;, true, nil},
	{&amp;quot;[x\\-]&amp;quot;, &amp;quot;x&amp;quot;, true, nil},
	{&amp;quot;[x\\-]&amp;quot;, &amp;quot;-&amp;quot;, true, nil},
	{&amp;quot;[x\\-]&amp;quot;, &amp;quot;z&amp;quot;, false, nil},
	{&amp;quot;[\\-x]&amp;quot;, &amp;quot;x&amp;quot;, true, nil},
	{&amp;quot;[\\-x]&amp;quot;, &amp;quot;-&amp;quot;, true, nil},
	{&amp;quot;[\\-x]&amp;quot;, &amp;quot;a&amp;quot;, false, nil},
	{&amp;quot;[]a]&amp;quot;, &amp;quot;]&amp;quot;, false, ErrBadPattern},
	{&amp;quot;[-]&amp;quot;, &amp;quot;-&amp;quot;, false, ErrBadPattern},
	{&amp;quot;[x-]&amp;quot;, &amp;quot;x&amp;quot;, false, ErrBadPattern},
	{&amp;quot;[x-]&amp;quot;, &amp;quot;-&amp;quot;, false, ErrBadPattern},
	{&amp;quot;[x-]&amp;quot;, &amp;quot;z&amp;quot;, false, ErrBadPattern},
	{&amp;quot;[-x]&amp;quot;, &amp;quot;x&amp;quot;, false, ErrBadPattern},
	{&amp;quot;[-x]&amp;quot;, &amp;quot;-&amp;quot;, false, ErrBadPattern},
	{&amp;quot;[-x]&amp;quot;, &amp;quot;a&amp;quot;, false, ErrBadPattern},
	{&amp;quot;\\&amp;quot;, &amp;quot;a&amp;quot;, false, ErrBadPattern},
	{&amp;quot;[a-b-c]&amp;quot;, &amp;quot;a&amp;quot;, false, ErrBadPattern},
	{&amp;quot;[&amp;quot;, &amp;quot;a&amp;quot;, false, ErrBadPattern},
	{&amp;quot;[^&amp;quot;, &amp;quot;a&amp;quot;, false, ErrBadPattern},
	{&amp;quot;[^bc&amp;quot;, &amp;quot;a&amp;quot;, false, ErrBadPattern},
	{&amp;quot;a[&amp;quot;, &amp;quot;a&amp;quot;, false, nil},
	{&amp;quot;a[&amp;quot;, &amp;quot;ab&amp;quot;, false, ErrBadPattern},
	{&amp;quot;*x&amp;quot;, &amp;quot;xxx&amp;quot;, true, nil},
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-2-2-glob&#34;&gt;2.2.2 &lt;code&gt;Glob&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;签名：&lt;code&gt;func Glob(pattern string) (matches []string, err error)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;用途：列出与指定的模式 pattern 完全匹配的文件或目录（匹配原则同&lt;code&gt;Match&lt;/code&gt;）&lt;/p&gt;

&lt;p&gt;示例：&lt;a href=&#34;https://play.golang.org/p/GxqJkYQp_xm&#34; target=&#34;_blank&#34;&gt;https://play.golang.org/p/GxqJkYQp_xm&lt;/a&gt; (run local)&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Path</title>
      <link>https://mooncaker816.github.io/2018/06/26/path/</link>
      <pubDate>Tue, 26 Jun 2018 12:45:39 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/06/26/path/</guid>
      <description>&lt;h1 id=&#34;1-path包概要&#34;&gt;1. Path包概要&lt;/h1&gt;

&lt;h2 id=&#34;1-1-概述&#34;&gt;1.1 概述&lt;/h2&gt;

&lt;p&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Package path implements utility routines for manipulating slash-separated paths.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　&lt;code&gt;path&lt;/code&gt; 包实现了对以&lt;code&gt;/&lt;/code&gt;为分隔的路径的操作&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The path package should only be used for paths separated by forward
slashes, such as the paths in URLs. This package does not deal with
Windows paths with drive letters or backslashes; to manipulate
operating system paths, use the path/filepath package.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　该包只能用于对以正斜杠&lt;code&gt;/&lt;/code&gt;为分隔的路径的处理，比如 URL，而不能处理带有windows中的盘符或者反斜杠&lt;code&gt;\&lt;/code&gt;的路径，对于这类路径的处理需要使用 &lt;code&gt;path/filepath&lt;/code&gt; 包&lt;/p&gt;

&lt;h2 id=&#34;1-2-包结构&#34;&gt;1.2 包结构&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;├── example_test.go
├── match.go
├── match_test.go
├── path.go
└── path_test.go
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;2-深入-path-包&#34;&gt;2. 深入&lt;code&gt;path&lt;/code&gt;包&lt;/h1&gt;

&lt;h2 id=&#34;2-1-path-go-path-test-go&#34;&gt;2.1 &lt;code&gt;path.go&lt;/code&gt; &amp;amp; &lt;code&gt;path_test.go&lt;/code&gt;&lt;/h2&gt;

&lt;h3 id=&#34;2-1-1-clean&#34;&gt;2.1.1 &lt;code&gt;Clean&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;签名：&lt;code&gt;func Clean(path string) string&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;用途：&lt;code&gt;Clean&lt;/code&gt;函数主要是对给定路径进行以下格式化：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;替换多个斜杠&lt;code&gt;//&lt;/code&gt;为单个斜杠&lt;code&gt;/&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;消除&lt;code&gt;.&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;消除&lt;code&gt;..&lt;/code&gt;当且仅当前一个元素不是&lt;code&gt;..&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;替换绝对路径开头的&lt;code&gt;/..&lt;/code&gt;为&lt;code&gt;/&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;格式化后的路径不以&lt;code&gt;/&lt;/code&gt;结尾，除非该路径就是根路径&lt;code&gt;/&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;若格式化后路径为空，则返回&lt;code&gt;.&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;示例：&lt;a href=&#34;https://play.golang.org/p/Ya85iuk0uMU&#34; target=&#34;_blank&#34;&gt;https://play.golang.org/p/Ya85iuk0uMU&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;    // Already clean
	&amp;quot;&amp;quot; =&amp;gt; &amp;quot;.&amp;quot;
	&amp;quot;abc&amp;quot; =&amp;gt; &amp;quot;abc&amp;quot;
	&amp;quot;abc/def&amp;quot; =&amp;gt; &amp;quot;abc/def&amp;quot;
	&amp;quot;a/b/c&amp;quot; =&amp;gt; &amp;quot;a/b/c&amp;quot;
	&amp;quot;.&amp;quot; =&amp;gt; &amp;quot;.&amp;quot;
	&amp;quot;..&amp;quot; =&amp;gt; &amp;quot;..&amp;quot;
	&amp;quot;../..&amp;quot; =&amp;gt; &amp;quot;../..&amp;quot;
	&amp;quot;../../abc&amp;quot; =&amp;gt; &amp;quot;../../abc&amp;quot;
	&amp;quot;/abc&amp;quot; =&amp;gt; &amp;quot;/abc&amp;quot;
	&amp;quot;/&amp;quot; =&amp;gt; &amp;quot;/&amp;quot;

    // Remove trailing slash
	&amp;quot;abc/&amp;quot; =&amp;gt; &amp;quot;abc&amp;quot;
	&amp;quot;abc/def/&amp;quot; =&amp;gt; &amp;quot;abc/def&amp;quot;
	&amp;quot;a/b/c/&amp;quot; =&amp;gt; &amp;quot;a/b/c&amp;quot;
	&amp;quot;./&amp;quot; =&amp;gt; &amp;quot;.&amp;quot;
	&amp;quot;../&amp;quot; =&amp;gt; &amp;quot;..&amp;quot;
	&amp;quot;../../&amp;quot; =&amp;gt; &amp;quot;../..&amp;quot;
	&amp;quot;/abc/&amp;quot; =&amp;gt; &amp;quot;/abc&amp;quot;

    // Remove doubled slash
	&amp;quot;abc//def//ghi&amp;quot; =&amp;gt; &amp;quot;abc/def/ghi&amp;quot;
	&amp;quot;//abc&amp;quot; =&amp;gt; &amp;quot;/abc&amp;quot;
	&amp;quot;///abc&amp;quot; =&amp;gt; &amp;quot;/abc&amp;quot;
	&amp;quot;//abc//&amp;quot; =&amp;gt; &amp;quot;/abc&amp;quot;
	&amp;quot;abc//&amp;quot; =&amp;gt; &amp;quot;abc&amp;quot;

	&amp;quot;abc/./def&amp;quot; =&amp;gt; &amp;quot;abc/def&amp;quot;
	&amp;quot;/./abc/def&amp;quot; =&amp;gt; &amp;quot;/abc/def&amp;quot;
	&amp;quot;abc/.&amp;quot; =&amp;gt; &amp;quot;abc&amp;quot;

    // Remove .. elements
	&amp;quot;abc/def/ghi/../jkl&amp;quot; =&amp;gt; &amp;quot;abc/def/jkl&amp;quot;
	&amp;quot;abc/def/../ghi/../jkl&amp;quot; =&amp;gt; &amp;quot;abc/jkl&amp;quot;
	&amp;quot;abc/def/..&amp;quot; =&amp;gt; &amp;quot;abc&amp;quot;
	&amp;quot;abc/def/../..&amp;quot; =&amp;gt; &amp;quot;.&amp;quot;
	&amp;quot;/abc/def/../..&amp;quot; =&amp;gt; &amp;quot;/&amp;quot;
	&amp;quot;abc/def/../../..&amp;quot; =&amp;gt; &amp;quot;..&amp;quot;
	&amp;quot;/abc/def/../../..&amp;quot; =&amp;gt; &amp;quot;/&amp;quot;
	&amp;quot;abc/def/../../../ghi/jkl/../../../mno&amp;quot; =&amp;gt; &amp;quot;../../mno&amp;quot;

    // Combinations
	&amp;quot;abc/./../def&amp;quot; =&amp;gt; &amp;quot;def&amp;quot;
	&amp;quot;abc//./../def&amp;quot; =&amp;gt; &amp;quot;def&amp;quot;
	&amp;quot;abc/../../././../def&amp;quot; =&amp;gt; &amp;quot;../../def&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-1-2-split&#34;&gt;2.1.2 &lt;code&gt;Split&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;签名：&lt;code&gt;func Split(path string) (dir, file string)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;用途：拆分路径为目录+文件，目录保留&lt;code&gt;/&lt;/code&gt;，若路径中没有&lt;code&gt;/&lt;/code&gt;，则目录为空&lt;/p&gt;

&lt;p&gt;示例：&lt;a href=&#34;https://play.golang.org/p/DG8QjjWdkuq&#34; target=&#34;_blank&#34;&gt;https://play.golang.org/p/DG8QjjWdkuq&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;	&amp;quot;a/b&amp;quot; =&amp;gt; &amp;quot;a/&amp;quot; + &amp;quot;b&amp;quot;
	&amp;quot;a/b/&amp;quot; =&amp;gt; &amp;quot;a/b/&amp;quot; + &amp;quot;&amp;quot;
	&amp;quot;a/&amp;quot; =&amp;gt; &amp;quot;a/&amp;quot; + &amp;quot;&amp;quot;
	&amp;quot;a&amp;quot; =&amp;gt; &amp;quot;&amp;quot; + &amp;quot;a&amp;quot;
	&amp;quot;/&amp;quot; =&amp;gt; &amp;quot;/&amp;quot; + &amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-1-3-join&#34;&gt;2.1.3 &lt;code&gt;Join&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;签名：&lt;code&gt;Join(elem ...string) string&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;用途：把所有元素按顺序拼接为路径，并对路径格式化&lt;/p&gt;

&lt;p&gt;示例：&lt;a href=&#34;https://play.golang.org/p/jxcwt_fgUpt&#34; target=&#34;_blank&#34;&gt;https://play.golang.org/p/jxcwt_fgUpt&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;	// zero parameters
	{[]string{} =&amp;gt; &amp;quot;&amp;quot;},

	// one parameter
	{[]string{&amp;quot;&amp;quot;} =&amp;gt; &amp;quot;&amp;quot;},
	{[]string{&amp;quot;a&amp;quot;} =&amp;gt; &amp;quot;a&amp;quot;},

	// two parameters
	{[]string{&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;} =&amp;gt; &amp;quot;a/b&amp;quot;},
	{[]string{&amp;quot;a&amp;quot;, &amp;quot;&amp;quot;} =&amp;gt; &amp;quot;a&amp;quot;},
	{[]string{&amp;quot;&amp;quot;, &amp;quot;b&amp;quot;} =&amp;gt; &amp;quot;b&amp;quot;},
	{[]string{&amp;quot;/&amp;quot;, &amp;quot;a&amp;quot;} =&amp;gt; &amp;quot;/a&amp;quot;},
	{[]string{&amp;quot;/&amp;quot;, &amp;quot;&amp;quot;} =&amp;gt; &amp;quot;/&amp;quot;},
	{[]string{&amp;quot;a/&amp;quot;, &amp;quot;b&amp;quot;} =&amp;gt; &amp;quot;a/b&amp;quot;},
	{[]string{&amp;quot;a/&amp;quot;, &amp;quot;&amp;quot;} =&amp;gt; &amp;quot;a&amp;quot;},
	{[]string{&amp;quot;&amp;quot;, &amp;quot;&amp;quot;} =&amp;gt; &amp;quot;&amp;quot;},
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-1-4-ext&#34;&gt;2.1.4 &lt;code&gt;Ext&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;签名：&lt;code&gt;Ext(path string) string&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;用途：根据&lt;code&gt;.&lt;/code&gt;返回路径中文件的扩展名，若没有&lt;code&gt;.&lt;/code&gt;则返回空&lt;/p&gt;

&lt;p&gt;示例：&lt;a href=&#34;https://play.golang.org/p/VxIO_oewphL&#34; target=&#34;_blank&#34;&gt;https://play.golang.org/p/VxIO_oewphL&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;	{&amp;quot;path.go&amp;quot; =&amp;gt; &amp;quot;.go&amp;quot;},
	{&amp;quot;path.pb.go&amp;quot; =&amp;gt; &amp;quot;.go&amp;quot;},
	{&amp;quot;a.dir/b&amp;quot; =&amp;gt; &amp;quot;&amp;quot;},
	{&amp;quot;a.dir/b.go&amp;quot; =&amp;gt; &amp;quot;.go&amp;quot;},
	{&amp;quot;a.dir/&amp;quot; =&amp;gt; &amp;quot;&amp;quot;},
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-1-5-base&#34;&gt;2.1.5 &lt;code&gt;Base&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;签名：&lt;code&gt;Base(path string) string&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;用途：先清除路径末尾的&lt;code&gt;/&lt;/code&gt;（如果有的话），再根据最后一个&lt;code&gt;/&lt;/code&gt;，返回该元素，若没有&lt;code&gt;/&lt;/code&gt;，则返回&lt;code&gt;.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;示例：&lt;a href=&#34;https://play.golang.org/p/bW-KYszq1fE&#34; target=&#34;_blank&#34;&gt;https://play.golang.org/p/bW-KYszq1fE&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;	{&amp;quot;&amp;quot; =&amp;gt; &amp;quot;.&amp;quot;},
	{&amp;quot;.&amp;quot; =&amp;gt; &amp;quot;.&amp;quot;},
	{&amp;quot;/.&amp;quot; =&amp;gt; &amp;quot;.&amp;quot;},
	{&amp;quot;/&amp;quot; =&amp;gt; &amp;quot;/&amp;quot;},
	{&amp;quot;////&amp;quot; =&amp;gt; &amp;quot;/&amp;quot;},
	{&amp;quot;x/&amp;quot; =&amp;gt; &amp;quot;x&amp;quot;},
	{&amp;quot;abc&amp;quot; =&amp;gt; &amp;quot;abc&amp;quot;},
	{&amp;quot;abc/def&amp;quot; =&amp;gt; &amp;quot;def&amp;quot;},
	{&amp;quot;a/b/.x&amp;quot; =&amp;gt; &amp;quot;.x&amp;quot;},
	{&amp;quot;a/b/c.&amp;quot; =&amp;gt; &amp;quot;c.&amp;quot;},
	{&amp;quot;a/b/c.x&amp;quot; =&amp;gt; &amp;quot;c.x&amp;quot;},
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-1-6-isabs&#34;&gt;2.1.6 &lt;code&gt;IsAbs&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;签名：&lt;code&gt;IsAbs(path string) bool&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;用途：判断路径是否为绝对路径，即以&lt;code&gt;/&lt;/code&gt;开头&lt;/p&gt;

&lt;p&gt;示例：&lt;a href=&#34;https://play.golang.org/p/MWv0m9Q8I-J&#34; target=&#34;_blank&#34;&gt;https://play.golang.org/p/MWv0m9Q8I-J&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;	{&amp;quot;&amp;quot; =&amp;gt; false},
	{&amp;quot;/&amp;quot; =&amp;gt; true},
	{&amp;quot;/usr/bin/gcc&amp;quot; =&amp;gt; true},
	{&amp;quot;..&amp;quot; =&amp;gt; false},
	{&amp;quot;/a/../bb&amp;quot; =&amp;gt; true},
	{&amp;quot;.&amp;quot; =&amp;gt; false},
	{&amp;quot;./&amp;quot; =&amp;gt; false},
	{&amp;quot;lala&amp;quot; =&amp;gt; false},
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-1-7-dir&#34;&gt;2.1.7 &lt;code&gt;Dir&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;签名：&lt;code&gt;Dir(path string) string&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;用途：返回去除最后一项后的目录路径,并格式化&lt;/p&gt;

&lt;p&gt;示例：&lt;a href=&#34;https://play.golang.org/p/DBULKf343C6&#34; target=&#34;_blank&#34;&gt;https://play.golang.org/p/DBULKf343C6&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;	{&amp;quot;&amp;quot; =&amp;gt; &amp;quot;.&amp;quot;},
	{&amp;quot;.&amp;quot; =&amp;gt; &amp;quot;.&amp;quot;},
	{&amp;quot;/.&amp;quot; =&amp;gt; &amp;quot;/&amp;quot;},
	{&amp;quot;/&amp;quot; =&amp;gt; &amp;quot;/&amp;quot;},
	{&amp;quot;////&amp;quot; =&amp;gt; &amp;quot;/&amp;quot;},
	{&amp;quot;/foo&amp;quot; =&amp;gt; &amp;quot;/&amp;quot;},
	{&amp;quot;x/&amp;quot; =&amp;gt; &amp;quot;x&amp;quot;},
	{&amp;quot;abc&amp;quot; =&amp;gt; &amp;quot;.&amp;quot;},
	{&amp;quot;abc/def&amp;quot; =&amp;gt; &amp;quot;abc&amp;quot;},
	{&amp;quot;abc////def&amp;quot; =&amp;gt; &amp;quot;abc&amp;quot;},
	{&amp;quot;a/b/.x&amp;quot; =&amp;gt; &amp;quot;a/b&amp;quot;},
	{&amp;quot;a/b/c.&amp;quot; =&amp;gt; &amp;quot;a/b&amp;quot;},
	{&amp;quot;a/b/c.x&amp;quot; =&amp;gt; &amp;quot;a/b&amp;quot;},
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2-2-match-go-match-test-go&#34;&gt;2.2 &lt;code&gt;match.go&lt;/code&gt; &amp;amp; &lt;code&gt;match_test.go&lt;/code&gt;&lt;/h2&gt;

&lt;h3 id=&#34;2-2-1-match&#34;&gt;2.2.1 &lt;code&gt;Match&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;签名：&lt;code&gt;func Match(pattern, name string) (matched bool, err error)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;用途：根据给定的模式对路径进行匹配，模式如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;	pattern:
		{ term }
	term:
		&#39;*&#39;         matches any sequence of non-/ characters 匹配任意数量的所有非/字符
		&#39;?&#39;         matches any single non-/ character 匹配所有单个非/字符
		&#39;[&#39; [ &#39;^&#39; ] { character-range } &#39;]&#39; 区间匹配，^表示除了该区间，匹配不能为空，至少需要一个
		            character class (must be non-empty)
		c           matches character c (c != &#39;*&#39;, &#39;?&#39;, &#39;\\&#39;, &#39;[&#39;) 匹配单个确定字符，除&#39;*&#39;, &#39;?&#39;, &#39;\\&#39;, &#39;[&#39;
		&#39;\\&#39; c      matches character c 可以看作转义匹配&#39;*&#39;, &#39;?&#39;, &#39;\\&#39;, &#39;[&#39;

	character-range:
		c           matches character c (c != &#39;\\&#39;, &#39;-&#39;, &#39;]&#39;) 在区间匹配中匹配单个确定字符，除&#39;\\&#39;, &#39;-&#39;, &#39;]&#39;
		&#39;\\&#39; c      matches character c 可以看作在区间匹配中转义匹配&#39;\\&#39;, &#39;-&#39;, &#39;]&#39;
		lo &#39;-&#39; hi   matches character c for lo &amp;lt;= c &amp;lt;= hi 区间范围
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;示例：&lt;a href=&#34;https://play.golang.org/p/yhfME8jBmn1&#34; target=&#34;_blank&#34;&gt;https://play.golang.org/p/yhfME8jBmn1&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;	{&amp;quot;abc&amp;quot;, &amp;quot;abc&amp;quot;, true, nil},
	{&amp;quot;*&amp;quot;, &amp;quot;abc&amp;quot;, true, nil},
	{&amp;quot;*c&amp;quot;, &amp;quot;abc&amp;quot;, true, nil},
	{&amp;quot;a*&amp;quot;, &amp;quot;a&amp;quot;, true, nil},
	{&amp;quot;a*&amp;quot;, &amp;quot;abc&amp;quot;, true, nil},
	{&amp;quot;a*&amp;quot;, &amp;quot;ab/c&amp;quot;, false, nil},
	{&amp;quot;a*/b&amp;quot;, &amp;quot;abc/b&amp;quot;, true, nil},
	{&amp;quot;a*/b&amp;quot;, &amp;quot;a/c/b&amp;quot;, false, nil},
	{&amp;quot;a*b*c*d*e*/f&amp;quot;, &amp;quot;axbxcxdxe/f&amp;quot;, true, nil},
	{&amp;quot;a*b*c*d*e*/f&amp;quot;, &amp;quot;axbxcxdxexxx/f&amp;quot;, true, nil},
	{&amp;quot;a*b*c*d*e*/f&amp;quot;, &amp;quot;axbxcxdxe/xxx/f&amp;quot;, false, nil},
	{&amp;quot;a*b*c*d*e*/f&amp;quot;, &amp;quot;axbxcxdxexxx/fff&amp;quot;, false, nil},
	{&amp;quot;a*b?c*x&amp;quot;, &amp;quot;abxbbxdbxebxczzx&amp;quot;, true, nil},
	{&amp;quot;a*b?c*x&amp;quot;, &amp;quot;abxbbxdbxebxczzy&amp;quot;, false, nil},
	{&amp;quot;ab[c]&amp;quot;, &amp;quot;abc&amp;quot;, true, nil},
	{&amp;quot;ab[b-d]&amp;quot;, &amp;quot;abc&amp;quot;, true, nil},
	{&amp;quot;ab[e-g]&amp;quot;, &amp;quot;abc&amp;quot;, false, nil},
	{&amp;quot;ab[^c]&amp;quot;, &amp;quot;abc&amp;quot;, false, nil},
	{&amp;quot;ab[^b-d]&amp;quot;, &amp;quot;abc&amp;quot;, false, nil},
	{&amp;quot;ab[^e-g]&amp;quot;, &amp;quot;abc&amp;quot;, true, nil},
	{&amp;quot;a\\*b&amp;quot;, &amp;quot;a*b&amp;quot;, true, nil},
	{&amp;quot;a\\*b&amp;quot;, &amp;quot;ab&amp;quot;, false, nil},
	{&amp;quot;a?b&amp;quot;, &amp;quot;a☺b&amp;quot;, true, nil},
	{&amp;quot;a[^a]b&amp;quot;, &amp;quot;a☺b&amp;quot;, true, nil},
	{&amp;quot;a???b&amp;quot;, &amp;quot;a☺b&amp;quot;, false, nil},
	{&amp;quot;a[^a][^a][^a]b&amp;quot;, &amp;quot;a☺b&amp;quot;, false, nil},
	{&amp;quot;[a-ζ]*&amp;quot;, &amp;quot;α&amp;quot;, true, nil},
	{&amp;quot;*[a-ζ]&amp;quot;, &amp;quot;A&amp;quot;, false, nil},
	{&amp;quot;a?b&amp;quot;, &amp;quot;a/b&amp;quot;, false, nil},
	{&amp;quot;a*b&amp;quot;, &amp;quot;a/b&amp;quot;, false, nil},
	{&amp;quot;[\\]a]&amp;quot;, &amp;quot;]&amp;quot;, true, nil},
	{&amp;quot;[\\-]&amp;quot;, &amp;quot;-&amp;quot;, true, nil},
	{&amp;quot;[x\\-]&amp;quot;, &amp;quot;x&amp;quot;, true, nil},
	{&amp;quot;[x\\-]&amp;quot;, &amp;quot;-&amp;quot;, true, nil},
	{&amp;quot;[x\\-]&amp;quot;, &amp;quot;z&amp;quot;, false, nil},
	{&amp;quot;[\\-x]&amp;quot;, &amp;quot;x&amp;quot;, true, nil},
	{&amp;quot;[\\-x]&amp;quot;, &amp;quot;-&amp;quot;, true, nil},
	{&amp;quot;[\\-x]&amp;quot;, &amp;quot;a&amp;quot;, false, nil},
	{&amp;quot;[]a]&amp;quot;, &amp;quot;]&amp;quot;, false, ErrBadPattern},
	{&amp;quot;[-]&amp;quot;, &amp;quot;-&amp;quot;, false, ErrBadPattern},
	{&amp;quot;[x-]&amp;quot;, &amp;quot;x&amp;quot;, false, ErrBadPattern},
	{&amp;quot;[x-]&amp;quot;, &amp;quot;-&amp;quot;, false, ErrBadPattern},
	{&amp;quot;[x-]&amp;quot;, &amp;quot;z&amp;quot;, false, ErrBadPattern},
	{&amp;quot;[-x]&amp;quot;, &amp;quot;x&amp;quot;, false, ErrBadPattern},
	{&amp;quot;[-x]&amp;quot;, &amp;quot;-&amp;quot;, false, ErrBadPattern},
	{&amp;quot;[-x]&amp;quot;, &amp;quot;a&amp;quot;, false, ErrBadPattern},
	{&amp;quot;\\&amp;quot;, &amp;quot;a&amp;quot;, false, ErrBadPattern},
	{&amp;quot;[a-b-c]&amp;quot;, &amp;quot;a&amp;quot;, false, ErrBadPattern},
	{&amp;quot;[&amp;quot;, &amp;quot;a&amp;quot;, false, ErrBadPattern},
	{&amp;quot;[^&amp;quot;, &amp;quot;a&amp;quot;, false, ErrBadPattern},
	{&amp;quot;[^bc&amp;quot;, &amp;quot;a&amp;quot;, false, ErrBadPattern},
	{&amp;quot;a[&amp;quot;, &amp;quot;a&amp;quot;, false, nil},
	{&amp;quot;a[&amp;quot;, &amp;quot;ab&amp;quot;, false, ErrBadPattern},
	{&amp;quot;*x&amp;quot;, &amp;quot;xxx&amp;quot;, true, nil},
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Go并发模式1</title>
      <link>https://mooncaker816.github.io/2018/06/13/go%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F1/</link>
      <pubDate>Wed, 13 Jun 2018 15:02:12 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/06/13/go%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F1/</guid>
      <description>&lt;h1 id=&#34;or-channel&#34;&gt;Or-Channel&lt;/h1&gt;

&lt;p&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;使用场景：&lt;br /&gt;
当你需要同时监测多个信号时，只要接收到其中任一个信号，就认为信号接收成功，需要进行下一步处理&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func or(channels ...&amp;lt;-chan interface{}) &amp;lt;-chan interface{} {
    switch len(channels) {
    case 0:
        return nil
    case 1:
        return channels[0]
    }
    orDone := make(chan interface{})
    go func() {
        defer close(orDone)
        switch len(channels) {
        case 2:
            select {
            case &amp;lt;-channels[0]:
            case &amp;lt;-channels[1]:
            }
        default:
            select {
            case &amp;lt;-channels[0]:
            case &amp;lt;-channels[1]:
            case &amp;lt;-channels[2]:
            case &amp;lt;-or(append(channels[3:], orDone)...):
            }
        }
    }()
    return orDone
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;测试：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func TestOr(t *testing.T) {
    st := time.Now()
    r := rand.New(rand.NewSource(time.Now().Unix()))
    &amp;lt;-or(
        randSig(r),
        randSig(r),
        randSig(r),
        randSig(r),
        randSig(r),
    )
    fmt.Printf(&amp;quot;closed after %v!\n&amp;quot;, time.Since(st))
}

func randSig(r *rand.Rand) &amp;lt;-chan interface{} {
    ch := make(chan interface{})
    go func() {
        defer close(ch)
        sec := time.Duration(r.Int63n(10)+3) * time.Second
        fmt.Printf(&amp;quot;closing after %v!\n&amp;quot;, sec)
        time.Sleep(sec)
    }()
    return ch
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;closing after 4s!
closing after 10s!
closing after 3s!
closing after 9s!
closing after 11s!
closed after 3.001062582s!
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>天文算法27</title>
      <link>https://mooncaker816.github.io/2018/05/28/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9527/</link>
      <pubDate>Mon, 28 May 2018 10:35:29 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/05/28/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9527/</guid>
      <description>&lt;h1 id=&#34;第二十九章-ephemeris-for-physical-observations-of-the-sun&#34;&gt;第二十九章 Ephemeris for Physical Observations of the Sun&lt;/h1&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-日面计算&#34;&gt;1. 日面计算&lt;/h2&gt;

&lt;p&gt;$P$ 为日轴方位角，自日面北点量起的太阳自转轴北端的方位角，向东为正&lt;br /&gt;
$B_0$ 为日面中心的日面纬度&lt;br /&gt;
$L_0$ 为日面中心的日面经度&lt;/p&gt;

&lt;p&gt;根据之前章节的算法，先计算太阳视黄经$λ$(包含光行差修正)，$λ&amp;rsquo;$为$λ$的黄经章动修正值，$ε$为真黄赤交角&lt;br /&gt;
再计算
\begin{cases}
θ = (JD - 2398220)\frac {360°}{25.38}\\[2ex]
I = 7°.25,(太阳赤道与黄道的倾角)\\[2ex]
K = 73°.6667 + 1°.3958333\frac {JD - 2396758}{36525},(太阳赤道与黄道的升交点的黄经)\\[2ex]
\tan x = -\cos λ&amp;rsquo;\tan ε\\[2ex]
\tan y = -\cos (λ - K)\tan I
\end{cases}
那么
\begin{cases}
P = x+y\\[2ex]
\sin B_0 = \sin(λ - K)\sin I\\[2ex]
\tan η = \frac {-\sin(λ - K)\cos I}{-\cos (λ - K)}\\[2ex]
L_0 = η-θ
\end{cases}&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Ephemeris returns the apparent orientation of the sun at the given jd.
// 计算日面参数
//
// Results:
//	P:  Position angle of the solar north pole.
//	B0: Heliographic latitude of the center of the solar disk.
//	L0: Heliographic longitude of the center of the solar disk.
func Ephemeris(jd float64, e *pp.V87Planet) (P, B0, L0 unit.Angle) {
	θ := unit.Angle((jd - 2398220) * 2 * math.Pi / 25.38)
	I := unit.AngleFromDeg(7.25)
	K := unit.AngleFromDeg(73.6667) +
		unit.AngleFromDeg(1.3958333).Mul((jd-2396758)/base.JulianCentury)

	L, _, R := solar.TrueVSOP87(e, jd)
	Δψ, Δε := nutation.Nutation(jd)
	ε0 := nutation.MeanObliquity(jd)
	ε := ε0 + Δε
	λ := L - unit.AngleFromSec(20.4898).Div(R)
	λp := λ + Δψ

	sλK, cλK := (λ - K).Sincos()
	sI, cI := I.Sincos()

	tx := -(λp.Cos() * ε.Tan())
	ty := -(cλK * I.Tan())
	P = unit.Angle(math.Atan(tx) + math.Atan(ty))
	B0 = unit.Angle(math.Asin(sλK * sI))
	η := unit.Angle(math.Atan2(-sλK*cI, -cλK))
	L0 = (η - θ).Mod1()
	return
}

// Cycle returns the jd of the start of the given synodic rotation.
//
// Argument c is the &amp;quot;Carrington&amp;quot; cycle number.
//
// Result is a dynamical time (not UT).
func Cycle(c int) (jde float64) {
	cf := float64(c)
	jde = 2398140.227 + 27.2752316*cf
	m := 281.96*math.Pi/180 + 26.882476*math.Pi/180*cf
	s2m, c2m := math.Sincos(2 * m)
	return jde + .1454*math.Sin(m) - .0085*s2m - .0141*c2m
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>天文算法26</title>
      <link>https://mooncaker816.github.io/2018/05/28/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9526/</link>
      <pubDate>Mon, 28 May 2018 09:25:36 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/05/28/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9526/</guid>
      <description>&lt;h1 id=&#34;第二十八章-equation-of-time-均时差&#34;&gt;第二十八章 Equation of Time 均时差&lt;/h1&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-均时差的概念&#34;&gt;1. 均时差的概念&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%9D%87%E6%99%82%E5%B7%AE&#34; target=&#34;_blank&#34;&gt;均时差&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;2-计算时差&#34;&gt;2. 计算时差&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;VSOP87理论计算&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;$$E = L_0 - 0°.0057183 - α + Δψ·\cos ε$$
其中$α$为太阳地心视赤经，$Δψ$为赤经章动，$ε$为真黄赤交角，$L_0$为太阳平黄经
$$L_0 = 280.4664567 + 360007.6982779τ + 0.03032028τ^2 + τ^3 /49931 - τ^4 /15300 - τ^5 /2000000$$
$τ$为儒略日千年数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// E computes the &amp;quot;equation of time&amp;quot; for the given JDE.
// 计算时差
//
// Parameter e must be a planetposition.V87Planet object for Earth obtained
// with planetposition.LoadPlanet.
//
// Result is equation of time as an hour angle.
func E(jde float64, e *pp.V87Planet) unit.HourAngle {
	τ := base.J2000Century(jde) * .1 // J2000儒略日千年数
	L0 := l0(τ)
	// code duplicated from solar.ApparentEquatorialVSOP87 so that
	// we can keep Δψ and cε
	s, β, R := solar.TrueVSOP87(e, jde) // 真太阳黄经
	Δψ, Δε := nutation.Nutation(jde)
	a := unit.AngleFromSec(-20.4898).Div(R) //光行差
	λ := s + Δψ + a                         //视黄经
	ε := nutation.MeanObliquity(jde) + Δε   // 真黄赤交角
	sε, cε := ε.Sincos()
	α, _ := coord.EclToEq(λ, β, sε, cε) // 视赤经
	// (28.1) p. 183
	E := L0 - unit.AngleFromDeg(.0057183) - unit.Angle(α) + Δψ.Mul(cε)
	return unit.HourAngle((E + math.Pi).Mod1() - math.Pi)
}

// (28.2) p. 183
// 太阳平黄经
func l0(τ float64) unit.Angle {
	return unit.AngleFromDeg(base.Horner(τ,
		280.4664567, 360007.6982779, .03032028,
		1./49931, -1./15300, -1./2000000))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;低精度时差计算&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;$$E = y\sin 2L_0 - 2e\sin M + 4ey\sin M \cos 2L_0 - \frac 12y^2\sin 4L_0 - \frac 54 e^2\sin 2M$$
其中$y = \tan^2(ε/2)，ε是平黄赤交角,L_0为太阳平黄经，e为地球轨道离心率，M为太阳平近点角$&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// ESmart computes the &amp;quot;equation of time&amp;quot; for the given JDE.
// 低精度计算时差
//
// Result is equation of time as an hour angle.
//
// Result is less accurate that E() but the function has the advantage
// of not requiring the V87Planet object.
func ESmart(jde float64) unit.HourAngle {
	ε := nutation.MeanObliquity(jde) // 平黄赤交角
	t := ε.Mul(.5).Tan()
	y := t * t
	T := base.J2000Century(jde)
	L0 := l0(T * .1)
	e := solar.Eccentricity(T) //地球轨道离心率
	M := solar.MeanAnomaly(T)  // 太阳平近点角
	s2L0, c2L0 := L0.Mul(2).Sincos()
	sM := M.Sin()
	// (28.3) p. 185, with double angle identity
	return unit.HourAngle(y*s2L0 - 2*e*sM + 4*e*y*sM*c2L0 -
		y*y*s2L0*c2L0 - 1.25*e*e*M.Mul(2).Sin())
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>天文算法25</title>
      <link>https://mooncaker816.github.io/2018/05/26/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9525/</link>
      <pubDate>Sat, 26 May 2018 08:58:00 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/05/26/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9525/</guid>
      <description>&lt;h1 id=&#34;第二十七章-分点和至点-equinoxes-and-solstices&#34;&gt;第二十七章 分点和至点 Equinoxes and Solstices&lt;/h1&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;分点（英语：equinox，或称二分点）是想像中天球赤道在天球上的位置，是每年太阳穿过天球赤道和黄道在天球上交点的天文事件[1]，这造成地球上各地的白天和夜晚几乎等长。&lt;/p&gt;

&lt;p&gt;二至点（亦称至点）可以是太阳在一年之中离地球赤道最远的两个事件中的任何一个，英文的字源（solstice） 来自拉丁文的太阳（sol）和保持直立（sistere），因为在至点时太阳直射的地球纬度是他能抵达的最南或最北的极值，而至点所在之日是一年之中日夜长短差异最大的一天。&lt;/p&gt;

&lt;p&gt;分点和至点时刻是指：太阳的地心视黄经(含光行差和章动)为90的整数倍时对应的时刻。因太阳黄纬不是真正为零的，所以在分点时刻太阳赤纬也不是真正为零的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://garyborjesson.files.wordpress.com/2013/03/equ-schem.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-近似时刻计算-最大误差1分钟&#34;&gt;1. 近似时刻计算(最大误差1分钟)&lt;/h2&gt;

&lt;p&gt;先找到平分点或平至点$JDE_0$&lt;br /&gt;
当$year \in [-1000,1000)$时，
\begin{cases}
Y = \frac {year}{1000}\\[2ex]
春分点：JDE_0 = 1721139.29189 + 365242.13740Y + 0.06134Y^2 + 0.00111Y^3 - 0.00071Y^4\\[2ex]
夏至点：JDE_0 = 1721233.25401 + 365241.72562Y - 0.05323Y^2 + 0.00907Y^3 + 0.00025Y^4\\[2ex]
秋分点：JDE_0 = 1721325.70455 + 365242.49558Y - 0.11677Y^2 - 0.00297Y^3 + 0.00074Y^4\\[2ex]
冬至点：JDE_0 = 1721414.39987 + 365242.88257Y - 0.00769Y^2 - 0.00933Y^3 - 0.00006Y^4\\[2ex]
\end{cases}
当$year \in [1000,3000]$时，
\begin{cases}
Y = \frac {year-2000}{1000}\\[2ex]
春分点：JDE_0 = 2451623.80984 + 365242.37404Y + 0.05169Y^2 - 0.00411Y^3 - 0.00057Y^4\\[2ex]
夏至点：JDE_0 = 2451716.56767 + 365241.62603Y + 0.00325Y^2 + 0.00888Y^3 - 0.00030Y^4\\[2ex]
秋分点：JDE_0 = 2451810.21715 + 365242.01767Y - 0.11575Y^2 + 0.00337Y^3 + 0.00078Y^4\\[2ex]
冬至点：JDE_0 = 2451900.05952 + 365242.74049Y - 0.06223Y^2 - 0.00823Y^3 + 0.00032Y^4\\[2ex]
\end{cases}
再计算
\begin{cases}
T &amp;amp;= \frac {JDE_0 - 2451545.0}{36525}\\[2ex]
W &amp;amp;= 35999°.373T - 2°.47\\[2ex]
Δλ &amp;amp;= 1 + 0.0334\cos W + 0.0007\cos (2W)\\[2ex]
S &amp;amp;= \sum A\cos(B+CT)
\end{cases}
其中$A,B,C$分别为下表中的系数项&lt;img src=&#34;https://mooncaker816.github.io/img/分至点.png&#34; alt=&#34;&#34; /&gt;
那么$$JDE = JDE_0 + \frac {0.00001S}{Δλ} days$$
注意此时得到的力学时DT，可以按需再转为UT&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var (
	mc0 = []float64{1721139.29189, 365242.13740, .06134, .00111, -.00071}
	jc0 = []float64{1721233.25401, 365241.72562, -.05232, .00907, .00025}
	sc0 = []float64{1721325.70455, 365242.49558, -.11677, -.00297, .00074}
	dc0 = []float64{1721414.39987, 365242.88257, -.00769, -.00933, -.00006}

	mc2 = []float64{2451623.80984, 365242.37404, .05169, -.00411, -.00057}
	jc2 = []float64{2451716.56767, 365241.62603, .00325, .00888, -.00030}
	sc2 = []float64{2451810.21715, 365242.01767, -.11575, .00337, .00078}
	dc2 = []float64{2451900.05952, 365242.74049, -.06223, -.00823, .00032}
)

type term struct {
	a, b, c float64
}

var terms = []term{
	{485, 324.96, 1934.136},
	{203, 337.23, 32964.467},
	{199, 342.08, 20.186},
	{182, 27.85, 445267.112},
	{156, 73.14, 45036.886},
	{136, 171.52, 22518.443},
	{77, 222.54, 65928.934},
	{74, 296.72, 3034.906},
	{70, 243.58, 9037.513},
	{58, 119.81, 33718.147},
	{52, 297.17, 150.678},
	{50, 21.02, 2281.226},

	{45, 247.54, 29929.562},
	{44, 325.15, 31555.956},
	{29, 60.93, 4443.417},
	{18, 155.12, 67555.328},
	{17, 288.79, 4562.452},
	{16, 198.04, 62894.029},
	{14, 199.76, 31436.921},
	{12, 95.39, 14577.848},
	{12, 287.11, 31931.756},
	{12, 320.81, 34777.259},
	{9, 227.73, 1222.114},
	{8, 15.45, 16859.074},
}

// March returns the JDE of the March equinox for the given year.
// 计算y年春分点力学时，y∈[-1000,3000]
//
// Results are valid for the years -1000 to +3000.
//
// Accuracy is within one minute of time for the years 1951-2050.
func March(y int) float64 {
	if y &amp;lt; 1000 {
		return eq(y, mc0)
	}
	return eq(y-2000, mc2)
}

// June returns the JDE of the June solstice for the given year.
// 计算y年夏至点力学时，y∈[-1000,3000]
//
// Results are valid for the years -1000 to +3000.
//
// Accuracy is within one minute of time for the years 1951-2050.
func June(y int) float64 {
	if y &amp;lt; 1000 {
		return eq(y, jc0)
	}
	return eq(y-2000, jc2)
}

// September returns the JDE of the September equinox for the given year.
// 计算y年秋分点力学时，y∈[-1000,3000]
//
// Results are valid for the years -1000 to +3000.
//
// Accuracy is within one minute of time for the years 1951-2050.
func September(y int) float64 {
	if y &amp;lt; 1000 {
		return eq(y, sc0)
	}
	return eq(y-2000, sc2)
}

// December returns the JDE of the December solstice for a given year.
// 计算y年冬至点力学时，y∈[-1000,3000]
//
// Results are valid for the years -1000 to +3000.
//
// Accuracy is within one minute of time for the years 1951-2050.
func December(y int) float64 {
	if y &amp;lt; 1000 {
		return eq(y, dc0)
	}
	return eq(y-2000, dc2)
}

func eq(y int, c []float64) float64 {
	J0 := base.Horner(float64(y)*.001, c...)
	T := base.J2000Century(J0)
	W := 35999.373*math.Pi/180*T - 2.47*math.Pi/180
	Δλ := 1 + .0334*math.Cos(W) + .0007*math.Cos(2*W)
	S := 0.
	for i := len(terms) - 1; i &amp;gt;= 0; i-- {
		t := &amp;amp;terms[i]
		S += t.a * math.Cos((t.b+t.c*T)*math.Pi/180)
	}
	return J0 + .00001*S/Δλ
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2-高精度分至点时刻计算&#34;&gt;2. 高精度分至点时刻计算&lt;/h2&gt;

&lt;p&gt;　　先用低精度方法算出近似时刻，再采用VSOP87理论计算出该时刻的太阳视黄经$λ$，&lt;br /&gt;
　　再根据各个分至点的几何度数按以下公式求该近似时刻的修正量，循环迭代，直至满足要求。
　　$$+58\sin (k90° - λ)$$
　　其中k=0,1,2,3分别对应春夏秋冬四个分至点&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// March2 returns a more accurate JDE of the March equinox.
// 高精度计算春分点力学时
//
// Result is accurate to one second of time.
//
// Parameter e must be a V87Planet object representing Earth, obtained with
// the package planetposition and code similar to
//
//	e, err := planetposition.LoadPlanet(planetposition.Earth, &amp;quot;&amp;quot;)
//	    if err != nil {
//	        ....
//
// See example under June2.
func March2(y int, e *pp.V87Planet) float64 {
	if y &amp;lt; 1000 {
		return eq2(y, e, 0, mc0)
	}
	return eq2(y-2000, e, 0, mc2)
}

// June2 returns a more accurate JDE of the June solstice.
// 高精度计算夏至点力学时
//
// Result is accurate to one second of time.
//
// Parameter e must be a V87Planet object representing Earth, obtained with
// the package planetposition.
func June2(y int, e *pp.V87Planet) float64 {
	if y &amp;lt; 1000 {
		return eq2(y, e, math.Pi/2, jc0)
	}
	return eq2(y-2000, e, math.Pi/2, jc2)
}

// September2 returns a more accurate JDE of the September equinox.
// 高精度计算秋分点力学时
//
// Result is accurate to one second of time.
//
// Parameter e must be a V87Planet object representing Earth, obtained with
// the package planetposition and code similar to
//
//	e, err := planetposition.LoadPlanet(planetposition.Earth, &amp;quot;&amp;quot;)
//	    if err != nil {
//	        ....
//
// See example under June2.
func September2(y int, e *pp.V87Planet) float64 {
	if y &amp;lt; 1000 {
		return eq2(y, e, math.Pi, sc0)
	}
	return eq2(y-2000, e, math.Pi, sc2)
}

// December2 returns a more accurate JDE of the December solstice.
// 高精度计算冬至点力学时
//
// Result is accurate to one second of time.
//
// Parameter e must be a V87Planet object representing Earth, obtained with
// the package planetposition and code similar to
//
//	e, err := planetposition.LoadPlanet(planetposition.Earth, &amp;quot;&amp;quot;)
//	    if err != nil {
//	        ....
//
// See example under June2.
func December2(y int, e *pp.V87Planet) float64 {
	if y &amp;lt; 1000 {
		return eq2(y, e, math.Pi*3/2, dc0)
	}
	return eq2(y-2000, e, math.Pi*3/2, dc2)
}

//先用低精度方法算出近似时刻，再采用VSOP87理论计算出该时刻的太阳视黄经λ，
//再根据各个分至点的几何度数求该近似时刻的修正量，循环迭代，直至满足要求。
func eq2(y int, e *pp.V87Planet, q unit.Angle, c []float64) float64 {
	J0 := base.Horner(float64(y)*.001, c...)
	for {
		λ, _, _ := solar.ApparentVSOP87(e, J0)
		c := 58 * (q - λ).Sin() // (27.1) p. 180
		J0 += c
		if math.Abs(c) &amp;lt; .000005 {
			break
		}
	}
	return J0
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>天文算法24</title>
      <link>https://mooncaker816.github.io/2018/05/25/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9524/</link>
      <pubDate>Fri, 25 May 2018 13:59:39 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/05/25/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9524/</guid>
      <description>&lt;h1 id=&#34;第二十六章-太阳直角坐标-rectangular-coordinates-of-the-sun&#34;&gt;第二十六章 太阳直角坐标 Rectangular Coordinates of the Sun&lt;/h1&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;　　太阳的地心赤道直角坐标$X,Y,Z$。原点在地心。$X$轴的方向指向春分点（经度为0），$Y$轴平放在赤道面上， 经度是90°，$Z$轴方向是北极。&lt;/p&gt;

&lt;h2 id=&#34;1-date-平分点参考系&#34;&gt;1. Date 平分点参考系&lt;/h2&gt;

&lt;p&gt;\begin{cases}
X &amp;amp;= R\cos β\cos ☉\\[2ex]
Y &amp;amp;= R(\cos β\sin ☉\cos ε - \sin β\sin ε)\\[2ex]
Z &amp;amp;= R(\cos β\sin ☉\sin ε + \sin β\cos ε)
\end{cases}
其中$☉,β,R$是太阳的地心几何黄经,黄纬,日地距离（可由&lt;code&gt;solar.TrueVSOP87&lt;/code&gt;求出），$ε$是平黄赤交角。&lt;br /&gt;
因为 Date 黄道坐标中，太阳的纬度不超过 1.2 角秒， 所以可以看成$\cos β=1$&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Position returns rectangular coordinates referenced to the mean equinox
// of date.
// Date 平分点太阳地心直角坐标
func Position(e *pp.V87Planet, jde float64) (x, y, z float64) {
	// (26.1) p. 171
	s, β, R := solar.TrueVSOP87(e, jde)
	sε, cε := nutation.MeanObliquity(jde).Sincos()
	ss, cs := s.Sincos()
	sβ := β.Sin()
	x = R * cs
	y = R * (ss*cε - sβ*sε)
	z = R * (ss*sε + sβ*cε)
	return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2-j2000标准分点参考系和b1950平分点参考系&#34;&gt;2. J2000标准分点参考系和B1950平分点参考系&lt;/h2&gt;

&lt;p&gt;通过VSOP87计算给定时刻地球的相对于 J2000.0 分点的日心黄经$L$和黄纬$B$，及距离$R$
$$☉ = L + 180°， β = -B$$
计算
\begin{cases}
X &amp;amp;= R\cos β*cos ☉\\[2ex]
Y &amp;amp;= R\cos β*sin ☉\\[2ex]
Z &amp;amp;= R\sin β
\end{cases}&lt;/p&gt;

&lt;p&gt;上述坐标仍是黄道坐标，J2000参考系的赤道坐标为：
\begin{cases}
X_0 &amp;amp;= 1.000000000000X+0.000000440360Y-0.000000190919Z\\[2ex]
Y_0 &amp;amp;= -0.000000479966X+0.917482137087Y-0.397776982902Z\\[2ex]
Z_0 &amp;amp;= 0.000000000000X+0.397776982902Y+0.917482137087Z
\end{cases}&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// PositionJ2000 returns rectangular coordinates referenced to equinox J2000.
// J2000太阳直角坐标
func PositionJ2000(e *pp.V87Planet, jde float64) (x, y, z float64) {
	x, y, z = xyz(e, jde)
	// (26.3) p. 174
	return x + .00000044036*y - .000000190919*z,
		-.000000479966*x + .917482137087*y - .397776982902*z,
		.397776982902*y + .917482137087*z
}

func xyz(e *pp.V87Planet, jde float64) (x, y, z float64) {
	l, b, r := e.Position2000(jde)
	s := l + math.Pi
	β := -b
	ss, cs := s.Sincos()
	sβ, cβ := β.Sincos()
	// (26.2) p. 172
	x = r * cβ * cs
	y = r * cβ * ss
	z = r * sβ
	return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;B1950平分点参考系坐标：
\begin{cases}
X_0 &amp;amp;=0.999925702634X+0.012189716217Y+0.000011134016Z\\[2ex]
Y_0 &amp;amp;=-0.011179418036X+0.917413998946Y-0.397777041885Z\\[2ex]
Z_0 &amp;amp;=-0.004859003787X+0.397747363646Y+0.917482111428Z
\end{cases}&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// PositionB1950 returns rectangular coordinates referenced to B1950.
// B1950 平分点参考系太阳直角坐标
//
// Results are referenced to the mean equator and equinox of the epoch B1950
// in the FK5 system, not FK4.
func PositionB1950(e *pp.V87Planet, jde float64) (x, y, z float64) {
	x, y, z = xyz(e, jde)
	return .999925702634*x + .012189716217*y + .000011134016*z,
		-.011179418036*x + .917413998946*y - .397777041885*z,
		-.004859003787*x + .397747363646*y + .917482111428*z
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;3-任意其它平分点参考系&#34;&gt;3. 任意其它平分点参考系&lt;/h2&gt;

&lt;p&gt;　　先计算出J2000标准分点标准$X_0,Y_0,Z_0$&lt;br /&gt;
　　然后按岁差计算中的方法计算出$ζ,z,θ$,&lt;br /&gt;
\begin{cases}
X_x &amp;amp;= \cos ζ\cos z\cos θ - \sin ζ\sin z\\[2ex]
X_y &amp;amp;= \sin ζ\cos z + \cos ζ\sin z\cos θ\\[2ex]
X_z &amp;amp;= \cos ζ\sin θ\\[2ex]
\end{cases}
\begin{cases}
Y_x &amp;amp;= -\cos ζ\sin z - \sin ζ\cos z\cos θ\\[2ex]
Y_y &amp;amp;= \cos ζ\cos z - \sin ζ\sin z\cos θ\\[2ex]
Y_z &amp;amp;= -\sin ζ\sin θ\\[2ex]
\end{cases}
\begin{cases}
Z_x &amp;amp;= -\cos z\sin θ\\[2ex]
Z_y &amp;amp;= -\sin z\sin θ\\[2ex]
Z_z &amp;amp;= \cos θ
\end{cases}
　　那么
\begin{cases}
X′ &amp;amp;= X_xX_0 + Y_xY_0 + Z_xZ_0\\[2ex]
Y′ &amp;amp;= X_yX_0 + Y_yY_0 + Z_yZ_0\\[2ex]
Z′ &amp;amp;= X_zX_0 + Y_zY_0 + Z_zZ_0
\end{cases}&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// PositionEquinox returns rectangular coordinates referenced to an arbitrary epoch.
// 任意其它平分点参考系太阳直角坐标
//
// Position will be computed for given Julian day &amp;quot;jde&amp;quot; but referenced to mean
// equinox &amp;quot;epoch&amp;quot; (year).
func PositionEquinox(e *pp.V87Planet, jde, epoch float64) (xp, yp, zp float64) {
	x0, y0, z0 := PositionJ2000(e, jde)
	t := (epoch - 2000) * .01
	ζ := base.Horner(t, ζt...) * t * math.Pi / 180 / 3600
	z := base.Horner(t, zt...) * t * math.Pi / 180 / 3600
	θ := base.Horner(t, θt...) * t * math.Pi / 180 / 3600
	sζ, cζ := math.Sincos(ζ)
	sz, cz := math.Sincos(z)
	sθ, cθ := math.Sincos(θ)
	xx := cζ*cz*cθ - sζ*sz
	xy := sζ*cz + cζ*sz*cθ
	xz := cζ * sθ
	yx := -cζ*sz - sζ*cz*cθ
	yy := cζ*cz - sζ*sz*cθ
	yz := -sζ * sθ
	zx := -cz * sθ
	zy := -sz * sθ
	zz := cθ
	return xx*x0 + yx*y0 + zx*z0,
		xy*x0 + yy*y0 + zy*z0,
		xz*x0 + yz*y0 + zz*z0
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>天文算法23</title>
      <link>https://mooncaker816.github.io/2018/05/25/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9523/</link>
      <pubDate>Fri, 25 May 2018 08:06:54 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/05/25/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9523/</guid>
      <description>&lt;h1 id=&#34;第二十五章-太阳坐标-solar-coordinates&#34;&gt;第二十五章 太阳坐标 Solar Coordinates&lt;/h1&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-低精度太阳黄经&#34;&gt;1. 低精度太阳黄经&lt;/h2&gt;

&lt;p&gt;当计算精度要求为0.01度，计算太阳位置时可假设地球运动是一个纯椭圆，也就说忽略月球及行星摄动。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;太阳真黄经&lt;/p&gt;

&lt;p&gt;$T$为J2000起算的儒略世纪数&lt;br /&gt;
\begin{align}
太阳几何平黄经：L_0 &amp;amp;= 280°.46646 + 36000°.76983T + 0°.0003032T^2\\[2ex]
太阳平近点角： M &amp;amp;= 357°.52911 + 35999°.05029T - 0°.0001537T^2\\[2ex]
地球轨道离心率： e &amp;amp;= 0.016708634 - 0.000042037T - 0.0000001267T^2\\[2ex]
太阳中心方程 ： C &amp;amp;= +(1°.914602 - 0°.004817T - 0°.000014T^2)\sin M\\[2ex]
&amp;amp;+(0°.019993 - 0°.000101T)\sin 2M\\[2ex]
&amp;amp;+ 0°.000289\sin 3M
\end{align}
那么，太阳的真黄经是：$☉ = L_0 + C$ 真近点角是：$ν = M + C$&lt;br /&gt;
日地距离(AU)为：$R =\frac {1.000001018(1-e^2)}{1+e\cos ν}$&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// True returns true geometric longitude and anomaly of the sun referenced to the mean equinox of date.
// 计算太阳真黄经s，真近点角ν
//
// Argument T is the number of Julian centuries since J2000.
// See base.J2000Century.
//
// Results:
//  s = true geometric longitude, ☉
//  ν = true anomaly
func True(T float64) (s, ν unit.Angle) {
    // (25.2) p. 163
    L0 := unit.AngleFromDeg(base.Horner(T, 280.46646, 36000.76983, 0.0003032))
    M := MeanAnomaly(T)
    C := unit.AngleFromDeg(base.Horner(T, 1.914602, -0.004817, -.000014)*
        M.Sin() +
        (0.019993-.000101*T)*M.Mul(2).Sin() +
        0.000289*M.Mul(3).Sin())
    return (L0 + C).Mod1(), (M + C).Mod1()
}

// MeanAnomaly returns the mean anomaly of Earth at the given T.
// 太阳平近点角
//
// Argument T is the number of Julian centuries since J2000.
// See base.J2000Century.
//
// Result is not normalized to the range 0..2π.
func MeanAnomaly(T float64) unit.Angle {
    // (25.3) p. 163
    return unit.AngleFromDeg(base.Horner(T, 357.52911, 35999.05029, -0.0001537))
}

// Eccentricity returns eccentricity of the Earth&#39;s orbit around the sun.
// 地球轨道离心率
//
// Argument T is the number of Julian centuries since J2000.
// See base.J2000Century.
func Eccentricity(T float64) float64 {
    // (25.4) p. 163
    return base.Horner(T, 0.016708634, -0.000042037, -0.0000001267)
}

// Radius returns the Sun-Earth distance in AU.
// 日地距离，单位为 AU
//
// Argument T is the number of Julian centuries since J2000.
// See base.J2000Century.
func Radius(T float64) float64 {
    _, ν := True(T)
    e := Eccentricity(T)
    // (25.5) p. 164
    return 1.000001018 * (1 - e*e) / (1 + e*ν.Cos())
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;太阳视黄经&lt;/p&gt;

&lt;p&gt;太阳视黄经$λ$ = 太阳真黄经$☉$ + 章动修正 + 光行差修正&lt;/p&gt;

&lt;p&gt;如果精度要求不高，可以采用以下公式：
\begin{cases}
Ω &amp;amp;= 125°.04 - 1934°.136T\\[2ex]
λ &amp;amp;= ☉ - 0°.00569 -0°.00478\sin Ω
\end{cases}&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// ApparentLongitude returns apparent longitude of the Sun referenced
// to the true equinox of date.
// 太阳视黄经，考虑了章动和光行差
//
// Argument T is the number of Julian centuries since J2000.
// See base.J2000Century.
//
// Result includes correction for nutation and aberration.
func ApparentLongitude(T float64) unit.Angle {
    Ω := node(T)
    s, _ := True(T)
    return s - unit.AngleFromDeg(.00569) -
        unit.AngleFromDeg(.00478).Mul(Ω.Sin())
}

func node(T float64) unit.Angle {
    return unit.AngleFromDeg(125.04 - 1934.136*T)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;J2000的太阳真黄经$☉_2000 = ☉ - 0°.01397(year-2000), 1900\leq year \leq 2100$&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// True2000 returns true geometric longitude and anomaly of the sun referenced to equinox J2000.
//
// Argument T is the number of Julian centuries since J2000.
// See base.J2000Century.
//
// Results are accurate to .01 degree for years 1900 to 2100.
//
// Results:
//  s = true geometric longitude, ☉
//  ν = true anomaly
// J2000的太阳真黄经，真近点角
func True2000(T float64) (s, ν unit.Angle) {
    s, ν = True(T)
    s -= unit.AngleFromDeg(.01397).Mul(T * 100)
    return
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;太阳地心赤经$α$，地心赤纬$δ$&lt;/p&gt;

&lt;p&gt;\begin{cases}
\tan α = \frac {\cos ε\sin ☉}{\cos ☉}\\[2ex]
\sin δ = \sin ε\sin ☉
\end{cases}&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// TrueEquatorial returns the true geometric position of the Sun as equatorial coordinates.
// 太阳真赤经，真赤纬
func TrueEquatorial(jde float64) (α unit.RA, δ unit.Angle) {
    s, _ := True(base.J2000Century(jde))
    ε := nutation.MeanObliquity(jde)
    ss, cs := s.Sincos()
    sε, cε := ε.Sincos()
    // (25.6, 25.7) p. 165
    α = unit.RAFromRad(math.Atan2(cε*ss, cs))
    δ = unit.Angle(math.Asin(sε * ss))
    return
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;太阳地心视赤经，视赤纬&lt;/p&gt;

&lt;p&gt;$☉$补上黄经章动及光行差得到太阳视黄经$λ$，$ε$补上交角章动$+0.00256\cos Ω$
\begin{cases}
\tan α = \frac {\cos ε\sin λ}{\cos λ}\\[2ex]
\sin δ = \sin ε\sin λ
\end{cases}&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// ApparentEquatorial returns the apparent position of the Sun as equatorial coordinates.
// 太阳视赤经，视赤纬
//
//  α: right ascension in radians
//  δ: declination in radians
func ApparentEquatorial(jde float64) (α unit.RA, δ unit.Angle) {
    T := base.J2000Century(jde)
    λ := ApparentLongitude(T)
    ε := nutation.MeanObliquity(jde)
    sλ, cλ := λ.Sincos()
    // (25.8) p. 165
    ε += unit.AngleFromDeg(.00256).Mul(node(T).Cos())
    sε, cε := ε.Sincos()
    α = unit.RAFromRad(math.Atan2(cε*sλ, cλ))
    δ = unit.Angle(math.Asin(sε * sλ))
    return
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2-高精度太阳黄经&#34;&gt;2. 高精度太阳黄经&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;太阳地心黄经，地心黄纬
先采用VSOP87理论计算地球位置得到地球的日心黄经$L$，黄纬$β$，日地距离$R$
再计算地心黄经$☉ = L + 180°$,黄纬$β=-B$&lt;br /&gt;
令$λ′ = ☉ - 1°.397T - 0°.00031T^2$&lt;br /&gt;
那么
\begin{cases}
Δ☉ = -0&amp;rdquo;.09033\\[2ex]
Δβ = +0&amp;rdquo;.03916(\cos(λ′) - \sin(λ′))
\end{cases}&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// TrueVSOP87 returns the true geometric position of the sun as ecliptic coordinates.
// 根据VSOP87理论计算太阳真黄经，真黄纬，日地距离
//
// Result computed by full VSOP87 theory.  Result is at equator and equinox
// of date in the FK5 frame.  It does not include nutation or aberration.
//
//  s: ecliptic longitude
//  β: ecliptic latitude
//  R: range in AU
func TrueVSOP87(e *pp.V87Planet, jde float64) (s, β unit.Angle, R float64) {
    l, b, r := e.Position(jde) //VSOP87算出的地球的日心黄经，黄纬，日地距离
    s = l + math.Pi
    // FK5 correction.
    λp := base.Horner(base.J2000Century(jde),
        s.Rad(), -1.397*math.Pi/180, -.00031*math.Pi/180)
    sλp, cλp := math.Sincos(λp)
    Δβ := unit.AngleFromSec(.03916).Mul(cλp - sλp)
    // (25.9) p. 166
    s -= unit.AngleFromSec(.09033)
    return s.Mod1(), Δβ - b, r
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;太阳地心视黄经&lt;/p&gt;

&lt;p&gt;与日心视黄经一样，对日心黄经进行章动和光行差修正
章动可以由章动公式求得，光行差可以由以下公式求得$$-20&amp;rdquo;.4898/R$$&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// ApparentVSOP87 returns the apparent position of the sun as ecliptic coordinates.
// 根据VSOP87理论计算太阳视黄经，视黄纬，日地距离，考虑了章动和光行差
// 即真黄经+黄经章动+光行差，真黄纬，日地距离不变
//
// Result computed by VSOP87, at equator and equinox of date in the FK5 frame,
// and includes effects of nutation and aberration.
//
//  λ: ecliptic longitude
//  β: ecliptic latitude
//  R: range in AU
func ApparentVSOP87(e *pp.V87Planet, jde float64) (λ, β unit.Angle, R float64) {
    // note: see duplicated code in ApparentEquatorialVSOP87.
    s, β, R := TrueVSOP87(e, jde)
    Δψ, _ := nutation.Nutation(jde)
    a := aberration(R)
    return s + Δψ + a, β, R
}

// Low precision formula.  The high precision formula is not implemented
// because the low precision formula already gives position results to the
// accuracy given on p. 165.  The high precision formula the represents lots
// of typing with associated chance of typos, and no way to test the result.
// 低精度光行差修正项
func aberration(R float64) unit.Angle {
    // (25.10) p. 167
    return unit.AngleFromSec(-20.4898).Div(R)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;太阳地心视赤经，视赤纬&lt;/p&gt;

&lt;p&gt;算法同低精度太阳地心视赤经，视赤纬一致&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// ApparentEquatorialVSOP87 returns the apparent position of the sun as equatorial coordinates.
// 根据VSOP87理论计算太阳视赤经，视赤纬，日地距离，考虑了章动和光行差
// 即先计算视黄经，视黄纬，此时考虑交角章动，用真黄赤交角转为赤道坐标
//
// Result computed by VSOP87, at equator and equinox of date in the FK5 frame,
// and includes effects of nutation and aberration.
//
//  α: right ascension
//  δ: declination
//  R: range in AU
func ApparentEquatorialVSOP87(e *pp.V87Planet, jde float64) (α unit.RA, δ unit.Angle, R float64) {
    // note: duplicate code from ApparentVSOP87 so we can keep Δε.
    // see also duplicate code in time.E().
    s, β, R := TrueVSOP87(e, jde)
    Δψ, Δε := nutation.Nutation(jde)
    a := aberration(R)
    λ := s + Δψ + a
    ε := nutation.MeanObliquity(jde) + Δε
    sε, cε := ε.Sincos()
    α, δ = coord.EclToEq(λ, β, sε, cε)
    return
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>天文算法22</title>
      <link>https://mooncaker816.github.io/2018/05/25/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9522/</link>
      <pubDate>Fri, 25 May 2018 08:04:20 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/05/25/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9522/</guid>
      <description>&lt;h1 id=&#34;第二十四章-reduction-of-ecliptical-elements-from-one-equinox-to-another-one&#34;&gt;第二十四章 Reduction of Ecliptical Elements from one Equinox to another one&lt;/h1&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;略&#34;&gt;略&lt;/h2&gt;</description>
    </item>
    
    <item>
      <title>天文算法21</title>
      <link>https://mooncaker816.github.io/2018/05/24/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9521/</link>
      <pubDate>Thu, 24 May 2018 20:01:23 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/05/24/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9521/</guid>
      <description>&lt;h1 id=&#34;第二十三章-apparent-place-of-a-star&#34;&gt;第二十三章 Apparent Place of a Star&lt;/h1&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-平-视位置&#34;&gt;1. 平，视位置&lt;/h2&gt;

&lt;p&gt;任意时刻恒星的平位置是：当观测者站在不动的太阳上（严格的说是太阳系的质心）看到它在天球上的视位置，并且，它的位置坐标涉及 Date 黄道平分点（或 Date 赤道平分点）。&lt;/p&gt;

&lt;p&gt;任意时刻恒星的视位置是：当观测者站在移动着的地心看到它在天球上的位置，其视坐标涉及瞬时赤道、黄道及分点&lt;/p&gt;

&lt;h2 id=&#34;2-平转视的影响因素&#34;&gt;2. 平转视的影响因素&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;恒星的自行运动&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第二十一章已经给出计算方法&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;岁差&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第二十一章已经给出计算方法&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;章动&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;赤经章动和赤纬章动&lt;/p&gt;

&lt;p&gt;\begin{cases}
Δα_1=(\cos ε+\sin ε\sin α\tan δ)Δψ-\cos α\tan δΔε\\[2ex]
Δδ_1 = \sin ε\cos αΔψ + \sin αΔε
\end{cases}
其中$Δψ,Δε$可以使用章动章节给出的方法计算，$ε$是平黄赤交角&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Nutation returns corrections due to nutation for equatorial coordinates
// of an object.
//
// Results are invalid for objects very near the celestial poles.
// 章动导致的赤道坐标修正
func Nutation(α unit.RA, δ unit.Angle, jd float64) (Δα1 unit.HourAngle, Δδ1 unit.Angle) {
	ε := nutation.MeanObliquity(jd)
	sε, cε := ε.Sincos()
	Δψ, Δε := nutation.Nutation(jd)
	sα, cα := α.Sincos()
	tδ := δ.Tan()
	// (23.1) p. 151
	Δα1 = unit.HourAngle((cε+sε*sα*tδ)*Δψ.Rad() - cα*tδ*Δε.Rad())
	Δδ1 = Δψ.Mul(sε*cα) + Δε.Mul(sα)
	return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;周年光行差&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;黄道周年光行差：&lt;br /&gt;
$λ,β$是恒星的黄经和黄纬，$K$是光行差常数（20&amp;rdquo;.49552），$Θ$是太阳真黄经(也叫几何黄经)，$e$是地球 轨道的离心率，$π$轨道近日点经度&lt;br /&gt;
\begin{cases}
Θ 可使用后续章节的方法计算\\[2ex]
e = 0.016708617 - 0.000042037T - 0.0000001236T^2\\[2ex]
π = 102°.93735 + 1°.71953T + 0°.00046T^2
\end{cases}
$T$是J2000.0起算的儒略世纪数
则
\begin{cases}
Δλ &amp;amp;= \frac {-K\cos (Θ-λ)+eK\cos (π-λ)}{\cos β}\\[2ex]
Δβ &amp;amp;= -K\sin β(\sin (Θ-λ)-e\sin (π-λ))
\end{cases}&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// κ is the constnt of aberration in radians.
var κ = unit.AngleFromSec(20.49552)

// longitude of perihelian of Earth&#39;s orbit.
// 近日点经度
func perihelion(T float64) unit.Angle {
	return unit.AngleFromDeg(base.Horner(T, 102.93735, 1.71946, .00046))
}
// EclipticAberration returns corrections due to aberration for ecliptic
// coordinates of an object.
// 光行差导致的黄道坐标的修正
func EclipticAberration(λ, β unit.Angle, jd float64) (Δλ, Δβ unit.Angle) {
	T := base.J2000Century(jd)
	s, _ := solar.True(T)      //太阳真黄经
	e := solar.Eccentricity(T) //地球轨道离心率
	π := perihelion(T)         //地球近日点经度
	sβ, cβ := β.Sincos()
	ssλ, csλ := (s - λ).Sincos()
	sπλ, cπλ := (π - λ).Sincos()
	// (23.2) p. 151
	Δλ = κ.Mul((e*cπλ - csλ) / cβ)
	Δβ = -κ.Mul(sβ * (ssλ - e*sπλ))
	return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;赤道周年光行差：
\begin{cases}
Δα_2 &amp;amp;= -K\frac {\cos α\cos Θ\cos ε + \sin α\sin Θ}{\cos δ} + eK\frac {\cos α\cos π\cos ε + \sin α\sin π}{\cos δ}\\[2ex]
Δδ_2 &amp;amp;= -K(\cos Θ\cos ε(\tan ε\cos δ - \sin α\sin δ)+\cos α\sin δ\sin Θ)\\[2ex]
&amp;amp;+eK(\cos π\cos ε(\tan ε\cos δ - \sin α\sin δ)+\cos α\sin δ\sin π)
\end{cases}&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Aberration returns corrections due to aberration for equatorial
// coordinates of an object.
// 光行差导致的赤道坐标的修正
func Aberration(α unit.RA, δ unit.Angle, jd float64) (Δα2 unit.HourAngle, Δδ2 unit.Angle) {
	ε := nutation.MeanObliquity(jd)
	T := base.J2000Century(jd)
	s, _ := solar.True(T)
	e := solar.Eccentricity(T)
	π := perihelion(T)
	sα, cα := α.Sincos()
	sδ, cδ := δ.Sincos()
	ss, cs := s.Sincos()
	sπ, cπ := π.Sincos()
	cε := ε.Cos()
	tε := ε.Tan()
	q1 := cα * cε
	// (23.3) p. 152
	Δα2 = unit.HourAngle(κ.Rad() * (e*(q1*cπ+sα*sπ) - (q1*cs + sα*ss)) / cδ)
	q2 := cε * (tε*cδ - sα*sδ)
	q3 := cα * sδ
	Δδ2 = κ.Mul(e*(cπ*q2+sπ*q3) - (cs*q2 + ss*q3))
	return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ron_Vondrak法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// AberrationRonVondrak uses the Ron-Vondrák expression to compute corrections
// due to aberration for equatorial coordinates of an object.
// RonVondrak方法计算光行差引起的赤道坐标的修正
func AberrationRonVondrak(α unit.RA, δ unit.Angle, jd float64) (Δα unit.HourAngle, Δδ unit.Angle) {
	T := base.J2000Century(jd)
	r := &amp;amp;rv{
		T:  T,
		L2: 3.1761467 + 1021.3285546*T,
		L3: 1.7534703 + 628.3075849*T,
		L4: 6.2034809 + 334.0612431*T,
		L5: 0.5995465 + 52.9690965*T,
		L6: 0.8740168 + 21.3299095*T,
		L7: 5.4812939 + 7.4781599*T,
		L8: 5.3118863 + 3.8133036*T,
		Lp: 3.8103444 + 8399.6847337*T,
		D:  5.1984667 + 7771.3771486*T,
		Mp: 2.3555559 + 8328.6914289*T,
		F:  1.6279052 + 8433.4661601*T,
	}
	var Xp, Yp, Zp float64
	// sum smaller terms first
	for i := 35; i &amp;gt;= 0; i-- {
		x, y, z := rvTerm[i](r)
		Xp += x
		Yp += y
		Zp += z
	}
	sα, cα := α.Sincos()
	sδ, cδ := δ.Sincos()
	// (23.4) p. 156
	Δα = unit.HourAngle((Yp*cα - Xp*sα) / (c * cδ))
	Δδ = unit.Angle(-((Xp*cα+Yp*sα)*sδ - Zp*cδ) / c)
	return
}

const c = 17314463350 // unit is 1e-8 AU / day

type rv struct {
	T, L2, L3, L4, L5, L6, L7, L8, Lp, D, Mp, F float64
}

type rvFunc func(*rv) (x, y, z float64)

var rvTerm = [36]rvFunc{
	func(r *rv) (x, y, z float64) { // 1
		sA, cA := math.Sincos(r.L3)
		return (-1719914-2*r.T)*sA - 25*cA,
			(25-13*r.T)*sA + (1578089+156*r.T)*cA,
			(10+32*r.T)*sA + (684185-358*r.T)*cA
	},
	func(r *rv) (x, y, z float64) { // 2
		sA, cA := math.Sincos(2 * r.L3)
		return (6434+141*r.T)*sA + (28007-107*r.T)*cA,
			(25697-95*r.T)*sA + (-5904-130*r.T)*cA,
			(11141-48*r.T)*sA + (-2559-55*r.T)*cA
	},
	func(r *rv) (x, y, z float64) { // 3
		sA, cA := math.Sincos(r.L5)
		return 715 * sA, 6*sA - 657*cA, -15*sA - 282*cA
	},
	func(r *rv) (x, y, z float64) { // 4
		sA, cA := math.Sincos(r.Lp)
		return 715 * sA, -656 * cA, -285 * cA
	},
	func(r *rv) (x, y, z float64) { // 5
		sA, cA := math.Sincos(3 * r.L3)
		return (486-5*r.T)*sA + (-236-4*r.T)*cA,
			(-216-4*r.T)*sA + (-446+5*r.T)*cA,
			-94*sA - 193*cA
	},
	func(r *rv) (x, y, z float64) { // 6
		sA, cA := math.Sincos(r.L6)
		return 159 * sA, 2*sA - 147*cA, -6*sA - 61*cA
	},
	func(r *rv) (x, y, z float64) { // 7
		cA := math.Cos(r.F)
		return 0, 26 * cA, -59 * cA
	},
	func(r *rv) (x, y, z float64) { // 8
		sA, cA := math.Sincos(r.Lp + r.Mp)
		return 39 * sA, -36 * cA, -16 * cA
	},
	func(r *rv) (x, y, z float64) { // 9
		sA, cA := math.Sincos(2 * r.L5)
		return 33*sA - 10*cA, -9*sA - 30*cA, -5*sA - 13*cA
	},
	func(r *rv) (x, y, z float64) { // 10
		sA, cA := math.Sincos(2*r.L3 - r.L5)
		return 31*sA + cA, sA - 28*cA, -12 * cA
	},
	func(r *rv) (x, y, z float64) { // 11
		sA, cA := math.Sincos(3*r.L3 - 8*r.L4 + 3*r.L5)
		return 8*sA - 28*cA, 25*sA + 8*cA, 11*sA + 3*cA
	},
	func(r *rv) (x, y, z float64) { // 12
		sA, cA := math.Sincos(5*r.L3 - 8*r.L4 + 3*r.L5)
		return 8*sA - 28*cA, -25*sA - 8*cA, -11*sA + -3*cA
	},
	func(r *rv) (x, y, z float64) { // 13
		sA, cA := math.Sincos(2*r.L2 - r.L3)
		return 21 * sA, -19 * cA, -8 * cA
	},
	func(r *rv) (x, y, z float64) { // 14
		sA, cA := math.Sincos(r.L2)
		return -19 * sA, 17 * cA, 8 * cA
	},
	func(r *rv) (x, y, z float64) { // 15
		sA, cA := math.Sincos(r.L7)
		return 17 * sA, -16 * cA, -7 * cA
	},
	func(r *rv) (x, y, z float64) { // 16
		sA, cA := math.Sincos(r.L3 - 2*r.L5)
		return 16 * sA, 15 * cA, sA + 7*cA
	},
	func(r *rv) (x, y, z float64) { // 17
		sA, cA := math.Sincos(r.L8)
		return 16 * sA, sA - 15*cA, -3*sA - 6*cA
	},
	func(r *rv) (x, y, z float64) { // 18
		sA, cA := math.Sincos(r.L3 + r.L5)
		return 11*sA - cA, -sA - 10*cA, -sA - 5*cA
	},
	func(r *rv) (x, y, z float64) { // 19
		sA, cA := math.Sincos(2*r.L2 - 2*r.L3)
		return -11 * cA, -10 * sA, -4 * sA
	},
	func(r *rv) (x, y, z float64) { // 20
		sA, cA := math.Sincos(r.L3 - r.L5)
		return -11*sA - 2*cA, -2*sA + 9*cA, -sA + 4*cA
	},
	func(r *rv) (x, y, z float64) { // 21
		sA, cA := math.Sincos(4 * r.L3)
		return -7*sA - 8*cA, -8*sA + 6*cA, -3*sA + 3*cA
	},
	func(r *rv) (x, y, z float64) { // 22
		sA, cA := math.Sincos(3*r.L3 - 2*r.L5)
		return -10 * sA, 9 * cA, 4 * cA
	},
	func(r *rv) (x, y, z float64) { // 23
		sA, cA := math.Sincos(r.L2 - 2*r.L3)
		return -9 * sA, -9 * cA, -4 * cA
	},
	func(r *rv) (x, y, z float64) { // 24
		sA, cA := math.Sincos(2*r.L2 - 3*r.L3)
		return -9 * sA, -8 * cA, -4 * cA
	},
	func(r *rv) (x, y, z float64) { // 25
		sA, cA := math.Sincos(2 * r.L6)
		return -9 * cA, -8 * sA, -3 * sA
	},
	func(r *rv) (x, y, z float64) { // 26
		sA, cA := math.Sincos(2*r.L2 - 4*r.L3)
		return -9 * cA, 8 * sA, 3 * sA
	},
	func(r *rv) (x, y, z float64) { // 27
		sA, cA := math.Sincos(3*r.L3 - 2*r.L4)
		return 8 * sA, -8 * cA, -3 * cA
	},
	func(r *rv) (x, y, z float64) { // 28
		sA, cA := math.Sincos(r.Lp + 2*r.D - r.Mp)
		return 8 * sA, -7 * cA, -3 * cA
	},
	func(r *rv) (x, y, z float64) { // 29
		sA, cA := math.Sincos(8*r.L2 - 12*r.L3)
		return -4*sA - 7*cA, -6*sA + 4*cA, -3*sA + 2*cA
	},
	func(r *rv) (x, y, z float64) { // 30
		sA, cA := math.Sincos(8*r.L2 - 14*r.L3)
		return -4*sA - 7*cA, 6*sA - 4*cA, 3*sA - 2*cA
	},
	func(r *rv) (x, y, z float64) { // 31
		sA, cA := math.Sincos(2 * r.L4)
		return -6*sA - 5*cA, -4*sA + 5*cA, -2*sA + 2*cA
	},
	func(r *rv) (x, y, z float64) { // 32
		sA, cA := math.Sincos(3*r.L2 - 4*r.L3)
		return -sA - cA, -2*sA - 7*cA, sA - 4*cA
	},
	func(r *rv) (x, y, z float64) { // 33
		sA, cA := math.Sincos(2*r.L3 - 2*r.L5)
		return 4*sA - 6*cA, -5*sA - 4*cA, -2*sA - 2*cA
	},
	func(r *rv) (x, y, z float64) { // 34
		sA, cA := math.Sincos(3*r.L2 - 3*r.L3)
		return -7 * cA, -6 * sA, -3 * sA
	},
	func(r *rv) (x, y, z float64) { // 35
		sA, cA := math.Sincos(2*r.L3 - 2*r.L4)
		return 5*sA - 5*cA, -4*sA - 5*cA, -2*sA - 2*cA
	},
	func(r *rv) (x, y, z float64) { // 36
		sA, cA := math.Sincos(r.Lp - 2*r.D)
		return 5 * sA, -5 * cA, -2 * cA
	},
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;周年视差&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;该算法忽略&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>天文算法20</title>
      <link>https://mooncaker816.github.io/2018/05/23/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9520/</link>
      <pubDate>Wed, 23 May 2018 16:58:54 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/05/23/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9520/</guid>
      <description>&lt;h1 id=&#34;第二十二章-章动和黄赤交角-nutation-and-the-obliquity-of-the-ecliptic&#34;&gt;第二十二章 章动和黄赤交角 Nutation and the Obliquity of the Ecliptic&lt;/h1&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-名词解释&#34;&gt;1. 名词解释&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E7%AB%A0%E5%8B%95&#34; target=&#34;_blank&#34;&gt;章动&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;2-章动的分量&#34;&gt;2. 章动的分量&lt;/h2&gt;

&lt;p&gt;　　章动可以很容易的分解为黄道的水平分量和的垂直分量。黄道上的分量记为$Δψ$，称为黄经章动；它影响了天球上所有天体的经度。黄道的垂直分量记为$Δε$，称为交角章动，它影响了黄赤交角。&lt;/p&gt;

&lt;h2 id=&#34;3-较精确计算章动&#34;&gt;3. 较精确计算章动&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Nutation returns nutation in longitude (Δψ) and nutation in obliquity (Δε)
// for a given JDE.
//
// JDE = UT + ΔT, see package deltat.
//
// Computation is by 1980 IAU theory, with terms &amp;lt; .0003″ neglected.
// 计算 jde 对应的章动
func Nutation(jde float64) (Δψ, Δε unit.Angle) {
	T := base.J2000Century(jde)
	D := base.Horner(T,
		297.85036, 445267.11148, -0.0019142, 1./189474) * math.Pi / 180
	M := base.Horner(T,
		357.52772, 35999.050340, -0.0001603, -1./300000) * math.Pi / 180
	N := base.Horner(T,
		134.96298, 477198.867398, 0.0086972, 1./56250) * math.Pi / 180
	F := base.Horner(T,
		93.27191, 483202.017538, -0.0036825, 1./327270) * math.Pi / 180
	Ω := base.Horner(T,
		125.04452, -1934.136261, 0.0020708, 1./450000) * math.Pi / 180
	// sum in reverse order to accumulate smaller terms first
	var Δψs, Δεs float64
	for i := len(table22A) - 1; i &amp;gt;= 0; i-- {
		row := table22A[i]
		arg := row.d*D + row.m*M + row.n*N + row.f*F + row.ω*Ω
		s, c := math.Sincos(arg)
		Δψs += s * (row.s0 + row.s1*T)
		Δεs += c * (row.c0 + row.c1*T)
	}
	Δψ = unit.AngleFromSec(Δψs * .0001)
	Δε = unit.AngleFromSec(Δεs * .0001)
	return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;4-粗略计算章动&#34;&gt;4. 粗略计算章动&lt;/h2&gt;

&lt;p&gt;Δψ精度为0.5″,Δε精度为0.1″&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// ApproxNutation returns a fast approximation of nutation in longitude (Δψ)
// and nutation in obliquity (Δε) for a given JDE.
//
// Accuracy is 0.5″ in Δψ, 0.1″ in Δε.
// 精度要求为0.5″ in Δψ, 0.1″ in Δε
func ApproxNutation(jde float64) (Δψ, Δε unit.Angle) {
	T := (jde - base.J2000) / 36525
	Ω := (125.04452 - 1934.136261*T) * math.Pi / 180
	L := (280.4665 + 36000.7698*T) * math.Pi / 180
	N := (218.3165 + 481267.8813*T) * math.Pi / 180
	sΩ, cΩ := math.Sincos(Ω)
	s2L, c2L := math.Sincos(2 * L)
	s2N, c2N := math.Sincos(2 * N)
	s2Ω, c2Ω := math.Sincos(2 * Ω)
	Δψ = unit.AngleFromSec(-17.2*sΩ - 1.32*s2L - 0.23*s2N + 0.21*s2Ω)
	Δε = unit.AngleFromSec(9.2*cΩ + 0.57*c2L + 0.1*c2N - 0.09*c2Ω)
	return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;5-黄赤交角&#34;&gt;5. 黄赤交角&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;平黄赤交角$ε_0$：黄道与平赤道的夹角&lt;/p&gt;

&lt;p&gt;$$ε_0 = 23°26&amp;rsquo;21&amp;rdquo;.448 - 46&amp;rdquo;.8150T - 0&amp;rdquo;.00059T^2 + 0&amp;rdquo;.001813T^3$$&lt;/p&gt;

&lt;p&gt;T是J2000.0起算的儒略世纪数&lt;/p&gt;

&lt;p&gt;　　当时间范围很长，上述公式的精度并不令人满意：2000年误差1&amp;rdquo;，4000误差为10&amp;rdquo;。Laskar提供了以下改良的的公式，式中U是J2000.0起算的儒略万年数，即U=T/100：
\begin{align}
ε_0 =&amp;amp; 23°26&amp;rsquo;21&amp;rdquo;.448 - 4680&amp;rdquo;.93U - 1.55U^2 + 1999.25U^3 - 51.38U^4 - 249.67U^5 \\[2ex]
&amp;amp;-39.05U^6 + 7.12U^7 + 27.87U^8 + 5.79U^9 + 2.45U^{10}
\end{align}
　　该表达式的精度是：1000年后误差0&amp;rdquo;.01(公元 1000 到 3000)，10000年后误差数个角秒。&lt;br /&gt;
　　&lt;strong&gt;该表达式适用于|U|&amp;lt;1，即 J2000.0 起算前后各 10000 年的范围内。&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// MeanObliquity returns mean obliquity (ε₀) following the IAU 1980
// polynomial.
//
// Accuracy is 1″ over the range 1000 to 3000 years and 10″ over the range
// 0 to 4000 years.
// 平黄赤交角 - 精度一般，2000年误差 1&amp;quot;，4000年误差为 10&amp;quot;
func MeanObliquity(jde float64) unit.Angle {
    // (22.2) p. 147
    return unit.AngleFromSec(base.Horner(base.J2000Century(jde),
        unit.FromSexaSec(&#39; &#39;, 23, 26, 21.448),
        -46.815,
        -0.00059,
        0.001813))
}

// MeanObliquityLaskar returns mean obliquity (ε₀) following the Laskar
// 1986 polynomial.
//
// Accuracy over the range 1000 to 3000 years is .01″.
//
// Accuracy over the valid date range of -8000 to +12000 years is
// &amp;quot;a few seconds.&amp;quot;
// 平黄赤交角 - 精度较好，1000年后误差0&amp;quot;.01(公元 1000 到 3000)，10000年后误差数个角秒
// 适用范围：J2000.0 起算前后各10000年的范围内。
func MeanObliquityLaskar(jde float64) unit.Angle {
    // (22.3) p. 147
    return unit.AngleFromSec(base.Horner(base.J2000Century(jde)*.01,
        unit.FromSexaSec(&#39; &#39;, 23, 26, 21.448),
        -4680.93,
        -1.55,
        1999.25,
        -51.38,
        -249.67,
        -39.05,
        7.12,
        27.87,
        5.79,
        2.45))
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;真黄赤交角：黄道与真赤道的夹角&lt;/p&gt;

&lt;p&gt;$$ε = ε_0 + Δε$$&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
  </channel>
</rss>
