<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Mooncaker816 on Mooncaker816</title>
    <link>https://mooncaker816.github.io/</link>
    <description>Recent content in Mooncaker816 on Mooncaker816</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <copyright>&amp;copy; 2018-Present</copyright>
    <lastBuildDate>Wed, 20 Apr 2016 00:00:00 +0800</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>天文算法12</title>
      <link>https://mooncaker816.github.io/2018/05/20/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9512/</link>
      <pubDate>Sun, 20 May 2018 10:13:34 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/05/20/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9512/</guid>
      <description>&lt;h1 id=&#34;第十四章-the-parallactic-angle&#34;&gt;第十四章 The Parallactic Angle&lt;/h1&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-什么是parallactic-angle&#34;&gt;1. 什么是Parallactic Angle&lt;/h2&gt;

&lt;p&gt;　　&lt;strong&gt;&lt;em&gt;Parallactic is NOT Parallax&lt;/em&gt;&lt;/strong&gt;&lt;br /&gt;
　　这里所说的 Parallactic Angle 并不是 Parallax，Parallax是从两个不同的视点看同一物体时这两条视线之间的夹角(或半角)，主要用来测定物体的距离，如&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E7%A7%92%E5%B7%AE%E8%B7%9D&#34; target=&#34;_blank&#34;&gt;秒差距&lt;/a&gt;这一距离单位就是利用视差角来定义的。&lt;br /&gt;
　　In spherical astronomy, the parallactic angle is the angle between the great circle through a celestial object and the zenith(&lt;strong&gt;天体与天顶所在的大圆，即天球地平经线&lt;/strong&gt;), and the hour circle of the object（&lt;strong&gt;天体的时角，即天球赤道经线&lt;/strong&gt;）.It is usually denoted q. In the triangle zenith—object—celestial pole, the parallactic angle will be the position angle of the zenith at the celestial object. Despite its name, this angle is unrelated with parallax. The parallactic angle is zero when the object crosses the meridian.&lt;br /&gt;
　　换句话说，就是天体地平经线与天体赤道经线之间的角度。&lt;/p&gt;

&lt;h2 id=&#34;2-计算parallactic-angle&#34;&gt;2. 计算Parallactic Angle&lt;/h2&gt;

&lt;p&gt;$$\tan q=\frac {\sin H}{\tan φ\cos δ -\sin δ\cos H}$$
　　式中，$φ$是观测站地理纬度,$δ$是天体的赤纬，$H$是该时刻的时角。&lt;/p&gt;

&lt;p&gt;如何推导？&lt;br /&gt;
&lt;img src=&#34;https://mooncaker816.github.io/img/triangle.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如上图，P为天球极点，Z为天顶，X为观测目标，此时观测点为球心（地平坐标系），&lt;br /&gt;
由观测站地理纬度$φ$可知，弧长
$\newcommand{arc}[1]{\stackrel{\Large\frown}{#1}}\arc{PZ}= 90°-φ$,&lt;br /&gt;
由天体的赤纬$δ$可知，弧长
$\newcommand{arc}[1]{\stackrel{\Large\frown}{#1}}\arc{PX}= 90°-δ$,&lt;br /&gt;
由天体的时角$H$可知，球面角
$\angle ZPX = H$,&lt;br /&gt;
假设 X 的仰角为$a$,则弧长
$\newcommand{arc}[1]{\stackrel{\Large\frown}{#1}}\arc{ZX}= 90°-a$,&lt;br /&gt;
根据球面余弦公式，我们有
\begin{cases}
\cos (90°-a) &amp;amp;= \cos (90°-φ)\cos (90°-δ) + \sin (90°-φ)\sin (90°-δ)\cos H\\[2ex]
\cos (90°-φ) &amp;amp;= \cos (90°-a)\cos (90°-δ) + \sin (90°-a)\sin (90°-δ)\cos q
\end{cases}
即
\begin{cases}
\sin a &amp;amp;= \sin φ\sin δ + \cos φ\cos δ\cos H, &amp;amp;(1)\\[2ex]
\sin φ &amp;amp;= \sin a\sin δ + \cos a\cos δ\cos q, &amp;amp;(2)
\end{cases}
根据正弦公式，我们有$$\frac {\sin H}{\cos a} = \frac {\sin q}{\cos φ},\ \ \ (3)$$
由(2)(3)可得
\begin{align}
\tan q &amp;amp;= \frac {\sin q}{\cos q}\\[2ex]
&amp;amp; = \frac {\frac {\sin H\cos φ}{\cos a}}{\frac {\sin φ-\sin a\sin δ}{\cos a\cos δ}}\\[2ex]
&amp;amp; = \frac {\sin H\cos φ\cos δ}{\sin φ-\sin a\sin δ}
\end{align}
再将(1)代入上式中，
\begin{align}
\tan q &amp;amp; = \frac {\sin H\cos φ\cos δ}{\sin φ-\sin δ(\sin φ\sin δ + \cos φ\cos δ\cos H)}\\[2ex]
&amp;amp; = \frac {\sin H\cos φ\cos δ}{\sin φ\cos^2δ - \cos φ\cos δ\sin δ\cos H}\\[2ex]
&amp;amp; = \frac {\sin H}{\tan φ\cos δ - \sin δ\cos H}
\end{align}
得证&lt;/p&gt;

&lt;p&gt;　　当天体位于中天时恰好与天顶重合，则有$δ=φ$，此时$\tan q = \frac 00$，没有意义，也就是说角度由-90°跳到90°。&lt;br /&gt;
　　当天体位于地平线上时，即$a=0°$时，由(2)式直接可得$$\cos q = \frac {\sin φ}{\cos δ}$$
与时角$H$无关&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// ParallacticAngle returns parallactic angle of a celestial object.
//
//	φ is geographic latitude of observer.观测点地理纬度
//	δ is declination of observed object.天体赤纬
//	H is hour angle of observed object.天体赤经（时角）
//  计算天体的Parallactic Angle
func ParallacticAngle(φ, δ unit.Angle, H unit.HourAngle) unit.Angle {
	sδ, cδ := δ.Sincos()
	sH, cH := H.Sincos()
	// (14.1) p. 98
	return unit.Angle(math.Atan2(sH, φ.Tan()*cδ-sδ*cH))
}

// ParallacticAngleOnHorizon is a special case of ParallacticAngle.
//
// The hour angle is not needed as an input and the math inside simplifies.
// 当天体位于地平线上时，计算Parallactic Angle，与时角无关
func ParallacticAngleOnHorizon(φ, δ unit.Angle) unit.Angle {
	return unit.Angle(math.Acos(φ.Sin() / δ.Cos()))
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>天文算法11</title>
      <link>https://mooncaker816.github.io/2018/05/19/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9511/</link>
      <pubDate>Sat, 19 May 2018 15:04:04 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/05/19/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9511/</guid>
      <description>&lt;h1 id=&#34;第十三章-坐标的转换-transformation-of-coordinates&#34;&gt;第十三章 坐标的转换 Transformation of Coordinates&lt;/h1&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-天球坐标系统&#34;&gt;1. 天球坐标系统&lt;/h2&gt;

&lt;p&gt;　　天球坐标系统，是天文学上用来描绘天体在天球上位置的坐标系统。有许多不同的坐标系统都使用球面坐标投影在天球上，类似于使用在地球表面的地理坐标系统。这些坐标系统的不同处只在用来将天空分割成两个相等半球的大圆，也就是基面的不同。例如，地理坐标系统的基面是地球的赤道。每个坐标系统的命名都是依据其所选择的基面。&lt;/p&gt;

&lt;p&gt;\begin{array}{c|ccc}
坐标系统 &amp;amp; 基面 &amp;amp; 极 &amp;amp; 坐标 \\&lt;br /&gt;
\hline
地平 &amp;amp; 地平面 &amp;amp; 天顶/天底 &amp;amp; 高度（也称为仰角） - 方位 - 子午圈 \\&lt;br /&gt;
赤道 &amp;amp; 天球赤道 &amp;amp; 天极 &amp;amp; 赤纬 - 赤经或时角 \\&lt;br /&gt;
黄道 &amp;amp; 黄道 &amp;amp; 黄极 &amp;amp; 黄纬 - 黄经 \\&lt;br /&gt;
银河 &amp;amp; 银河平面 &amp;amp; 银极 &amp;amp; 银经 - 银纬 \\&lt;br /&gt;
超星系 &amp;amp; 超星系平面 &amp;amp;  &amp;amp;  \\&lt;br /&gt;
\end{array}&lt;/p&gt;

&lt;h2 id=&#34;2-地平坐标系&#34;&gt;2. 地平坐标系&lt;/h2&gt;

&lt;p&gt;　　地平坐标系，又作地平座标系，是天球坐标系统中的一种，以观测者所在地为中心点，所在地的地平线作为基础平面，将天球适当的分成能看见的上半球和看不见（被地球本身遮蔽）的下半球。上半球的顶点（最高点）称为天顶，下半球的顶点（最低点）称为地底。&lt;/p&gt;

&lt;p&gt;地平坐标系统是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;高度角（Altitude, Alt）或仰角又称地平纬度，是天体和观测者所在地的地平线的夹角，有时就称为高度或海拔标高（elevation, geometric height）。&lt;/li&gt;
&lt;li&gt;方位角（Azimuth, Az）又称地平经度，是沿着地平线测量的角度（由正北方为起点向东方测量）。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因此地平坐标系有时也被称为高度/方位（Alt/Az）坐标系统。
&lt;img src=&#34;https://kotobank.jp/image/dictionary/daijisen/media/103135.jpg&#34; alt=&#34;地平坐标系&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;注：方位角的测量可以从北点向东测量，也可从南点向西测量，两者相差180°。天文学家习惯从南点开始测量。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;3-赤道坐标系&#34;&gt;3. 赤道坐标系&lt;/h2&gt;

&lt;p&gt;　　赤道坐标系统，又作赤道座标系统，大概是使用得最广泛的天球坐标系统，他的元素是:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;赤纬Declination（ $\delta$ ）&lt;/li&gt;
&lt;li&gt;赤经Right ascension（ $\alpha$ ）－也记为RA&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　他与地理坐标系统非常相似，因为两者使用相同的基准平面和相同的极点。地球的赤道在天球上的投影就称为天球赤道，相同的，地理极点在天球上的投影就是天极。&lt;/p&gt;

&lt;p&gt;他有两种变化：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;时角系统像地理坐标系统一样，被固定在地球的表面上。&lt;/li&gt;
&lt;li&gt;赤经系统被固定于恒星上(实际上并非如此，请参考岁差和章动)。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因此，在经过一夜或数个夜晚，就能看出来星星在天空中的位置移动了，当然，这并非恒星在天球上的运动，只是地球运动造成的。因为岁差和章动的影响，在相当长的时间间隔下所做的观测，就必须注明所使用的特殊历元，为行星、恒星、星系等等的位置做记录。现在使用的历元是J2000.0分点，稍早期使用的是B1950.0分点。&lt;/p&gt;

&lt;p&gt;赤道坐标系统中与纬度相似的值是赤纬(缩写为Dec.)，是天体在天球赤道上方或下方的角度。与经度对应的是赤经(缩写为RA)，是与春分点的角度距离，不同于经度的是赤经以时、分、秒为单位，而非度、分、秒。因为地球的运动造成赤道坐标系统的视运动，就会造成恒星时和时角的相对变化。将天球运转一周的时间定为24小时，所以每小时天球会转动15度(360º / 24h = 15)。&lt;/p&gt;

&lt;p&gt;赤道坐标系统也是赤道仪上很普通的设备，也就是定位圈。定位圈与星图或星历表上的位置结合，可以让赤道仪很容易的指向已知天体在天球上的位置。
&lt;img src=&#34;https://kotobank.jp/image/dictionary/daijisen/media/103123.jpg&#34; alt=&#34;赤道坐标系&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;4-黄道坐标系&#34;&gt;4. 黄道坐标系&lt;/h2&gt;

&lt;p&gt;黄道是由地球上观察太阳一年中在天球上的视运动所通过的路径，若以地球“不动”作参照的话就是太阳绕地球公转的轨道平面（黄道面）在天球上的投影。&lt;/p&gt;

&lt;p&gt;黄道与天赤道相交于两点：春分点与秋分点（这两点称二分点）；而黄道对应的两个几何极是北黄极（在天龙座）、与南黄极 (在剑鱼座)。&lt;/p&gt;

&lt;p&gt;在黄道上与黄道平行的小圆称黄纬，符号β，以由黄道面向北黄极方向为正值（0°至90°），向南黄极方向则为负值。垂直黄道的经度称黄经，符号为λ，由春分点起由西向东量度（0°至360°）。像赤道坐标系中的赤经一样，以春分点做为黄经的起点。&lt;/p&gt;

&lt;p&gt;因为地轴有进动现象，此坐标系的两个黄极亦会因岁差影响而使坐标数值逐渐移动，计算时必须说明坐标系参照的历元。现常采用的是J2000.0历元（之前的出版物多以B1950.0历元），在天文年历这类精度较高的刊物中，则参考当天或当月之瞬时分点计算。&lt;/p&gt;

&lt;p&gt;此坐标系特别适合标示太阳系内天体的位置，大多数行星（水星和冥王星除外）与许多小行星轨道平面与黄道的倾角都很小，故其黄纬值（β）都不大。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kotobank.jp/image/dictionary/daijisen/media/103079.jpg&#34; alt=&#34;黄道坐标系&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;5-坐标系转换&#34;&gt;5. 坐标系转换&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;$λ$和$β$代表黄经和黄纬&lt;/li&gt;
&lt;li&gt;$α$和$δ$代表赤经和赤纬&lt;/li&gt;
&lt;li&gt;$φ,A,h$代表观察者纬度，方位角，和仰角，其中默认A从南点向西测量&lt;/li&gt;
&lt;li&gt;$ε$黄赤交角&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;注：如果给定的为视坐标，在转换为本地地平坐标时要先将视赤经（时角）转换为本地时角。&lt;br /&gt;
例如：如果θ是本地恒星时，$θ_0$ 是格林尼治恒星时，L 是观者站经度（从格林尼治向西为正，东为负），那么本地时角为$ θ - α 或 θ_0 - L – α$&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;5-1-赤道转黄道-α-δ-rightarrow-λ-β&#34;&gt;5.1 赤道转黄道($α,δ\  \Rightarrow\  λ,β$)&lt;/h3&gt;

&lt;p&gt;\begin{align}
\sin β &amp;amp;=\cos ε\sin δ-\sin α\cos δ\sin ε\\[2ex]
\cos λ\cos β &amp;amp;=\cos α\cos δ\\[2ex]
\sin λ\cos β &amp;amp;=\sin ε\sin δ+\sin α\cos δ\cos ε
\end{align}&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Obliquity represents the obliquity of the ecliptic.
// 黄赤交角对应的 sin,cos 值
type Obliquity struct {
	S, C float64 // sine and cosine of obliquity
}

// NewObliquity constructs a new Obliquity.
//
// Struct members are initialized from the given value ε of the obliquity of
// the ecliptic.
// 计算黄赤交角对应的 sin,cos 值
func NewObliquity(ε unit.Angle) *Obliquity {
	r := &amp;amp;Obliquity{}
	r.S, r.C = ε.Sincos()
	return r
}

// Ecliptic coordinates are referenced to the plane of the ecliptic.
// 黄道坐标结构
type Ecliptic struct {
	Lon unit.Angle // Longitude (λ)黄经
	Lat unit.Angle // Latitude (β)黄纬
}

// EqToEcl converts equatorial coordinates to ecliptic coordinates.
// 赤道转黄道
func (ecl *Ecliptic) EqToEcl(eq *Equatorial, ε *Obliquity) *Ecliptic {
	ecl.Lon, ecl.Lat = EqToEcl(eq.RA, eq.Dec, ε.S, ε.C)
	return ecl
}

// EqToEcl converts equatorial coordinates to ecliptic coordinates.
//
//	α: right ascension coordinate to transform
//	δ: declination coordinate to transform
//	sε: sine of obliquity of the ecliptic
//	cε: cosine of obliquity of the ecliptic
//
// Results:
//
//	λ: ecliptic longitude黄经
//	β: ecliptic latitude黄纬
//  赤道转黄道
func EqToEcl(α unit.RA, δ unit.Angle, sε, cε float64) (λ, β unit.Angle) {
	sα, cα := α.Sincos()
	sδ, cδ := δ.Sincos()
	λ = unit.Angle(math.Atan2(sα*cε+(sδ/cδ)*sε, cα)) // (13.1) p. 93
	β = unit.Angle(math.Asin(sδ*cε - cδ*sε*sα))      // (13.2) p. 93
	return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;5-2-黄道转赤道-λ-β-rightarrow-α-δ&#34;&gt;5.2 黄道转赤道($λ,β\  \Rightarrow\  α,δ$)&lt;/h3&gt;

&lt;p&gt;\begin{align}
\sin δ &amp;amp;=\sin ε\sin λ\cos β+\cos ε\sin β\\[2ex]
\cos α\cos δ &amp;amp;=\cos λ\cos β\\[2ex]
\sin α\cos δ &amp;amp;=\cos ε\sin λ\cos β-\sin ε\sin β
\end{align}&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Equatorial coordinates are referenced to the Earth&#39;s rotational axis.
// 赤道坐标结构
type Equatorial struct {
	RA  unit.RA    // Right ascension (α)赤经（时角）
	Dec unit.Angle // Declination (δ)赤纬
}

// EclToEq converts ecliptic coordinates to equatorial coordinates.
// 黄道转赤道
func (eq *Equatorial) EclToEq(ecl *Ecliptic, ε *Obliquity) *Equatorial {
	eq.RA, eq.Dec = EclToEq(ecl.Lon, ecl.Lat, ε.S, ε.C)
	return eq
}

// EclToEq converts ecliptic coordinates to equatorial coordinates.
//
//	λ: ecliptic longitude coordinate to transform
//	β: ecliptic latitude coordinate to transform
//	sε: sine of obliquity of the ecliptic
//	cε: cosine of obliquity of the ecliptic
//
// Results:
//	α: right ascension赤经（时角）
//	δ: declination赤纬
// 黄道转赤道
func EclToEq(λ, β unit.Angle, sε, cε float64) (α unit.RA, δ unit.Angle) {
	sλ, cλ := λ.Sincos()
	sβ, cβ := β.Sincos()
	α = unit.RAFromRad(math.Atan2(sλ*cε-(sβ/cβ)*sε, cλ)) // (13.3) p. 93
	δ = unit.Angle(math.Asin(sβ*cε + cβ*sε*sλ))          // (13.4) p. 93
	return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;5-3-地平转赤道-φ-a-h-rightarrow-α-δ&#34;&gt;5.3 地平转赤道($φ,A,h\  \Rightarrow\  α,δ$)&lt;/h3&gt;

&lt;p&gt;\begin{align}
\sin δ &amp;amp;=\sin φ\sin h-\cos φ\cos h\cos A\\[2ex]
\cos δ\cos α &amp;amp;=-\cos φ\sin h-\sin φ\cos h\cos A\\[2ex]
\cos δ\sin α &amp;amp;=-\sin A\cos h
\end{align}&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// HzToEq transforms horizontal coordinates to equatorial coordinates.
//
// Sidereal time st must be consistent with the equatorial coordinates
// in the sense that if coordinates are apparent, sidereal time must be
// apparent as well.
// 地平转赤道
func (eq *Equatorial) HzToEq(hz *Horizontal, g globe.Coord, st unit.Time) *Equatorial {
	eq.RA, eq.Dec = HzToEq(hz.Az, hz.Alt, g.Lat, g.Lon, st)
	return eq
}

// HzToEq transforms horizontal coordinates to equatorial coordinates.
//
//	A: azimuth方位角
//	h: elevation仰角
//	φ: latitude of observer on Earth观测纬度
//	ψ: longitude of observer on Earth观测经度
//	st: sidereal time at Greenwich at time of observation.恒星时
//
// Sidereal time must be consistent with the equatorial coordinates
// in the sense that tf coordinates are apparent, sidereal time must be
// apparent as well.
// 恒星时必须和所给条件保持一致
//
// Results:
//
//	α: right ascension赤经（时角）
//	δ: declination赤纬
// 地平转赤道
func HzToEq(A, h, φ, ψ unit.Angle, st unit.Time) (α unit.RA, δ unit.Angle) {
	sA, cA := A.Sincos()
	sh, ch := h.Sincos()
	sφ, cφ := φ.Sincos()
	H := math.Atan2(sA, cA*sφ+sh/ch*cφ)
	α = unit.RAFromRad(st.Rad() - ψ.Rad() - H)
	δ = unit.Angle(math.Asin(sφ*sh - cφ*ch*cA))
	return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;5-4-赤道转地平-φ-α-δ-rightarrow-a-h&#34;&gt;5.4 赤道转地平($φ,α,δ\  \Rightarrow\  A,h$)&lt;/h3&gt;

&lt;p&gt;\begin{align}
\sin h &amp;amp;= \sin φ\sin δ+\cos φ\cos δ\cos α\\[2ex]
\cos A\cos h &amp;amp;=-\cos φ\sin δ+\sin φ\cos δ\cos α\\[2ex]
\sin A\cos h &amp;amp;=\cos δ\sin α
\end{align}&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Horizontal coordinates are referenced to the local horizon of an observer
// on the surface of the Earth.
// 地平坐标结构
type Horizontal struct {
	Az  unit.Angle // Azimuth (A)方位角
	Alt unit.Angle // Altitude (h)仰角
}

// EqToHz computes Horizontal coordinates from equatorial coordinates.
//
// Argument g is the location of the observer on the Earth.  Argument st
// is the sidereal time at Greenwich.
//
// Sidereal time must be consistent with the equatorial coordinates.
// If coordinates are apparent, sidereal time must be apparent as well.
// 赤道转地平
func (hz *Horizontal) EqToHz(eq *Equatorial, g *globe.Coord, st unit.Time) *Horizontal {
	hz.Az, hz.Alt = EqToHz(eq.RA, eq.Dec, g.Lat, g.Lon, st)
	return hz
}

// EqToHz computes Horizontal coordinates from equatorial coordinates.
//
//	α: right ascension coordinate to transform
//	δ: declination coordinate to transform
//	φ: latitude of observer on Earth
//	ψ: longitude of observer on Earth
//	st: sidereal time at Greenwich at time of observation.
//
// Sidereal time must be consistent with the equatorial coordinates.
// If coordinates are apparent, sidereal time must be apparent as well.
//
// Results:
//
//	A: azimuth of observed point, measured westward from the South.
//	h: elevation, or height of observed point above horizon.
// 赤道转地平
func EqToHz(α unit.RA, δ, φ, ψ unit.Angle, st unit.Time) (A, h unit.Angle) {
	H := st.Rad() - ψ.Rad() - α.Rad()
	sH, cH := math.Sincos(H)
	sφ, cφ := φ.Sincos()
	sδ, cδ := δ.Sincos()
	A = unit.Angle(math.Atan2(sH, cH*sφ-(sδ/cδ)*cφ)) // (13.5) p. 93
	h = unit.Angle(math.Asin(sφ*sδ + cφ*cδ*cH))      // (13.6) p. 93
	return
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>天文算法10</title>
      <link>https://mooncaker816.github.io/2018/05/19/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9510/</link>
      <pubDate>Sat, 19 May 2018 09:20:12 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/05/19/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9510/</guid>
      <description>&lt;h1 id=&#34;第十二章-格林威治恒星时-sidereal-time-at-greenwich&#34;&gt;第十二章 格林威治恒星时 Sidereal Time at Greenwich&lt;/h1&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-恒星时&#34;&gt;1. 恒星时&lt;/h2&gt;

&lt;p&gt;　　&lt;strong&gt;恒星时是天文学和大地测量学标示的天球子午圈值&lt;/strong&gt;，由于借用了时间的计量单位，所以常被误解为是一种时间单位。恒星时是根据地球自转来计算的，它的基础是恒星日（比地球的自转周期短约8.4毫秒）。由于地球环绕太阳的公转运动，恒星日比平太阳日（也就是日常生活中所使用的日）短约1/365（相应约四分钟或一度）。&lt;/p&gt;

&lt;p&gt;　　恒星时的定义是一个地方的子午圈与天球的春分点之间的时角，因此地球上每个地方的恒星时都与它的经度有关。&lt;/p&gt;

&lt;p&gt;　　由于地球的章动春分点在天球上并不固定，而是以18.6年的周期围绕着平均春分点摆动。因此恒星时又分真恒星时和平恒星时。真恒星时是通过直接测量子午线与实际的春分点之间的时角获得的，平恒星时则忽略了地球的章动。真恒星时与平恒星时之间的差异最大可达约0.4秒。&lt;/p&gt;

&lt;p&gt;　　一个地方的当地恒星时与格林尼治天文台的恒星时之间的差就是这个地方的经度（参见天体导航）。因此通过观测恒星时可以确定当地的经度（假如格林尼治天文台的恒星时已知的话）或者可以确定时间（假如当地的经度已知的话）。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;一颗恒星的时角$\tau$ 、它的赤经$α$和当地的恒星时$θ$之间的关系为 $\tau=\theta -\alpha$&lt;/li&gt;
&lt;li&gt;当地的恒星时等于位于天顶的恒星的赤经&lt;/li&gt;
&lt;li&gt;当地的恒星时等于正位于中天恒星的赤经&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　通过确定恒星时可以简化天文学的计算，比如通过恒星时和当地的纬度可以很方便地计算出哪些星正好在地平线以上。&lt;/p&gt;

&lt;h2 id=&#34;2-恒星时的计算&#34;&gt;2. 恒星时的计算&lt;/h2&gt;

&lt;h3 id=&#34;2-1-格林威治0h平恒星时&#34;&gt;2.1 格林威治0h平恒星时&lt;/h3&gt;

&lt;p&gt;　　一个给定的世界时日期的&lt;strong&gt;&lt;em&gt;(0h UT)&lt;/em&gt;&lt;/strong&gt;，格林尼治子午圈的平恒星时可按如下计算。&lt;br /&gt;
　　1. 先计算当天（0h UT）对应的$JD$&lt;br /&gt;
　　2. 计算$T = \frac {JD - 2451545.0}{36525}$&lt;br /&gt;
　　3. 采用 &lt;strong&gt;IAU1982&lt;/strong&gt; 的格林尼治子午圈的平恒星时表达式： $$θ_0 = 6h41m50s.54841 + 8640184s.812866T + 0s.093104T^2 - 0s.0000062T^3$$
　　4. 若以度为单位，则上式为：$$θ_0 = 100.46061837 + 36000.770053608T + 0.000387933T^2 - T^3 / 38710000$$&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;注意，上述公式只适用于(0h UT）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// jdToCFrac returns values for use in computing sidereal time at Greenwich.
//
// Cen is centuries from J2000 of the JD at 0h UT of argument jd.  This is
// the value to use for evaluating the IAU sidereal time polynomial.
// DayFrac is the fraction of jd after 0h UT.  It is used to compute the
// final value of sidereal time.
// 计算 T = cen，dayFrac 为此 jd 对应的天的小数
func jdToCFrac(jd float64) (cen, dayFrac float64) {
	j0, f := math.Modf(jd + .5)
	return base.J2000Century(j0 - .5), f
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// J2000Century returns the number of Julian centuries since J2000.
//
// The quantity appears as T in a number of time series.
func J2000Century(jde float64) float64 {
	// The formula is given in a number of places in the book, for example
	// (12.1) p. 87.
	// (22.1) p. 143.
	// (25.1) p. 163.
	return (jde - J2000) / JulianCentury
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Mean0UT returns mean sidereal time at Greenwich at 0h UT on the given JD.
//
// The result is in the range [0,86400).
// 计算格林威治 0h UT 平恒星时，并化简为单位为秒一天之内的值[0,86400).
func Mean0UT(jd float64) unit.Time {
	s, _ := mean0UT(jd)
	return s.Mod1()
}

// 计算格林威治 0h UT 平恒星时，并返回此 jd 一天中相对于0h的秒数，用于瞬时平恒星时的计算
func mean0UT(jd float64) (sidereal, dayFrac unit.Time) {
	cen, f := jdToCFrac(jd)
	// (12.2) p. 87
	return unit.Time(base.Horner(cen, iau82...)), unit.TimeFromDay(f)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-2-格林威治任意-ut-平恒星时&#34;&gt;2.2 格林威治任意 UT 平恒星时&lt;/h3&gt;

&lt;p&gt;　　1. 计算0h 平恒星时&lt;br /&gt;
　　2. UT * 1.00273790935&lt;br /&gt;
　　3. 1 + 2 的结果即为格林威治瞬时平恒星时&lt;br /&gt;
　　4. 若以度为单位，则：$$θ_0 = 280.46061837 + 360.98564736629(JD-2451545.0) + 0.000387933T^2 - T^3 / 38710000$$&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Mean returns mean sidereal time at Greenwich for a given JD.
//
// Computation is by IAU 1982 coefficients.
// The result is in the range [0,86400).
// 计算格林威治 jd 时刻的瞬时平恒星时,化简结果至一天范围之内
func Mean(jd float64) unit.Time {
	return mean(jd).Mod1()
}

// 计算格林威治 jd 时刻的瞬时平恒星时
func mean(jd float64) unit.Time {
	s, f := mean0UT(jd)
	return s + f*1.00273790935
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-3-格林威治视恒星时&#34;&gt;2.3 格林威治视恒星时&lt;/h3&gt;

&lt;p&gt;　　要取得视恒星时，即真春分点起算的格林尼治时角，应加上修正值 $Δψ\cos ε$，式中 $Δψ$ 是黄经章动，$ε$ 是真黄赤交角。这个修正值也就作赤经章动（也称作分点方程）。因为 $Δψ$ 是个小量，所以 $ε$ 误差 10&amp;rdquo;也没关系。&lt;br /&gt;
　　如果 $Δψ$ 的单位是角秒（1 度是 3600 秒），则以时秒(1 小时是 3600 秒)为单位的修正值是：$\frac {Δψ\cos ε}{15}$&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Apparent returns apparent sidereal time at Greenwich for the given JD.
//
// Apparent is mean plus the nutation in right ascension.
//
// The result is in the range [0,86400).
// 计算格林威治瞬时视恒星时
func Apparent(jd float64) unit.Time {
	s := mean(jd)                  // Time
	n := nutation.NutationInRA(jd) // HourAngle
	return (s + n.Time()).Mod1()
}

// Apparent0UT returns apparent sidereal time at Greenwich at 0h UT
// on the given JD.
//
// The result is in the range [0,86400).
// 计算格林威治0h UT视恒星时
func Apparent0UT(jd float64) unit.Time {
	j0, f := math.Modf(jd + .5)
	cen := (j0 - .5 - base.J2000) / 36525
	s := unit.Time(base.Horner(cen, iau82...)) +
		unit.TimeFromDay(f*1.00273790935)
	n := nutation.NutationInRA(j0) // HourAngle
	return (s + n.Time()).Mod1()
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>天文算法9</title>
      <link>https://mooncaker816.github.io/2018/05/18/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%959/</link>
      <pubDate>Fri, 18 May 2018 15:55:20 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/05/18/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%959/</guid>
      <description>&lt;h1 id=&#34;第十一章-地球球体-the-earth-s-globe&#34;&gt;第十一章 地球球体 The Earth&amp;rsquo;s Globe&lt;/h1&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-椭球体&#34;&gt;1. 椭球体&lt;/h2&gt;

&lt;p&gt;　　天文学上，通常我们将地球看做一个近似的椭球体。如下图，&lt;img src=&#34;http://www.tleer.cn/uploads/allimg/170224/2-1F224111032348.jpg&#34; alt=&#34;&#34; /&gt;
所以子午圈截面为一个椭圆。如下图，&lt;img src=&#34;https://mooncaker816.github.io/img/tuoyuan.png&#34; alt=&#34;&#34; /&gt;
　　假设上图中$C$为地心，$N$为北极，$S$为南极，$CF$为赤道半径，$NC = b, CF = a$,$O$为观察点，$HK$为地平面，$OP\perp HK$,$OM//SN$，$OM$与$OH$的夹角是$φ$，$CF$与$CO$的夹角是$φ&amp;rsquo;$，$CO$的长度为$\rho$&lt;br /&gt;
　　则$φ$为$O$点的&lt;strong&gt;地理纬度&lt;/strong&gt;，$\angle OPF = φ$，$φ&amp;rsquo;$为$O$点的&lt;strong&gt;地心纬度&lt;/strong&gt;,$\rho$为$O$点的&lt;strong&gt;地心半径&lt;/strong&gt;,在极点和赤道上$φ=φ′$，在其它纬度上$|φ′|&amp;lt;|φ|$&lt;br /&gt;
　　地心纬度$φ&amp;rsquo;$与地理纬度$φ$的关系为：$\tan φ′=\frac {b^2}{a^2} \tan φ，$(&lt;a href=&#34;https://baike.baidu.com/item/地心纬度&#34; target=&#34;_blank&#34;&gt;推导&lt;/a&gt;)&lt;br /&gt;
　　由椭球体扁率$f=\frac {a-b}a$,可知$b=a(1-f)$,子午圈椭圆离心率
\begin{align}
e &amp;amp;= \frac ca\\[2ex]
&amp;amp; = \frac {\sqrt {a^2-b^2}}{a}\\[2ex]
&amp;amp; = \sqrt {2f-f^2}
\end{align}
　　地心纬度$φ&amp;rsquo;$对应的归化纬度$u$,有
\begin{cases}
\tan φ&amp;rsquo; = \frac ba \tan u\\[2ex]
\tan u = \frac ba \tan φ\\[2ex]
\end{cases}
且
\begin{cases}
\rho \cos φ&amp;rsquo; = a\cos u, \ (相当于子午圈椭圆上观察点O的x坐标)\\[2ex]
\rho \sin φ&amp;rsquo; = b\sin u, \ (相当于子午圈椭圆上观察点O的y坐标)
\end{cases}
　　如果观察点的海拔高度为$H$,且$\rho$以赤道半径$a$为单位，则有
\begin{cases}
\rho \cos φ&amp;rsquo; = cos u + \frac Ha\cos φ\\[2ex]
\rho \sin φ&amp;rsquo; = \frac ba\sin u + \frac Ha\sin φ
\end{cases}&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Ellipsoid represents an ellipsoid of revolution.
//
// Typical unit for Er is Km.
// 地球椭球体
type Ellipsoid struct {
	Er float64 // equatorial radius 赤道半径
	Fl float64 // flattening 地球扁率
}

// IAU 1976 values.  Radius in Km.
var Earth76 = Ellipsoid{Er: 6378.14, Fl: 1 / 298.257}

// A returns equatorial radius in units of e.Er.
//
// A is a common identifier for equatorial radius.
// 子午圈椭圆长半轴（赤道半径）
func (e Ellipsoid) A() float64 {
	return e.Er
}

// B returns polar radius in units of e.ER.
//
// B is a common identifier for polar radius.
//
// 子午圈椭圆短半轴（地心到极点的距离）
func (e Ellipsoid) B() float64 {
	return e.Er * (1 - e.Fl)
}

// Eccentricity of a meridian.
// 子午圈椭圆离心率
func (e Ellipsoid) Eccentricity() float64 {
	return math.Sqrt((2 - e.Fl) * e.Fl)
}

// ParallaxConstants computes parallax constants ρ sin φ′ and ρ cos φ′.
//
// Arguments are geographic latitude φ and height h above the ellipsoid.
// For e.Er in Km, h must be in meters.
// 海拔为h的观察点对应的ρ sin φ′，ρ cos φ′
func (e Ellipsoid) ParallaxConstants(φ unit.Angle, h float64) (s, c float64) {
	boa := 1 - e.Fl
	su, cu := math.Sincos(math.Atan(boa * φ.Tan()))
	s, c = φ.Sincos()
	hoa := h * 1e-3 / e.Er
	return su*boa + hoa*s, cu + hoa*c
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2-其他椭球公式&#34;&gt;2. 其他椭球公式&lt;/h2&gt;

&lt;p&gt;　　在椭球上给定的一点，地理纬度与地心纬度的差值为：$φ - φ′ = 692&amp;rdquo;.73sin(2φ) - 1&amp;rdquo;.16sin(4φ)$&lt;br /&gt;
　　当$u=45°$时，$φ-φ′$达到最大值。 如果$φ_0$和$φ_0′$是此时相应的地理纬度和地心纬度，我们有：$$tan(φ_0) = a/b，tan(φ_0′) = b/a， φ_0+φ_0′=90°$$
对于&lt;strong&gt;&lt;em&gt;IAU1976&lt;/em&gt;&lt;/strong&gt;($a = 6378.14km,b = 6356.755km,f=\frac {1}{298.257}$)
有
\begin{align}
φ_0 = 45°05′46&amp;rdquo;.36,\\[2ex]
φ_0′ = 44°54′13&amp;rdquo;.64,\\[2ex]
φ_0 - φ_0′ = 11′32&amp;rdquo;.73
\end{align}
　　海平面上，$$\rho =0.9983271+0.0016764\cos {2φ}-0.0000035\cos {4φ}$$
　　同纬度$φ$的圆的半径：$$R_p = \frac {a\cos φ}{\sqrt{(1-e^2\sin^2φ)}}$$
　　因此，在同一纬度$φ$上，经度变化1度，相应的长度变化为$(π/180)R_p$,线速度为$ωR_p$,其中$ω = 7.292114992*10^{-5}(弧度/秒)$&lt;br /&gt;
　　地球子午圈的曲率半径，在纬度$φ$：$$R_m=\frac {a(1-e^2)}{(1-e^2\sin ^2 φ)^{\frac 32}}$$
且纬度变化1度，相应的长度变化：$(π/180)R_m$,在赤道时，$R_m$达到最小值，值为$a(1-e^2)=6335.44km$， 在极点时达到最大值，值为$\frac {a}{\sqrt {1-e^2}}=6399.60km$&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Rho is distance from Earth center to a point on the ellipsoid at latitude φ.
//
// Result unit is fraction of the equatorial radius.
// 海平面上，ρ值计算
func Rho(φ unit.Angle) float64 {
	// Magic numbers...
	return .9983271 + .0016764*φ.Mul(2).Cos() - .0000035*φ.Mul(4).Cos()
}

// RadiusAtLatitude returns the radius of the circle that is the parallel of
// latitude φ.
//
// Result unit is same as e.Er (typically Km.)
// 同纬度圆半径
func (e Ellipsoid) RadiusAtLatitude(φ unit.Angle) float64 {
	s, c := φ.Sincos()
	return e.A() * c / math.Sqrt(1-(2-e.Fl)*e.Fl*s*s)
}

// OneDegreeOfLongitude returns the length of one degree of longitude.
//
// Argument rp is the radius of a circle that is a parallel of latitude
// (as returned by Ellipsoid.RadiusAtLatitude.)
//
// Result is distance along one degree of the circle, in same units as rp.
// 同纬度，计算经度变化1度时长度变化的值
func OneDegreeOfLongitude(rp float64) float64 {
	return rp * math.Pi / 180
}

// RotationRate1996_5 is the rotational angular velocity of the Earth
// with respect to the stars at the epoch 1996.5.
//
// Unit is radian/second.
const RotationRate1996_5 = 7.292114992e-5

// RadiusOfCurvature of meridian at latitude φ.
//
// Result in units of e.ER, typically Km.
// 纬度为φ，子午圈曲率半径
func (e Ellipsoid) RadiusOfCurvature(φ unit.Angle) float64 {
	s := φ.Sin()
	e2 := (2 - e.Fl) * e.Fl
	return e.A() * (1 - e2) / math.Pow(1-e2*s*s, 1.5)
}

// OneDegreeOfLatitude returns the length of one degree of latitude.
//
// Argument rm is the radius of curvature along a meridian.
// (as returned by Ellipsoid.RadiusOfCurvature.)
// Result is distance in units of rm along one degree of the meridian.
// 同经度，计算纬度变化1度时长度变化的值
func OneDegreeOfLatitude(rm float64) float64 {
	return rm * math.Pi / 180
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;3-地表两点间的距离&#34;&gt;3. 地表两点间的距离&lt;/h2&gt;

&lt;p&gt;　　假设经纬度是分别是$(L_1,φ_1),(L_2,φ_2)$，且这两点在海平面。
　　如果精度要求不高，可以把地球看作球形，平均半径为6371km。使用下式可得到两点间的角距离：$$\cos d=\sin φ_1\sin φ_2 +\cos φ_1\cos φ_2\cos(L_1-L_2)$$
那么$$s = \frac {6371πd}{180}$$
　　高精度计算可使用以下方法：
$$F=\frac {φ_1+φ_2}{2},G=\frac {φ_1-φ_2}{2},\lambda = \frac {L_1-L_2}{2}$$
$$S = \sin^2G\cos^2\lambda+\cos^2F\sin^2\lambda$$
$$C = \cos^2G\cos^2\lambda+\sin^2F\sin^2\lambda$$
$$\tan ω = \sqrt{\frac SC}$$
$$R=\frac{\sqrt{SC}}{ω}$$
$$D=2ωa,H_1=\frac{3R-1}{2C},H_2=\frac{3R+1}{2S}$$
$$s=D(1+fH_1\sin^2F\cos^2G-fH_2\cos^2F\sin^2G)$$&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Distance is distance between two points measured along the surface
// of an ellipsoid.
//
// Accuracy is much better than that of ApproxAngularDistance or
// ApproxLinearDistance.
//
// Result unit is units of e.Er, typically Km.
// 地表两点距离
func (e Ellipsoid) Distance(c1, c2 Coord) float64 {
	// From AA, ch 11, p 84.
	s2f, c2f := sincos2((c1.Lat + c2.Lat) / 2)
	s2g, c2g := sincos2((c1.Lat - c2.Lat) / 2)
	s2λ, c2λ := sincos2((c1.Lon - c2.Lon) / 2)
	s := s2g*c2λ + c2f*s2λ
	c := c2g*c2λ + s2f*s2λ
	ω := math.Atan(math.Sqrt(s / c))
	r := math.Sqrt(s*c) / ω
	d := 2 * ω * e.Er
	h1 := (3*r - 1) / (2 * c)
	h2 := (3*r + 1) / (2 * s)
	return d * (1 + e.Fl*(h1*s2f*c2g-h2*c2f*s2g))
}

func sincos2(x unit.Angle) (s2, c2 float64) {
	s, c := x.Sincos()
	return s * s, c * c
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>天文算法8</title>
      <link>https://mooncaker816.github.io/2018/05/17/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%958/</link>
      <pubDate>Thu, 17 May 2018 09:56:34 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/05/17/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%958/</guid>
      <description>&lt;h1 id=&#34;第十章-力学时和世界时-dynamical-time-universal-time&#34;&gt;第十章 力学时和世界时 Dynamical Time &amp;amp; Universal Time&lt;/h1&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-力学时&#34;&gt;1. 力学时&lt;/h2&gt;

&lt;p&gt;　　力学时（Dynamical Time，简称DT）是一种从历书时(ET)到地球时(TT)过渡的时间尺度。分为地球力学时（Temps Dynamique Terrestrique，简称TDT）和质心力学时（Temps Dynamique Barycentrique，简称TDB）两种。&lt;/p&gt;

&lt;p&gt;　　1958年国际天文学联合会（IAU）决定从1960年开始使用以地球公转运动为基准的历书时（ET）代替以地球自转为基准的世界时（UT），目的是解决由于地球自转速度不均匀导致的世界时的时间尺度不均匀的问题。但是由于历书时所用的基准地球运动的理论框架是牛顿力学，根据广义相对论可知，在以太阳为中心的坐标系和以地球为中心的坐标系中时间将会不同。为解决这一问题，1976年国际天文学联合会分别定义了地球力学时（TDT）和质心力学时（TDB）。这两个时间尺度可以看作是历书时在两个坐标系中的实现。1991年，地球力学时被重新精确定义后改名为地球时（TT）。&lt;/p&gt;

&lt;p&gt;　　太阳系质心力学时（TDB）和地心力学时（TDT） 的区分。这两个系统最多相差 0.0017 秒，此种差异与地球以椭圆轨道绕日运动有关(相对论效应)。因这一差异小到可以被大多数实际应用忽略，&lt;strong&gt;&lt;em&gt;故此处我们对质心力学时和地球力学时不加区分，统称为力学时(TD)。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;/p&gt;

&lt;h2 id=&#34;2-世界时&#34;&gt;2. 世界时&lt;/h2&gt;

&lt;p&gt;　　世界时（Universal Time，简称UT）是一种以格林尼治子夜起算的平太阳时。世界时是以地球自转为基准得到的时间尺度，其精度受到地球自转不均匀变化和极移的影响，为了解决这种影响，1955年国际天文联合会定义了UT0、UT1和UT2三个系统：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;UT0系统是由一个天文台的天文观测直接测定的世界时，没有考虑极移造成的天文台地理坐标变化。该系统曾长期被认为是稳定均匀的时间计量系统，得到过广泛应用。&lt;/li&gt;
&lt;li&gt;UT1系统是在UT0的基础上加入了极移改正 Δλ，修正地轴摆动的影响。&lt;strong&gt;UT1是目前使用的世界时标准。被作为目前世界民用时间标准UTC在增减闰秒时的参照标准。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;UT2系统是UT1的平滑处理版本，在UT1基础上加入了地球自转速率的季节性改正 ΔT。&lt;/li&gt;
&lt;li&gt;它们之间的关系可以表示为：
\begin{align}
UT1 = UT0 + Δλ\\[2ex]
UT2 = UT1 + ΔT
\end{align}&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　&lt;/p&gt;

&lt;h2 id=&#34;3-协调世界时&#34;&gt;3. 协调世界时&lt;/h2&gt;

&lt;p&gt;　　协调世界时（英语：Coordinated Universal Time，法语：Temps Universel Coordonné，简称UTC）是最主要的世界时间标准，其以原子时秒长为基础，在时刻上尽量接近于格林尼治标准时间。&lt;/p&gt;

&lt;p&gt;　　协调世界时是世界上调节时钟和时间的主要时间标准，它与0度经线的平太阳时相差不超过1秒，并不遵守夏令时。协调世界时是最接近格林威治标准时间（GMT）的几个替代时间系统之一。对于大多数用途来说，UTC时间被认为能与GMT时间互换，但GMT时间已不再被科学界所确定。&lt;/p&gt;

&lt;p&gt;　　UTC基于国际原子时，并通过不规则的加入闰秒来抵消地球自转变慢的影响。闰秒在必要的时候会被插入到UTC中，以保证协调世界时（UTC）与世界时（UT1）相差不超过0.9秒。&lt;/p&gt;

&lt;p&gt;　　为了保证协调世界时很接近世界时UT1，UTC从基于TAI的线性方程转变成另一方程时，偶尔会出现不连续点。这些不连续点以闰秒的形式体现出来，这些不连续点就是造成了UTC天的长度不规则的闰秒。IERS规定不连续点仅出现在6月或12月底，但也有规定将3月或者9月作为备选。国际地球自转服务组织(IERS)跟踪并公布UTC时间和世界时的差别，即$DUT1 = UT1 - UTC$，另外，IERS也负责引入不连续的闰秒来保证它们的时间差DUT1在±0.9秒之间。&lt;/p&gt;

&lt;p&gt;　　&lt;/p&gt;

&lt;h2 id=&#34;4-计算力学时和世界时之间的差值&#34;&gt;4. 计算力学时和世界时之间的差值&lt;/h2&gt;

&lt;p&gt;　　由于地球自转一直在变缓，而且变缓规律难以预测，力学时和世界时之间的精确差值 $ΔT = TD - UT$ 只能由天文观测值推算。&lt;br /&gt;
　　书中给出了1620年至1998年的ΔT数据，所以在此之间的时间可以通过插值法来计算，其余时期的数据可以用以下方式推算：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;令 $t=\frac {year-2000}{100}$&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// c2000 returns centuries from calendar year 2000.0.
//
// Arg should be a calendar year.
// 计算年份y距离2000年的世纪数
func c2000(y float64) float64 {
    return (y - 2000) * .01
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;$ΔT = 2177 + 497t + 44.1t^2, year &amp;lt; +948 $&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// PolyBefore948 returns a polynomial approximation of ΔT valid for calendar
// years before 948.
// +948年之前的ΔT推算公式
func PolyBefore948(year float64) (ΔT unit.Time) {
    // (10.1) p. 78
    return unit.Time(base.Horner(c2000(year), 2177, 497, 44.1))
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;$ΔT = 102 + 102t + 25.3t^2, +948 \leq year \leq +1600 || year \geq +2000 $&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Poly948to1600 returns a polynomial approximation of ΔT valid for calendar
// years 948 to 1600.
// +984年至1600年的ΔT推算公式
func Poly948to1600(year float64) (ΔT unit.Time) {
    // (10.2) p. 78
    return unit.Time(base.Horner(c2000(year), 102, 102, 25.3))
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;若 $+2000 \leq year \leq +2100$, 还要在第3步的基础上加上一个修正量$+0.37(year-2100)$&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// PolyAfter2000 returns a polynomial approximation of ΔT valid for calendar
// years after 2000.
// 2000年以后的ΔT推算公式
func PolyAfter2000(year float64) (ΔT unit.Time) {
    ΔT = Poly948to1600(year)
    if year &amp;lt; 2100 {
        ΔT += unit.Time(.37 * (year - 2100))
    }
    return
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;经验公式：&lt;/p&gt;

&lt;p&gt;5.0 $\  儒略日世纪数\theta=\frac {JDE-J1900.0}{36525},J1900.0=2415020.0(1899-12-31)$&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// jc1900 returns julian centuries from the epoch J1900.0
//
// Arg should be a julian day, technically JDE.
// 计算儒略日jde距离J1900.0的世纪数
func jc1900(jde float64) float64 {
    return (jde - base.J1900) / base.JulianCentury
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5.1 $\  1800 - 1997$：(最大误差2.3秒)
    \begin{align}
    ΔT = &amp;amp;-1.02 + 91.02\theta + 265.90\theta^2 - 839.16\theta^3 - 1545.20\theta^4 \\[2ex]
    &amp;amp;+ 3603.62\theta^5 + 4385.98\theta^6 - 6993.23\theta^7 - 6090.04\theta^8 \\[2ex]
    &amp;amp;+ 6298.12\theta^9 + 4102.86\theta^{10} - 2137.64\theta^{11} - 1081.51\theta^{12}
    \end{align}&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Poly1800to1997 returns a polynomial approximation of ΔT valid for years
// 1800 to 1997.
//
// The accuracy is within 2.3 seconds.
// 1800至1997ΔT经验公式，最大误差2.3秒
func Poly1800to1997(jde float64) (ΔT unit.Time) {
    return unit.Time(base.Horner(jc1900(jde),
        -1.02, 91.02, 265.90, -839.16, -1545.20,
        3603.62, 4385.98, -6993.23, -6090.04,
        6298.12, 4102.86, -2137.64, -1081.51))
}    
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5.2 $\  1800 - 1899$：(最大误差0.9秒)
    \begin{align}
    ΔT = &amp;amp;-2.50 + 228.95\theta + 5218.61\theta^2 + 56282.84\theta^3 + 324011.78\theta^4 \\[2ex]
    &amp;amp;+ 1061660.75\theta^5 + 2087298.89\theta^6 + 2513807.78\theta^7 + 1818961.41\theta^8 \\[2ex]
    &amp;amp;+ 727058.63\theta^9 + 123563.95\theta^{10}
    \end{align}&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Poly1800to1899 returns a polynomial approximation of ΔT valid for years
// 1800 to 1899.
//
// The accuracy is within 0.9 seconds.
// 1800至1899ΔT经验公式，最大误差0.9秒
func Poly1800to1899(jde float64) (ΔT unit.Time) {
    return unit.Time(base.Horner(jc1900(jde),
        -2.50, 228.95, 5218.61, 56282.84, 324011.78,
        1061660.75, 2087298.89, 2513807.78,
        1818961.41, 727058.63, 123563.95))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5.3 $\  1900 - 1997$：(最大误差0.9秒)
    \begin{align}
    ΔT = &amp;amp;-2.44 + 87.24\theta + 815.20\theta^2 - 2637.80\theta^3 - 18756.33\theta^4 \\[2ex]
    &amp;amp;+ 124906.15\theta^5 - 303191.19\theta^6 + 372919.88\theta^7 - 232424.66\theta^8 \\[2ex]
    &amp;amp;+ 58353.42\theta^9
    \end{align}&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Poly1900to1997 returns a polynomial approximation of ΔT valid for years
// 1900 to 1997.
//
// The accuracy is within 0.9 seconds.
// 1900至1997ΔT经验公式，最大误差0.9秒
func Poly1900to1997(jde float64) (ΔT unit.Time) {
    return unit.Time(base.Horner(jc1900(jde),
        -2.44, 87.24, 815.20, -2637.80, -18756.33,
        124906.15, -303191.19, 372919.88,
        -232424.66, 58353.42))
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>天文算法7</title>
      <link>https://mooncaker816.github.io/2018/05/17/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%957/</link>
      <pubDate>Thu, 17 May 2018 08:56:34 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/05/17/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%957/</guid>
      <description>&lt;h1 id=&#34;第九章-犹太历和穆斯林历&#34;&gt;第九章 犹太历和穆斯林历&lt;/h1&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;略&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>天文算法6</title>
      <link>https://mooncaker816.github.io/2018/05/17/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%956/</link>
      <pubDate>Thu, 17 May 2018 07:40:44 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/05/17/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%956/</guid>
      <description>&lt;h1 id=&#34;第八章-复活节日-date-of-easter&#34;&gt;第八章 复活节日 Date of Easter&lt;/h1&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;　　对西方的节日没有多少了解，这里就直接给出书中的算法吧~&lt;/p&gt;

&lt;h2 id=&#34;1-格里历复活节算法&#34;&gt;1. 格里历复活节算法&lt;/h2&gt;

&lt;p&gt;\begin{array}{l|ccc}
被除数 &amp;amp; 除数 &amp;amp; 商 &amp;amp; 余数 \\&lt;br /&gt;
\hline
年份y &amp;amp; 19 &amp;amp; - &amp;amp; a \\&lt;br /&gt;
年份y &amp;amp; 100 &amp;amp; b &amp;amp; c \\&lt;br /&gt;
b &amp;amp; 4 &amp;amp; d &amp;amp; e \\&lt;br /&gt;
b+8 &amp;amp; 25 &amp;amp; f &amp;amp; - \\&lt;br /&gt;
b-f+1 &amp;amp; 3 &amp;amp; g &amp;amp; - \\&lt;br /&gt;
19a+b-d-g+15 &amp;amp; 30 &amp;amp; - &amp;amp; h \\&lt;br /&gt;
c &amp;amp; 4 &amp;amp; i &amp;amp; k \\&lt;br /&gt;
32+2e+2i-h-k &amp;amp; 7 &amp;amp; - &amp;amp; l \\&lt;br /&gt;
a+11h+22l &amp;amp; 451 &amp;amp; m &amp;amp; - \\&lt;br /&gt;
h+l-7m+114 &amp;amp; 31 &amp;amp; n &amp;amp; p \\&lt;br /&gt;
\end{array}&lt;/p&gt;

&lt;p&gt;得 $$n = 月份, \ p+1 = 日期$$&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Gregorian returns month and day of Easter in the Gregorian calendar.
// 格里历复活节日算法
func Gregorian(y int) (m, d int) {
	a := y % 19
	b, c := y/100, y%100
	d, e := b/4, b%4
	f := (b + 8) / 25
	g := (b - f + 1) / 3
	h := (19*a + b - d - g + 15) % 30
	i, k := c/4, c%4
	l := (32 + 2*e + 2*i - h - k) % 7
	m = (a + 11*h + 22*l) / 451
	n := h + l - 7*m + 114
	n, p := n/31, n%31
	return n, p + 1
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2-儒略历复活节算法&#34;&gt;2. 儒略历复活节算法&lt;/h2&gt;

&lt;p&gt;\begin{array}{l|ccc}
被除数 &amp;amp; 除数 &amp;amp; 商 &amp;amp; 余数 \\&lt;br /&gt;
\hline
年份y &amp;amp; 4 &amp;amp; - &amp;amp; a \\&lt;br /&gt;
年份y &amp;amp; 7 &amp;amp; - &amp;amp; b \\&lt;br /&gt;
年份y &amp;amp; 19 &amp;amp; - &amp;amp; c \\&lt;br /&gt;
19c+15 &amp;amp; 30 &amp;amp; - &amp;amp; d \\&lt;br /&gt;
2a+4b-d+34 &amp;amp; 7 &amp;amp; - &amp;amp; e \\&lt;br /&gt;
d+e+114 &amp;amp; 31 &amp;amp; f &amp;amp; g \\&lt;br /&gt;
\end{array}&lt;/p&gt;

&lt;p&gt;得 $$f = 月份, \ g+1 = 日期$$&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Julian returns month and day of Easter in the Julian calendar.
// 儒略历复活节日算法
func Julian(y int) (m, d int) {
	a := y % 4
	b := y % 7
	c := y % 19
	d = (19*c + 15) % 30
	e := (2*a + 4*b - d + 34) % 7
	f := d + e + 114
	f, g := f/31, f%31
	return f, g + 1
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>天文算法5</title>
      <link>https://mooncaker816.github.io/2018/05/16/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%955/</link>
      <pubDate>Wed, 16 May 2018 09:27:51 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/05/16/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%955/</guid>
      <description>&lt;h1 id=&#34;第七章-儒略日-julian-day&#34;&gt;第七章 儒略日 Julian Day&lt;/h1&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-儒略历和格里高利历&#34;&gt;1. 儒略历和格里高利历&lt;/h2&gt;

&lt;h3 id=&#34;1-1-定义&#34;&gt;1.1 定义&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;儒略历，是格里历的前身，由罗马共和国独裁官儒略·凯撒采纳埃及亚历山大的希腊数学家兼天文学家索西琴尼计算的历法，在公元前45年1月1日起执行，取代旧罗马历历法的历法。一年设12个月，大小月交替，四年一闰，平年365日，闰年于二月底增加一闰日，年平均长度为365.25日。由于累积误差随着时间越来越大，1582年后由教皇格里高利十三世改良，变为格里历，即沿用至今的公历。但大英帝国、北美十三州等直到1752年才从儒略历改用格里历。现今儒略历只有苏格兰昔德兰群岛之富拉岛、阿索斯神权共和国和一些北非的柏柏尔人使用。&lt;/p&gt;

&lt;p&gt;格里历（拉丁语：Calendarium Gregorianum，又译、国瑞历、额我略历、格列高利历、格里高利历、葛瑞格里历、格列高历，也称基督历[1]），是由意大利医生兼哲学家阿洛伊修斯·里利乌斯改革儒略历制定的历法，由罗马大公教会教宗格列高利十三世在1582年颁行。公历是阳历的一种，于1912年在中国引进采用，因农历等中国传统历法是阴阳历，故公历在中文中又称阳历、西历、新历、公历。格里历与儒略历一样，格里历也是每四年在2月底置一闰日，但格里历特别规定，除非能被400整除，所有的世纪年（能被100整除）都不设闰日；如此，每四百年，格里历仅有97个闰年，比儒略历减少3个闰年 [注 1]。 格里历的历年平均长度为365.2425日，接近平均回归年的365.242199074日，即约每3300年误差一日，也更接近春分点回归年的365.24237日，即约每8000年误差一日；而儒略历的历年为365.25日，约每128年就误差一日[注 1]。到1582年时，儒略历的春分日（3月21日）与地球公转到春分点的实际时间已相差10天。因此，格里历开始实行时，将儒略历1582年10月4日星期四的次日，为格里历1582年10月15日星期五，即有10天被删除，但原星期的周期保持不变。格里历的纪年沿用儒略历，自传统的耶稣诞生年开始，称为“公元”，亦称“西元”。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;1-2-区别&#34;&gt;1.2 区别&lt;/h3&gt;

&lt;p&gt;　　由定义可见，儒略历和格里高利历都属于阳历，后者是以太阳回归年为基础，对前者置润误差进行调整后的历法。所以两者之间最大的不同就是置润规则。&lt;/p&gt;

&lt;h4 id=&#34;1-2-1-置润规则&#34;&gt;1.2.1 置润规则&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;儒略历&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;能被4整除的年份为闰年（产生多润的原因，从而使儒略历在日期上落后于格里历）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;格里历&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;能被4整除但不能被100整除的非世纪年 + 能被400整除的世纪年，即要在儒略历闰年中扣除那些不能被400整除的世纪年（如1600，1700等）&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// LeapYearJulian returns true if year y in the Julian calendar is a leap year.
// 儒略历闰年判断
func LeapYearJulian(y int) bool {
	return y%4 == 0
}

// LeapYearGregorian returns true if year y in the Gregorian calendar is a leap year.
// 格里历闰年判断
func LeapYearGregorian(y int) bool {
	return (y%4 == 0 &amp;amp;&amp;amp; y%100 != 0) || y%400 == 0
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;1-2-2-转换&#34;&gt;1.2.2 转换&lt;/h4&gt;

&lt;p&gt;　　知道了这个不同，我们就能推导出两种历法之间实际的相差天数，如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;1582年：&lt;br /&gt;
格里历10月15日，合儒略历10月5日，或之后的日期：格里历日期减10日等于儒略历日期。&lt;/li&gt;
&lt;li&gt;1583年——1699年：&lt;br /&gt;
格里历日期减10日等于儒略历日期。&lt;/li&gt;
&lt;li&gt;1700年（格里历没有闰日，但儒略历有）：&lt;br /&gt;
格里历2月28日，合儒略历2月18日，或之前的日期：格里历日期减10日等于儒略历日期。&lt;br /&gt;
格里历3月1日，合儒略历2月19日，或之后的日期：格里历日期减11日等于儒略历日期。&lt;/li&gt;
&lt;li&gt;1701年——1799年：&lt;br /&gt;
格里历日期减11日等于儒略历日期。&lt;/li&gt;
&lt;li&gt;1800年（格里历没有闰日，但儒略历有）：&lt;br /&gt;
格里历2月28日，合儒略历2月17日，或之前的日期：格里历日期减11日等于儒略历日期。&lt;br /&gt;
格里历3月1日，合儒略历2月18日，或之后的日期：格里历日期减12日等于儒略历日期。&lt;/li&gt;
&lt;li&gt;1801年——1899年：&lt;br /&gt;
格里历日期减12日等于儒略历日期。&lt;/li&gt;
&lt;li&gt;1900年（格里历没有闰日，但儒略历有）：&lt;br /&gt;
格里历2月28日，合儒略历2月16日，或之前的日期：格里历日期减12日等于儒略历日期。&lt;br /&gt;
格里历3月1日，合儒略历2月17日，或之后的日期：格里历日期减13日等于儒略历日期。&lt;/li&gt;
&lt;li&gt;1901年——2099年：&lt;br /&gt;
格里历日期减13日等于儒略历日期。&lt;/li&gt;
&lt;li&gt;2100年（格里历没有闰日，但儒略历有）：&lt;br /&gt;
格里历2月28日，合儒略历2月15日，或之前的日期：格里历日期减13日等于儒略历日期。&lt;br /&gt;
格里历3月1日，合儒略历2月16日，或之后的日期：格里历日期减14日等于儒略历日期。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2-儒略日-julian-day&#34;&gt;2. 儒略日 Julian Day&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;儒略日（Julian Day）&lt;/strong&gt;&lt;br /&gt;
儒略日是在儒略周期内以连续的日数计算时间的计时法，主要是天文学家在使用。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;儒略日数（Julian Day Number，JDN）&lt;/strong&gt;&lt;br /&gt;
儒略日数的计算是从格林威治标准时间的中午开始，包含一个整天的时间，起点的时间（0日）回溯至儒略历的公元前4713年1月1日中午12点（在格里历是公元前4714年11月24日），这个日期是三种多年周期的共同起点，且是历史上最接近现代的一个起点。例如，2000年1月1日的UT12:00是儒略日2,451,545。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;儒略日期（Julian date，JD）&lt;/strong&gt;&lt;br /&gt;
儒略日期是以格林威治标准时中午12:00的儒略日加上那一天的瞬时时间的分数。儒略日期是儒略日添加小数部分所表示的儒略日数。例如，2013年1月1日00:30:00（UT）是儒略日期2,456,293.520833。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;儒略周期（Julian Period）&lt;/strong&gt;&lt;br /&gt;
儒略周期是开始于公元前4713年，长达7980年的纪年法，被用于历史上各种不同历法的日期转换。公元2018年是儒略周期的6731年，下一个儒略周期将开始于公元3268年。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;儒略日起点&lt;/strong&gt;&lt;br /&gt;
儒略日的起点订在西元前4713年（天文学上记为 -4712年）1月1日格林威治时间平午（世界时12:00），即JD 0指定为UT时间B.C.4713年1月1日12:00到UC时间B.C.4713年1月2日12:00的24小时。每一天赋予了一个唯一的数字，顺数而下，如：1996年1月1日12:00:00的儒略日是2450084。这个日期是考虑了太阳、月亮的轨道运行周期，以及当时收税的间隔而订出来的。Joseph Scaliger定义儒略周期为7980年，是因28、19、15的最小公倍数为28×19×15=7980。其中：&lt;/p&gt;

&lt;p&gt;28年为一太阳周期（solar cycle），经过一太阳周期，则星期的日序与月的日序会重复。&lt;/p&gt;

&lt;p&gt;19年为一太阴周期，或称默冬章（Metonic cycle），因235朔望月=19回归年，经过一太阴周期则阴历月年的日序重复。&lt;/p&gt;

&lt;p&gt;15年为一小纪（indiction cycle），此为罗马皇帝君士坦丁一世所颁，每15年评定财产价值以供课税，成为古罗马用的一个纪元单位，&lt;/p&gt;

&lt;p&gt;故以7980年为一儒略周期，而所选的起点公元前4713年，则是这三个循环周期同时开始的最近年份。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;简化儒略日（MJD）&lt;/strong&gt;&lt;br /&gt;
由于儒略日数字位数太多，国际天文学联合会于1973年采用简化儒略日（MJD），其定义为MJD = JD - 2400000.5。MJD相应的起点是1858年11月17日世界时0时。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　算法中主要用的是 &lt;strong&gt;儒略日期（Julian date，JD）&lt;/strong&gt;，后续简称为&lt;strong&gt;儒略日&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;3-儒略日和阳历日期-格里历-儒略历日期-的转换&#34;&gt;3. 儒略日和阳历日期（格里历、儒略历日期）的转换&lt;/h2&gt;

&lt;h3 id=&#34;3-1-阳历日期-y-m-d-rightarrow-儒略日-jd&#34;&gt;3.1 阳历日期$(Y,M,D)$ $\Rightarrow$ 儒略日$(JD)$&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;设$Y$为给定年份，$M$为月份，$D$为该月日期（可以带小数）。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;若 $M &amp;gt; 2$，$Y$和$M$不变，&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;若 $M =1或2$，以$Y–1$代$Y$，以$M+12$代$M$，换句话说，如果日期在1月或2月，则被看作是在前一年的13月或14月。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对格里历有 ：$A = \lfloor \frac {Y}{100}\rfloor$ $B = 2 - A + \lfloor \frac{A}{4}\rfloor$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对儒略历，取 $B = 0$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;要求的儒略日即为：$$JD = \lfloor 365.25(Y+4716)\rfloor+\lfloor30.6001(M+1)\rfloor+D+B-1524.5$$&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;此处作对30.6001取值的解释是为了确保小数在运算时的准确性，如30.6 * 5 应该等于153，但是很多计算机得出的结果是152.999 9998。&lt;/p&gt;

&lt;p&gt;另一种方式就是用306代替，最后再除以10取整&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// FloorDiv returns the integer floor of the fractional value (x / y).
//
// It uses integer math only, so is more efficient than using floating point
// intermediate values.  This function can be used in many places where INT()
// appears in AA.  As with built in integer division, it panics with y == 0.
func FloorDiv(x, y int) (q int) {
	q = x / y
	if (x &amp;lt; 0) != (y &amp;lt; 0) &amp;amp;&amp;amp; x%y != 0 {
		q--
	}
	return
}

// FloorDiv64 returns the integer floor of the fractional value (x / y).
//
// It uses integer math only, so is more efficient than using floating point
// intermediate values.  This function can be used in many places where INT()
// appears in AA.  As with built in integer division, it panics with y == 0.
func FloorDiv64(x, y int64) (q int64) {
	q = x / y
	if (x &amp;lt; 0) != (y &amp;lt; 0) &amp;amp;&amp;amp; x%y != 0 {
		q--
	}
	return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// CalendarGregorianToJD converts a Gregorian year, month, and day of month
// to Julian day.
//
// Negative years are valid, back to JD 0.  The result is not valid for
// dates before JD 0.
// 格里历日期转儒略日
func CalendarGregorianToJD(y, m int, d float64) float64 {
	switch m {
	case 1, 2:
		y--
		m += 12
	}
	a := base.FloorDiv(y, 100)
	b := 2 - a + base.FloorDiv(a, 4)
	// (7.1) p. 61
	return float64(base.FloorDiv64(36525*(int64(y+4716)), 100)) +
		float64(base.FloorDiv(306*(m+1), 10)+b) + d - 1524.5
}

// CalendarJulianToJD converts a Julian year, month, and day of month to Julian day.
//
// Negative years are valid, back to JD 0.  The result is not valid for
// dates before JD 0.
// 儒略历日期转儒略日
func CalendarJulianToJD(y, m int, d float64) float64 {
	switch m {
	case 1, 2:
		y--
		m += 12
	}
	return float64(base.FloorDiv64(36525*(int64(y+4716)), 100)) +
		float64(base.FloorDiv(306*(m+1), 10)) + d - 1524.5
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3-2-儒略日-jd-rightarrow-阳历日期-y-m-d&#34;&gt;3.2 儒略日$(JD)$ $\Rightarrow$ 阳历日期$(y,m,d)$&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;将 $JD$ 加上 0.5，令$Z$为其整数部分，$F$ 为尾数（小数）部分。&lt;/li&gt;
&lt;li&gt;若 $Z$ &amp;lt; 2299161，取 $A$ = $Z$;&lt;br /&gt;
若 $Z$ 大于等于 2299161，计算
\begin{align}
α &amp;amp;=\lfloor \frac {Z-1867216.25}{36524.25}\rfloor\\[2ex]
A &amp;amp;=Z+1+α-\lfloor \frac α4\rfloor
\end{align}&lt;/li&gt;
&lt;li&gt;然后计算
\begin{align}
B &amp;amp;= A+1524\\[2ex]
C &amp;amp;= \lfloor \frac {B-122.1}{365.25}\rfloor\\[2ex]
D &amp;amp;= \lfloor 365.25C\rfloor\\[2ex]
E &amp;amp;= \lfloor \frac {B-D}{30.6001}\rfloor\\[2ex]
\end{align}&lt;/li&gt;
&lt;li&gt;该月日期（带小数部分）则为：$$d = B - D - \lfloor 30.6001E\rfloor + F$$&lt;/li&gt;
&lt;li&gt;月份 m 为：
\begin{cases}
m = E – 1 ;&amp;amp;  \text {if $E$ &amp;lt; 14}\\[2ex]
m = E – 13 ;&amp;amp;  \text {if $E$ $\geq$ 14}
\end{cases}&lt;/li&gt;
&lt;li&gt;年份为 y：
\begin{cases}
y = C – 4716 ;&amp;amp;  \text {if $m$ &amp;gt; 2}\\[2ex]
y = C – 4715 ;&amp;amp;  \text {if $m$ $\leq$ 2}
\end{cases}&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// JDToCalendar returns the calendar date for the given jd.
//
// Note that this function returns a date in either the Julian or Gregorian
// Calendar, as appropriate.
// 儒略日转公历日期
// 如果儒略日对应的格里历时间点在1582-10-15 12点之前，则转为儒略历日期
// 如果儒略日对应的格里历时间点在1582-10-15 12点之后，则转为格里历日期
func JDToCalendar(jd float64) (year, month int, day float64) {
	zf, f := math.Modf(jd + .5)
	z := int64(zf)
	a := z
	// if z &amp;gt;= 2299151 { // typo 应该是2299161对应于现实格里历起始日1582-10-15中午12点
	if z &amp;gt;= 2299161 { // typo 应该是2299161对应于现实格里历起始日1582-10-15中午12点
		α := base.FloorDiv64(z*100-186721625, 3652425)
		a = z + 1 + α - base.FloorDiv64(α, 4)
	}
	b := a + 1524
	c := base.FloorDiv64(b*100-12210, 36525)
	d := base.FloorDiv64(36525*c, 100)
	e := int(base.FloorDiv64((b-d)*1e4, 306001))
	// compute return values
	day = float64(int(b-d)-base.FloorDiv(306001*e, 1e4)) + f
	switch e {
	default:
		month = e - 1
	case 14, 15:
		month = e - 13
	}
	switch month {
	default:
		year = int(c) - 4716
	case 1, 2:
		year = int(c) - 4715
	}
	return
}

// jdToCalendarGregorian returns the Gregorian calendar date for the given jd.
//
// Note that it returns a Gregorian date even for dates before the start of
// the Gregorian calendar.  The function is useful when working with Go
// time.Time values because they are always based on the Gregorian calendar.
// 始终转为格里历，忽略儒略历转格里历被扣除的那10天，即把1582-10-15 12点之前的日期也当成格里历算
func jdToCalendarGregorian(jd float64) (year, month int, day float64) {
	zf, f := math.Modf(jd + .5)
	z := int64(zf)
	α := base.FloorDiv64(z*100-186721625, 3652425)
	a := z + 1 + α - base.FloorDiv64(α, 4)
	b := a + 1524
	c := base.FloorDiv64(b*100-12210, 36525)
	d := base.FloorDiv64(36525*c, 100)
	e := int(base.FloorDiv64((b-d)*1e4, 306001))
	// compute return values
	day = float64(int(b-d)-base.FloorDiv(306001*e, 1e4)) + f
	switch e {
	default:
		month = e - 1
	case 14, 15:
		month = e - 13
	}
	switch month {
	default:
		year = int(c) - 4716
	case 1, 2:
		year = int(c) - 4715
	}
	return
}

// JDToTime takes a JD and returns a Go time.Time value.
// 儒略历转为格里历日期对应的 Go Time 类型
func JDToTime(jd float64) time.Time {
	// time.Time is always Gregorian
	y, m, d := jdToCalendarGregorian(jd)
	t := time.Date(y, time.Month(m), 0, 0, 0, 0, 0, time.UTC)
	return t.Add(time.Duration(d * 24 * float64(time.Hour)))
}

// TimeToJD takes a Go time.Time and returns a JD as float64.
//
// Any time zone offset in the time.Time is ignored and the time is
// treated as UTC.
// Go Time 类型转为儒略日（默认日期为格里历）
func TimeToJD(t time.Time) float64 {
	ut := t.UTC()
	y, m, _ := ut.Date()
	d := ut.Sub(time.Date(y, m, 0, 0, 0, 0, 0, time.UTC))
	// time.Time is always Gregorian
	return CalendarGregorianToJD(y, int(m), float64(d)/float64(24*time.Hour))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3-3-儒略日-jd-rightarrow-星期几&#34;&gt;3.3 儒略日$(JD)$ $\Rightarrow$ 星期几&lt;/h3&gt;

&lt;p&gt;　　因为儒略日0.0(-4712-1-1 12:00) 是星期一，往后7天一循环就能得出星期几了&lt;br /&gt;
　　计算该日0时的儒略日，加上1.5，再除以7，所得余数将指示出星期几：&lt;br /&gt;
若余数为0，则为星期日，1为星期一，2为星期二，3为星期三，4为星期四，5为星期五，6为星期六。&lt;br /&gt;
　　儒略历到格里高利历的换算并不影响星期。 因而，在1582年10月4日星期四接下来的一天便是10月15日星期五。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// DayOfWeek determines the day of the week for a given JD.
//
// The value returned is an integer in the range 0 to 6, where 0 represents
// Sunday.  This is the same convention followed in the time package of the
// Go standard library.
// 儒略日0.0为-4712-1-1 12:00 星期一，往后7天一循环就能得出星期几了
func DayOfWeek(jd float64) int {
	return int(jd+1.5) % 7
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3-4-日阳历日期-y-m-d-rightarrow-年内序数日-n&#34;&gt;3.4 日阳历日期$(Y,M,D)$ $\Rightarrow$ 年内序数日$(N)$&lt;/h3&gt;

&lt;p&gt;　　年内的序数日$N$可由以下公式得出：$$N = \lfloor \frac {275M}{9}\rfloor - K\lfloor \frac {M+9}{12}\rfloor + D - 30 $$
　　此处$M$为月份，$D$为该月日期，闰年$K = 1$，平年$K = 2$&lt;br /&gt;
　　$N$ 取整数，自1月1日开始取值1，直至12月31日取值365（或闰年取值366）。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;如何推导出这个公式？&lt;/strong&gt;&lt;br /&gt;
　　乍一看挺没头绪的，我们先来看一个数列$$ a_m = \lfloor \frac {5(m+1)}{9}\rfloor, (m=0,1,2,\dots,12)$$&lt;/p&gt;

&lt;p&gt;\begin{array}{c|ccl}
m &amp;amp; a_m &amp;amp; a_m - a_{m-1} &amp;amp; 当月天数 \\&lt;br /&gt;
\hline
0 &amp;amp; 0 &amp;amp; - &amp;amp; - \\&lt;br /&gt;
1 &amp;amp; 1 &amp;amp; 1 &amp;amp; 31 \\&lt;br /&gt;
2 &amp;amp; 1 &amp;amp; 0 &amp;amp; 30(看做30) \\&lt;br /&gt;
3 &amp;amp; 2 &amp;amp; 1 &amp;amp; 31 \\&lt;br /&gt;
4 &amp;amp; 2 &amp;amp; 0 &amp;amp; 30 \\&lt;br /&gt;
5 &amp;amp; 3 &amp;amp; 1 &amp;amp; 31 \\&lt;br /&gt;
6 &amp;amp; 3 &amp;amp; 0 &amp;amp; 30 \\&lt;br /&gt;
7 &amp;amp; 4 &amp;amp; 1 &amp;amp; 31 \\&lt;br /&gt;
8 &amp;amp; 5 &amp;amp; 1 &amp;amp; 31 \\&lt;br /&gt;
9 &amp;amp; 5 &amp;amp; 0 &amp;amp; 30 \\&lt;br /&gt;
10 &amp;amp; 6 &amp;amp; 1 &amp;amp; 31 \\&lt;br /&gt;
11 &amp;amp; 6 &amp;amp; 0 &amp;amp; 30 \\&lt;br /&gt;
12 &amp;amp; 7 &amp;amp; 1 &amp;amp; 31
\end{array}&lt;/p&gt;

&lt;p&gt;　　如果把$m$看成是月份，并且暂时把二月看成是30天，那么第二列恰好是$当月天数-30$，所以我们就可以用以下公式来表示每个月的天数。
$$D_m = 30 + a_m - a_{m-1}$$&lt;/p&gt;

&lt;p&gt;　　所以从1月到m月的总天数：
\begin{align}
S_m = &amp;amp; D_1+D_2+,\dots,+D_m\\[2ex]
= &amp;amp; 30 + a_m - a_{m-1} + \\[2ex]
&amp;amp; 30 + a_{m-1} - a_{m-2} + \\[2ex]
&amp;amp; \cdots \\[2ex]
&amp;amp; 30 + a_2 - a_1 + \\[2ex]
&amp;amp; 30 + a_1 - a_0 \\[2ex]
= &amp;amp; 30m + a_m - a_0\\[2ex]
= &amp;amp; 30m + \lfloor \frac {5(m+1)}{9}\rfloor
\end{align}&lt;/p&gt;

&lt;p&gt;　　由于上述表达式只有在2月等于30天的情况下才成立，所以当$m\geq 2$时还要根据平年、闰年分别减去相应的天数2，1，得到1月到$m$月的总天数和为：
\begin{align}
S_m=30m + \lfloor \frac {5(m+1)}{9}\rfloor - \lfloor \frac {m+10}{12}\rfloor k,\ 其中
\end{align}
\begin{cases}
k = 1 , \ 闰年\\[2ex]
k = 2 , \ 平年
\end{cases}&lt;/p&gt;

&lt;p&gt;　　所以$M$月$D$日的年内序数$N$为：
\begin{align}
N &amp;amp;= S_{M-1} + D\\[2ex]
&amp;amp;= 30(M-1) + \lfloor \frac {5M}{9}\rfloor - \lfloor \frac {M+9}{12}\rfloor k + D\\[2ex]
&amp;amp;= \lfloor \frac {275M}{9}\rfloor - \lfloor \frac {M+9}{12}\rfloor k -30 + D\\[2ex]
\end{align}&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// DayOfYearGregorian computes the day number within the year of the Gregorian
// calendar.
// 格里历年内序数
func DayOfYearGregorian(y, m, d int) int {
	return DayOfYear(y, m, d, LeapYearGregorian(y))
}

// DayOfYearJulian computes the day number within the year of the Julian
// calendar.
// 儒略历年内序数
func DayOfYearJulian(y, m, d int) int {
	return DayOfYear(y, m, d, LeapYearJulian(y))
}

// DayOfYear computes the day number within the year.
//
// This form of the function is not specific to the Julian or Gregorian
// calendar, but you must tell it whether the year is a leap year.
// 输入闰年标识，计算年内序数
func DayOfYear(y, m, d int, leap bool) int {
	k := 2
	if leap {
		k--
	}
	return wholeMonths(m, k) + d
}

// m月之前的所有月份天数之和
func wholeMonths(m, k int) int {
	return 275*m/9 - k*((m+9)/12) - 30
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3-5-年内序数日-n-rightarrow-阳历日期-m-d&#34;&gt;3.5 年内序数日$(N)$  $\Rightarrow$ 阳历日期$(M,D)$&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// DayOfYearToCalendar returns the calendar month and day for a given
// day of year and leap year status.
// 年内序数求对应的日期
func DayOfYearToCalendar(n int, leap bool) (m, d int) {
	k := 2
	if leap {
		k--
	}
	if n &amp;lt; 32 {
		m = 1
	} else {
		m = (900*(k+n) + 98*275) / 27500
	}
	return m, n - wholeMonths(m, k)
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>天文算法4</title>
      <link>https://mooncaker816.github.io/2018/05/15/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%954/</link>
      <pubDate>Tue, 15 May 2018 17:34:49 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/05/15/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%954/</guid>
      <description>&lt;h1 id=&#34;第六章-排序-sort&#34;&gt;第六章 排序 Sort&lt;/h1&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;Go 标准库已经够了，所以就略了&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>天文算法3</title>
      <link>https://mooncaker816.github.io/2018/05/15/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%953/</link>
      <pubDate>Tue, 15 May 2018 13:48:36 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/05/15/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%953/</guid>
      <description>&lt;h1 id=&#34;第五章-迭代-iteration&#34;&gt;第五章 迭代 Iteration&lt;/h1&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-什么是迭代算法&#34;&gt;1. 什么是迭代算法&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;　　迭代法（英语：Iterative Method），在计算数学中，迭代是通过从一个初始估计出发寻找一系列近似解来解决问题（一般是解方程或者方程组）的数学过程，为实现这一过程所使用的方法统称。&lt;/p&gt;

&lt;p&gt;　　跟迭代法相对应的是直接法（或者称为一次解法），即一次性解决问题，例如通过开方解决方程 $ x^{2}=4$。一般如果可能，直接解法总是优先考虑的。但当遇到复杂问题时，特别是在未知量很多，方程为非线性时，我们无法找到直接解法（例如五次以及更高次的代数方程没有解析解，参见阿贝尔定理），这时候或许可以通过迭代法寻求方程（组）的近似解。&lt;/p&gt;

&lt;p&gt;　　最常见的迭代法是牛顿法。其他还包括最速下降法、共轭迭代法、变尺度迭代法、最小二乘法、线性规划、非线性规划、单纯型法、惩罚函数法、斜率投影法、遗传算法、模拟退火等等。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　以上是 wiki 上对迭代算法的描述，可以看出，迭代法的主要用途就是求解近似根，这一点我们再第三章插值函数逆推插值点的介绍中已经得到了运用。下面我们主要介绍牛顿迭代法和二分迭代法。&lt;/p&gt;

&lt;h2 id=&#34;2-牛顿迭代法&#34;&gt;2. 牛顿迭代法&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;　　首先，选择一个接近函数$f(x)$零点的 $x_0$，计算相应的 $f(x_0)$和切线斜率 $f&amp;rsquo;(x_0)$。然后我们计算穿过点 $(x_0,f(x_0))$并且斜率为 $f&amp;rsquo;(x_0)$的直线和 $x$轴的交点的 $x$坐标，也就是求如下方程的解：
$$0=(x-x_0)f&amp;rsquo;(x_0)+f(x_0)$$
　　我们将新求得的点的$x$坐标命名为$x_1$，通常$x_1$会比$x_0$更接近方程$f(x)=0$的解。因此我们现在可以利用$x_1$开始下一轮迭代。迭代公式可化简为如下所示：
$$x_{n+1}=x_n - \frac {f(x_n)}{f&amp;rsquo;(x_n)}$$
　　已经证明，如果$f&amp;rsquo;$是连续的，并且待求的零点$x$是孤立的，那么在零点$x$周围存在一个区域，只要初始值$x_0$位于这个邻近区域内，那么牛顿法必定收敛。&lt;/p&gt;

&lt;p&gt;　　并且，如果$f&amp;rsquo;(x)\neq 0$，那么牛顿法将具有平方收敛的性能。粗略的说，这意味着每迭代一次，牛顿法结果的有效数字将增加一倍。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/thumb/e/e0/NewtonIteration_Ani.gif/600px-NewtonIteration_Ani.gif&#34; width=400 height=300 /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// BetterFunc is a convience type definition.
type BetterFunc func(float64) float64
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// DecimalPlaces iterates to a fixed number of decimal places.
//
// Inputs are an improvement function, a starting value, the number of
// decimal places desired in the result, and an iteration limit.
// better 为迭代公式，start 为起始点，places 为视作迭代结束的最大精度值的小数点位数,
// maxIterations 为迭代最大次数
func DecimalPlaces(better BetterFunc, start float64, places, maxIterations int) (float64, error) {
	d := math.Pow(10, float64(-places))
	for i := 0; i &amp;lt; maxIterations; i++ {
		n := better(start)
		if math.Abs(n-start) &amp;lt; d {
			return n, nil
		}
		start = n
	}
	return 0, errors.New(&amp;quot;Maximum iterations reached&amp;quot;)
}

// FullPrecison iterates to (nearly) the full precision of a float64.
//
// To allow for a little bit of floating point jitter, FullPrecision iterates
// to 15 significant figures, which is the maximum number of full significant
// figures representable in a float64, but still a couple of bits shy of the
// full representable precision.
// 和 DecimalPlaces 功能类似，只不过默认迭代结束的标志为小于float64的最大精度15
func FullPrecision(better BetterFunc, start float64, maxIterations int) (float64, error) {
	for i := 0; i &amp;lt; maxIterations; i++ {
		n := better(start)
		if math.Abs((n-start)/n) &amp;lt; 1e-15 {
			return n, nil
		}
		start = n
	}
	return 0, errors.New(&amp;quot;Maximum iterations reached&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;3-二分迭代法&#34;&gt;3. 二分迭代法&lt;/h2&gt;

&lt;p&gt;　　二分迭代法，顾名思义，就是计算中点的函数值，并与当前低值和高值比较，&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;若与低值同号，则把该值作为新的低值，继续迭代&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;若与高值同号，则把该值作为新的高值，继续迭代&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// RootFunc is a convience type definition.
type RootFunc func(float64) float64
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// BinaryRoot finds a root between given bounds by binary search.
//
// Inputs are a function on x and the bounds on x.  A root must exist between
// the given bounds, otherwise the result is not meaningful.
// 因为float64 的小数bit位最多为52位(10进制为15位有效数字)，
// 即每次迭代理论上能提升一位精度，所以最多52次就应该跳出迭代
func BinaryRoot(f RootFunc, lower, upper float64) float64 {
	yLower := f(lower)
	var mid float64
	for j := 0; j &amp;lt; 52; j++ {
		mid = (lower + upper) / 2
		yMid := f(mid)
		if yMid == 0 {
			break
		}
		if math.Signbit(yLower) == math.Signbit(yMid) { // 与低值同号，替代低值
			lower = mid
			yLower = yMid
		} else {
			upper = mid //与高值同号，替换高值
		}
	}
	return mid
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>天文算法2</title>
      <link>https://mooncaker816.github.io/2018/05/13/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%952/</link>
      <pubDate>Sun, 13 May 2018 19:38:14 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/05/13/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%952/</guid>
      <description>&lt;h1 id=&#34;第四章-拟合-curve-fitting&#34;&gt;第四章 拟合 Curve Fitting&lt;/h1&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-什么是拟合&#34;&gt;1. 什么是拟合&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;曲线拟合(Curve Fitting)的数学定义是指用连续曲线近似地刻画或比拟平面上一组离散点所表示的坐标之间的函数关系，是一种用解析表达式逼近离散数据的方法。曲线拟合通俗的说法就是“拉曲线”，也就是将现有数据透过数学方法来代入一条数学方程式的表示方法。科学和工程遇到的很多问题，往往只能通过诸如采样、实验等方法获得若干离散的数据，根据这些数据，如果能够找到一个连续的函数（也就是曲线）或者更加密集的离散方程，使得实验数据与方程的曲线能够在最大程度上近似吻合，就可以根据曲线方程对数据进行数学计算，对实验结果进行理论分析，甚至对某些不具备测量条件的位置的结果进行估算。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;2-最小二乘拟合&#34;&gt;2. 最小二乘拟合&lt;/h2&gt;

&lt;p&gt;　　考虑 N 个数据点，它们的坐标是$(x_1,y_1),(x_2,y_2),\dots,(x_n,y_n)$
假设这些值中的 X 是严格的精确值，Y 的值是测量值(含有一些误差)。
对于一个给定的 X，如$x_1$，对应的值$y_1$与曲线 C 上对应的 Y 值将存在一个差值$d_1$，我们称这个差值为偏差、误差或残差，它可能是正、负或零。类似的，$x_2,\dots,x_n$,对应的差值为 $d_2,\dots,d_n$。&lt;/p&gt;

&lt;p&gt;　　我们用 $d_1^2+d_2^2+\cdots+d_n^2$ 作为衡量曲线 C 拟合的“最佳”程度，这个值越小越好，越大则越不好。因此，我们做以下定义：任何一种类型的曲线，它们都有一个共同的特性， 当 $$\sum_{i=1}^n d_i^2$$最小时，称为最佳拟合曲线。&lt;/p&gt;

&lt;p&gt;　　一条曲线具有这一特性时，称之为“最小二乘拟合”， 这样的曲线称为“最小二乘曲线”。&lt;/p&gt;

&lt;h3 id=&#34;2-1-线性拟合&#34;&gt;2.1 线性拟合&lt;/h3&gt;

&lt;p&gt;　　&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;线性方程&lt;/p&gt;

&lt;p&gt;假设拟合的曲线为直线$y=ax+b$,则最小二乘差方和为：
$$\sum_{i=1}^n[y_i-(ax_i+b)]^2$$
所以问题转化为求解上述关于a,b的二元函数的最小值&lt;/p&gt;

&lt;p&gt;对上式中a求偏导&lt;/p&gt;

&lt;p&gt;\begin{multline}
\shoveleft
\begin{aligned}
\frac \partial {\partial a}\sum_{i=1}^n[y_i-(ax_i+b)]^2 &amp;amp;= -2\sum_{i=1}^n({x_iy_i}-a{x_i^2}-b {x_i})\\[2ex]
&amp;amp; =-2\sum_{i=1}^n{x_i}[{y_i}-(a{x_i}+b)]\\[2ex]
\end{aligned}
\end{multline}&lt;/p&gt;

&lt;p&gt;\begin{multline}
\shoveleft
\text {由极值的必要条件可知，}\\[2ex]
\shoveleft
-2\sum_{i=1}^n{x_i}[{y_i}-(a{x_i}+b)] = 0\\[2ex]
\shoveleft
\therefore \sum_{i=1}^n{x_iy_i}-a\sum_{i=1}^n{x_i^2}-b\sum_{i=1}^n{x_i}=0
\end{multline}&lt;/p&gt;

&lt;p&gt;同理对b求偏导可得：
\begin{align}
\sum_{i=1}^n{y_i}-a\sum_{i=1}^n{x_i}-bn=0
\end{align}&lt;/p&gt;

&lt;p&gt;求解关于a,b 的二元一次方程组，
\begin{cases}
\sum\limits_{i=1}^n{x_iy_i}-a\sum\limits_{i=1}^n{x_i^2}-b\sum\limits_{i=1}^n{x_i}=0 \\[2ex]
\sum\limits_{i=1}^n{y_i}-a\sum\limits_{i=1}^n{x_i}-bn=0
\end{cases}&lt;/p&gt;

&lt;p&gt;得
\begin{align}
a &amp;amp;= \frac {\sum\limits_{i=1}^n{x_i}\sum\limits_{i=1}^n{y_i}-n\sum\limits_{i=1}^n{x_iy_i}}{  (\sum\limits_{i=1}^n{x_i})^2-n\sum\limits_{i=1}^n{x_i}^2}\\[2ex]
b &amp;amp;= \frac {\sum\limits_{i=1}^n{x_i}\sum\limits_{i=1}^n{x_iy_i}-\sum\limits_{i=1}^n{y_i} \sum\limits_{i=1}^n{x_i}^2}{(\sum\limits_{i=1}^n{x_i})^2-n\sum\limits_{i=1}^n{x_i}^2}
\end{align}&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;皮尔逊相关系数r&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E7%9A%AE%E5%B0%94%E9%80%8A%E7%A7%AF%E7%9F%A9%E7%9B%B8%E5%85%B3%E7%B3%BB%E6%95%B0&#34; target=&#34;_blank&#34;&gt;定义&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;由定义可知，
\begin{align}
r=\frac {\sum\limits_{i=1}^n(x_i-\bar x)(y_i-\bar y)}{\sqrt {\sum\limits_{i=1}^n(x_i-\bar x)^2}\sqrt {\sum\limits_{i=1}^n(y_i-\bar y)^2}}, \\[2ex]
\text {其中 } \bar x=\frac 1n\sum_{i=1}^nx_i,\bar y=\frac 1n\sum_{i=1}^ny_i
\end{align}&lt;/p&gt;

&lt;p&gt;\begin{multline}
\shoveleft
\begin{aligned}
化简 \ \  &amp;amp; \sum\limits_{i=1}^n(x_i-\bar x)(y_i-\bar y)\\[2ex]
= &amp;amp; \sum\limits_{i=1}^n(x_iy_i-x_i\bar y-\bar xy_i+\bar x\bar y)\\[2ex]
= &amp;amp; \sum\limits_{i=1}^nx_iy_i - \sum\limits_{i=1}^nx_i\bar y - \sum\limits_{i=1}^n\bar xy_i+\sum\limits_{i=1}^n\bar x\bar y\\[2ex]
= &amp;amp; \sum\limits_{i=1}^nx_iy_i - \frac 1n\sum\limits_{i=1}^ny_i\sum\limits_{i=1}^nx_i - \frac 1n\sum\limits_{i=1}^nx_i\sum\limits_{i=1}^ny_i + \frac 1n\sum\limits_{i=1}^nx_i\sum\limits_{i=1}^ny_i\\[2ex]
= &amp;amp; \sum\limits_{i=1}^nx_iy_i - \frac 1n\sum\limits_{i=1}^ny_i\sum\limits_{i=1}^nx_i\\[2ex]
化简 \ \  &amp;amp; \sum\limits_{i=1}^n(x_i-\bar x)^2\\[2ex]
= &amp;amp; \sum\limits_{i=1}^n(x_i^2-2x_i\bar x+\bar x^2)\\[2ex]
= &amp;amp; \sum\limits_{i=1}^nx_i^2 - 2\bar x\sum\limits_{i=1}^nx_i + n\bar x^2\\[2ex]
= &amp;amp; \sum\limits_{i=1}^nx_i^2 - 2n\bar x^2 + n\bar x^2\\[2ex]
= &amp;amp; \sum\limits_{i=1}^nx_i^2 - n\bar x^2\\[2ex]
= &amp;amp; \sum\limits_{i=1}^nx_i^2 - \frac 1n(\sum\limits_{i=1}^nx_i)^2\\[2ex]
同上 \ \  &amp;amp; \sum\limits_{i=1}^n(y_i-\bar y)^2\\[2ex]
= &amp;amp; \sum\limits_{i=1}^ny_i^2 - \frac 1n(\sum\limits_{i=1}^ny_i)^2\\[2ex]
\end{aligned}
\end{multline}
\begin{multline}
\shoveleft
\begin{aligned}
\therefore \ \ r&amp;amp;=\frac {\sum\limits_{i=1}^nx_iy_i - \frac 1n\sum\limits_{i=1}^ny_i\sum\limits_{i=1}^nx_i}{\sqrt{\sum\limits_{i=1}^nx_i^2 - \frac 1n(\sum\limits_{i=1}^nx_i)^2}\sqrt{\sum\limits_{i=1}^ny_i^2 - \frac 1n(\sum\limits_{i=1}^ny_i)^2}}\\[2ex]
&amp;amp; =\frac {n\sum\limits_{i=1}^nx_iy_i - \sum\limits_{i=1}^ny_i\sum\limits_{i=1}^nx_i}{\sqrt{n\sum\limits_{i=1}^nx_i^2 - (\sum\limits_{i=1}^nx_i)^2}\sqrt{n\sum\limits_{i=1}^ny_i^2 - (\sum\limits_{i=1}^ny_i)^2}}
\end{aligned}
\end{multline}&lt;/p&gt;

&lt;p&gt;　　这个系数介于+1 到-1 之间。如果值为+1 或-1，说明 x 和 y 之间有完全的线性关系，所有的点(x,y)精确的在同一条直线上。如果 r = +1，y 随 x 单调递增，如果 r = -1，y 随 x 单调递减。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;代码&lt;/p&gt;

&lt;p&gt;　　到这里我们就已经推导出求解线性方程和相关系数的公式，再结合代码看看&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Linear fits a line to sample data.
//
// Argument p is a list of data points.  Results a and b are coefficients
// of the best fit line y = ax + b.
// 求解线性拟合直线
// sx = ∑x sy = ∑y sxy = ∑xy sx2 = ∑x^2
func Linear(p []struct{ X, Y float64 }) (a, b float64) {
    var sx, sy, sx2, sxy float64
    for i := range p {
        x := p[i].X
        y := p[i].Y
        sx += x
        sy += y
        sx2 += x * x
        sxy += x * y
    }
    n := float64(len(p))
    d := n*sx2 - sx*sx
    // (4.2) p. 36
    a = (n*sxy - sx*sy) / d
    b = (sy*sx2 - sx*sxy) / d
    return
}

// CorrelationCoefficient returns a correlation coefficient for sample data.
// 求解相关系数 r
func CorrelationCoefficient(p []struct{ X, Y float64 }) float64 {
    var sx, sy, sx2, sy2, sxy float64
    for i := range p {
        x := p[i].X
        y := p[i].Y
        sx += x
        sy += y
        sx2 += x * x
        sy2 += y * y
        sxy += x * y
    }
    n := float64(len(p))
    // (4.3) p. 38
    return (n*sxy - sx*sy) / (math.Sqrt(n*sx2-sx*sx) * math.Sqrt(n*sy2-sy*sy))
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;2-2-二次曲线拟合&#34;&gt;2.2 二次曲线拟合&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;二次方程$y = ax^2 + bx + c$&lt;/p&gt;

&lt;p&gt;　　假设我们希望画一条逼近 N 个点的最佳二次曲线：$y = ax^2 + bx + c$ 这是一个纵轴的抛物线。同一次直线类似，差方和为$$\sum_{i=1}^n[y_i-(ax_i^2+bx_i+c)]^2$$
依次对上式中的a,b,c求偏导，得
\begin{align}
\sum_{i=1}^n(-2x_i^2y_i+2ax_i^4+2bx_i^3+2cx_i^2) = 0\\[2ex]
\sum_{i=1}^n(-2x_iy_i+2ax_i^3+2bx_i^2+2cx_i) = 0\\[2ex]
\sum_{i=1}^n(-2y_i+2ax_i^2+2bx_i+2c) = 0\\[2ex]
\end{align}
\begin{multline}
\begin{aligned}
\therefore &amp;amp; \sum_{i=1}^nx_i^2y_i=\sum_{i=1}^nax_i^4+\sum_{i=1}^nbx_i^3+\sum_{i=1}^ncx_i^2\\[2ex]
 &amp;amp; \sum_{i=1}^nx_iy_i=\sum_{i=1}^nax_i^3+\sum_{i=1}^nbx_i^2+\sum_{i=1}^ncx_i\\[2ex]
 &amp;amp; \sum_{i=1}^ny_i=\sum_{i=1}^nax_i^2+\sum_{i=1}^nbx_i+nc\\[2ex]
\end{aligned}
\end{multline}&lt;/p&gt;

&lt;p&gt;求解以下三元一次方程组
\begin{cases}
\sum\limits_{i=1}^nx_i^2y_i=\sum\limits_{i=1}^nax_i^4+\sum\limits_{i=1}^nbx_i^3+\sum\limits_{i=1}^ncx_i^2\\[2ex]
\sum\limits_{i=1}^nx_iy_i=\sum\limits_{i=1}^nax_i^3+\sum\limits_{i=1}^nbx_i^2+\sum\limits_{i=1}^ncx_i\\[2ex]
\sum\limits_{i=1}^ny_i=\sum\limits_{i=1}^nax_i^2+\sum\limits_{i=1}^nbx_i+nc\\[2ex]
\end{cases}&lt;/p&gt;

&lt;p&gt;得
\begin{multline}
\shoveleft
\begin{aligned}
a &amp;amp;= \frac {NQV+PRT+PQU-Q^2T-P^2V-NRU}{D}\\[2ex]
b &amp;amp;= \frac {NSU+PQV+QRT-Q^2U-PST-NRV}{D}\\[2ex]
c &amp;amp;= \frac {QST+QRU+PRV-Q^2V-PSU-R^2T}{D}\\[2ex]
\end{aligned}
\end{multline}&lt;/p&gt;

&lt;p&gt;\begin{multline}
\shoveleft
\begin{aligned}
其中\ &amp;amp;P =\sum\limits_{i=1}^nx_i,\ Q=\sum\limits_{i=1}^nx_i^2,\ R=\sum\limits_{i=1}^nx_i^3,\ S=\sum\limits_{i=1}^nx_i^4,\\[2ex]
&amp;amp;T=\sum\limits_{i=1}^ny_i,\ U=\sum\limits_{i=1}^nx_iy_i,\ V=\sum\limits_{i=1}^nx_i^2y_i,\\[2ex]
&amp;amp;D = NQS+2PQR-Q^3-P^2S-NR^2
\end{aligned}
\end{multline}&lt;/p&gt;

&lt;p&gt;　　至此我们的程序就能很方便的通过上述公式，对这 N 个点进行一次完整的遍历，计算上述 P,Q,R,S,T,U,V,D,即可求得拟合曲线方程。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Quadratic fits y = ax² + bx + c to sample data.
//
// Argument p is a list of data points.  Results a, b, and c are coefficients
// of the best fit quadratic y = ax² + bx + c.
// 求解二次拟合曲线系数
func Quadratic(p []struct{ X, Y float64 }) (a, b, c float64) {
    var P, Q, R, S, T, U, V float64
    for i := range p {
        x := p[i].X
        y := p[i].Y
        x2 := x * x
        P += x
        Q += x2
        R += x * x2
        S += x2 * x2
        T += y
        U += x * y
        V += x2 * y
    }
    N := float64(len(p))
    // (4.5) p. 43
    D := N*Q*S + 2*P*Q*R - Q*Q*Q - P*P*S - N*R*R
    // (4.6) p. 43
    a = (N*Q*V + P*R*T + P*Q*U - Q*Q*T - P*P*V - N*R*U) / D
    b = (N*S*U + P*Q*V + Q*R*T - Q*Q*U - P*S*T - N*R*V) / D
    c = (Q*S*T + Q*R*U + P*R*V - Q*Q*V - P*S*U - R*R*T) / D
    return
}   
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;一般曲线拟合（多重线回归）&lt;/p&gt;

&lt;p&gt;　　最佳线性拟合的原理可以被扩展到其它函数，这个函数可以含有超过两个未知的线性系数。
让我们考虑三个函数的线性组合的情况。 假设我们已知：$$y = af_0(x) + bf_1(x) + cf_2(x)$$
式中$f_0$、$f_1$ 和 $f_2$ 是三个关于 x 的已知函数，但系数 a、 b 和 c 是未知的。此外，假设已知 3 个 x 对应的 y 值。那么 系数 a、b、c 可按如下得到。
求和计算：
\begin{align}
M &amp;amp;= \sum f_0^2 &amp;amp;U &amp;amp;= \sum yf_0\\[2ex]
P &amp;amp;= \sum f_0f_1 &amp;amp;V &amp;amp;= \sum yf_1\\[2ex]
Q &amp;amp;= \sum f_0f_2 &amp;amp;W &amp;amp;= \sum yf_2\\[2ex]
R &amp;amp;= \sum f_1^2 \\[2ex]
S &amp;amp;= \sum f_1f_2 \\[2ex]
T &amp;amp;= \sum f_2^2 \\[2ex]
\end{align}
$$D = MRT+2PQS-MS^2-RQ^2-TP^2$$
那么：
\begin{align}
a &amp;amp;= \frac {U(RT-S^2)+V(QS-PT)+W(PS-QR)}{D}\\[2ex]
b &amp;amp;= \frac {U(SQ-PT)+V(MT-Q^2)+W(PQ-MS)}{D}\\[2ex]
c &amp;amp;= \frac {U(PS-RQ)+V(PQ-MS)+W(MR-P^2)}{D}
\end{align}
另一种特殊情况，考虑 y=af(x)，只有一个未知系数。 我们容易得到：
$$a = \frac {\sum yf}{\sum f^2}$$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Func3 implements multiple linear regression for a linear combination
// of three functions.
//
// Given sample data and three functions in x, Func3 returns coefficients
// a, b, and c fitting y = aƒ₀(x) + bƒ₁(x) + cƒ₂(x) to sample data.
// 多重线性回归
func Func3(p []struct{ X, Y float64 }, f0, f1, f2 func(float64) float64) (a, b, c float64)  {
    var M, P, Q, R, S, T, U, V, W float64
    for i := range p {
        x := p[i].X
        y := p[i].Y
        y0 := f0(x)
        y1 := f1(x)
        y2 := f2(x)
        M += y0 * y0
        P += y0 * y1
        Q += y0 * y2
        R += y1 * y1
        S += y1 * y2
        T += y2 * y2
        U += y * y0
        V += y * y1
        W += y * y2
    }
    // (4.7) p. 44
    D := M*R*T + 2*P*Q*S - M*S*S - R*Q*Q - T*P*P
    a = (U*(R*T-S*S) + V*(Q*S-P*T) + W*(P*S-Q*R)) / D
    b = (U*(S*Q-P*T) + V*(M*T-Q*Q) + W*(P*Q-M*S)) / D
    c = (U*(P*S-R*Q) + V*(P*Q-M*S) + W*(M*R-P*P)) / D
    return
}

// Func1 fits a linear multiple of a function to sample data.
//
// Given sample data and a function in x, Func1 returns coefficient
// a fitting y = aƒ(x).
func Func1(p []struct{ X, Y float64 }, f func(float64) float64) float64 {
    var syf, sf2 float64
    // (4.8) p. 45
    for i := range p {
        f := f(p[i].X)
        y := p[i].Y
        syf += y * f
        sf2 += f * f
    }
    return syf / sf2
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>天文算法1</title>
      <link>https://mooncaker816.github.io/2018/05/12/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%951/</link>
      <pubDate>Sat, 12 May 2018 21:43:17 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/05/12/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%951/</guid>
      <description>&lt;h2 id=&#34;①背景&#34;&gt;①背景&lt;/h2&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;计算精确的农历节气和日月合朔时间点，需要使用天文算法来实现。《Astronomical Algorithms》正是这么一本不那么让人望而生畏的介绍天文算法的书籍，国内比较出名的寿星万年历亦是基于此书中的算法。&lt;/p&gt;

&lt;p&gt;作为一名 Gopher 本想自造轮子来实现，但是万能的 Github 上已有前人身先士卒，直接上地址&lt;a href=&#34;https://github.com/soniakeys/meeus&#34; target=&#34;_blank&#34;&gt;meeus&lt;/a&gt;，该库基本上完整的实现了Astronomical Algorithms中的算法，而且每一章节对应一个 package，浏览起来不会让人感觉没有头绪。&lt;/p&gt;

&lt;p&gt;好了，话不多说，接下来就结合书和代码来学习。&lt;/p&gt;

&lt;h2 id=&#34;②第一章hints-and-tips&#34;&gt;②第一章Hints and Tips&lt;/h2&gt;

&lt;p&gt;略&lt;/p&gt;

&lt;h2 id=&#34;③第二章-about-accuracy&#34;&gt;③第二章 About accuracy&lt;/h2&gt;

&lt;p&gt;略&lt;/p&gt;

&lt;h2 id=&#34;④第三章-interpolation-插值&#34;&gt;④第三章 Interpolation 插值&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%A6&#34; target=&#34;_blank&#34;&gt;数学&lt;/a&gt;的&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90&#34; target=&#34;_blank&#34;&gt;数值分析&lt;/a&gt;领域中，&lt;strong&gt;内插&lt;/strong&gt;或称插值（英语：interpolation)是一种通过已知的、&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E9%9B%A2%E6%95%A3&#34; target=&#34;_blank&#34;&gt;离散&lt;/a&gt;的&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE&#34; target=&#34;_blank&#34;&gt;数据&lt;/a&gt;点，在范围内推求新数据点的过程或方法。求解&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E7%A7%91%E5%AD%A6&#34; target=&#34;_blank&#34;&gt;科学&lt;/a&gt;和&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%B7%A5%E7%A8%8B&#34; target=&#34;_blank&#34;&gt;工程&lt;/a&gt;的问题时，通常有许多数据点借由&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E9%87%87%E6%A0%B7&#34; target=&#34;_blank&#34;&gt;采样&lt;/a&gt;、&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%AE%9E%E9%AA%8C&#34; target=&#34;_blank&#34;&gt;实验&lt;/a&gt;等方法获得，这些数据可能代表了有限个数值函数，其中自变量的值。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;本章主要介绍了低阶等距节点牛顿插值和拉格朗日插值的应用。&lt;/p&gt;

&lt;h3 id=&#34;1-牛顿插值&#34;&gt;1. &lt;strong&gt;牛顿插值&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E7%89%9B%E9%A1%BF%E5%A4%9A%E9%A1%B9%E5%BC%8F&#34; target=&#34;_blank&#34;&gt;牛顿多项式&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%B7%AE%E5%88%86&#34; target=&#34;_blank&#34;&gt;差分&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;2-三点等距二阶差商的牛顿插值&#34;&gt;2. &lt;strong&gt;三点等距二阶差商的牛顿插值&lt;/strong&gt;&lt;/h3&gt;

&lt;h4 id=&#34;2-1-插值公式&#34;&gt;2.1  插值公式&lt;/h4&gt;

&lt;p&gt;二阶牛顿插值多项式为:
$N(x) = [y_0] + [y_0,y_1](x-x_0) + [y_0,y_1,y_2](x-x_0)(x-x_1)$，如下图
&lt;img src=&#34;https://wikimedia.org/api/rest_v1/media/math/render/svg/b8d0bfa61c4977eeaf3022de361f67dd5f4cb8a9&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;假设有三点$(x_0,y_0),(x_1,y_1),(x_2,y_2),x_0,x_1,x_2$等距(单位长度1) ,&lt;/p&gt;

&lt;p&gt;且$n$ 为插值因子,$x$距离$x_1$最近
\begin{align}
n&amp;amp;=(x-x_1)/单位长度\\&lt;br /&gt;
&amp;amp;=x-x1
\end{align}&lt;/p&gt;

&lt;p&gt;令 $a=y_1-y_0, b=y_2-y_1,c=b-a=y_0+y_2-2y_1$
则有：
\begin{align}
x-x_0 &amp;amp;= x-x_1 + 1\\&lt;br /&gt;
&amp;amp;= n + 1
\end{align}
\begin{align}
f(x) &amp;amp;= y_0 + a(x-x_0)+(c/(x_2-x_0))(x-x_0)(x-x_1)\\&lt;br /&gt;
&amp;amp;= y_0 + a(n+1) + 0.5c(n+1)n\\&lt;br /&gt;
&amp;amp;= y_1-a + an + a + 0.5n(cn+c)\\&lt;br /&gt;
&amp;amp;= y_1 + 0.5n(cn+b-a+2a)\\&lt;br /&gt;
&amp;amp;= y_1 + 0.5n(cn+a+b)\\&lt;br /&gt;
\end{align}&lt;/p&gt;

&lt;p&gt;即为算法中三点插值的公式.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;书中三点从1开始计数，公式为:$y_2+0.5n(cn+a+b)$&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Len3 allows second difference interpolation.
// 等距三点插值结构
type Len3 struct {
x1, x3             float64   //x1,x3分别为起始点和终止点，无需给出x2，因为等距
y                  []float64 //y为x1,x2,x3对应的值的序列
a, b, c            float64   //a=y2-y1, b=y3-y2, c=b-a=y3+y1-2y2
abSum, xSum, xDiff float64   //计数插值的中间变量
}

// NewLen3 prepares a Len3 object from a table of three rows of x and y values.
//
// X values must be equally spaced, so only the first and last are supplied.
// X1 must not equal x3.  Y must be a slice of three y values.
// 根据上述定义，创建三点插值结构
func NewLen3(x1, x3 float64, y []float64) (*Len3, error) {
if len(y) != 3 {
	return nil, ErrorNot3
}
if x3 == x1 {
	return nil, ErrorNoXRange
}
d := &amp;amp;Len3{
	x1: x1,
	x3: x3,
	y:  append([]float64{}, y...),
}
// differences. (3.1) p. 23
d.a = y[1] - y[0]
d.b = y[2] - y[1]
d.c = d.b - d.a
// other intermediate values
d.abSum = d.a + d.b
d.xSum = x3 + x1
d.xDiff = x3 - x1
return d, nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;考虑到实际问题中一般可能多于三点，此时只要选取目标点附近的三点即可，可用以下函数来自动构造&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Len3ForInterpolateX is a special purpose Len3 constructor.
//
// Like NewLen3, it takes a table of x and y values, but it is not limited
// to tables of 3 rows.  An X value is also passed that represents the
// interpolation target x value.  Len3ForInterpolateX will locate the
// appropriate three rows of the table for interpolating for x, and initialize
// the Len3 object for those rows.
//
//	x is the target for interpolation
//	x1 is the x value corresponding to the first y value of the table.
//	xn is the x value corresponding to the last y value of the table.
//	y is all y values in the table.  len(y) should be &amp;gt;= 3.
//
// 给定n个点，但是我们只需选取离目标点x最接近的三个点来做三点插值，
// 此时可用以下函数来自动选择最优三点，来构造三点插值
// 同样，前提是n个点等距，且与y一一对应
func Len3ForInterpolateX(x, x1, xn float64, y []float64) (*Len3, error) {
	if len(y) &amp;gt; 3 {
		interval := (xn - x1) / float64(len(y)-1)
		if interval == 0 {
			return nil, ErrorNoXRange
		}
		nearestX := int((x-x1)/interval + .5)
		if nearestX &amp;lt; 1 {
			nearestX = 1
		} else if nearestX &amp;gt; len(y)-2 {
			nearestX = len(y) - 2
		}
		y = y[nearestX-1 : nearestX+2]
		xn = x1 + float64(nearestX+1)*interval
		x1 = x1 + float64(nearestX-1)*interval
	}
	return NewLen3(x1, xn, y)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;插值因子 $n$ 为：目标点 $x$ 与 中间点 $x_2$之差除以实际步长&lt;br /&gt;
\begin{equation}
\because n = 2(x - x_2)/(x_3-x_1), x_2 = x_1 + (x_3-x_1)/2\\&lt;br /&gt;
\therefore n = [2x - (x_1+x_3)]/(x_3-x_1)\\&lt;br /&gt;
\end{equation}&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// InterpolateX interpolates for a given x value.
// 计算插值因子n，调用非严格插值计算
func (d *Len3) InterpolateX(x float64) (y float64) {
	n := (2*x - d.xSum) / d.xDiff
	return d.InterpolateN(n)
}

// InterpolateXStrict interpolates for a given x value,
// restricting x to the range x1 to x3 given to the constructor NewLen3.
// 计算插值因子n，调用严格插值计算
func (d *Len3) InterpolateXStrict(x float64) (y float64, err error) {
	n := (2*x - d.xSum) / d.xDiff
	y, err = d.InterpolateNStrict(n)
	if err == ErrorNOutOfRange {
		err = ErrorXOutOfRange
	}
	return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过调用三点插值公式获得目标插值，这里分为严格模式和非严格模式，&lt;/p&gt;

&lt;p&gt;所谓严格模式就是指目标点一定在三点的范围之内且必须离我们选择的三点的中间点最近，确保插值子$|n|&amp;lt;=1$；&lt;/p&gt;

&lt;p&gt;非严格模式就没有上述规定，可能目标点已经超出三点范围，得出的结果也相对不如严格模式精确。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// InterpolateN interpolates for a given interpolating factor n.
//
// This is interpolation formula (3.3)
//
// The interpolation factor n is x-x2 in units of the tabular x interval.
// (See Meeus p. 24.)
// 非严格插值计算，不用保证目标点插值因子绝对值小于等于1，
// 即不用保证离我们所选三点中点距离小于一个步长
func (d *Len3) InterpolateN(n float64) (y float64) {
	return d.y[1] + n*.5*(d.abSum+n*d.c)
}

// InterpolateNStrict interpolates for a given interpolating factor n.
//
// N is restricted to the range [-1..1] corresponding to the range x1 to x3
// given to the constructor NewLen3.
// 严格插值计算，必须保证目标点插值因子绝对值小于等于1，
// 即必须保证离我们所选三点中点距离小于一个步长
func (d *Len3) InterpolateNStrict(n float64) (y float64, err error) {
	if n &amp;lt; -1 || n &amp;gt; 1 {
		return 0, ErrorNOutOfRange
	}
	return d.InterpolateN(n), nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;2-2-极值&#34;&gt;2.2 &lt;strong&gt;极值&lt;/strong&gt;：&lt;/h4&gt;

&lt;p&gt;因为 $y_1 + 0.5n(cn+a+b)$是关于 $n$ 的二次函数($c \neq 0$时)，由二次函数的性质可知：&lt;/p&gt;

&lt;p&gt;当 $n=-(a+b)/(2c)$时，有极值$-(a+b)^2/(8c)$&lt;/p&gt;

&lt;p&gt;但是如果插值因子$|n|&amp;gt;1$,则无法取到(已超出插值函数的定义域)&lt;/p&gt;

&lt;p&gt;再由$n = [2x - (x_1+x_3)]/(x_3-x_1)$&lt;/p&gt;

&lt;p&gt;得出此时实际$x = [n(x_3-x_1)+(x_1+x_3)]/2$&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Extremum returns the x and y values at the extremum.
//
// Results are restricted to the range of the table given to the constructor
// NewLen3.
func (d *Len3) Extremum() (x, y float64, err error) {
	if d.c == 0 {
		return 0, 0, ErrorNoExtremum
	}
	n := d.abSum / (-2 * d.c) // (3.5), p. 25
	if n &amp;lt; -1 || n &amp;gt; 1 {
		return 0, 0, ErrorExtremumOutside
	}
	x = .5 * (d.xSum + d.xDiff*n)          // 根据实际步长得出极值点x
	y = d.y[1] - (d.abSum*d.abSum)/(8*d.c) // (3.4), p. 25
	return x, y, nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;2-3-根&#34;&gt;2.3 根&lt;/h4&gt;

&lt;p&gt;和普通方程类似，有时候我们需要求解插值函数的&amp;rdquo;根&amp;rdquo;，即 $y=0$所对应的插值点&lt;/p&gt;

&lt;p&gt;同样借助 $y=y_1+ 0.5n(cn+a+b)$,令 $y=0$&lt;/p&gt;

&lt;p&gt;得$n = -2y_1/(cn+a+b)$&lt;/p&gt;

&lt;p&gt;此时再利用迭代法求解近似根 $n_0$&lt;/p&gt;

&lt;p&gt;当插值曲线曲率比较大时，可采用以下修正量来进行迭代，直到满足精度要求为止&lt;/p&gt;

&lt;p&gt;$Δn_0 = -[ 2y_1 +n_0 (a+b+cn_0 ) ]/(a +b + 2cn_0 )$&lt;/p&gt;

&lt;p&gt;求解得到满足精度要求的 $n$ 后，再根据实际步长得出 $x$，即为&amp;rdquo;根&amp;rdquo;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Len3Zero finds a zero of the quadratic function represented by the table.
//
// That is, it returns an x value that yields y=0.
//
// Argument strong switches between two strategies for the estimation step.
// when iterating to converge on the zero.
//
// Strong=false specifies a quick and dirty estimate that works well
// for gentle curves, but can work poorly or fail on more dramatic curves.
//
// Strong=true specifies a more sophisticated and thus somewhat more
// expensive estimate.  However, if the curve has quick changes, This estimate
// will converge more reliably and in fewer steps, making it a better choice.
//
// Results are restricted to the range of the table given to the constructor
// NewLen3.
// strong 为考虑修正量的迭代方式，更为精确
func (d *Len3) Zero(strong bool) (x float64, err error) {
	var f iterFunc
	if strong {
		// (3.7), p. 27
		f = func(n0 float64) float64 {
			return n0 - (2*d.y[1]+n0*(d.abSum+d.c*n0))/(d.abSum+2*d.c*n0)
		}
	} else {
		// (3.6), p. 26
		f = func(n0 float64) float64 {
			return -2 * d.y[1] / (d.abSum + d.c*n0)
		}
	}
	n0, ok := iterate(0, f)
	if !ok {
		return 0, ErrorNoConverge
	}
	if n0 &amp;gt; 1 || n0 &amp;lt; -1 {
		return 0, ErrorZeroOutside
	}
	return .5 * (d.xSum + d.xDiff*n0), nil // success
}

type iterFunc func(n0 float64) (n1 float64)

func iterate(n0 float64, f iterFunc) (n1 float64, ok bool) {
	for limit := 0; limit &amp;lt; 50; limit++ {
		n1 = f(n0)
		if math.IsInf(n1, 0) || math.IsNaN(n1) {
			break // failure to converge
		}
		if math.Abs((n1-n0)/n0) &amp;lt; 1e-15 {
			return n1, true // success
		}
		n0 = n1
	}
	return 0, false // failure to converge
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3-五点等距四阶差商的牛顿插值&#34;&gt;3.  &lt;strong&gt;五点等距四阶差商的牛顿插值&lt;/strong&gt;&lt;/h3&gt;

&lt;h4 id=&#34;3-1-五点插值公式&#34;&gt;3.1 五点插值公式&lt;/h4&gt;

&lt;p&gt;五点和三点类似，这里直接给出公式，不再进行推导&lt;/p&gt;

&lt;p&gt;5点：$(x_1,y_1),(x_2,y_2),(x_3,y_3),(x_4,y_4),(x_5,y_5)$&lt;/p&gt;

&lt;p&gt;$y=y_3+ \frac {n} {2}(b+c)+\frac {n^2} {2}f+\frac{n(n^2-1)}{12}(h+j)+\frac {n^2(n^2-1)}{24k}$&lt;/p&gt;

&lt;p&gt;或者&lt;/p&gt;

&lt;p&gt;$y=y_3+n(\frac {b+c}{2}-\frac {h+j}{12})+n^2(\frac {f}{2}-\frac {k}{24})+n^3(\frac {h+j}{12})+n^4(\frac {k}{24})$&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Len5 allows fourth difference interpolation.
// 五点等距插值结构
type Len5 struct {
	x1, x5      float64   // x1为起始点，x5为终止点
	y           []float64 // y 为x1,x2,x3,x4,x5的一一映射
	a, b, c, d  float64   // a=y2-y1, b=y3-y2, c=y4-y3, d=y5-y4
	e, f, g     float64   // e=b-a, f=c-b, g=d-c
	h, j, k     float64   // h=f-e, j=g-f, k=j-h
	y3          float64   // y3为中间点的 y 值
	xSum, xDiff float64   // xSum=x1+x5, xDiff=x5-x1
	interpCoeff []float64 // 插值函数对应插值因子 n 的各项系数（0-4）
}

// NewLen5 prepares a Len5 object from a table of five rows of x and y values.
//
// X values must be equally spaced, so only the first and last are supplied.
// X1 must not equal x5.  Y must be a slice of five y values.
// 构造5点插值结构
func NewLen5(x1, x5 float64, y []float64) (*Len5, error) {
	if len(y) != 5 {
		return nil, ErrorNot5
	}
	if x5 == x1 {
		return nil, ErrorNoXRange
	}
	d := &amp;amp;Len5{
		x1: x1,
		x5: x5,
		y:  append([]float64{}, y...),
		y3: y[2],
	}
	// differences
	d.a = y[1] - y[0]
	d.b = y[2] - y[1]
	d.c = y[3] - y[2]
	d.d = y[4] - y[3]
	d.e = d.b - d.a
	d.f = d.c - d.b
	d.g = d.d - d.c
	d.h = d.f - d.e
	d.j = d.g - d.f
	d.k = d.j - d.h
	// other intermediate values
	d.xSum = x5 + x1
	d.xDiff = x5 - x1
	d.interpCoeff = []float64{ // (3.8) p. 28
		d.y3,
		(d.b+d.c)/2 - (d.h+d.j)/12,
		d.f/2 - d.k/24,
		(d.h + d.j) / 12,
		d.k / 24,
	}
	return d, nil
}
// InterpolateX interpolates for a given x value.
func (d *Len5) InterpolateX(x float64) (y float64) {
	n := (4*x - 2*d.xSum) / d.xDiff
	return d.InterpolateN(n)
}
// InterpolateXStrict interpolates for a given x value,
// restricting x to the range x1 to x5 given to the the constructor NewLen5.
func (d *Len5) InterpolateXStrict(x float64) (y float64, err error) {
	n := (4*x - 2*d.xSum) / d.xDiff
	y, err = d.InterpolateNStrict(n)
	if err == ErrorNOutOfRange {
		err = ErrorXOutOfRange
	}
	return
}
// InterpolateN interpolates for a given interpolating factor n.
//
// The interpolation factor n is x-x3 in units of the tabular x interval.
// (See Meeus p. 28.)
// Horner 为工具函数，求解多项式之和，interpCoeff为多项式系数
func (d *Len5) InterpolateN(n float64) (y float64) {
	return base.Horner(n, d.interpCoeff...)
}
// InterpolateNStrict interpolates for a given interpolating factor n.
//
// N is restricted to the range [-1..1].  This is only half the range given
// to the constructor NewLen5, but is the recommendation given on p. 31.
func (d *Len5) InterpolateNStrict(n float64) (y float64, err error) {
	if n &amp;lt; -1 || n &amp;gt; 1 {
		return 0, ErrorNOutOfRange
	}
	return base.Horner(n, d.interpCoeff...), nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;3-2-五点极值&#34;&gt;3.2 五点极值&lt;/h4&gt;

&lt;p&gt;函数的极值对应的插值因子 $n_m$ 可通过解以下方程得到：&lt;/p&gt;

&lt;p&gt;$n_m=\frac {6b+6c-h-j+3n_m^2(h+j)+2n_m^3k}{k-12f}$&lt;/p&gt;

&lt;p&gt;和上面的一样，我们可以执行迭代。首次，把 $n_m=0$代 入方程右边,迭代求得$n_m$&lt;/p&gt;

&lt;p&gt;当我们最后得到$n_m$后，$x_m=\frac {x_1+x_5}{2}+\frac {x_5-x_1}{4}n_m$&lt;/p&gt;

&lt;p&gt;再代入5点插值函数就可以获得极值&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Extremum returns the x and y values at the extremum.
//
// Results are restricted to the range of the table given to the constructor
// NewLen5.  (Meeus actually recommends restricting the range to one unit of
// the tabular interval, but that seems a little harsh.)
// 5点插值极值
func (d *Len5) Extremum() (x, y float64, err error) {
	// (3.9) p. 29
	nCoeff := []float64{
		6*(d.b+d.c) - d.h - d.j,
		0,
		3 * (d.h + d.k), // 不应该是 d.h+d.j 吗？
		2 * d.k,
	}
	den := d.k - 12*d.f
	if den == 0 {
		return 0, 0, ErrorExtremumOutside
	}
	n0, ok := iterate(0, func(n0 float64) float64 {
		return base.Horner(n0, nCoeff...) / den
	})
	if !ok {
		return 0, 0, ErrorNoConverge
	}
	if n0 &amp;lt; -2 || n0 &amp;gt; 2 {
		return 0, 0, ErrorExtremumOutside
	}
	x = .5*d.xSum + .25*d.xDiff*n0
	y = base.Horner(n0, d.interpCoeff...)
	return x, y, nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;3-3-五点求根&#34;&gt;3.3 五点求根&lt;/h4&gt;

&lt;p&gt;令$y=0$通过以下公式迭代求插值因子$n_0$,起始$n_0=0$&lt;/p&gt;

&lt;p&gt;$n_0=\frac {-24y_3+n_0^2(k-12f)-2n_0^3(h+j)-n_0^4k}{2(6b+6c-h-j)}$&lt;/p&gt;

&lt;p&gt;当曲率比较大时，同样可以加入修正&lt;/p&gt;

&lt;p&gt;$Δn_0 =-\frac {Mn_0^4+Nn_0^3+Pn_0^2+Qn_0+y_3}{4Mn_0^3+3Nn_0^2+2Pn_0+Q},$&lt;/p&gt;

&lt;p&gt;$(M=\frac{k}{24},N=\frac{h+j}{12},P=\frac{f}{2}-M,Q=\frac{b+c}{2}-N)$&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Len5Zero finds a zero of the quartic function represented by the table.
//
// That is, it returns an x value that yields y=0.
//
// Argument strong switches between two strategies for the estimation step.
// when iterating to converge on the zero.
//
// Strong=false specifies a quick and dirty estimate that works well
// for gentle curves, but can work poorly or fail on more dramatic curves.
//
// Strong=true specifies a more sophisticated and thus somewhat more
// expensive estimate.  However, if the curve has quick changes, This estimate
// will converge more reliably and in fewer steps, making it a better choice.
//
// Results are restricted to the range of the table given to the constructor
// NewLen5.
// strong 为带修正模式
func (d *Len5) Zero(strong bool) (x float64, err error) {
	var f iterFunc
	if strong {
		// (3.11), p. 29
		M := d.k / 24
		N := (d.h + d.j) / 12
		P := d.f/2 - M
		Q := (d.b+d.c)/2 - N
		numCoeff := []float64{d.y3, Q, P, N, M}
		denCoeff := []float64{Q, 2 * P, 3 * N, 4 * M}
		f = func(n0 float64) float64 {
			return n0 -
				base.Horner(n0, numCoeff...)/base.Horner(n0, denCoeff...)
		}
	} else {
		// (3.10), p. 29
		numCoeff := []float64{
			-24 * d.y3,
			0,
			d.k - 12*d.f,
			-2 * (d.h + d.j),
			-d.k,
		}
		den := 12*(d.b+d.c) - 2*(d.h+d.j)
		f = func(n0 float64) float64 {
			return base.Horner(n0, numCoeff...) / den
		}
	}
	n0, ok := iterate(0, f)
	if !ok {
		return 0, ErrorNoConverge
	}
	if n0 &amp;gt; 2 || n0 &amp;lt; -2 {
		return 0, ErrorZeroOutside
	}
	x = .5*d.xSum + .25*d.xDiff*n0
	return x, nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;4-四点等距中间点插值&#34;&gt;4. &lt;strong&gt;四点等距中间点插值&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;假设有$(x_1,y_1),(x_2,y_2),(x_3,y_3),(x_4,y_4)$
那么 $x_2$到 $x_3$ 之间的中点对应的函数值为：
$y = [ 9(y_2 +y_3 ) - y_1 - y_4 ] / 16$&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Len4Half interpolates a center value from a table of four rows.
func Len4Half(y []float64) (float64, error) {
	if len(y) != 4 {
		return 0, ErrorNot4
	}
	// (3.12) p. 32
	return (9*(y[1]+y[2]) - y[0] - y[3]) / 16, nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;5-横坐标不等间距插值-拉格朗日插值&#34;&gt;5. &lt;strong&gt;横坐标不等间距插值：拉格朗日插值&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;\begin{align}
y=y_1L_1+y_2L_2+\cdots+y_nL_n\\[2ex]
L_i = \prod_{
\substack{
i+1\\&lt;br /&gt;
i \neq j
}}^n
\frac {x-x_j}{x_i-x_j}
\end{align}&lt;/p&gt;

&lt;p&gt;上式是一个 $n-1$ 阶的多项式，这是利用 $y_1,y_2,\dots y_n$ 所能得到的唯一的一个 $n-1$ 阶多项式（注：多项式 插值具有唯一性）。但拉格朗日公式本身有个缺点，就是没有给出所需的数据点数量，以争取达到理想的精度。不过， 当我们希望表达一个函数的明确的插值多项式时，而$x$ 又远离插值节点，那么使用拉格朗日公式是有益的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Lagrange performs interpolation with unequally-spaced abscissae.
//
// Given a table of X and Y values, interpolate a new y value for argument x.
//
// X values in the table do not have to be equally spaced; they do not even
// have to be in order.  They must however, be distinct.
// table 中包含了 n 个点且xi 必须互异,x 为目标插值点
func Lagrange(x float64, table []struct{ X, Y float64 }) (y float64) {
	// method of BASIC program, p. 33.
	sum := 0.
	for i := range table {
		xi := table[i].X
		prod := 1.
		for j := range table {
			if i != j {
				xj := table[j].X
				prod *= (x - xj) / (xi - xj)
			}
		}
		sum += table[i].Y * prod
	}
	return sum
}
// LagrangePoly uses the formula of Lagrange to produce an interpolating
// polynomial.
//
// X values in the table do not have to be equally spaced; they do not even
// have to be in order.  They must however, be distinct.
//
// The returned polynomial will be of degree n-1 where n is the number of rows
// in the table.  It can be evaluated for x using common.Horner.
// 构造拉格朗日多项式，返回各项系数(0-n)
func LagrangePoly(table []struct{ X, Y float64 }) []float64 {
	// Method not fully described by Meeus, but needed for numerical solution
	// to Example 3.g.
	sum := make([]float64, len(table))
	prod := make([]float64, len(table))
	last := len(table) - 1
	for i := range table {
		xi := table[i].X
		yi := table[i].Y
		prod[last] = 1
		den := 1.
		n := last
		for j := range table {
			if i != j {
				xj := table[j].X
				prod[n-1] = prod[n] * -xj
				for k := n; k &amp;lt; last; k++ {
					prod[k] -= prod[k+1] * xj
				}
				n--
				den *= (xi - xj)
			}
		}
		for j, pj := range prod {
			sum[j] += yi * pj / den
		}
	}
	return sum
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Linux Centos 命令之 cp,rm,mv</title>
      <link>https://mooncaker816.github.io/2018/04/21/linux-centos-%E5%91%BD%E4%BB%A4%E4%B9%8B-cprmmv/</link>
      <pubDate>Sat, 21 Apr 2018 13:50:00 +0000</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/04/21/linux-centos-%E5%91%BD%E4%BB%A4%E4%B9%8B-cprmmv/</guid>
      <description>&lt;h2 id=&#34;cp-copy-拷贝目录-文件&#34;&gt;cp - copy 拷贝目录，文件&lt;/h2&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;usage&#34;&gt;Usage：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Usage: cp [OPTION]... [-T] SOURCE DEST
  or:  cp [OPTION]... SOURCE... DIRECTORY
  or:  cp [OPTION]... -t DIRECTORY SOURCE...
Copy SOURCE to DEST, or multiple SOURCE(s) to DIRECTORY.

Mandatory arguments to long options are mandatory for short options too.
  -a, --archive                same as -dR --preserve=all
      --attributes-only        don&#39;t copy the file data, just the attributes
      --backup[=CONTROL]       make a backup of each existing destination file
  -b                           like --backup but does not accept an argument
      --copy-contents          copy contents of special files when recursive
  -d                           same as --no-dereference --preserve=links
  -f, --force                  if an existing destination file cannot be
                                 opened, remove it and try again (this option
                                 is ignored when the -n option is also used)
  -i, --interactive            prompt before overwrite (overrides a previous -n
                                  option)
  -H                           follow command-line symbolic links in SOURCE
  -l, --link                   hard link files instead of copying
  -L, --dereference            always follow symbolic links in SOURCE
  -n, --no-clobber             do not overwrite an existing file (overrides
                                 a previous -i option)
  -P, --no-dereference         never follow symbolic links in SOURCE
  -p                           same as --preserve=mode,ownership,timestamps
      --preserve[=ATTR_LIST]   preserve the specified attributes (default:
                                 mode,ownership,timestamps), if possible
                                 additional attributes: context, links, xattr,
                                 all
  -c                           deprecated, same as --preserve=context
      --no-preserve=ATTR_LIST  don&#39;t preserve the specified attributes
      --parents                use full source file name under DIRECTORY
  -R, -r, --recursive          copy directories recursively
      --reflink[=WHEN]         control clone/CoW copies. See below
      --remove-destination     remove each existing destination file before
                                 attempting to open it (contrast with --force)
      --sparse=WHEN            control creation of sparse files. See below
      --strip-trailing-slashes  remove any trailing slashes from each SOURCE
                                 argument
  -s, --symbolic-link          make symbolic links instead of copying
  -S, --suffix=SUFFIX          override the usual backup suffix
  -t, --target-directory=DIRECTORY  copy all SOURCE arguments into DIRECTORY
  -T, --no-target-directory    treat DEST as a normal file
  -u, --update                 copy only when the SOURCE file is newer
                                 than the destination file or when the
                                 destination file is missing
  -v, --verbose                explain what is being done
  -x, --one-file-system        stay on this file system
  -Z                           set SELinux security context of destination
                                 file to default type
      --context[=CTX]          like -Z, or if CTX is specified then set the
                                 SELinux or SMACK security context to CTX
      --help     display this help and exit
      --version  output version information and exit

By default, sparse SOURCE files are detected by a crude heuristic and the
corresponding DEST file is made sparse as well.  That is the behavior
selected by --sparse=auto.  Specify --sparse=always to create a sparse DEST
file whenever the SOURCE file contains a long enough sequence of zero bytes.
Use --sparse=never to inhibit creation of sparse files.

When --reflink[=always] is specified, perform a lightweight copy, where the
data blocks are copied only when modified.  If this is not possible the copy
fails, or if --reflink=auto is specified, fall back to a standard copy.

The backup suffix is &#39;~&#39;, unless set with --suffix or SIMPLE_BACKUP_SUFFIX.
The version control method may be selected via the --backup option or through
the VERSION_CONTROL environment variable.  Here are the values:

  none, off       never make backups (even if --backup is given)
  numbered, t     make numbered backups
  existing, nil   numbered if numbered backups exist, simple otherwise
  simple, never   always make simple backups

As a special case, cp makes a backup of SOURCE when the force and backup
options are given and SOURCE and DEST are the same name for an existing,
regular file.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;常用选项&#34;&gt;常用选项：&lt;/h3&gt;

&lt;p&gt;-a / -p：连同文件属性一起复制（用户组属性受 id 权限限制）&lt;/p&gt;

&lt;p&gt;-i（interactive）：覆盖询问&lt;/p&gt;

&lt;p&gt;-r（recursive）： 用于目录的递归复制&lt;/p&gt;

&lt;p&gt;-u （update）：source 比 destination 新才复制&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;覆盖询问&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@78063f0fe2e8 ~]# cp ~/.bashrc /tmp/bashrc
[root@78063f0fe2e8 ~]# cp -i ~/.bashrc /tmp/bashrc
cp: overwrite ‘/tmp/bashrc’? y
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;连同文件属性一起复制&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@78063f0fe2e8 ~]# cd /tmp
[root@78063f0fe2e8 tmp]# cp /var/log/wtmp .
[root@78063f0fe2e8 tmp]# ls -l /var/log/wtmp wtmp
-rw-rw-r-- 1 root utmp 0 Apr  2 18:38 /var/log/wtmp
-rw-r--r-- 1 root root 0 Apr 21 06:23 wtmp
[root@78063f0fe2e8 tmp]# cp -a /var/log/wtmp wtmp2
[root@78063f0fe2e8 tmp]# ls -l /var/log/wtmp wtmp2
-rw-rw-r-- 1 root utmp 0 Apr  2 18:38 /var/log/wtmp
-rw-rw-r-- 1 root utmp 0 Apr  2 18:38 wtmp2
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;用于目录的递归复制&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@78063f0fe2e8 tmp]# cp /etc /tmp
cp: omitting directory ‘/etc’
[root@78063f0fe2e8 tmp]# cp -r /etc /tmp
&lt;/code&gt;&lt;/pre&gt;

&lt;asciinema-player src=&#34;https://mooncaker816.github.io/asciinema/177529&#34; cols=&#34;80&#34; rows=&#34;24&#34;&gt;&lt;/asciinema-player&gt;

&lt;h2 id=&#34;rm-remove-删除目录或文件&#34;&gt;rm - remove 删除目录或文件&lt;/h2&gt;

&lt;h3 id=&#34;usage-1&#34;&gt;Usage：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Usage: rm [OPTION]... FILE...
Remove (unlink) the FILE(s).

  -f, --force           ignore nonexistent files and arguments, never prompt
  -i                    prompt before every removal
  -I                    prompt once before removing more than three files, or
                          when removing recursively; less intrusive than -i,
                          while still giving protection against most mistakes
      --interactive[=WHEN]  prompt according to WHEN: never, once (-I), or
                          always (-i); without WHEN, prompt always
      --one-file-system  when removing a hierarchy recursively, skip any
                          directory that is on a file system different from
                          that of the corresponding command line argument
      --no-preserve-root  do not treat &#39;/&#39; specially
      --preserve-root   do not remove &#39;/&#39; (default)
  -r, -R, --recursive   remove directories and their contents recursively
  -d, --dir             remove empty directories
  -v, --verbose         explain what is being done
      --help     display this help and exit
      --version  output version information and exit

By default, rm does not remove directories.  Use the --recursive (-r or -R)
option to remove each listed directory, too, along with all of its contents.

To remove a file whose name starts with a &#39;-&#39;, for example &#39;-foo&#39;,
use one of these commands:
  rm -- -foo

  rm ./-foo

Note that if you use rm to remove a file, it might be possible to recover
some of its contents, given sufficient expertise and/or time.  For greater
assurance that the contents are truly unrecoverable, consider using shred.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;常用选项-1&#34;&gt;常用选项：&lt;/h3&gt;

&lt;p&gt;-f（force）：忽略不存在的文件&lt;/p&gt;

&lt;p&gt;-i（interactive）：询问删除&lt;/p&gt;

&lt;p&gt;-r（recursive）：递归删除&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sh-4.2# cd /tmp
sh-4.2# ls
bashrc		  mingle1  tmpxq2sylvo-ascii.cast  wtmp2
ks-script-hE5IPf  test1    wtmp			   yum.log
sh-4.2# rm -i bashrc
rm: remove regular file ‘bashrc’? y
sh-4.2# ls
ks-script-hE5IPf  mingle1  test1  tmpxq2sylvo-ascii.cast  wtmp	wtmp2  yum.log
sh-4.2# rmdir mingle1
sh-4.2# rmdir test1
rmdir: failed to remove ‘test1’: Directory not empty
sh-4.2# rm -rf test1
sh-4.2# ls
ks-script-hE5IPf  tmpxq2sylvo-ascii.cast  wtmp	wtmp2  yum.log
sh-4.2# touch ./-aaa-
sh-4.2# ls
-aaa-  ks-script-hE5IPf  tmpxq2sylvo-ascii.cast  wtmp  wtmp2  yum.log
sh-4.2# rm -f -aaa-
rm: invalid option -- &#39;a&#39;
Try &#39;rm ./-aaa-&#39; to remove the file ‘-aaa-’.
Try &#39;rm --help&#39; for more information.
sh-4.2# rm -f ./-aaa-
sh-4.2# ls
ks-script-hE5IPf  tmpxq2sylvo-ascii.cast  wtmp	wtmp2  yum.log
sh-4.2# rm -rf wtmp*
sh-4.2# ls
ks-script-hE5IPf  tmpxq2sylvo-ascii.cast  yum.log
&lt;/code&gt;&lt;/pre&gt;

&lt;asciinema-player src=&#34;https://mooncaker816.github.io/asciinema/177530&#34; cols=&#34;80&#34; rows=&#34;24&#34;&gt;&lt;/asciinema-player&gt;

&lt;h2 id=&#34;mv-move-移动文件或目录-更名&#34;&gt;mv - move 移动文件或目录，更名&lt;/h2&gt;

&lt;h3 id=&#34;usage-2&#34;&gt;Usage：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Usage: mv [OPTION]... [-T] SOURCE DEST
  or:  mv [OPTION]... SOURCE... DIRECTORY
  or:  mv [OPTION]... -t DIRECTORY SOURCE...
Rename SOURCE to DEST, or move SOURCE(s) to DIRECTORY.

Mandatory arguments to long options are mandatory for short options too.
      --backup[=CONTROL]       make a backup of each existing destination file
  -b                           like --backup but does not accept an argument
  -f, --force                  do not prompt before overwriting
  -i, --interactive            prompt before overwrite
  -n, --no-clobber             do not overwrite an existing file
If you specify more than one of -i, -f, -n, only the final one takes effect.
      --strip-trailing-slashes  remove any trailing slashes from each SOURCE
                                 argument
  -S, --suffix=SUFFIX          override the usual backup suffix
  -t, --target-directory=DIRECTORY  move all SOURCE arguments into DIRECTORY
  -T, --no-target-directory    treat DEST as a normal file
  -u, --update                 move only when the SOURCE file is newer
                                 than the destination file or when the
                                 destination file is missing
  -v, --verbose                explain what is being done
  -Z, --context                set SELinux security context of destination
                                 file to default type
      --help     display this help and exit
      --version  output version information and exit

The backup suffix is &#39;~&#39;, unless set with --suffix or SIMPLE_BACKUP_SUFFIX.
The version control method may be selected via the --backup option or through
the VERSION_CONTROL environment variable.  Here are the values:

  none, off       never make backups (even if --backup is given)
  numbered, t     make numbered backups
  existing, nil   numbered if numbered backups exist, simple otherwise
  simple, never   always make simple backups
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;常用选项-2&#34;&gt;常用选项：&lt;/h3&gt;

&lt;p&gt;-f（force）：不询问直接覆盖&lt;/p&gt;

&lt;p&gt;-i（ interactive）： 询问覆盖&lt;/p&gt;

&lt;p&gt;-u（update）：source 新于 destination 才会 move&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;普通移动&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sh-4.2# cd /tmp
sh-4.2# cp ~/.bashrc bashrc1
sh-4.2# cp ~/.bashrc bashrc2
sh-4.2# ls
bashrc1  bashrc2  ks-script-hE5IPf  tmp8u627nsx-ascii.cast  yum.log
sh-4.2# mkdir mvtest
sh-4.2# ls
bashrc1  bashrc2  ks-script-hE5IPf  mvtest  tmp8u627nsx-ascii.cast  yum.log
sh-4.2# mv bashrc1 bashrc2 mvtest
sh-4.2# ls
ks-script-hE5IPf  mvtest  tmp8u627nsx-ascii.cast  yum.log
sh-4.2# cd mvtest
sh-4.2# ls
bashrc1  bashrc2
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;重命名&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sh-4.2# cd ..
sh-4.2# ls
ks-script-hE5IPf  mvtest  tmp8u627nsx-ascii.cast  yum.log
sh-4.2# mv mvtest mvtest2
sh-4.2# ls
ks-script-hE5IPf  mvtest2  tmp8u627nsx-ascii.cast  yum.log
&lt;/code&gt;&lt;/pre&gt;

&lt;asciinema-player src=&#34;https://mooncaker816.github.io/asciinema/177531&#34; cols=&#34;80&#34; rows=&#34;24&#34;&gt;&lt;/asciinema-player&gt;</description>
    </item>
    
    <item>
      <title>Linux Centos 命令之 touch,cat,tac,more,less</title>
      <link>https://mooncaker816.github.io/2018/04/21/linux-centos-%E5%91%BD%E4%BB%A4%E4%B9%8B-touchcattacmoreless/</link>
      <pubDate>Sat, 21 Apr 2018 13:50:00 +0000</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/04/21/linux-centos-%E5%91%BD%E4%BB%A4%E4%B9%8B-touchcattacmoreless/</guid>
      <description>&lt;h2 id=&#34;touch-创建空文件-修改时间&#34;&gt;touch -  创建空文件，修改时间&lt;/h2&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;usage&#34;&gt;Usage：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Usage: touch [OPTION]... FILE...
Update the access and modification times of each FILE to the current time.

A FILE argument that does not exist is created empty, unless -c or -h
is supplied.

A FILE argument string of - is handled specially and causes touch to
change the times of the file associated with standard output.

Mandatory arguments to long options are mandatory for short options too.
  -a                     change only the access time
  -c, --no-create        do not create any files
  -d, --date=STRING      parse STRING and use it instead of current time
  -f                     (ignored)
  -h, --no-dereference   affect each symbolic link instead of any referenced
                         file (useful only on systems that can change the
                         timestamps of a symlink)
  -m                     change only the modification time
  -r, --reference=FILE   use this file&#39;s times instead of current time
  -t STAMP               use [[CC]YY]MMDDhhmm[.ss] instead of current time
      --time=WORD        change the specified time:
                           WORD is access, atime, or use: equivalent to -a
                           WORD is modify or mtime: equivalent to -m
      --help     display this help and exit
      --version  output version information and exit

Note that the -d and -t options accept different time-date formats.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mtime ：modification time （默认）&lt;/p&gt;

&lt;p&gt;文件的内容被修改时会更新&lt;/p&gt;

&lt;p&gt;ctime ：status time&lt;/p&gt;

&lt;p&gt;文件的属性或权限被修改时会更新&lt;/p&gt;

&lt;p&gt;atime ： access time&lt;/p&gt;

&lt;p&gt;文件的内容被读取时会更新&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@78063f0fe2e8 etc]# ls -l login.defs
-rw-r--r-- 1 root root 2028 Nov  4  2016 login.defs
[root@78063f0fe2e8 etc]# ls -l login.defs --time=atime
-rw-r--r-- 1 root root 2028 Nov  4  2016 login.defs
[root@78063f0fe2e8 etc]# ls -l login.defs --time=ctime
-rw-r--r-- 1 root root 2028 Apr 20 14:19 login.defs
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;常用选项&#34;&gt;常用选项：&lt;/h3&gt;

&lt;p&gt;-a（access） ：仅修改访问时间&lt;/p&gt;

&lt;p&gt;-c（）：仅修改文件时间，若文件不存在则&lt;strong&gt;不&lt;/strong&gt;创建新文件&lt;/p&gt;

&lt;p&gt;-m（modification）： 仅修改 mtime&lt;/p&gt;

&lt;p&gt;-t （time）：想要修改的时间[YYMMDDhhmm]&lt;/p&gt;

&lt;p&gt;-d（date）：修改的日期&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;新建空文件&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sh-4.2# cd /tmp
sh-4.2# touch testtouch
sh-4.2# ls -l testtouch
-rw-r--r-- 1 root root 0 Apr 21 07:52 testtouch
sh-4.2# ls -l testtouch --time=atime
-rw-r--r-- 1 root root 0 Apr 21 07:52 testtouch
sh-4.2# ls -l testtouch --time=ctime
-rw-r--r-- 1 root root 0 Apr 21 07:52 testtouch
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;修改时间&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sh-4.2# cp -a ~/.bashrc bashrc
sh-4.2# ls -l bashrc
-rw-r--r-- 1 root root 176 Dec 29  2013 bashrc
sh-4.2# ls -l bashrc --time=atime
-rw-r--r-- 1 root root 176 Dec 29  2013 bashrc
sh-4.2# ls -l bashrc --time=ctime
-rw-r--r-- 1 root root 176 Apr 21 07:53 bashrc
sh-4.2# touch -d &amp;quot;2 days ago&amp;quot; bashrc
sh-4.2# ls -l bashrc
-rw-r--r-- 1 root root 176 Apr 19 07:55 bashrc
sh-4.2# ls -l bashrc --time=atime
-rw-r--r-- 1 root root 176 Apr 19 07:55 bashrc
sh-4.2# ls -l bashrc --time=ctime
-rw-r--r-- 1 root root 176 Apr 21 07:55 bashrc
sh-4.2# touch -t 1801011000 bashrc
sh-4.2# ls -l bashrc
-rw-r--r-- 1 root root 176 Jan  1 10:00 bashrc
sh-4.2# ls -l bashrc --time=ctime
-rw-r--r-- 1 root root 176 Apr 21 07:57 bashrc
sh-4.2# ls -l bashrc --time=atime
-rw-r--r-- 1 root root 176 Jan  1 10:00 bashrc
&lt;/code&gt;&lt;/pre&gt;

&lt;asciinema-player src=&#34;https://mooncaker816.github.io/asciinema/177538&#34; cols=&#34;80&#34; rows=&#34;24&#34;&gt;&lt;/asciinema-player&gt;

&lt;h2 id=&#34;cat-concatenate-浏览文件&#34;&gt;cat - concatenate 浏览文件&lt;/h2&gt;

&lt;h3 id=&#34;usage-1&#34;&gt;Usage：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Usage: cat [OPTION]... [FILE]...
Concatenate FILE(s), or standard input, to standard output.

  -A, --show-all           equivalent to -vET
  -b, --number-nonblank    number nonempty output lines, overrides -n
  -e                       equivalent to -vE
  -E, --show-ends          display $ at end of each line
  -n, --number             number all output lines
  -s, --squeeze-blank      suppress repeated empty output lines
  -t                       equivalent to -vT
  -T, --show-tabs          display TAB characters as ^I
  -u                       (ignored)
  -v, --show-nonprinting   use ^ and M- notation, except for LFD and TAB
      --help     display this help and exit
      --version  output version information and exit

With no FILE, or when FILE is -, read standard input.

Examples:
  cat f - g  Output f&#39;s contents, then standard input, then g&#39;s contents.
  cat        Copy standard input to standard output.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;常用选项-1&#34;&gt;常用选项：&lt;/h3&gt;

&lt;p&gt;-A（All）：显示所有，包括特殊字符，等价于-vET&lt;/p&gt;

&lt;p&gt;-v（verbose）：列出看不出来的特殊字符&lt;/p&gt;

&lt;p&gt;-T（Tab）：将 Tab 按键以^I 显示出来&lt;/p&gt;

&lt;p&gt;-b（blank）：列出行号，空白行不标号&lt;/p&gt;

&lt;p&gt;-n（number）：列出行号，空白行也有&lt;/p&gt;

&lt;p&gt;-E（End）：将结尾的断行字符$显示出来&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sh-4.2# cat /etc/issue
\S
Kernel \r on an \m

sh-4.2# cat -n /etc/issue
     1	\S
     2	Kernel \r on an \m
     3
sh-4.2# cat -b /etc/issue
     1	\S
     2	Kernel \r on an \m

sh-4.2# cd /tmp
sh-4.2# ls
bashrc		  mvtest2    testtouch		     yum.log
ks-script-hE5IPf  test.conf  tmpk3saal44-ascii.cast
sh-4.2# cat -A test.conf
^Ihello$
this is a test file only...$
sh-4.2# cat -An test.conf
     1	^Ihello$
     2	this is a test file only...$
&lt;/code&gt;&lt;/pre&gt;

&lt;asciinema-player src=&#34;https://mooncaker816.github.io/asciinema/177541&#34; cols=&#34;80&#34; rows=&#34;24&#34;&gt;&lt;/asciinema-player&gt;

&lt;h2 id=&#34;tac-反向-cat&#34;&gt;tac - 反向 cat&lt;/h2&gt;

&lt;h3 id=&#34;usage-2&#34;&gt;Usage：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Usage: tac [OPTION]... [FILE]...
Write each FILE to standard output, last line first.
With no FILE, or when FILE is -, read standard input.

Mandatory arguments to long options are mandatory for short options too.
  -b, --before             attach the separator before instead of after
  -r, --regex              interpret the separator as a regular expression
  -s, --separator=STRING   use STRING as the separator instead of newline
      --help     display this help and exit
      --version  output version information and exit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;tac 没有 -n 选项&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@78063f0fe2e8 ~]# tac /etc/issue

Kernel \r on an \m
\S
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;nl-添加行号显示文件&#34;&gt;nl - 添加行号显示文件&lt;/h2&gt;

&lt;h3 id=&#34;usage-3&#34;&gt;Usage：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Usage: nl [OPTION]... [FILE]...
Write each FILE to standard output, with line numbers added.
With no FILE, or when FILE is -, read standard input.

Mandatory arguments to long options are mandatory for short options too.
  -b, --body-numbering=STYLE      use STYLE for numbering body lines
  -d, --section-delimiter=CC      use CC for separating logical pages
  -f, --footer-numbering=STYLE    use STYLE for numbering footer lines
  -h, --header-numbering=STYLE    use STYLE for numbering header lines
  -i, --line-increment=NUMBER     line number increment at each line
  -l, --join-blank-lines=NUMBER   group of NUMBER empty lines counted as one
  -n, --number-format=FORMAT      insert line numbers according to FORMAT
  -p, --no-renumber               do not reset line numbers at logical pages
  -s, --number-separator=STRING   add STRING after (possible) line number
  -v, --starting-line-number=NUMBER  first line number on each logical page
  -w, --number-width=NUMBER       use NUMBER columns for line numbers
      --help     display this help and exit
      --version  output version information and exit

By default, selects -v1 -i1 -l1 -sTAB -w6 -nrn -hn -bt -fn.  CC are
two delimiter characters for separating logical pages, a missing
second character implies :.  Type \\ for \.  STYLE is one of:

  a         number all lines
  t         number only nonempty lines
  n         number no lines
  pBRE      number only lines that contain a match for the basic regular
            expression, BRE

FORMAT is one of:

  ln   left justified, no leading zeros
  rn   right justified, no leading zeros
  rz   right justified, leading zeros
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@78063f0fe2e8 ~]# nl /etc/issue
     1	\S
     2	Kernel \r on an \m

[root@78063f0fe2e8 ~]# nl /etc/issue -b a
     1	\S
     2	Kernel \r on an \m
     3
[root@78063f0fe2e8 ~]# nl /etc/issue -b a -n rz
000001	\S
000002	Kernel \r on an \m
000003
[root@78063f0fe2e8 ~]# nl /etc/issue -b a -n ln
1     	\S
2     	Kernel \r on an \m
3
[root@78063f0fe2e8 ~]# nl /etc/issue -b a -n rn
     1	\S
     2	Kernel \r on an \m
     3
[root@78063f0fe2e8 ~]# nl /etc/issue -b a -n rn -w 3
  1	\S
  2	Kernel \r on an \m
  3
[root@78063f0fe2e8 ~]# nl /etc/issue -b a -n rz -w 3
001	\S
002	Kernel \r on an \m
003
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;more-一页一页显示文件内容&#34;&gt;more - 一页一页显示文件内容&lt;/h2&gt;

&lt;h3 id=&#34;usage-4&#34;&gt;Usage：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;more: unknown option -help
Usage: more [options] file...

Options:
  -d        display help instead of ring bell
  -f        count logical, rather than screen lines
  -l        suppress pause after form feed
  -p        do not scroll, clean screen and display text
  -c        do not scroll, display text and clean line ends
  -u        suppress underlining
  -s        squeeze multiple blank lines into one
  -NUM      specify the number of lines per screenful
  +NUM      display file beginning from line number NUM
  +/STRING  display file beginning from search string match
  -V        output version information and exit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;空格：向下翻一页&lt;/p&gt;

&lt;p&gt;Enter：向下一行&lt;/p&gt;

&lt;p&gt;/字符串：向下查询字符串&lt;/p&gt;

&lt;p&gt;q：退出查看&lt;/p&gt;

&lt;p&gt;b：往回翻页&lt;/p&gt;

&lt;h2 id=&#34;less-more-的进阶&#34;&gt;less - more 的进阶&lt;/h2&gt;

&lt;p&gt;略&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Linux Centos 命令之 mkdir,rmdir,pwd,cd</title>
      <link>https://mooncaker816.github.io/2018/04/21/linux-centos-%E5%91%BD%E4%BB%A4%E4%B9%8B-mkdirrmdirpwdcd/</link>
      <pubDate>Sat, 21 Apr 2018 12:50:00 +0000</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/04/21/linux-centos-%E5%91%BD%E4%BB%A4%E4%B9%8B-mkdirrmdirpwdcd/</guid>
      <description>&lt;h2 id=&#34;mkdir-make-directory-创建目录&#34;&gt;mkdir - make directory 创建目录&lt;/h2&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;usage&#34;&gt;Usage：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Usage: mkdir [OPTION]... DIRECTORY...
Create the DIRECTORY(ies), if they do not already exist.

Mandatory arguments to long options are mandatory for short options too.
  -m, --mode=MODE   set file mode (as in chmod), not a=rwx - umask
  -p, --parents     no error if existing, make parent directories as needed
  -v, --verbose     print a message for each created directory
  -Z                   set SELinux security context of each created directory
                         to the default type
      --context[=CTX]  like -Z, or if CTX is specified then set the SELinux
                         or SMACK security context to CTX
      --help     display this help and exit
      --version  output version information and exit
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;常用选项&#34;&gt;常用选项：&lt;/h3&gt;

&lt;p&gt;-m（mode）：按指定权限创建目录，若没有该选项则按 umask 的默认设置创建&lt;/p&gt;

&lt;p&gt;-p（parent）：递归创建所有目录&lt;/p&gt;

&lt;p&gt;-v（verbose）： 打印出每个创建的目录&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;递归创建目录&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@78063f0fe2e8 ~]# mkdir -pv /tmp/test1/test2/test3
mkdir: created directory ‘/tmp/test1’
mkdir: created directory ‘/tmp/test1/test2’
mkdir: created directory ‘/tmp/test1/test2/test3’
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;目录的权限由 umask 决定&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@78063f0fe2e8 ~]# umask
0022
[root@78063f0fe2e8 ~]# umask -S
u=rwx,g=rx,o=rx
[root@78063f0fe2e8 ~]# ls /tmp/test1 -l
total 4
drwxr-xr-x 3 root root 4096 Apr 21 05:01 test2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;022是指对应三个组别分别要减去的权限分数，777-022=755=（rwxr-xr-x）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;指定创建权限为711的目录&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@78063f0fe2e8 ~]# mkdir /tmp/mingle -m 711
[root@78063f0fe2e8 ~]# ls /tmp/mingle -ld
drwx--x--x 2 root root 4096 Apr 21 05:10 /tmp/mingle
&lt;/code&gt;&lt;/pre&gt;

&lt;asciinema-player src=&#34;https://mooncaker816.github.io/asciinema/177520&#34; cols=&#34;80&#34; rows=&#34;24&#34;&gt;&lt;/asciinema-player&gt;

&lt;h2 id=&#34;rmdir-remove-empty-directory-删除空目录&#34;&gt;rmdir - remove empty directory 删除空目录&lt;/h2&gt;

&lt;h3 id=&#34;usage-1&#34;&gt;Usage：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Usage: rmdir [OPTION]... DIRECTORY...
Remove the DIRECTORY(ies), if they are empty.

      --ignore-fail-on-non-empty
                  ignore each failure that is solely because a directory
                    is non-empty
  -p, --parents   remove DIRECTORY and its ancestors; e.g., &#39;rmdir -p a/b/c&#39; is
                    similar to &#39;rmdir a/b/c a/b a&#39;
  -v, --verbose   output a diagnostic for every directory processed
      --help     display this help and exit
      --version  output version information and exit
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;常用选项-1&#34;&gt;常用选项：&lt;/h3&gt;

&lt;p&gt;-p（parent）：递归删除空目录&lt;/p&gt;

&lt;p&gt;-v（verbose）：打印出每个删除的目录&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@78063f0fe2e8 ~]# mkdir -p /tmp/test1/test2/test3
[root@78063f0fe2e8 ~]# rmdir -pv /tmp/test1/test2/test3
rmdir: removing directory, ‘/tmp/test1/test2/test3’
rmdir: removing directory, ‘/tmp/test1/test2’
rmdir: removing directory, ‘/tmp/test1’
rmdir: removing directory, ‘/tmp’
rmdir: failed to remove directory ‘/tmp’: Directory not empty
&lt;/code&gt;&lt;/pre&gt;

&lt;asciinema-player src=&#34;https://mooncaker816.github.io/asciinema/177521&#34; cols=&#34;80&#34; rows=&#34;24&#34;&gt;&lt;/asciinema-player&gt;

&lt;h2 id=&#34;pwd-print-working-directory-打印当前路径&#34;&gt;pwd - print working directory 打印当前路径&lt;/h2&gt;

&lt;h3 id=&#34;usage-2&#34;&gt;Usage：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pwd [-LP]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;常用选项-2&#34;&gt;常用选项：&lt;/h3&gt;

&lt;p&gt;-L（link）：若为软链，则显示软链路径(默认)&lt;/p&gt;

&lt;p&gt;-P（）：若为软链，则显示为实际指向路径&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@78063f0fe2e8 mail]# ls -ld /var/mail
lrwxrwxrwx 1 root root 10 Apr  2 18:38 /var/mail -&amp;gt; spool/mail
[root@78063f0fe2e8 mail]# pwd
/var/mail
[root@78063f0fe2e8 mail]# pwd -P
/var/spool/mail
[root@78063f0fe2e8 mail]# pwd -L
/var/mail
&lt;/code&gt;&lt;/pre&gt;

&lt;asciinema-player src=&#34;https://mooncaker816.github.io/asciinema/177522&#34; cols=&#34;80&#34; rows=&#34;24&#34;&gt;&lt;/asciinema-player&gt;

&lt;h2 id=&#34;cd-change-directory-切换当前路径&#34;&gt;cd - change directory 切换当前路径&lt;/h2&gt;

&lt;h3 id=&#34;常用目录&#34;&gt;常用目录：&lt;/h3&gt;

&lt;p&gt;&amp;rdquo;.&amp;rdquo; ： 当前目录&lt;/p&gt;

&lt;p&gt;&amp;rdquo;..&amp;rdquo; ：上级目录&lt;/p&gt;

&lt;p&gt;&amp;rdquo;-&amp;rdquo; ：前一个工作目录&lt;/p&gt;

&lt;p&gt;&amp;ldquo;~&amp;ldquo;,&amp;rdquo; &amp;ldquo; ：当前用户所在的主目录
&amp;ldquo;~account&amp;rdquo; ：account 这个用户所在的主目录&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@78063f0fe2e8 mail]# cd
[root@78063f0fe2e8 ~]#
[root@78063f0fe2e8 ~]# cd /tmp
[root@78063f0fe2e8 tmp]# cd
[root@78063f0fe2e8 ~]# cd ~root
[root@78063f0fe2e8 ~]# cd -
/root
[root@78063f0fe2e8 ~]# cd ..
[root@78063f0fe2e8 /]# cd -
/root
[root@78063f0fe2e8 ~]# cd /var/mail
[root@78063f0fe2e8 mail]#
&lt;/code&gt;&lt;/pre&gt;

&lt;asciinema-player src=&#34;https://mooncaker816.github.io/asciinema/177524&#34; cols=&#34;80&#34; rows=&#34;24&#34;&gt;&lt;/asciinema-player&gt;</description>
    </item>
    
  </channel>
</rss>
