<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Mooncaker816 on Mooncaker816</title>
    <link>https://mooncaker816.github.io/</link>
    <description>Recent content in Mooncaker816 on Mooncaker816</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <copyright>&amp;copy; 2018-Present</copyright>
    <lastBuildDate>Wed, 20 Apr 2016 00:00:00 +0800</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>天文算法6</title>
      <link>https://mooncaker816.github.io/2018/05/17/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%956/</link>
      <pubDate>Thu, 17 May 2018 07:40:44 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/05/17/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%956/</guid>
      <description>&lt;h1 id=&#34;第八章-复活节日-date-of-easter&#34;&gt;第八章 复活节日 Date of Easter&lt;/h1&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;　　对西方的节日没有多少了解，这里就直接给出书中的算法吧~&lt;/p&gt;

&lt;h2 id=&#34;1-格里历复活节算法&#34;&gt;1. 格里历复活节算法&lt;/h2&gt;

&lt;p&gt;\begin{array}{l|ccc}
被除数 &amp;amp; 除数 &amp;amp; 商 &amp;amp; 余数 \\&lt;br /&gt;
\hline
年份y &amp;amp; 19 &amp;amp; - &amp;amp; a \\&lt;br /&gt;
年份y &amp;amp; 100 &amp;amp; b &amp;amp; c \\&lt;br /&gt;
b &amp;amp; 4 &amp;amp; d &amp;amp; e \\&lt;br /&gt;
b+8 &amp;amp; 25 &amp;amp; f &amp;amp; - \\&lt;br /&gt;
b-f+1 &amp;amp; 3 &amp;amp; g &amp;amp; - \\&lt;br /&gt;
19a+b-d-g+15 &amp;amp; 30 &amp;amp; - &amp;amp; h \\&lt;br /&gt;
c &amp;amp; 4 &amp;amp; i &amp;amp; k \\&lt;br /&gt;
32+2e+2i-h-k &amp;amp; 7 &amp;amp; - &amp;amp; l \\&lt;br /&gt;
a+11h+22l &amp;amp; 451 &amp;amp; m &amp;amp; - \\&lt;br /&gt;
h+l-7m+114 &amp;amp; 31 &amp;amp; n &amp;amp; p \\&lt;br /&gt;
\end{array}&lt;/p&gt;

&lt;p&gt;得 $$n = 月份, \ p+1 = 日期$$&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Gregorian returns month and day of Easter in the Gregorian calendar.
// 格里历复活节日算法
func Gregorian(y int) (m, d int) {
	a := y % 19
	b, c := y/100, y%100
	d, e := b/4, b%4
	f := (b + 8) / 25
	g := (b - f + 1) / 3
	h := (19*a + b - d - g + 15) % 30
	i, k := c/4, c%4
	l := (32 + 2*e + 2*i - h - k) % 7
	m = (a + 11*h + 22*l) / 451
	n := h + l - 7*m + 114
	n, p := n/31, n%31
	return n, p + 1
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2-儒略历复活节算法&#34;&gt;2. 儒略历复活节算法&lt;/h2&gt;

&lt;p&gt;\begin{array}{l|ccc}
被除数 &amp;amp; 除数 &amp;amp; 商 &amp;amp; 余数 \\&lt;br /&gt;
\hline
年份y &amp;amp; 4 &amp;amp; - &amp;amp; a \\&lt;br /&gt;
年份y &amp;amp; 7 &amp;amp; - &amp;amp; b \\&lt;br /&gt;
年份y &amp;amp; 19 &amp;amp; - &amp;amp; c \\&lt;br /&gt;
19c+15 &amp;amp; 30 &amp;amp; - &amp;amp; d \\&lt;br /&gt;
2a+4b-d+34 &amp;amp; 7 &amp;amp; - &amp;amp; e \\&lt;br /&gt;
d+e+114 &amp;amp; 31 &amp;amp; f &amp;amp; g \\&lt;br /&gt;
\end{array}&lt;/p&gt;

&lt;p&gt;得 $$f = 月份, \ g+1 = 日期$$&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Julian returns month and day of Easter in the Julian calendar.
// 儒略历复活节日算法
func Julian(y int) (m, d int) {
	a := y % 4
	b := y % 7
	c := y % 19
	d = (19*c + 15) % 30
	e := (2*a + 4*b - d + 34) % 7
	f := d + e + 114
	f, g := f/31, f%31
	return f, g + 1
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>天文算法5</title>
      <link>https://mooncaker816.github.io/2018/05/16/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%955/</link>
      <pubDate>Wed, 16 May 2018 09:27:51 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/05/16/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%955/</guid>
      <description>&lt;h1 id=&#34;第七章-儒略日-julian-day&#34;&gt;第七章 儒略日 Julian Day&lt;/h1&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-儒略历和格里高利历&#34;&gt;1. 儒略历和格里高利历&lt;/h2&gt;

&lt;h3 id=&#34;1-1-定义&#34;&gt;1.1 定义&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;儒略历，是格里历的前身，由罗马共和国独裁官儒略·凯撒采纳埃及亚历山大的希腊数学家兼天文学家索西琴尼计算的历法，在公元前45年1月1日起执行，取代旧罗马历历法的历法。一年设12个月，大小月交替，四年一闰，平年365日，闰年于二月底增加一闰日，年平均长度为365.25日。由于累积误差随着时间越来越大，1582年后由教皇格里高利十三世改良，变为格里历，即沿用至今的公历。但大英帝国、北美十三州等直到1752年才从儒略历改用格里历。现今儒略历只有苏格兰昔德兰群岛之富拉岛、阿索斯神权共和国和一些北非的柏柏尔人使用。&lt;/p&gt;

&lt;p&gt;格里历（拉丁语：Calendarium Gregorianum，又译、国瑞历、额我略历、格列高利历、格里高利历、葛瑞格里历、格列高历，也称基督历[1]），是由意大利医生兼哲学家阿洛伊修斯·里利乌斯改革儒略历制定的历法，由罗马大公教会教宗格列高利十三世在1582年颁行。公历是阳历的一种，于1912年在中国引进采用，因农历等中国传统历法是阴阳历，故公历在中文中又称阳历、西历、新历、公历。格里历与儒略历一样，格里历也是每四年在2月底置一闰日，但格里历特别规定，除非能被400整除，所有的世纪年（能被100整除）都不设闰日；如此，每四百年，格里历仅有97个闰年，比儒略历减少3个闰年 [注 1]。 格里历的历年平均长度为365.2425日，接近平均回归年的365.242199074日，即约每3300年误差一日，也更接近春分点回归年的365.24237日，即约每8000年误差一日；而儒略历的历年为365.25日，约每128年就误差一日[注 1]。到1582年时，儒略历的春分日（3月21日）与地球公转到春分点的实际时间已相差10天。因此，格里历开始实行时，将儒略历1582年10月4日星期四的次日，为格里历1582年10月15日星期五，即有10天被删除，但原星期的周期保持不变。格里历的纪年沿用儒略历，自传统的耶稣诞生年开始，称为“公元”，亦称“西元”。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;1-2-区别&#34;&gt;1.2 区别&lt;/h3&gt;

&lt;p&gt;　　由定义可见，儒略历和格里高利历都属于阳历，后者是以太阳回归年为基础，对前者置润误差进行调整后的历法。所以两者之间最大的不同就是置润规则。&lt;/p&gt;

&lt;h4 id=&#34;1-2-1-置润规则&#34;&gt;1.2.1 置润规则&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;儒略历&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;能被4整除的年份为闰年（产生多润的原因，从而使儒略历在日期上落后于格里历）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;格里历&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;能被4整除但不能被100整除的非世纪年 + 能被400整除的世纪年，即要在儒略历闰年中扣除那些不能被400整除的世纪年（如1600，1700等）&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// LeapYearJulian returns true if year y in the Julian calendar is a leap year.
// 儒略历闰年判断
func LeapYearJulian(y int) bool {
	return y%4 == 0
}

// LeapYearGregorian returns true if year y in the Gregorian calendar is a leap year.
// 格里历闰年判断
func LeapYearGregorian(y int) bool {
	return (y%4 == 0 &amp;amp;&amp;amp; y%100 != 0) || y%400 == 0
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;1-2-2-转换&#34;&gt;1.2.2 转换&lt;/h4&gt;

&lt;p&gt;　　知道了这个不同，我们就能推导出两种历法之间实际的相差天数，如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;1582年：&lt;br /&gt;
格里历10月15日，合儒略历10月5日，或之后的日期：格里历日期减10日等于儒略历日期。&lt;/li&gt;
&lt;li&gt;1583年——1699年：&lt;br /&gt;
格里历日期减10日等于儒略历日期。&lt;/li&gt;
&lt;li&gt;1700年（格里历没有闰日，但儒略历有）：&lt;br /&gt;
格里历2月28日，合儒略历2月18日，或之前的日期：格里历日期减10日等于儒略历日期。&lt;br /&gt;
格里历3月1日，合儒略历2月19日，或之后的日期：格里历日期减11日等于儒略历日期。&lt;/li&gt;
&lt;li&gt;1701年——1799年：&lt;br /&gt;
格里历日期减11日等于儒略历日期。&lt;/li&gt;
&lt;li&gt;1800年（格里历没有闰日，但儒略历有）：&lt;br /&gt;
格里历2月28日，合儒略历2月17日，或之前的日期：格里历日期减11日等于儒略历日期。&lt;br /&gt;
格里历3月1日，合儒略历2月18日，或之后的日期：格里历日期减12日等于儒略历日期。&lt;/li&gt;
&lt;li&gt;1801年——1899年：&lt;br /&gt;
格里历日期减12日等于儒略历日期。&lt;/li&gt;
&lt;li&gt;1900年（格里历没有闰日，但儒略历有）：&lt;br /&gt;
格里历2月28日，合儒略历2月16日，或之前的日期：格里历日期减12日等于儒略历日期。&lt;br /&gt;
格里历3月1日，合儒略历2月17日，或之后的日期：格里历日期减13日等于儒略历日期。&lt;/li&gt;
&lt;li&gt;1901年——2099年：&lt;br /&gt;
格里历日期减13日等于儒略历日期。&lt;/li&gt;
&lt;li&gt;2100年（格里历没有闰日，但儒略历有）：&lt;br /&gt;
格里历2月28日，合儒略历2月15日，或之前的日期：格里历日期减13日等于儒略历日期。&lt;br /&gt;
格里历3月1日，合儒略历2月16日，或之后的日期：格里历日期减14日等于儒略历日期。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2-儒略日-julian-day&#34;&gt;2. 儒略日 Julian Day&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;儒略日（Julian Day）&lt;/strong&gt;&lt;br /&gt;
儒略日是在儒略周期内以连续的日数计算时间的计时法，主要是天文学家在使用。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;儒略日数（Julian Day Number，JDN）&lt;/strong&gt;&lt;br /&gt;
儒略日数的计算是从格林威治标准时间的中午开始，包含一个整天的时间，起点的时间（0日）回溯至儒略历的公元前4713年1月1日中午12点（在格里历是公元前4714年11月24日），这个日期是三种多年周期的共同起点，且是历史上最接近现代的一个起点。例如，2000年1月1日的UT12:00是儒略日2,451,545。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;儒略日期（Julian date，JD）&lt;/strong&gt;&lt;br /&gt;
儒略日期是以格林威治标准时中午12:00的儒略日加上那一天的瞬时时间的分数。儒略日期是儒略日添加小数部分所表示的儒略日数。例如，2013年1月1日00:30:00（UT）是儒略日期2,456,293.520833。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;儒略周期（Julian Period）&lt;/strong&gt;&lt;br /&gt;
儒略周期是开始于公元前4713年，长达7980年的纪年法，被用于历史上各种不同历法的日期转换。公元2018年是儒略周期的6731年，下一个儒略周期将开始于公元3268年。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;儒略日起点&lt;/strong&gt;&lt;br /&gt;
儒略日的起点订在西元前4713年（天文学上记为 -4712年）1月1日格林威治时间平午（世界时12:00），即JD 0指定为UT时间B.C.4713年1月1日12:00到UC时间B.C.4713年1月2日12:00的24小时。每一天赋予了一个唯一的数字，顺数而下，如：1996年1月1日12:00:00的儒略日是2450084。这个日期是考虑了太阳、月亮的轨道运行周期，以及当时收税的间隔而订出来的。Joseph Scaliger定义儒略周期为7980年，是因28、19、15的最小公倍数为28×19×15=7980。其中：&lt;/p&gt;

&lt;p&gt;28年为一太阳周期（solar cycle），经过一太阳周期，则星期的日序与月的日序会重复。&lt;/p&gt;

&lt;p&gt;19年为一太阴周期，或称默冬章（Metonic cycle），因235朔望月=19回归年，经过一太阴周期则阴历月年的日序重复。&lt;/p&gt;

&lt;p&gt;15年为一小纪（indiction cycle），此为罗马皇帝君士坦丁一世所颁，每15年评定财产价值以供课税，成为古罗马用的一个纪元单位，&lt;/p&gt;

&lt;p&gt;故以7980年为一儒略周期，而所选的起点公元前4713年，则是这三个循环周期同时开始的最近年份。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;简化儒略日（MJD）&lt;/strong&gt;&lt;br /&gt;
由于儒略日数字位数太多，国际天文学联合会于1973年采用简化儒略日（MJD），其定义为MJD = JD - 2400000.5。MJD相应的起点是1858年11月17日世界时0时。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　算法中主要用的是 &lt;strong&gt;儒略日期（Julian date，JD）&lt;/strong&gt;，后续简称为&lt;strong&gt;儒略日&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;3-儒略日和阳历日期-格里历-儒略历日期-的转换&#34;&gt;3. 儒略日和阳历日期（格里历、儒略历日期）的转换&lt;/h2&gt;

&lt;h3 id=&#34;3-1-阳历日期-y-m-d-rightarrow-儒略日-jd&#34;&gt;3.1 阳历日期$(Y,M,D)$ $\Rightarrow$ 儒略日$(JD)$&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;设$Y$为给定年份，$M$为月份，$D$为该月日期（可以带小数）。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;若 $M &amp;gt; 2$，$Y$和$M$不变，&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;若 $M =1或2$，以$Y–1$代$Y$，以$M+12$代$M$，换句话说，如果日期在1月或2月，则被看作是在前一年的13月或14月。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对格里历有 ：$A = \lfloor \frac {Y}{100}\rfloor$ $B = 2 - A + \lfloor \frac{A}{4}\rfloor$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对儒略历，取 $B = 0$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;要求的儒略日即为：$$JD = \lfloor 365.25(Y+4716)\rfloor+\lfloor30.6001(M+1)\rfloor+D+B-1524.5$$&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;此处作对30.6001取值的解释是为了确保小数在运算时的准确性，如30.6 * 5 应该等于153，但是很多计算机得出的结果是152.999 9998。&lt;/p&gt;

&lt;p&gt;另一种方式就是用306代替，最后再除以10取整&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// FloorDiv returns the integer floor of the fractional value (x / y).
//
// It uses integer math only, so is more efficient than using floating point
// intermediate values.  This function can be used in many places where INT()
// appears in AA.  As with built in integer division, it panics with y == 0.
func FloorDiv(x, y int) (q int) {
	q = x / y
	if (x &amp;lt; 0) != (y &amp;lt; 0) &amp;amp;&amp;amp; x%y != 0 {
		q--
	}
	return
}

// FloorDiv64 returns the integer floor of the fractional value (x / y).
//
// It uses integer math only, so is more efficient than using floating point
// intermediate values.  This function can be used in many places where INT()
// appears in AA.  As with built in integer division, it panics with y == 0.
func FloorDiv64(x, y int64) (q int64) {
	q = x / y
	if (x &amp;lt; 0) != (y &amp;lt; 0) &amp;amp;&amp;amp; x%y != 0 {
		q--
	}
	return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// CalendarGregorianToJD converts a Gregorian year, month, and day of month
// to Julian day.
//
// Negative years are valid, back to JD 0.  The result is not valid for
// dates before JD 0.
// 格里历日期转儒略日
func CalendarGregorianToJD(y, m int, d float64) float64 {
	switch m {
	case 1, 2:
		y--
		m += 12
	}
	a := base.FloorDiv(y, 100)
	b := 2 - a + base.FloorDiv(a, 4)
	// (7.1) p. 61
	return float64(base.FloorDiv64(36525*(int64(y+4716)), 100)) +
		float64(base.FloorDiv(306*(m+1), 10)+b) + d - 1524.5
}

// CalendarJulianToJD converts a Julian year, month, and day of month to Julian day.
//
// Negative years are valid, back to JD 0.  The result is not valid for
// dates before JD 0.
// 儒略历日期转儒略日
func CalendarJulianToJD(y, m int, d float64) float64 {
	switch m {
	case 1, 2:
		y--
		m += 12
	}
	return float64(base.FloorDiv64(36525*(int64(y+4716)), 100)) +
		float64(base.FloorDiv(306*(m+1), 10)) + d - 1524.5
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3-2-儒略日-jd-rightarrow-阳历日期-y-m-d&#34;&gt;3.2 儒略日$(JD)$ $\Rightarrow$ 阳历日期$(y,m,d)$&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;将 $JD$ 加上 0.5，令$Z$为其整数部分，$F$ 为尾数（小数）部分。&lt;/li&gt;
&lt;li&gt;若 $Z$ &amp;lt; 2299161，取 $A$ = $Z$;&lt;br /&gt;
若 $Z$ 大于等于 2299161，计算
\begin{align}
α &amp;amp;=\lfloor \frac {Z-1867216.25}{36524.25}\rfloor\\[2ex]
A &amp;amp;=Z+1+α-\lfloor \frac α4\rfloor
\end{align}&lt;/li&gt;
&lt;li&gt;然后计算
\begin{align}
B &amp;amp;= A+1524\\[2ex]
C &amp;amp;= \lfloor \frac {B-122.1}{365.25}\rfloor\\[2ex]
D &amp;amp;= \lfloor 365.25C\rfloor\\[2ex]
E &amp;amp;= \lfloor \frac {B-D}{30.6001}\rfloor\\[2ex]
\end{align}&lt;/li&gt;
&lt;li&gt;该月日期（带小数部分）则为：$$d = B - D - \lfloor 30.6001E\rfloor + F$$&lt;/li&gt;
&lt;li&gt;月份 m 为：
\begin{cases}
m = E – 1 ;&amp;amp;  \text {if $E$ &amp;lt; 14}\\[2ex]
m = E – 13 ;&amp;amp;  \text {if $E$ $\geq$ 14}
\end{cases}&lt;/li&gt;
&lt;li&gt;年份为 y：
\begin{cases}
y = C – 4716 ;&amp;amp;  \text {if $m$ &amp;gt; 2}\\[2ex]
y = C – 4715 ;&amp;amp;  \text {if $m$ $\leq$ 2}
\end{cases}&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// JDToCalendar returns the calendar date for the given jd.
//
// Note that this function returns a date in either the Julian or Gregorian
// Calendar, as appropriate.
// 儒略日转公历日期
// 如果儒略日对应的格里历时间点在1582-10-15 12点之前，则转为儒略历日期
// 如果儒略日对应的格里历时间点在1582-10-15 12点之后，则转为格里历日期
func JDToCalendar(jd float64) (year, month int, day float64) {
	zf, f := math.Modf(jd + .5)
	z := int64(zf)
	a := z
	// if z &amp;gt;= 2299151 { // typo 应该是2299161对应于现实格里历起始日1582-10-15中午12点
	if z &amp;gt;= 2299161 { // typo 应该是2299161对应于现实格里历起始日1582-10-15中午12点
		α := base.FloorDiv64(z*100-186721625, 3652425)
		a = z + 1 + α - base.FloorDiv64(α, 4)
	}
	b := a + 1524
	c := base.FloorDiv64(b*100-12210, 36525)
	d := base.FloorDiv64(36525*c, 100)
	e := int(base.FloorDiv64((b-d)*1e4, 306001))
	// compute return values
	day = float64(int(b-d)-base.FloorDiv(306001*e, 1e4)) + f
	switch e {
	default:
		month = e - 1
	case 14, 15:
		month = e - 13
	}
	switch month {
	default:
		year = int(c) - 4716
	case 1, 2:
		year = int(c) - 4715
	}
	return
}

// jdToCalendarGregorian returns the Gregorian calendar date for the given jd.
//
// Note that it returns a Gregorian date even for dates before the start of
// the Gregorian calendar.  The function is useful when working with Go
// time.Time values because they are always based on the Gregorian calendar.
// 始终转为格里历，忽略儒略历转格里历被扣除的那10天，即把1582-10-15 12点之前的日期也当成格里历算
func jdToCalendarGregorian(jd float64) (year, month int, day float64) {
	zf, f := math.Modf(jd + .5)
	z := int64(zf)
	α := base.FloorDiv64(z*100-186721625, 3652425)
	a := z + 1 + α - base.FloorDiv64(α, 4)
	b := a + 1524
	c := base.FloorDiv64(b*100-12210, 36525)
	d := base.FloorDiv64(36525*c, 100)
	e := int(base.FloorDiv64((b-d)*1e4, 306001))
	// compute return values
	day = float64(int(b-d)-base.FloorDiv(306001*e, 1e4)) + f
	switch e {
	default:
		month = e - 1
	case 14, 15:
		month = e - 13
	}
	switch month {
	default:
		year = int(c) - 4716
	case 1, 2:
		year = int(c) - 4715
	}
	return
}

// JDToTime takes a JD and returns a Go time.Time value.
// 儒略历转为格里历日期对应的 Go Time 类型
func JDToTime(jd float64) time.Time {
	// time.Time is always Gregorian
	y, m, d := jdToCalendarGregorian(jd)
	t := time.Date(y, time.Month(m), 0, 0, 0, 0, 0, time.UTC)
	return t.Add(time.Duration(d * 24 * float64(time.Hour)))
}

// TimeToJD takes a Go time.Time and returns a JD as float64.
//
// Any time zone offset in the time.Time is ignored and the time is
// treated as UTC.
// Go Time 类型转为儒略日（默认日期为格里历）
func TimeToJD(t time.Time) float64 {
	ut := t.UTC()
	y, m, _ := ut.Date()
	d := ut.Sub(time.Date(y, m, 0, 0, 0, 0, 0, time.UTC))
	// time.Time is always Gregorian
	return CalendarGregorianToJD(y, int(m), float64(d)/float64(24*time.Hour))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3-3-儒略日-jd-rightarrow-星期几&#34;&gt;3.3 儒略日$(JD)$ $\Rightarrow$ 星期几&lt;/h3&gt;

&lt;p&gt;　　因为儒略日0.0(-4712-1-1 12:00) 是星期一，往后7天一循环就能得出星期几了&lt;br /&gt;
　　计算该日0时的儒略日，加上1.5，再除以7，所得余数将指示出星期几：&lt;br /&gt;
若余数为0，则为星期日，1为星期一，2为星期二，3为星期三，4为星期四，5为星期五，6为星期六。&lt;br /&gt;
　　儒略历到格里高利历的换算并不影响星期。 因而，在1582年10月4日星期四接下来的一天便是10月15日星期五。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// DayOfWeek determines the day of the week for a given JD.
//
// The value returned is an integer in the range 0 to 6, where 0 represents
// Sunday.  This is the same convention followed in the time package of the
// Go standard library.
// 儒略日0.0为-4712-1-1 12:00 星期一，往后7天一循环就能得出星期几了
func DayOfWeek(jd float64) int {
	return int(jd+1.5) % 7
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3-4-日阳历日期-y-m-d-rightarrow-年内序数日-n&#34;&gt;3.4 日阳历日期$(Y,M,D)$ $\Rightarrow$ 年内序数日$(N)$&lt;/h3&gt;

&lt;p&gt;　　年内的序数日$N$可由以下公式得出：$$N = \lfloor \frac {275M}{9}\rfloor - K\lfloor \frac {M+9}{12}\rfloor + D - 30 $$
　　此处$M$为月份，$D$为该月日期，闰年$K = 1$，平年$K = 2$&lt;br /&gt;
　　$N$ 取整数，自1月1日开始取值1，直至12月31日取值365（或闰年取值366）。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;如何推导出这个公式？&lt;/strong&gt;&lt;br /&gt;
　　乍一看挺没头绪的，我们先来看一个数列$$ a_m = \lfloor \frac {5(m+1)}{9}\rfloor, (m=0,1,2,\dots,12)$$&lt;/p&gt;

&lt;p&gt;\begin{array}{c|ccl}
m &amp;amp; a_m &amp;amp; a_m - a_{m-1} &amp;amp; 当月天数 \\&lt;br /&gt;
\hline
0 &amp;amp; 0 &amp;amp; - &amp;amp; - \\&lt;br /&gt;
1 &amp;amp; 1 &amp;amp; 1 &amp;amp; 31 \\&lt;br /&gt;
2 &amp;amp; 1 &amp;amp; 0 &amp;amp; 30(看做30) \\&lt;br /&gt;
3 &amp;amp; 2 &amp;amp; 1 &amp;amp; 31 \\&lt;br /&gt;
4 &amp;amp; 2 &amp;amp; 0 &amp;amp; 30 \\&lt;br /&gt;
5 &amp;amp; 3 &amp;amp; 1 &amp;amp; 31 \\&lt;br /&gt;
6 &amp;amp; 3 &amp;amp; 0 &amp;amp; 30 \\&lt;br /&gt;
7 &amp;amp; 4 &amp;amp; 1 &amp;amp; 31 \\&lt;br /&gt;
8 &amp;amp; 5 &amp;amp; 1 &amp;amp; 31 \\&lt;br /&gt;
9 &amp;amp; 5 &amp;amp; 0 &amp;amp; 30 \\&lt;br /&gt;
10 &amp;amp; 6 &amp;amp; 1 &amp;amp; 31 \\&lt;br /&gt;
11 &amp;amp; 6 &amp;amp; 0 &amp;amp; 30 \\&lt;br /&gt;
12 &amp;amp; 7 &amp;amp; 1 &amp;amp; 31
\end{array}&lt;/p&gt;

&lt;p&gt;　　如果把$m$看成是月份，并且暂时把二月看成是30天，那么第二列恰好是$当月天数-30$，所以我们就可以用以下公式来表示每个月的天数。
$$D_m = 30 + a_m - a_{m-1}$$&lt;/p&gt;

&lt;p&gt;　　所以从1月到m月的总天数：
\begin{align}
S_m = &amp;amp; D_1+D_2+,\dots,+D_m\\[2ex]
= &amp;amp; 30 + a_m - a_{m-1} + \\[2ex]
&amp;amp; 30 + a_{m-1} - a_{m-2} + \\[2ex]
&amp;amp; \cdots \\[2ex]
&amp;amp; 30 + a_2 - a_1 + \\[2ex]
&amp;amp; 30 + a_1 - a_0 \\[2ex]
= &amp;amp; 30m + a_m - a_0\\[2ex]
= &amp;amp; 30m + \lfloor \frac {5(m+1)}{9}\rfloor
\end{align}&lt;/p&gt;

&lt;p&gt;　　由于上述表达式只有在2月等于30天的情况下才成立，所以当$m\geq 2$时还要根据平年、闰年分别减去相应的天数2，1，得到1月到$m$月的总天数和为：
\begin{align}
S_m=30m + \lfloor \frac {5(m+1)}{9}\rfloor - \lfloor \frac {m+10}{12}\rfloor k,\ 其中
\end{align}
\begin{cases}
k = 1 , \ 闰年\\[2ex]
k = 2 , \ 平年
\end{cases}&lt;/p&gt;

&lt;p&gt;　　所以$M$月$D$日的年内序数$N$为：
\begin{align}
N &amp;amp;= S_{M-1} + D\\[2ex]
&amp;amp;= 30(M-1) + \lfloor \frac {5M}{9}\rfloor - \lfloor \frac {M+9}{12}\rfloor k + D\\[2ex]
&amp;amp;= \lfloor \frac {275M}{9}\rfloor - \lfloor \frac {M+9}{12}\rfloor k -30 + D\\[2ex]
\end{align}&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// DayOfYearGregorian computes the day number within the year of the Gregorian
// calendar.
// 格里历年内序数
func DayOfYearGregorian(y, m, d int) int {
	return DayOfYear(y, m, d, LeapYearGregorian(y))
}

// DayOfYearJulian computes the day number within the year of the Julian
// calendar.
// 儒略历年内序数
func DayOfYearJulian(y, m, d int) int {
	return DayOfYear(y, m, d, LeapYearJulian(y))
}

// DayOfYear computes the day number within the year.
//
// This form of the function is not specific to the Julian or Gregorian
// calendar, but you must tell it whether the year is a leap year.
// 输入闰年标识，计算年内序数
func DayOfYear(y, m, d int, leap bool) int {
	k := 2
	if leap {
		k--
	}
	return wholeMonths(m, k) + d
}

// m月之前的所有月份天数之和
func wholeMonths(m, k int) int {
	return 275*m/9 - k*((m+9)/12) - 30
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3-5-年内序数日-n-rightarrow-阳历日期-m-d&#34;&gt;3.5 年内序数日$(N)$  $\Rightarrow$ 阳历日期$(M,D)$&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// DayOfYearToCalendar returns the calendar month and day for a given
// day of year and leap year status.
// 年内序数求对应的日期
func DayOfYearToCalendar(n int, leap bool) (m, d int) {
	k := 2
	if leap {
		k--
	}
	if n &amp;lt; 32 {
		m = 1
	} else {
		m = (900*(k+n) + 98*275) / 27500
	}
	return m, n - wholeMonths(m, k)
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>天文算法4</title>
      <link>https://mooncaker816.github.io/2018/05/15/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%954/</link>
      <pubDate>Tue, 15 May 2018 17:34:49 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/05/15/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%954/</guid>
      <description>&lt;h1 id=&#34;第六章-排序-sort&#34;&gt;第六章 排序 Sort&lt;/h1&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;Go 标准库已经够了，所以就略了&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>天文算法3</title>
      <link>https://mooncaker816.github.io/2018/05/15/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%953/</link>
      <pubDate>Tue, 15 May 2018 13:48:36 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/05/15/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%953/</guid>
      <description>&lt;h1 id=&#34;第五章-迭代-iteration&#34;&gt;第五章 迭代 Iteration&lt;/h1&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-什么是迭代算法&#34;&gt;1. 什么是迭代算法&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;　　迭代法（英语：Iterative Method），在计算数学中，迭代是通过从一个初始估计出发寻找一系列近似解来解决问题（一般是解方程或者方程组）的数学过程，为实现这一过程所使用的方法统称。&lt;/p&gt;

&lt;p&gt;　　跟迭代法相对应的是直接法（或者称为一次解法），即一次性解决问题，例如通过开方解决方程 $ x^{2}=4$。一般如果可能，直接解法总是优先考虑的。但当遇到复杂问题时，特别是在未知量很多，方程为非线性时，我们无法找到直接解法（例如五次以及更高次的代数方程没有解析解，参见阿贝尔定理），这时候或许可以通过迭代法寻求方程（组）的近似解。&lt;/p&gt;

&lt;p&gt;　　最常见的迭代法是牛顿法。其他还包括最速下降法、共轭迭代法、变尺度迭代法、最小二乘法、线性规划、非线性规划、单纯型法、惩罚函数法、斜率投影法、遗传算法、模拟退火等等。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　以上是 wiki 上对迭代算法的描述，可以看出，迭代法的主要用途就是求解近似根，这一点我们再第三章插值函数逆推插值点的介绍中已经得到了运用。下面我们主要介绍牛顿迭代法和二分迭代法。&lt;/p&gt;

&lt;h2 id=&#34;2-牛顿迭代法&#34;&gt;2. 牛顿迭代法&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;　　首先，选择一个接近函数$f(x)$零点的 $x_0$，计算相应的 $f(x_0)$和切线斜率 $f&amp;rsquo;(x_0)$。然后我们计算穿过点 $(x_0,f(x_0))$并且斜率为 $f&amp;rsquo;(x_0)$的直线和 $x$轴的交点的 $x$坐标，也就是求如下方程的解：
$$0=(x-x_0)f&amp;rsquo;(x_0)+f(x_0)$$
　　我们将新求得的点的$x$坐标命名为$x_1$，通常$x_1$会比$x_0$更接近方程$f(x)=0$的解。因此我们现在可以利用$x_1$开始下一轮迭代。迭代公式可化简为如下所示：
$$x_{n+1}=x_n - \frac {f(x_n)}{f&amp;rsquo;(x_n)}$$
　　已经证明，如果$f&amp;rsquo;$是连续的，并且待求的零点$x$是孤立的，那么在零点$x$周围存在一个区域，只要初始值$x_0$位于这个邻近区域内，那么牛顿法必定收敛。&lt;/p&gt;

&lt;p&gt;　　并且，如果$f&amp;rsquo;(x)\neq 0$，那么牛顿法将具有平方收敛的性能。粗略的说，这意味着每迭代一次，牛顿法结果的有效数字将增加一倍。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/thumb/e/e0/NewtonIteration_Ani.gif/600px-NewtonIteration_Ani.gif&#34; width=400 height=300 /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// BetterFunc is a convience type definition.
type BetterFunc func(float64) float64
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// DecimalPlaces iterates to a fixed number of decimal places.
//
// Inputs are an improvement function, a starting value, the number of
// decimal places desired in the result, and an iteration limit.
// better 为迭代公式，start 为起始点，places 为视作迭代结束的最大精度值的小数点位数,
// maxIterations 为迭代最大次数
func DecimalPlaces(better BetterFunc, start float64, places, maxIterations int) (float64, error) {
	d := math.Pow(10, float64(-places))
	for i := 0; i &amp;lt; maxIterations; i++ {
		n := better(start)
		if math.Abs(n-start) &amp;lt; d {
			return n, nil
		}
		start = n
	}
	return 0, errors.New(&amp;quot;Maximum iterations reached&amp;quot;)
}

// FullPrecison iterates to (nearly) the full precision of a float64.
//
// To allow for a little bit of floating point jitter, FullPrecision iterates
// to 15 significant figures, which is the maximum number of full significant
// figures representable in a float64, but still a couple of bits shy of the
// full representable precision.
// 和 DecimalPlaces 功能类似，只不过默认迭代结束的标志为小于float64的最大精度15
func FullPrecision(better BetterFunc, start float64, maxIterations int) (float64, error) {
	for i := 0; i &amp;lt; maxIterations; i++ {
		n := better(start)
		if math.Abs((n-start)/n) &amp;lt; 1e-15 {
			return n, nil
		}
		start = n
	}
	return 0, errors.New(&amp;quot;Maximum iterations reached&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;3-二分迭代法&#34;&gt;3. 二分迭代法&lt;/h2&gt;

&lt;p&gt;　　二分迭代法，顾名思义，就是计算中点的函数值，并与当前低值和高值比较，&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;若与低值同号，则把该值作为新的低值，继续迭代&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;若与高值同号，则把该值作为新的高值，继续迭代&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// RootFunc is a convience type definition.
type RootFunc func(float64) float64
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// BinaryRoot finds a root between given bounds by binary search.
//
// Inputs are a function on x and the bounds on x.  A root must exist between
// the given bounds, otherwise the result is not meaningful.
// 因为float64 的小数bit位最多为52位(10进制为15位有效数字)，
// 即每次迭代理论上能提升一位精度，所以最多52次就应该跳出迭代
func BinaryRoot(f RootFunc, lower, upper float64) float64 {
	yLower := f(lower)
	var mid float64
	for j := 0; j &amp;lt; 52; j++ {
		mid = (lower + upper) / 2
		yMid := f(mid)
		if yMid == 0 {
			break
		}
		if math.Signbit(yLower) == math.Signbit(yMid) { // 与低值同号，替代低值
			lower = mid
			yLower = yMid
		} else {
			upper = mid //与高值同号，替换高值
		}
	}
	return mid
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>天文算法2</title>
      <link>https://mooncaker816.github.io/2018/05/13/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%952/</link>
      <pubDate>Sun, 13 May 2018 19:38:14 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/05/13/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%952/</guid>
      <description>&lt;h1 id=&#34;第四章-拟合-curve-fitting&#34;&gt;第四章 拟合 Curve Fitting&lt;/h1&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-什么是拟合&#34;&gt;1. 什么是拟合&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;曲线拟合(Curve Fitting)的数学定义是指用连续曲线近似地刻画或比拟平面上一组离散点所表示的坐标之间的函数关系，是一种用解析表达式逼近离散数据的方法。曲线拟合通俗的说法就是“拉曲线”，也就是将现有数据透过数学方法来代入一条数学方程式的表示方法。科学和工程遇到的很多问题，往往只能通过诸如采样、实验等方法获得若干离散的数据，根据这些数据，如果能够找到一个连续的函数（也就是曲线）或者更加密集的离散方程，使得实验数据与方程的曲线能够在最大程度上近似吻合，就可以根据曲线方程对数据进行数学计算，对实验结果进行理论分析，甚至对某些不具备测量条件的位置的结果进行估算。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;2-最小二乘拟合&#34;&gt;2. 最小二乘拟合&lt;/h2&gt;

&lt;p&gt;　　考虑 N 个数据点，它们的坐标是$(x_1,y_1),(x_2,y_2),\dots,(x_n,y_n)$
假设这些值中的 X 是严格的精确值，Y 的值是测量值(含有一些误差)。
对于一个给定的 X，如$x_1$，对应的值$y_1$与曲线 C 上对应的 Y 值将存在一个差值$d_1$，我们称这个差值为偏差、误差或残差，它可能是正、负或零。类似的，$x_2,\dots,x_n$,对应的差值为 $d_2,\dots,d_n$。&lt;/p&gt;

&lt;p&gt;　　我们用 $d_1^2+d_2^2+\cdots+d_n^2$ 作为衡量曲线 C 拟合的“最佳”程度，这个值越小越好，越大则越不好。因此，我们做以下定义：任何一种类型的曲线，它们都有一个共同的特性， 当 $$\sum_{i=1}^n d_i^2$$最小时，称为最佳拟合曲线。&lt;/p&gt;

&lt;p&gt;　　一条曲线具有这一特性时，称之为“最小二乘拟合”， 这样的曲线称为“最小二乘曲线”。&lt;/p&gt;

&lt;h3 id=&#34;2-1-线性拟合&#34;&gt;2.1 线性拟合&lt;/h3&gt;

&lt;p&gt;　　&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;线性方程&lt;/p&gt;

&lt;p&gt;假设拟合的曲线为直线$y=ax+b$,则最小二乘差方和为：
$$\sum_{i=1}^n[y_i-(ax_i+b)]^2$$
所以问题转化为求解上述关于a,b的二元函数的最小值&lt;/p&gt;

&lt;p&gt;对上式中a求偏导&lt;/p&gt;

&lt;p&gt;\begin{multline}
\shoveleft
\begin{aligned}
\frac \partial {\partial a}\sum_{i=1}^n[y_i-(ax_i+b)]^2 &amp;amp;= -2\sum_{i=1}^n({x_iy_i}-a{x_i^2}-b {x_i})\\[2ex]
&amp;amp; =-2\sum_{i=1}^n{x_i}[{y_i}-(a{x_i}+b)]\\[2ex]
\end{aligned}
\end{multline}&lt;/p&gt;

&lt;p&gt;\begin{multline}
\shoveleft
\text {由极值的必要条件可知，}\\[2ex]
\shoveleft
-2\sum_{i=1}^n{x_i}[{y_i}-(a{x_i}+b)] = 0\\[2ex]
\shoveleft
\therefore \sum_{i=1}^n{x_iy_i}-a\sum_{i=1}^n{x_i^2}-b\sum_{i=1}^n{x_i}=0
\end{multline}&lt;/p&gt;

&lt;p&gt;同理对b求偏导可得：
\begin{align}
\sum_{i=1}^n{y_i}-a\sum_{i=1}^n{x_i}-bn=0
\end{align}&lt;/p&gt;

&lt;p&gt;求解关于a,b 的二元一次方程组，
\begin{cases}
\sum\limits_{i=1}^n{x_iy_i}-a\sum\limits_{i=1}^n{x_i^2}-b\sum\limits_{i=1}^n{x_i}=0 \\[2ex]
\sum\limits_{i=1}^n{y_i}-a\sum\limits_{i=1}^n{x_i}-bn=0
\end{cases}&lt;/p&gt;

&lt;p&gt;得
\begin{align}
a &amp;amp;= \frac {\sum\limits_{i=1}^n{x_i}\sum\limits_{i=1}^n{y_i}-n\sum\limits_{i=1}^n{x_iy_i}}{  (\sum\limits_{i=1}^n{x_i})^2-n\sum\limits_{i=1}^n{x_i}^2}\\[2ex]
b &amp;amp;= \frac {\sum\limits_{i=1}^n{x_i}\sum\limits_{i=1}^n{x_iy_i}-\sum\limits_{i=1}^n{y_i} \sum\limits_{i=1}^n{x_i}^2}{(\sum\limits_{i=1}^n{x_i})^2-n\sum\limits_{i=1}^n{x_i}^2}
\end{align}&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;皮尔逊相关系数r&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E7%9A%AE%E5%B0%94%E9%80%8A%E7%A7%AF%E7%9F%A9%E7%9B%B8%E5%85%B3%E7%B3%BB%E6%95%B0&#34; target=&#34;_blank&#34;&gt;定义&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;由定义可知，
\begin{align}
r=\frac {\sum\limits_{i=1}^n(x_i-\bar x)(y_i-\bar y)}{\sqrt {\sum\limits_{i=1}^n(x_i-\bar x)^2}\sqrt {\sum\limits_{i=1}^n(y_i-\bar y)^2}}, \\[2ex]
\text {其中 } \bar x=\frac 1n\sum_{i=1}^nx_i,\bar y=\frac 1n\sum_{i=1}^ny_i
\end{align}&lt;/p&gt;

&lt;p&gt;\begin{multline}
\shoveleft
\begin{aligned}
化简 \ \  &amp;amp; \sum\limits_{i=1}^n(x_i-\bar x)(y_i-\bar y)\\[2ex]
= &amp;amp; \sum\limits_{i=1}^n(x_iy_i-x_i\bar y-\bar xy_i+\bar x\bar y)\\[2ex]
= &amp;amp; \sum\limits_{i=1}^nx_iy_i - \sum\limits_{i=1}^nx_i\bar y - \sum\limits_{i=1}^n\bar xy_i+\sum\limits_{i=1}^n\bar x\bar y\\[2ex]
= &amp;amp; \sum\limits_{i=1}^nx_iy_i - \frac 1n\sum\limits_{i=1}^ny_i\sum\limits_{i=1}^nx_i - \frac 1n\sum\limits_{i=1}^nx_i\sum\limits_{i=1}^ny_i + \frac 1n\sum\limits_{i=1}^nx_i\sum\limits_{i=1}^ny_i\\[2ex]
= &amp;amp; \sum\limits_{i=1}^nx_iy_i - \frac 1n\sum\limits_{i=1}^ny_i\sum\limits_{i=1}^nx_i\\[2ex]
化简 \ \  &amp;amp; \sum\limits_{i=1}^n(x_i-\bar x)^2\\[2ex]
= &amp;amp; \sum\limits_{i=1}^n(x_i^2-2x_i\bar x+\bar x^2)\\[2ex]
= &amp;amp; \sum\limits_{i=1}^nx_i^2 - 2\bar x\sum\limits_{i=1}^nx_i + n\bar x^2\\[2ex]
= &amp;amp; \sum\limits_{i=1}^nx_i^2 - 2n\bar x^2 + n\bar x^2\\[2ex]
= &amp;amp; \sum\limits_{i=1}^nx_i^2 - n\bar x^2\\[2ex]
= &amp;amp; \sum\limits_{i=1}^nx_i^2 - \frac 1n(\sum\limits_{i=1}^nx_i)^2\\[2ex]
同上 \ \  &amp;amp; \sum\limits_{i=1}^n(y_i-\bar y)^2\\[2ex]
= &amp;amp; \sum\limits_{i=1}^ny_i^2 - \frac 1n(\sum\limits_{i=1}^ny_i)^2\\[2ex]
\end{aligned}
\end{multline}
\begin{multline}
\shoveleft
\begin{aligned}
\therefore \ \ r&amp;amp;=\frac {\sum\limits_{i=1}^nx_iy_i - \frac 1n\sum\limits_{i=1}^ny_i\sum\limits_{i=1}^nx_i}{\sqrt{\sum\limits_{i=1}^nx_i^2 - \frac 1n(\sum\limits_{i=1}^nx_i)^2}\sqrt{\sum\limits_{i=1}^ny_i^2 - \frac 1n(\sum\limits_{i=1}^ny_i)^2}}\\[2ex]
&amp;amp; =\frac {n\sum\limits_{i=1}^nx_iy_i - \sum\limits_{i=1}^ny_i\sum\limits_{i=1}^nx_i}{\sqrt{n\sum\limits_{i=1}^nx_i^2 - (\sum\limits_{i=1}^nx_i)^2}\sqrt{n\sum\limits_{i=1}^ny_i^2 - (\sum\limits_{i=1}^ny_i)^2}}
\end{aligned}
\end{multline}&lt;/p&gt;

&lt;p&gt;　　这个系数介于+1 到-1 之间。如果值为+1 或-1，说明 x 和 y 之间有完全的线性关系，所有的点(x,y)精确的在同一条直线上。如果 r = +1，y 随 x 单调递增，如果 r = -1，y 随 x 单调递减。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;代码&lt;/p&gt;

&lt;p&gt;　　到这里我们就已经推导出求解线性方程和相关系数的公式，再结合代码看看&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Linear fits a line to sample data.
//
// Argument p is a list of data points.  Results a and b are coefficients
// of the best fit line y = ax + b.
// 求解线性拟合直线
// sx = ∑x sy = ∑y sxy = ∑xy sx2 = ∑x^2
func Linear(p []struct{ X, Y float64 }) (a, b float64) {
    var sx, sy, sx2, sxy float64
    for i := range p {
        x := p[i].X
        y := p[i].Y
        sx += x
        sy += y
        sx2 += x * x
        sxy += x * y
    }
    n := float64(len(p))
    d := n*sx2 - sx*sx
    // (4.2) p. 36
    a = (n*sxy - sx*sy) / d
    b = (sy*sx2 - sx*sxy) / d
    return
}

// CorrelationCoefficient returns a correlation coefficient for sample data.
// 求解相关系数 r
func CorrelationCoefficient(p []struct{ X, Y float64 }) float64 {
    var sx, sy, sx2, sy2, sxy float64
    for i := range p {
        x := p[i].X
        y := p[i].Y
        sx += x
        sy += y
        sx2 += x * x
        sy2 += y * y
        sxy += x * y
    }
    n := float64(len(p))
    // (4.3) p. 38
    return (n*sxy - sx*sy) / (math.Sqrt(n*sx2-sx*sx) * math.Sqrt(n*sy2-sy*sy))
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;2-2-二次曲线拟合&#34;&gt;2.2 二次曲线拟合&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;二次方程$y = ax^2 + bx + c$&lt;/p&gt;

&lt;p&gt;　　假设我们希望画一条逼近 N 个点的最佳二次曲线：$y = ax^2 + bx + c$ 这是一个纵轴的抛物线。同一次直线类似，差方和为$$\sum_{i=1}^n[y_i-(ax_i^2+bx_i+c)]^2$$
依次对上式中的a,b,c求偏导，得
\begin{align}
\sum_{i=1}^n(-2x_i^2y_i+2ax_i^4+2bx_i^3+2cx_i^2) = 0\\[2ex]
\sum_{i=1}^n(-2x_iy_i+2ax_i^3+2bx_i^2+2cx_i) = 0\\[2ex]
\sum_{i=1}^n(-2y_i+2ax_i^2+2bx_i+2c) = 0\\[2ex]
\end{align}
\begin{multline}
\begin{aligned}
\therefore &amp;amp; \sum_{i=1}^nx_i^2y_i=\sum_{i=1}^nax_i^4+\sum_{i=1}^nbx_i^3+\sum_{i=1}^ncx_i^2\\[2ex]
 &amp;amp; \sum_{i=1}^nx_iy_i=\sum_{i=1}^nax_i^3+\sum_{i=1}^nbx_i^2+\sum_{i=1}^ncx_i\\[2ex]
 &amp;amp; \sum_{i=1}^ny_i=\sum_{i=1}^nax_i^2+\sum_{i=1}^nbx_i+nc\\[2ex]
\end{aligned}
\end{multline}&lt;/p&gt;

&lt;p&gt;求解以下三元一次方程组
\begin{cases}
\sum\limits_{i=1}^nx_i^2y_i=\sum\limits_{i=1}^nax_i^4+\sum\limits_{i=1}^nbx_i^3+\sum\limits_{i=1}^ncx_i^2\\[2ex]
\sum\limits_{i=1}^nx_iy_i=\sum\limits_{i=1}^nax_i^3+\sum\limits_{i=1}^nbx_i^2+\sum\limits_{i=1}^ncx_i\\[2ex]
\sum\limits_{i=1}^ny_i=\sum\limits_{i=1}^nax_i^2+\sum\limits_{i=1}^nbx_i+nc\\[2ex]
\end{cases}&lt;/p&gt;

&lt;p&gt;得
\begin{multline}
\shoveleft
\begin{aligned}
a &amp;amp;= \frac {NQV+PRT+PQU-Q^2T-P^2V-NRU}{D}\\[2ex]
b &amp;amp;= \frac {NSU+PQV+QRT-Q^2U-PST-NRV}{D}\\[2ex]
c &amp;amp;= \frac {QST+QRU+PRV-Q^2V-PSU-R^2T}{D}\\[2ex]
\end{aligned}
\end{multline}&lt;/p&gt;

&lt;p&gt;\begin{multline}
\shoveleft
\begin{aligned}
其中\ &amp;amp;P =\sum\limits_{i=1}^nx_i,\ Q=\sum\limits_{i=1}^nx_i^2,\ R=\sum\limits_{i=1}^nx_i^3,\ S=\sum\limits_{i=1}^nx_i^4,\\[2ex]
&amp;amp;T=\sum\limits_{i=1}^ny_i,\ U=\sum\limits_{i=1}^nx_iy_i,\ V=\sum\limits_{i=1}^nx_i^2y_i,\\[2ex]
&amp;amp;D = NQS+2PQR-Q^3-P^2S-NR^2
\end{aligned}
\end{multline}&lt;/p&gt;

&lt;p&gt;　　至此我们的程序就能很方便的通过上述公式，对这 N 个点进行一次完整的遍历，计算上述 P,Q,R,S,T,U,V,D,即可求得拟合曲线方程。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Quadratic fits y = ax² + bx + c to sample data.
//
// Argument p is a list of data points.  Results a, b, and c are coefficients
// of the best fit quadratic y = ax² + bx + c.
// 求解二次拟合曲线系数
func Quadratic(p []struct{ X, Y float64 }) (a, b, c float64) {
    var P, Q, R, S, T, U, V float64
    for i := range p {
        x := p[i].X
        y := p[i].Y
        x2 := x * x
        P += x
        Q += x2
        R += x * x2
        S += x2 * x2
        T += y
        U += x * y
        V += x2 * y
    }
    N := float64(len(p))
    // (4.5) p. 43
    D := N*Q*S + 2*P*Q*R - Q*Q*Q - P*P*S - N*R*R
    // (4.6) p. 43
    a = (N*Q*V + P*R*T + P*Q*U - Q*Q*T - P*P*V - N*R*U) / D
    b = (N*S*U + P*Q*V + Q*R*T - Q*Q*U - P*S*T - N*R*V) / D
    c = (Q*S*T + Q*R*U + P*R*V - Q*Q*V - P*S*U - R*R*T) / D
    return
}   
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;一般曲线拟合（多重线回归）&lt;/p&gt;

&lt;p&gt;　　最佳线性拟合的原理可以被扩展到其它函数，这个函数可以含有超过两个未知的线性系数。
让我们考虑三个函数的线性组合的情况。 假设我们已知：$$y = af_0(x) + bf_1(x) + cf_2(x)$$
式中$f_0$、$f_1$ 和 $f_2$ 是三个关于 x 的已知函数，但系数 a、 b 和 c 是未知的。此外，假设已知 3 个 x 对应的 y 值。那么 系数 a、b、c 可按如下得到。
求和计算：
\begin{align}
M &amp;amp;= \sum f_0^2 &amp;amp;U &amp;amp;= \sum yf_0\\[2ex]
P &amp;amp;= \sum f_0f_1 &amp;amp;V &amp;amp;= \sum yf_1\\[2ex]
Q &amp;amp;= \sum f_0f_2 &amp;amp;W &amp;amp;= \sum yf_2\\[2ex]
R &amp;amp;= \sum f_1^2 \\[2ex]
S &amp;amp;= \sum f_1f_2 \\[2ex]
T &amp;amp;= \sum f_2^2 \\[2ex]
\end{align}
$$D = MRT+2PQS-MS^2-RQ^2-TP^2$$
那么：
\begin{align}
a &amp;amp;= \frac {U(RT-S^2)+V(QS-PT)+W(PS-QR)}{D}\\[2ex]
b &amp;amp;= \frac {U(SQ-PT)+V(MT-Q^2)+W(PQ-MS)}{D}\\[2ex]
c &amp;amp;= \frac {U(PS-RQ)+V(PQ-MS)+W(MR-P^2)}{D}
\end{align}
另一种特殊情况，考虑 y=af(x)，只有一个未知系数。 我们容易得到：
$$a = \frac {\sum yf}{\sum f^2}$$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Func3 implements multiple linear regression for a linear combination
// of three functions.
//
// Given sample data and three functions in x, Func3 returns coefficients
// a, b, and c fitting y = aƒ₀(x) + bƒ₁(x) + cƒ₂(x) to sample data.
// 多重线性回归
func Func3(p []struct{ X, Y float64 }, f0, f1, f2 func(float64) float64) (a, b, c float64)  {
    var M, P, Q, R, S, T, U, V, W float64
    for i := range p {
        x := p[i].X
        y := p[i].Y
        y0 := f0(x)
        y1 := f1(x)
        y2 := f2(x)
        M += y0 * y0
        P += y0 * y1
        Q += y0 * y2
        R += y1 * y1
        S += y1 * y2
        T += y2 * y2
        U += y * y0
        V += y * y1
        W += y * y2
    }
    // (4.7) p. 44
    D := M*R*T + 2*P*Q*S - M*S*S - R*Q*Q - T*P*P
    a = (U*(R*T-S*S) + V*(Q*S-P*T) + W*(P*S-Q*R)) / D
    b = (U*(S*Q-P*T) + V*(M*T-Q*Q) + W*(P*Q-M*S)) / D
    c = (U*(P*S-R*Q) + V*(P*Q-M*S) + W*(M*R-P*P)) / D
    return
}

// Func1 fits a linear multiple of a function to sample data.
//
// Given sample data and a function in x, Func1 returns coefficient
// a fitting y = aƒ(x).
func Func1(p []struct{ X, Y float64 }, f func(float64) float64) float64 {
    var syf, sf2 float64
    // (4.8) p. 45
    for i := range p {
        f := f(p[i].X)
        y := p[i].Y
        syf += y * f
        sf2 += f * f
    }
    return syf / sf2
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>天文算法1</title>
      <link>https://mooncaker816.github.io/2018/05/12/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%951/</link>
      <pubDate>Sat, 12 May 2018 21:43:17 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/05/12/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%951/</guid>
      <description>&lt;h2 id=&#34;①背景&#34;&gt;①背景&lt;/h2&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;计算精确的农历节气和日月合朔时间点，需要使用天文算法来实现。《Astronomical Algorithms》正是这么一本不那么让人望而生畏的介绍天文算法的书籍，国内比较出名的寿星万年历亦是基于此书中的算法。&lt;/p&gt;

&lt;p&gt;作为一名 Gopher 本想自造轮子来实现，但是万能的 Github 上已有前人身先士卒，直接上地址&lt;a href=&#34;https://github.com/soniakeys/meeus&#34; target=&#34;_blank&#34;&gt;meeus&lt;/a&gt;，该库基本上完整的实现了Astronomical Algorithms中的算法，而且每一章节对应一个 package，浏览起来不会让人感觉没有头绪。&lt;/p&gt;

&lt;p&gt;好了，话不多说，接下来就结合书和代码来学习。&lt;/p&gt;

&lt;h2 id=&#34;②第一章hints-and-tips&#34;&gt;②第一章Hints and Tips&lt;/h2&gt;

&lt;p&gt;略&lt;/p&gt;

&lt;h2 id=&#34;③第二章-about-accuracy&#34;&gt;③第二章 About accuracy&lt;/h2&gt;

&lt;p&gt;略&lt;/p&gt;

&lt;h2 id=&#34;④第三章-interpolation-插值&#34;&gt;④第三章 Interpolation 插值&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%A6&#34; target=&#34;_blank&#34;&gt;数学&lt;/a&gt;的&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90&#34; target=&#34;_blank&#34;&gt;数值分析&lt;/a&gt;领域中，&lt;strong&gt;内插&lt;/strong&gt;或称插值（英语：interpolation)是一种通过已知的、&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E9%9B%A2%E6%95%A3&#34; target=&#34;_blank&#34;&gt;离散&lt;/a&gt;的&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE&#34; target=&#34;_blank&#34;&gt;数据&lt;/a&gt;点，在范围内推求新数据点的过程或方法。求解&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E7%A7%91%E5%AD%A6&#34; target=&#34;_blank&#34;&gt;科学&lt;/a&gt;和&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%B7%A5%E7%A8%8B&#34; target=&#34;_blank&#34;&gt;工程&lt;/a&gt;的问题时，通常有许多数据点借由&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E9%87%87%E6%A0%B7&#34; target=&#34;_blank&#34;&gt;采样&lt;/a&gt;、&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%AE%9E%E9%AA%8C&#34; target=&#34;_blank&#34;&gt;实验&lt;/a&gt;等方法获得，这些数据可能代表了有限个数值函数，其中自变量的值。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;本章主要介绍了低阶等距节点牛顿插值和拉格朗日插值的应用。&lt;/p&gt;

&lt;h3 id=&#34;1-牛顿插值&#34;&gt;1. &lt;strong&gt;牛顿插值&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E7%89%9B%E9%A1%BF%E5%A4%9A%E9%A1%B9%E5%BC%8F&#34; target=&#34;_blank&#34;&gt;牛顿多项式&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%B7%AE%E5%88%86&#34; target=&#34;_blank&#34;&gt;差分&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;2-三点等距二阶差商的牛顿插值&#34;&gt;2. &lt;strong&gt;三点等距二阶差商的牛顿插值&lt;/strong&gt;&lt;/h3&gt;

&lt;h4 id=&#34;2-1-插值公式&#34;&gt;2.1  插值公式&lt;/h4&gt;

&lt;p&gt;二阶牛顿插值多项式为:
$N(x) = [y_0] + [y_0,y_1](x-x_0) + [y_0,y_1,y_2](x-x_0)(x-x_1)$，如下图
&lt;img src=&#34;https://wikimedia.org/api/rest_v1/media/math/render/svg/b8d0bfa61c4977eeaf3022de361f67dd5f4cb8a9&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;假设有三点$(x_0,y_0),(x_1,y_1),(x_2,y_2),x_0,x_1,x_2$等距(单位长度1) ,&lt;/p&gt;

&lt;p&gt;且$n$ 为插值因子,$x$距离$x_1$最近
\begin{align}
n&amp;amp;=(x-x_1)/单位长度\\&lt;br /&gt;
&amp;amp;=x-x1
\end{align}&lt;/p&gt;

&lt;p&gt;令 $a=y_1-y_0, b=y_2-y_1,c=b-a=y_0+y_2-2y_1$
则有：
\begin{align}
x-x_0 &amp;amp;= x-x_1 + 1\\&lt;br /&gt;
&amp;amp;= n + 1
\end{align}
\begin{align}
f(x) &amp;amp;= y_0 + a(x-x_0)+(c/(x_2-x_0))(x-x_0)(x-x_1)\\&lt;br /&gt;
&amp;amp;= y_0 + a(n+1) + 0.5c(n+1)n\\&lt;br /&gt;
&amp;amp;= y_1-a + an + a + 0.5n(cn+c)\\&lt;br /&gt;
&amp;amp;= y_1 + 0.5n(cn+b-a+2a)\\&lt;br /&gt;
&amp;amp;= y_1 + 0.5n(cn+a+b)\\&lt;br /&gt;
\end{align}&lt;/p&gt;

&lt;p&gt;即为算法中三点插值的公式.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;书中三点从1开始计数，公式为:$y_2+0.5n(cn+a+b)$&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Len3 allows second difference interpolation.
// 等距三点插值结构
type Len3 struct {
x1, x3             float64   //x1,x3分别为起始点和终止点，无需给出x2，因为等距
y                  []float64 //y为x1,x2,x3对应的值的序列
a, b, c            float64   //a=y2-y1, b=y3-y2, c=b-a=y3+y1-2y2
abSum, xSum, xDiff float64   //计数插值的中间变量
}

// NewLen3 prepares a Len3 object from a table of three rows of x and y values.
//
// X values must be equally spaced, so only the first and last are supplied.
// X1 must not equal x3.  Y must be a slice of three y values.
// 根据上述定义，创建三点插值结构
func NewLen3(x1, x3 float64, y []float64) (*Len3, error) {
if len(y) != 3 {
	return nil, ErrorNot3
}
if x3 == x1 {
	return nil, ErrorNoXRange
}
d := &amp;amp;Len3{
	x1: x1,
	x3: x3,
	y:  append([]float64{}, y...),
}
// differences. (3.1) p. 23
d.a = y[1] - y[0]
d.b = y[2] - y[1]
d.c = d.b - d.a
// other intermediate values
d.abSum = d.a + d.b
d.xSum = x3 + x1
d.xDiff = x3 - x1
return d, nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;考虑到实际问题中一般可能多于三点，此时只要选取目标点附近的三点即可，可用以下函数来自动构造&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Len3ForInterpolateX is a special purpose Len3 constructor.
//
// Like NewLen3, it takes a table of x and y values, but it is not limited
// to tables of 3 rows.  An X value is also passed that represents the
// interpolation target x value.  Len3ForInterpolateX will locate the
// appropriate three rows of the table for interpolating for x, and initialize
// the Len3 object for those rows.
//
//	x is the target for interpolation
//	x1 is the x value corresponding to the first y value of the table.
//	xn is the x value corresponding to the last y value of the table.
//	y is all y values in the table.  len(y) should be &amp;gt;= 3.
//
// 给定n个点，但是我们只需选取离目标点x最接近的三个点来做三点插值，
// 此时可用以下函数来自动选择最优三点，来构造三点插值
// 同样，前提是n个点等距，且与y一一对应
func Len3ForInterpolateX(x, x1, xn float64, y []float64) (*Len3, error) {
	if len(y) &amp;gt; 3 {
		interval := (xn - x1) / float64(len(y)-1)
		if interval == 0 {
			return nil, ErrorNoXRange
		}
		nearestX := int((x-x1)/interval + .5)
		if nearestX &amp;lt; 1 {
			nearestX = 1
		} else if nearestX &amp;gt; len(y)-2 {
			nearestX = len(y) - 2
		}
		y = y[nearestX-1 : nearestX+2]
		xn = x1 + float64(nearestX+1)*interval
		x1 = x1 + float64(nearestX-1)*interval
	}
	return NewLen3(x1, xn, y)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;插值因子 $n$ 为：目标点 $x$ 与 中间点 $x_2$之差除以实际步长&lt;br /&gt;
\begin{equation}
\because n = 2(x - x_2)/(x_3-x_1), x_2 = x_1 + (x_3-x_1)/2\\&lt;br /&gt;
\therefore n = [2x - (x_1+x_3)]/(x_3-x_1)\\&lt;br /&gt;
\end{equation}&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// InterpolateX interpolates for a given x value.
// 计算插值因子n，调用非严格插值计算
func (d *Len3) InterpolateX(x float64) (y float64) {
	n := (2*x - d.xSum) / d.xDiff
	return d.InterpolateN(n)
}

// InterpolateXStrict interpolates for a given x value,
// restricting x to the range x1 to x3 given to the constructor NewLen3.
// 计算插值因子n，调用严格插值计算
func (d *Len3) InterpolateXStrict(x float64) (y float64, err error) {
	n := (2*x - d.xSum) / d.xDiff
	y, err = d.InterpolateNStrict(n)
	if err == ErrorNOutOfRange {
		err = ErrorXOutOfRange
	}
	return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过调用三点插值公式获得目标插值，这里分为严格模式和非严格模式，&lt;/p&gt;

&lt;p&gt;所谓严格模式就是指目标点一定在三点的范围之内且必须离我们选择的三点的中间点最近，确保插值子$|n|&amp;lt;=1$；&lt;/p&gt;

&lt;p&gt;非严格模式就没有上述规定，可能目标点已经超出三点范围，得出的结果也相对不如严格模式精确。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// InterpolateN interpolates for a given interpolating factor n.
//
// This is interpolation formula (3.3)
//
// The interpolation factor n is x-x2 in units of the tabular x interval.
// (See Meeus p. 24.)
// 非严格插值计算，不用保证目标点插值因子绝对值小于等于1，
// 即不用保证离我们所选三点中点距离小于一个步长
func (d *Len3) InterpolateN(n float64) (y float64) {
	return d.y[1] + n*.5*(d.abSum+n*d.c)
}

// InterpolateNStrict interpolates for a given interpolating factor n.
//
// N is restricted to the range [-1..1] corresponding to the range x1 to x3
// given to the constructor NewLen3.
// 严格插值计算，必须保证目标点插值因子绝对值小于等于1，
// 即必须保证离我们所选三点中点距离小于一个步长
func (d *Len3) InterpolateNStrict(n float64) (y float64, err error) {
	if n &amp;lt; -1 || n &amp;gt; 1 {
		return 0, ErrorNOutOfRange
	}
	return d.InterpolateN(n), nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;2-2-极值&#34;&gt;2.2 &lt;strong&gt;极值&lt;/strong&gt;：&lt;/h4&gt;

&lt;p&gt;因为 $y_1 + 0.5n(cn+a+b)$是关于 $n$ 的二次函数($c \neq 0$时)，由二次函数的性质可知：&lt;/p&gt;

&lt;p&gt;当 $n=-(a+b)/(2c)$时，有极值$-(a+b)^2/(8c)$&lt;/p&gt;

&lt;p&gt;但是如果插值因子$|n|&amp;gt;1$,则无法取到(已超出插值函数的定义域)&lt;/p&gt;

&lt;p&gt;再由$n = [2x - (x_1+x_3)]/(x_3-x_1)$&lt;/p&gt;

&lt;p&gt;得出此时实际$x = [n(x_3-x_1)+(x_1+x_3)]/2$&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Extremum returns the x and y values at the extremum.
//
// Results are restricted to the range of the table given to the constructor
// NewLen3.
func (d *Len3) Extremum() (x, y float64, err error) {
	if d.c == 0 {
		return 0, 0, ErrorNoExtremum
	}
	n := d.abSum / (-2 * d.c) // (3.5), p. 25
	if n &amp;lt; -1 || n &amp;gt; 1 {
		return 0, 0, ErrorExtremumOutside
	}
	x = .5 * (d.xSum + d.xDiff*n)          // 根据实际步长得出极值点x
	y = d.y[1] - (d.abSum*d.abSum)/(8*d.c) // (3.4), p. 25
	return x, y, nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;2-3-根&#34;&gt;2.3 根&lt;/h4&gt;

&lt;p&gt;和普通方程类似，有时候我们需要求解插值函数的&amp;rdquo;根&amp;rdquo;，即 $y=0$所对应的插值点&lt;/p&gt;

&lt;p&gt;同样借助 $y=y_1+ 0.5n(cn+a+b)$,令 $y=0$&lt;/p&gt;

&lt;p&gt;得$n = -2y_1/(cn+a+b)$&lt;/p&gt;

&lt;p&gt;此时再利用迭代法求解近似根 $n_0$&lt;/p&gt;

&lt;p&gt;当插值曲线曲率比较大时，可采用以下修正量来进行迭代，直到满足精度要求为止&lt;/p&gt;

&lt;p&gt;$Δn_0 = -[ 2y_1 +n_0 (a+b+cn_0 ) ]/(a +b + 2cn_0 )$&lt;/p&gt;

&lt;p&gt;求解得到满足精度要求的 $n$ 后，再根据实际步长得出 $x$，即为&amp;rdquo;根&amp;rdquo;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Len3Zero finds a zero of the quadratic function represented by the table.
//
// That is, it returns an x value that yields y=0.
//
// Argument strong switches between two strategies for the estimation step.
// when iterating to converge on the zero.
//
// Strong=false specifies a quick and dirty estimate that works well
// for gentle curves, but can work poorly or fail on more dramatic curves.
//
// Strong=true specifies a more sophisticated and thus somewhat more
// expensive estimate.  However, if the curve has quick changes, This estimate
// will converge more reliably and in fewer steps, making it a better choice.
//
// Results are restricted to the range of the table given to the constructor
// NewLen3.
// strong 为考虑修正量的迭代方式，更为精确
func (d *Len3) Zero(strong bool) (x float64, err error) {
	var f iterFunc
	if strong {
		// (3.7), p. 27
		f = func(n0 float64) float64 {
			return n0 - (2*d.y[1]+n0*(d.abSum+d.c*n0))/(d.abSum+2*d.c*n0)
		}
	} else {
		// (3.6), p. 26
		f = func(n0 float64) float64 {
			return -2 * d.y[1] / (d.abSum + d.c*n0)
		}
	}
	n0, ok := iterate(0, f)
	if !ok {
		return 0, ErrorNoConverge
	}
	if n0 &amp;gt; 1 || n0 &amp;lt; -1 {
		return 0, ErrorZeroOutside
	}
	return .5 * (d.xSum + d.xDiff*n0), nil // success
}

type iterFunc func(n0 float64) (n1 float64)

func iterate(n0 float64, f iterFunc) (n1 float64, ok bool) {
	for limit := 0; limit &amp;lt; 50; limit++ {
		n1 = f(n0)
		if math.IsInf(n1, 0) || math.IsNaN(n1) {
			break // failure to converge
		}
		if math.Abs((n1-n0)/n0) &amp;lt; 1e-15 {
			return n1, true // success
		}
		n0 = n1
	}
	return 0, false // failure to converge
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3-五点等距四阶差商的牛顿插值&#34;&gt;3.  &lt;strong&gt;五点等距四阶差商的牛顿插值&lt;/strong&gt;&lt;/h3&gt;

&lt;h4 id=&#34;3-1-五点插值公式&#34;&gt;3.1 五点插值公式&lt;/h4&gt;

&lt;p&gt;五点和三点类似，这里直接给出公式，不再进行推导&lt;/p&gt;

&lt;p&gt;5点：$(x_1,y_1),(x_2,y_2),(x_3,y_3),(x_4,y_4),(x_5,y_5)$&lt;/p&gt;

&lt;p&gt;$y=y_3+ \frac {n} {2}(b+c)+\frac {n^2} {2}f+\frac{n(n^2-1)}{12}(h+j)+\frac {n^2(n^2-1)}{24k}$&lt;/p&gt;

&lt;p&gt;或者&lt;/p&gt;

&lt;p&gt;$y=y_3+n(\frac {b+c}{2}-\frac {h+j}{12})+n^2(\frac {f}{2}-\frac {k}{24})+n^3(\frac {h+j}{12})+n^4(\frac {k}{24})$&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Len5 allows fourth difference interpolation.
// 五点等距插值结构
type Len5 struct {
	x1, x5      float64   // x1为起始点，x5为终止点
	y           []float64 // y 为x1,x2,x3,x4,x5的一一映射
	a, b, c, d  float64   // a=y2-y1, b=y3-y2, c=y4-y3, d=y5-y4
	e, f, g     float64   // e=b-a, f=c-b, g=d-c
	h, j, k     float64   // h=f-e, j=g-f, k=j-h
	y3          float64   // y3为中间点的 y 值
	xSum, xDiff float64   // xSum=x1+x5, xDiff=x5-x1
	interpCoeff []float64 // 插值函数对应插值因子 n 的各项系数（0-4）
}

// NewLen5 prepares a Len5 object from a table of five rows of x and y values.
//
// X values must be equally spaced, so only the first and last are supplied.
// X1 must not equal x5.  Y must be a slice of five y values.
// 构造5点插值结构
func NewLen5(x1, x5 float64, y []float64) (*Len5, error) {
	if len(y) != 5 {
		return nil, ErrorNot5
	}
	if x5 == x1 {
		return nil, ErrorNoXRange
	}
	d := &amp;amp;Len5{
		x1: x1,
		x5: x5,
		y:  append([]float64{}, y...),
		y3: y[2],
	}
	// differences
	d.a = y[1] - y[0]
	d.b = y[2] - y[1]
	d.c = y[3] - y[2]
	d.d = y[4] - y[3]
	d.e = d.b - d.a
	d.f = d.c - d.b
	d.g = d.d - d.c
	d.h = d.f - d.e
	d.j = d.g - d.f
	d.k = d.j - d.h
	// other intermediate values
	d.xSum = x5 + x1
	d.xDiff = x5 - x1
	d.interpCoeff = []float64{ // (3.8) p. 28
		d.y3,
		(d.b+d.c)/2 - (d.h+d.j)/12,
		d.f/2 - d.k/24,
		(d.h + d.j) / 12,
		d.k / 24,
	}
	return d, nil
}
// InterpolateX interpolates for a given x value.
func (d *Len5) InterpolateX(x float64) (y float64) {
	n := (4*x - 2*d.xSum) / d.xDiff
	return d.InterpolateN(n)
}
// InterpolateXStrict interpolates for a given x value,
// restricting x to the range x1 to x5 given to the the constructor NewLen5.
func (d *Len5) InterpolateXStrict(x float64) (y float64, err error) {
	n := (4*x - 2*d.xSum) / d.xDiff
	y, err = d.InterpolateNStrict(n)
	if err == ErrorNOutOfRange {
		err = ErrorXOutOfRange
	}
	return
}
// InterpolateN interpolates for a given interpolating factor n.
//
// The interpolation factor n is x-x3 in units of the tabular x interval.
// (See Meeus p. 28.)
// Horner 为工具函数，求解多项式之和，interpCoeff为多项式系数
func (d *Len5) InterpolateN(n float64) (y float64) {
	return base.Horner(n, d.interpCoeff...)
}
// InterpolateNStrict interpolates for a given interpolating factor n.
//
// N is restricted to the range [-1..1].  This is only half the range given
// to the constructor NewLen5, but is the recommendation given on p. 31.
func (d *Len5) InterpolateNStrict(n float64) (y float64, err error) {
	if n &amp;lt; -1 || n &amp;gt; 1 {
		return 0, ErrorNOutOfRange
	}
	return base.Horner(n, d.interpCoeff...), nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;3-2-五点极值&#34;&gt;3.2 五点极值&lt;/h4&gt;

&lt;p&gt;函数的极值对应的插值因子 $n_m$ 可通过解以下方程得到：&lt;/p&gt;

&lt;p&gt;$n_m=\frac {6b+6c-h-j+3n_m^2(h+j)+2n_m^3k}{k-12f}$&lt;/p&gt;

&lt;p&gt;和上面的一样，我们可以执行迭代。首次，把 $n_m=0$代 入方程右边,迭代求得$n_m$&lt;/p&gt;

&lt;p&gt;当我们最后得到$n_m$后，$x_m=\frac {x_1+x_5}{2}+\frac {x_5-x_1}{4}n_m$&lt;/p&gt;

&lt;p&gt;再代入5点插值函数就可以获得极值&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Extremum returns the x and y values at the extremum.
//
// Results are restricted to the range of the table given to the constructor
// NewLen5.  (Meeus actually recommends restricting the range to one unit of
// the tabular interval, but that seems a little harsh.)
// 5点插值极值
func (d *Len5) Extremum() (x, y float64, err error) {
	// (3.9) p. 29
	nCoeff := []float64{
		6*(d.b+d.c) - d.h - d.j,
		0,
		3 * (d.h + d.k), // 不应该是 d.h+d.j 吗？
		2 * d.k,
	}
	den := d.k - 12*d.f
	if den == 0 {
		return 0, 0, ErrorExtremumOutside
	}
	n0, ok := iterate(0, func(n0 float64) float64 {
		return base.Horner(n0, nCoeff...) / den
	})
	if !ok {
		return 0, 0, ErrorNoConverge
	}
	if n0 &amp;lt; -2 || n0 &amp;gt; 2 {
		return 0, 0, ErrorExtremumOutside
	}
	x = .5*d.xSum + .25*d.xDiff*n0
	y = base.Horner(n0, d.interpCoeff...)
	return x, y, nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;3-3-五点求根&#34;&gt;3.3 五点求根&lt;/h4&gt;

&lt;p&gt;令$y=0$通过以下公式迭代求插值因子$n_0$,起始$n_0=0$&lt;/p&gt;

&lt;p&gt;$n_0=\frac {-24y_3+n_0^2(k-12f)-2n_0^3(h+j)-n_0^4k}{2(6b+6c-h-j)}$&lt;/p&gt;

&lt;p&gt;当曲率比较大时，同样可以加入修正&lt;/p&gt;

&lt;p&gt;$Δn_0 =-\frac {Mn_0^4+Nn_0^3+Pn_0^2+Qn_0+y_3}{4Mn_0^3+3Nn_0^2+2Pn_0+Q},$&lt;/p&gt;

&lt;p&gt;$(M=\frac{k}{24},N=\frac{h+j}{12},P=\frac{f}{2}-M,Q=\frac{b+c}{2}-N)$&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Len5Zero finds a zero of the quartic function represented by the table.
//
// That is, it returns an x value that yields y=0.
//
// Argument strong switches between two strategies for the estimation step.
// when iterating to converge on the zero.
//
// Strong=false specifies a quick and dirty estimate that works well
// for gentle curves, but can work poorly or fail on more dramatic curves.
//
// Strong=true specifies a more sophisticated and thus somewhat more
// expensive estimate.  However, if the curve has quick changes, This estimate
// will converge more reliably and in fewer steps, making it a better choice.
//
// Results are restricted to the range of the table given to the constructor
// NewLen5.
// strong 为带修正模式
func (d *Len5) Zero(strong bool) (x float64, err error) {
	var f iterFunc
	if strong {
		// (3.11), p. 29
		M := d.k / 24
		N := (d.h + d.j) / 12
		P := d.f/2 - M
		Q := (d.b+d.c)/2 - N
		numCoeff := []float64{d.y3, Q, P, N, M}
		denCoeff := []float64{Q, 2 * P, 3 * N, 4 * M}
		f = func(n0 float64) float64 {
			return n0 -
				base.Horner(n0, numCoeff...)/base.Horner(n0, denCoeff...)
		}
	} else {
		// (3.10), p. 29
		numCoeff := []float64{
			-24 * d.y3,
			0,
			d.k - 12*d.f,
			-2 * (d.h + d.j),
			-d.k,
		}
		den := 12*(d.b+d.c) - 2*(d.h+d.j)
		f = func(n0 float64) float64 {
			return base.Horner(n0, numCoeff...) / den
		}
	}
	n0, ok := iterate(0, f)
	if !ok {
		return 0, ErrorNoConverge
	}
	if n0 &amp;gt; 2 || n0 &amp;lt; -2 {
		return 0, ErrorZeroOutside
	}
	x = .5*d.xSum + .25*d.xDiff*n0
	return x, nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;4-四点等距中间点插值&#34;&gt;4. &lt;strong&gt;四点等距中间点插值&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;假设有$(x_1,y_1),(x_2,y_2),(x_3,y_3),(x_4,y_4)$
那么 $x_2$到 $x_3$ 之间的中点对应的函数值为：
$y = [ 9(y_2 +y_3 ) - y_1 - y_4 ] / 16$&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Len4Half interpolates a center value from a table of four rows.
func Len4Half(y []float64) (float64, error) {
	if len(y) != 4 {
		return 0, ErrorNot4
	}
	// (3.12) p. 32
	return (9*(y[1]+y[2]) - y[0] - y[3]) / 16, nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;5-横坐标不等间距插值-拉格朗日插值&#34;&gt;5. &lt;strong&gt;横坐标不等间距插值：拉格朗日插值&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;\begin{align}
y=y_1L_1+y_2L_2+\cdots+y_nL_n\\[2ex]
L_i = \prod_{
\substack{
i+1\\&lt;br /&gt;
i \neq j
}}^n
\frac {x-x_j}{x_i-x_j}
\end{align}&lt;/p&gt;

&lt;p&gt;上式是一个 $n-1$ 阶的多项式，这是利用 $y_1,y_2,\dots y_n$ 所能得到的唯一的一个 $n-1$ 阶多项式（注：多项式 插值具有唯一性）。但拉格朗日公式本身有个缺点，就是没有给出所需的数据点数量，以争取达到理想的精度。不过， 当我们希望表达一个函数的明确的插值多项式时，而$x$ 又远离插值节点，那么使用拉格朗日公式是有益的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Lagrange performs interpolation with unequally-spaced abscissae.
//
// Given a table of X and Y values, interpolate a new y value for argument x.
//
// X values in the table do not have to be equally spaced; they do not even
// have to be in order.  They must however, be distinct.
// table 中包含了 n 个点且xi 必须互异,x 为目标插值点
func Lagrange(x float64, table []struct{ X, Y float64 }) (y float64) {
	// method of BASIC program, p. 33.
	sum := 0.
	for i := range table {
		xi := table[i].X
		prod := 1.
		for j := range table {
			if i != j {
				xj := table[j].X
				prod *= (x - xj) / (xi - xj)
			}
		}
		sum += table[i].Y * prod
	}
	return sum
}
// LagrangePoly uses the formula of Lagrange to produce an interpolating
// polynomial.
//
// X values in the table do not have to be equally spaced; they do not even
// have to be in order.  They must however, be distinct.
//
// The returned polynomial will be of degree n-1 where n is the number of rows
// in the table.  It can be evaluated for x using common.Horner.
// 构造拉格朗日多项式，返回各项系数(0-n)
func LagrangePoly(table []struct{ X, Y float64 }) []float64 {
	// Method not fully described by Meeus, but needed for numerical solution
	// to Example 3.g.
	sum := make([]float64, len(table))
	prod := make([]float64, len(table))
	last := len(table) - 1
	for i := range table {
		xi := table[i].X
		yi := table[i].Y
		prod[last] = 1
		den := 1.
		n := last
		for j := range table {
			if i != j {
				xj := table[j].X
				prod[n-1] = prod[n] * -xj
				for k := n; k &amp;lt; last; k++ {
					prod[k] -= prod[k+1] * xj
				}
				n--
				den *= (xi - xj)
			}
		}
		for j, pj := range prod {
			sum[j] += yi * pj / den
		}
	}
	return sum
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Linux Centos 命令之 cp,rm,mv</title>
      <link>https://mooncaker816.github.io/2018/04/21/linux-centos-%E5%91%BD%E4%BB%A4%E4%B9%8B-cprmmv/</link>
      <pubDate>Sat, 21 Apr 2018 13:50:00 +0000</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/04/21/linux-centos-%E5%91%BD%E4%BB%A4%E4%B9%8B-cprmmv/</guid>
      <description>&lt;h2 id=&#34;cp-copy-拷贝目录-文件&#34;&gt;cp - copy 拷贝目录，文件&lt;/h2&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;usage&#34;&gt;Usage：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Usage: cp [OPTION]... [-T] SOURCE DEST
  or:  cp [OPTION]... SOURCE... DIRECTORY
  or:  cp [OPTION]... -t DIRECTORY SOURCE...
Copy SOURCE to DEST, or multiple SOURCE(s) to DIRECTORY.

Mandatory arguments to long options are mandatory for short options too.
  -a, --archive                same as -dR --preserve=all
      --attributes-only        don&#39;t copy the file data, just the attributes
      --backup[=CONTROL]       make a backup of each existing destination file
  -b                           like --backup but does not accept an argument
      --copy-contents          copy contents of special files when recursive
  -d                           same as --no-dereference --preserve=links
  -f, --force                  if an existing destination file cannot be
                                 opened, remove it and try again (this option
                                 is ignored when the -n option is also used)
  -i, --interactive            prompt before overwrite (overrides a previous -n
                                  option)
  -H                           follow command-line symbolic links in SOURCE
  -l, --link                   hard link files instead of copying
  -L, --dereference            always follow symbolic links in SOURCE
  -n, --no-clobber             do not overwrite an existing file (overrides
                                 a previous -i option)
  -P, --no-dereference         never follow symbolic links in SOURCE
  -p                           same as --preserve=mode,ownership,timestamps
      --preserve[=ATTR_LIST]   preserve the specified attributes (default:
                                 mode,ownership,timestamps), if possible
                                 additional attributes: context, links, xattr,
                                 all
  -c                           deprecated, same as --preserve=context
      --no-preserve=ATTR_LIST  don&#39;t preserve the specified attributes
      --parents                use full source file name under DIRECTORY
  -R, -r, --recursive          copy directories recursively
      --reflink[=WHEN]         control clone/CoW copies. See below
      --remove-destination     remove each existing destination file before
                                 attempting to open it (contrast with --force)
      --sparse=WHEN            control creation of sparse files. See below
      --strip-trailing-slashes  remove any trailing slashes from each SOURCE
                                 argument
  -s, --symbolic-link          make symbolic links instead of copying
  -S, --suffix=SUFFIX          override the usual backup suffix
  -t, --target-directory=DIRECTORY  copy all SOURCE arguments into DIRECTORY
  -T, --no-target-directory    treat DEST as a normal file
  -u, --update                 copy only when the SOURCE file is newer
                                 than the destination file or when the
                                 destination file is missing
  -v, --verbose                explain what is being done
  -x, --one-file-system        stay on this file system
  -Z                           set SELinux security context of destination
                                 file to default type
      --context[=CTX]          like -Z, or if CTX is specified then set the
                                 SELinux or SMACK security context to CTX
      --help     display this help and exit
      --version  output version information and exit

By default, sparse SOURCE files are detected by a crude heuristic and the
corresponding DEST file is made sparse as well.  That is the behavior
selected by --sparse=auto.  Specify --sparse=always to create a sparse DEST
file whenever the SOURCE file contains a long enough sequence of zero bytes.
Use --sparse=never to inhibit creation of sparse files.

When --reflink[=always] is specified, perform a lightweight copy, where the
data blocks are copied only when modified.  If this is not possible the copy
fails, or if --reflink=auto is specified, fall back to a standard copy.

The backup suffix is &#39;~&#39;, unless set with --suffix or SIMPLE_BACKUP_SUFFIX.
The version control method may be selected via the --backup option or through
the VERSION_CONTROL environment variable.  Here are the values:

  none, off       never make backups (even if --backup is given)
  numbered, t     make numbered backups
  existing, nil   numbered if numbered backups exist, simple otherwise
  simple, never   always make simple backups

As a special case, cp makes a backup of SOURCE when the force and backup
options are given and SOURCE and DEST are the same name for an existing,
regular file.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;常用选项&#34;&gt;常用选项：&lt;/h3&gt;

&lt;p&gt;-a / -p：连同文件属性一起复制（用户组属性受 id 权限限制）&lt;/p&gt;

&lt;p&gt;-i（interactive）：覆盖询问&lt;/p&gt;

&lt;p&gt;-r（recursive）： 用于目录的递归复制&lt;/p&gt;

&lt;p&gt;-u （update）：source 比 destination 新才复制&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;覆盖询问&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@78063f0fe2e8 ~]# cp ~/.bashrc /tmp/bashrc
[root@78063f0fe2e8 ~]# cp -i ~/.bashrc /tmp/bashrc
cp: overwrite ‘/tmp/bashrc’? y
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;连同文件属性一起复制&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@78063f0fe2e8 ~]# cd /tmp
[root@78063f0fe2e8 tmp]# cp /var/log/wtmp .
[root@78063f0fe2e8 tmp]# ls -l /var/log/wtmp wtmp
-rw-rw-r-- 1 root utmp 0 Apr  2 18:38 /var/log/wtmp
-rw-r--r-- 1 root root 0 Apr 21 06:23 wtmp
[root@78063f0fe2e8 tmp]# cp -a /var/log/wtmp wtmp2
[root@78063f0fe2e8 tmp]# ls -l /var/log/wtmp wtmp2
-rw-rw-r-- 1 root utmp 0 Apr  2 18:38 /var/log/wtmp
-rw-rw-r-- 1 root utmp 0 Apr  2 18:38 wtmp2
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;用于目录的递归复制&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@78063f0fe2e8 tmp]# cp /etc /tmp
cp: omitting directory ‘/etc’
[root@78063f0fe2e8 tmp]# cp -r /etc /tmp
&lt;/code&gt;&lt;/pre&gt;

&lt;asciinema-player src=&#34;https://mooncaker816.github.io/asciinema/177529&#34; cols=&#34;80&#34; rows=&#34;24&#34;&gt;&lt;/asciinema-player&gt;

&lt;h2 id=&#34;rm-remove-删除目录或文件&#34;&gt;rm - remove 删除目录或文件&lt;/h2&gt;

&lt;h3 id=&#34;usage-1&#34;&gt;Usage：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Usage: rm [OPTION]... FILE...
Remove (unlink) the FILE(s).

  -f, --force           ignore nonexistent files and arguments, never prompt
  -i                    prompt before every removal
  -I                    prompt once before removing more than three files, or
                          when removing recursively; less intrusive than -i,
                          while still giving protection against most mistakes
      --interactive[=WHEN]  prompt according to WHEN: never, once (-I), or
                          always (-i); without WHEN, prompt always
      --one-file-system  when removing a hierarchy recursively, skip any
                          directory that is on a file system different from
                          that of the corresponding command line argument
      --no-preserve-root  do not treat &#39;/&#39; specially
      --preserve-root   do not remove &#39;/&#39; (default)
  -r, -R, --recursive   remove directories and their contents recursively
  -d, --dir             remove empty directories
  -v, --verbose         explain what is being done
      --help     display this help and exit
      --version  output version information and exit

By default, rm does not remove directories.  Use the --recursive (-r or -R)
option to remove each listed directory, too, along with all of its contents.

To remove a file whose name starts with a &#39;-&#39;, for example &#39;-foo&#39;,
use one of these commands:
  rm -- -foo

  rm ./-foo

Note that if you use rm to remove a file, it might be possible to recover
some of its contents, given sufficient expertise and/or time.  For greater
assurance that the contents are truly unrecoverable, consider using shred.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;常用选项-1&#34;&gt;常用选项：&lt;/h3&gt;

&lt;p&gt;-f（force）：忽略不存在的文件&lt;/p&gt;

&lt;p&gt;-i（interactive）：询问删除&lt;/p&gt;

&lt;p&gt;-r（recursive）：递归删除&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sh-4.2# cd /tmp
sh-4.2# ls
bashrc		  mingle1  tmpxq2sylvo-ascii.cast  wtmp2
ks-script-hE5IPf  test1    wtmp			   yum.log
sh-4.2# rm -i bashrc
rm: remove regular file ‘bashrc’? y
sh-4.2# ls
ks-script-hE5IPf  mingle1  test1  tmpxq2sylvo-ascii.cast  wtmp	wtmp2  yum.log
sh-4.2# rmdir mingle1
sh-4.2# rmdir test1
rmdir: failed to remove ‘test1’: Directory not empty
sh-4.2# rm -rf test1
sh-4.2# ls
ks-script-hE5IPf  tmpxq2sylvo-ascii.cast  wtmp	wtmp2  yum.log
sh-4.2# touch ./-aaa-
sh-4.2# ls
-aaa-  ks-script-hE5IPf  tmpxq2sylvo-ascii.cast  wtmp  wtmp2  yum.log
sh-4.2# rm -f -aaa-
rm: invalid option -- &#39;a&#39;
Try &#39;rm ./-aaa-&#39; to remove the file ‘-aaa-’.
Try &#39;rm --help&#39; for more information.
sh-4.2# rm -f ./-aaa-
sh-4.2# ls
ks-script-hE5IPf  tmpxq2sylvo-ascii.cast  wtmp	wtmp2  yum.log
sh-4.2# rm -rf wtmp*
sh-4.2# ls
ks-script-hE5IPf  tmpxq2sylvo-ascii.cast  yum.log
&lt;/code&gt;&lt;/pre&gt;

&lt;asciinema-player src=&#34;https://mooncaker816.github.io/asciinema/177530&#34; cols=&#34;80&#34; rows=&#34;24&#34;&gt;&lt;/asciinema-player&gt;

&lt;h2 id=&#34;mv-move-移动文件或目录-更名&#34;&gt;mv - move 移动文件或目录，更名&lt;/h2&gt;

&lt;h3 id=&#34;usage-2&#34;&gt;Usage：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Usage: mv [OPTION]... [-T] SOURCE DEST
  or:  mv [OPTION]... SOURCE... DIRECTORY
  or:  mv [OPTION]... -t DIRECTORY SOURCE...
Rename SOURCE to DEST, or move SOURCE(s) to DIRECTORY.

Mandatory arguments to long options are mandatory for short options too.
      --backup[=CONTROL]       make a backup of each existing destination file
  -b                           like --backup but does not accept an argument
  -f, --force                  do not prompt before overwriting
  -i, --interactive            prompt before overwrite
  -n, --no-clobber             do not overwrite an existing file
If you specify more than one of -i, -f, -n, only the final one takes effect.
      --strip-trailing-slashes  remove any trailing slashes from each SOURCE
                                 argument
  -S, --suffix=SUFFIX          override the usual backup suffix
  -t, --target-directory=DIRECTORY  move all SOURCE arguments into DIRECTORY
  -T, --no-target-directory    treat DEST as a normal file
  -u, --update                 move only when the SOURCE file is newer
                                 than the destination file or when the
                                 destination file is missing
  -v, --verbose                explain what is being done
  -Z, --context                set SELinux security context of destination
                                 file to default type
      --help     display this help and exit
      --version  output version information and exit

The backup suffix is &#39;~&#39;, unless set with --suffix or SIMPLE_BACKUP_SUFFIX.
The version control method may be selected via the --backup option or through
the VERSION_CONTROL environment variable.  Here are the values:

  none, off       never make backups (even if --backup is given)
  numbered, t     make numbered backups
  existing, nil   numbered if numbered backups exist, simple otherwise
  simple, never   always make simple backups
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;常用选项-2&#34;&gt;常用选项：&lt;/h3&gt;

&lt;p&gt;-f（force）：不询问直接覆盖&lt;/p&gt;

&lt;p&gt;-i（ interactive）： 询问覆盖&lt;/p&gt;

&lt;p&gt;-u（update）：source 新于 destination 才会 move&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;普通移动&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sh-4.2# cd /tmp
sh-4.2# cp ~/.bashrc bashrc1
sh-4.2# cp ~/.bashrc bashrc2
sh-4.2# ls
bashrc1  bashrc2  ks-script-hE5IPf  tmp8u627nsx-ascii.cast  yum.log
sh-4.2# mkdir mvtest
sh-4.2# ls
bashrc1  bashrc2  ks-script-hE5IPf  mvtest  tmp8u627nsx-ascii.cast  yum.log
sh-4.2# mv bashrc1 bashrc2 mvtest
sh-4.2# ls
ks-script-hE5IPf  mvtest  tmp8u627nsx-ascii.cast  yum.log
sh-4.2# cd mvtest
sh-4.2# ls
bashrc1  bashrc2
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;重命名&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sh-4.2# cd ..
sh-4.2# ls
ks-script-hE5IPf  mvtest  tmp8u627nsx-ascii.cast  yum.log
sh-4.2# mv mvtest mvtest2
sh-4.2# ls
ks-script-hE5IPf  mvtest2  tmp8u627nsx-ascii.cast  yum.log
&lt;/code&gt;&lt;/pre&gt;

&lt;asciinema-player src=&#34;https://mooncaker816.github.io/asciinema/177531&#34; cols=&#34;80&#34; rows=&#34;24&#34;&gt;&lt;/asciinema-player&gt;</description>
    </item>
    
    <item>
      <title>Linux Centos 命令之 touch,cat,tac,more,less</title>
      <link>https://mooncaker816.github.io/2018/04/21/linux-centos-%E5%91%BD%E4%BB%A4%E4%B9%8B-touchcattacmoreless/</link>
      <pubDate>Sat, 21 Apr 2018 13:50:00 +0000</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/04/21/linux-centos-%E5%91%BD%E4%BB%A4%E4%B9%8B-touchcattacmoreless/</guid>
      <description>&lt;h2 id=&#34;touch-创建空文件-修改时间&#34;&gt;touch -  创建空文件，修改时间&lt;/h2&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;usage&#34;&gt;Usage：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Usage: touch [OPTION]... FILE...
Update the access and modification times of each FILE to the current time.

A FILE argument that does not exist is created empty, unless -c or -h
is supplied.

A FILE argument string of - is handled specially and causes touch to
change the times of the file associated with standard output.

Mandatory arguments to long options are mandatory for short options too.
  -a                     change only the access time
  -c, --no-create        do not create any files
  -d, --date=STRING      parse STRING and use it instead of current time
  -f                     (ignored)
  -h, --no-dereference   affect each symbolic link instead of any referenced
                         file (useful only on systems that can change the
                         timestamps of a symlink)
  -m                     change only the modification time
  -r, --reference=FILE   use this file&#39;s times instead of current time
  -t STAMP               use [[CC]YY]MMDDhhmm[.ss] instead of current time
      --time=WORD        change the specified time:
                           WORD is access, atime, or use: equivalent to -a
                           WORD is modify or mtime: equivalent to -m
      --help     display this help and exit
      --version  output version information and exit

Note that the -d and -t options accept different time-date formats.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mtime ：modification time （默认）&lt;/p&gt;

&lt;p&gt;文件的内容被修改时会更新&lt;/p&gt;

&lt;p&gt;ctime ：status time&lt;/p&gt;

&lt;p&gt;文件的属性或权限被修改时会更新&lt;/p&gt;

&lt;p&gt;atime ： access time&lt;/p&gt;

&lt;p&gt;文件的内容被读取时会更新&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@78063f0fe2e8 etc]# ls -l login.defs
-rw-r--r-- 1 root root 2028 Nov  4  2016 login.defs
[root@78063f0fe2e8 etc]# ls -l login.defs --time=atime
-rw-r--r-- 1 root root 2028 Nov  4  2016 login.defs
[root@78063f0fe2e8 etc]# ls -l login.defs --time=ctime
-rw-r--r-- 1 root root 2028 Apr 20 14:19 login.defs
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;常用选项&#34;&gt;常用选项：&lt;/h3&gt;

&lt;p&gt;-a（access） ：仅修改访问时间&lt;/p&gt;

&lt;p&gt;-c（）：仅修改文件时间，若文件不存在则&lt;strong&gt;不&lt;/strong&gt;创建新文件&lt;/p&gt;

&lt;p&gt;-m（modification）： 仅修改 mtime&lt;/p&gt;

&lt;p&gt;-t （time）：想要修改的时间[YYMMDDhhmm]&lt;/p&gt;

&lt;p&gt;-d（date）：修改的日期&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;新建空文件&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sh-4.2# cd /tmp
sh-4.2# touch testtouch
sh-4.2# ls -l testtouch
-rw-r--r-- 1 root root 0 Apr 21 07:52 testtouch
sh-4.2# ls -l testtouch --time=atime
-rw-r--r-- 1 root root 0 Apr 21 07:52 testtouch
sh-4.2# ls -l testtouch --time=ctime
-rw-r--r-- 1 root root 0 Apr 21 07:52 testtouch
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;修改时间&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sh-4.2# cp -a ~/.bashrc bashrc
sh-4.2# ls -l bashrc
-rw-r--r-- 1 root root 176 Dec 29  2013 bashrc
sh-4.2# ls -l bashrc --time=atime
-rw-r--r-- 1 root root 176 Dec 29  2013 bashrc
sh-4.2# ls -l bashrc --time=ctime
-rw-r--r-- 1 root root 176 Apr 21 07:53 bashrc
sh-4.2# touch -d &amp;quot;2 days ago&amp;quot; bashrc
sh-4.2# ls -l bashrc
-rw-r--r-- 1 root root 176 Apr 19 07:55 bashrc
sh-4.2# ls -l bashrc --time=atime
-rw-r--r-- 1 root root 176 Apr 19 07:55 bashrc
sh-4.2# ls -l bashrc --time=ctime
-rw-r--r-- 1 root root 176 Apr 21 07:55 bashrc
sh-4.2# touch -t 1801011000 bashrc
sh-4.2# ls -l bashrc
-rw-r--r-- 1 root root 176 Jan  1 10:00 bashrc
sh-4.2# ls -l bashrc --time=ctime
-rw-r--r-- 1 root root 176 Apr 21 07:57 bashrc
sh-4.2# ls -l bashrc --time=atime
-rw-r--r-- 1 root root 176 Jan  1 10:00 bashrc
&lt;/code&gt;&lt;/pre&gt;

&lt;asciinema-player src=&#34;https://mooncaker816.github.io/asciinema/177538&#34; cols=&#34;80&#34; rows=&#34;24&#34;&gt;&lt;/asciinema-player&gt;

&lt;h2 id=&#34;cat-concatenate-浏览文件&#34;&gt;cat - concatenate 浏览文件&lt;/h2&gt;

&lt;h3 id=&#34;usage-1&#34;&gt;Usage：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Usage: cat [OPTION]... [FILE]...
Concatenate FILE(s), or standard input, to standard output.

  -A, --show-all           equivalent to -vET
  -b, --number-nonblank    number nonempty output lines, overrides -n
  -e                       equivalent to -vE
  -E, --show-ends          display $ at end of each line
  -n, --number             number all output lines
  -s, --squeeze-blank      suppress repeated empty output lines
  -t                       equivalent to -vT
  -T, --show-tabs          display TAB characters as ^I
  -u                       (ignored)
  -v, --show-nonprinting   use ^ and M- notation, except for LFD and TAB
      --help     display this help and exit
      --version  output version information and exit

With no FILE, or when FILE is -, read standard input.

Examples:
  cat f - g  Output f&#39;s contents, then standard input, then g&#39;s contents.
  cat        Copy standard input to standard output.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;常用选项-1&#34;&gt;常用选项：&lt;/h3&gt;

&lt;p&gt;-A（All）：显示所有，包括特殊字符，等价于-vET&lt;/p&gt;

&lt;p&gt;-v（verbose）：列出看不出来的特殊字符&lt;/p&gt;

&lt;p&gt;-T（Tab）：将 Tab 按键以^I 显示出来&lt;/p&gt;

&lt;p&gt;-b（blank）：列出行号，空白行不标号&lt;/p&gt;

&lt;p&gt;-n（number）：列出行号，空白行也有&lt;/p&gt;

&lt;p&gt;-E（End）：将结尾的断行字符$显示出来&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sh-4.2# cat /etc/issue
\S
Kernel \r on an \m

sh-4.2# cat -n /etc/issue
     1	\S
     2	Kernel \r on an \m
     3
sh-4.2# cat -b /etc/issue
     1	\S
     2	Kernel \r on an \m

sh-4.2# cd /tmp
sh-4.2# ls
bashrc		  mvtest2    testtouch		     yum.log
ks-script-hE5IPf  test.conf  tmpk3saal44-ascii.cast
sh-4.2# cat -A test.conf
^Ihello$
this is a test file only...$
sh-4.2# cat -An test.conf
     1	^Ihello$
     2	this is a test file only...$
&lt;/code&gt;&lt;/pre&gt;

&lt;asciinema-player src=&#34;https://mooncaker816.github.io/asciinema/177541&#34; cols=&#34;80&#34; rows=&#34;24&#34;&gt;&lt;/asciinema-player&gt;

&lt;h2 id=&#34;tac-反向-cat&#34;&gt;tac - 反向 cat&lt;/h2&gt;

&lt;h3 id=&#34;usage-2&#34;&gt;Usage：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Usage: tac [OPTION]... [FILE]...
Write each FILE to standard output, last line first.
With no FILE, or when FILE is -, read standard input.

Mandatory arguments to long options are mandatory for short options too.
  -b, --before             attach the separator before instead of after
  -r, --regex              interpret the separator as a regular expression
  -s, --separator=STRING   use STRING as the separator instead of newline
      --help     display this help and exit
      --version  output version information and exit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;tac 没有 -n 选项&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@78063f0fe2e8 ~]# tac /etc/issue

Kernel \r on an \m
\S
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;nl-添加行号显示文件&#34;&gt;nl - 添加行号显示文件&lt;/h2&gt;

&lt;h3 id=&#34;usage-3&#34;&gt;Usage：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Usage: nl [OPTION]... [FILE]...
Write each FILE to standard output, with line numbers added.
With no FILE, or when FILE is -, read standard input.

Mandatory arguments to long options are mandatory for short options too.
  -b, --body-numbering=STYLE      use STYLE for numbering body lines
  -d, --section-delimiter=CC      use CC for separating logical pages
  -f, --footer-numbering=STYLE    use STYLE for numbering footer lines
  -h, --header-numbering=STYLE    use STYLE for numbering header lines
  -i, --line-increment=NUMBER     line number increment at each line
  -l, --join-blank-lines=NUMBER   group of NUMBER empty lines counted as one
  -n, --number-format=FORMAT      insert line numbers according to FORMAT
  -p, --no-renumber               do not reset line numbers at logical pages
  -s, --number-separator=STRING   add STRING after (possible) line number
  -v, --starting-line-number=NUMBER  first line number on each logical page
  -w, --number-width=NUMBER       use NUMBER columns for line numbers
      --help     display this help and exit
      --version  output version information and exit

By default, selects -v1 -i1 -l1 -sTAB -w6 -nrn -hn -bt -fn.  CC are
two delimiter characters for separating logical pages, a missing
second character implies :.  Type \\ for \.  STYLE is one of:

  a         number all lines
  t         number only nonempty lines
  n         number no lines
  pBRE      number only lines that contain a match for the basic regular
            expression, BRE

FORMAT is one of:

  ln   left justified, no leading zeros
  rn   right justified, no leading zeros
  rz   right justified, leading zeros
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@78063f0fe2e8 ~]# nl /etc/issue
     1	\S
     2	Kernel \r on an \m

[root@78063f0fe2e8 ~]# nl /etc/issue -b a
     1	\S
     2	Kernel \r on an \m
     3
[root@78063f0fe2e8 ~]# nl /etc/issue -b a -n rz
000001	\S
000002	Kernel \r on an \m
000003
[root@78063f0fe2e8 ~]# nl /etc/issue -b a -n ln
1     	\S
2     	Kernel \r on an \m
3
[root@78063f0fe2e8 ~]# nl /etc/issue -b a -n rn
     1	\S
     2	Kernel \r on an \m
     3
[root@78063f0fe2e8 ~]# nl /etc/issue -b a -n rn -w 3
  1	\S
  2	Kernel \r on an \m
  3
[root@78063f0fe2e8 ~]# nl /etc/issue -b a -n rz -w 3
001	\S
002	Kernel \r on an \m
003
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;more-一页一页显示文件内容&#34;&gt;more - 一页一页显示文件内容&lt;/h2&gt;

&lt;h3 id=&#34;usage-4&#34;&gt;Usage：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;more: unknown option -help
Usage: more [options] file...

Options:
  -d        display help instead of ring bell
  -f        count logical, rather than screen lines
  -l        suppress pause after form feed
  -p        do not scroll, clean screen and display text
  -c        do not scroll, display text and clean line ends
  -u        suppress underlining
  -s        squeeze multiple blank lines into one
  -NUM      specify the number of lines per screenful
  +NUM      display file beginning from line number NUM
  +/STRING  display file beginning from search string match
  -V        output version information and exit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;空格：向下翻一页&lt;/p&gt;

&lt;p&gt;Enter：向下一行&lt;/p&gt;

&lt;p&gt;/字符串：向下查询字符串&lt;/p&gt;

&lt;p&gt;q：退出查看&lt;/p&gt;

&lt;p&gt;b：往回翻页&lt;/p&gt;

&lt;h2 id=&#34;less-more-的进阶&#34;&gt;less - more 的进阶&lt;/h2&gt;

&lt;p&gt;略&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Linux Centos 命令之 mkdir,rmdir,pwd,cd</title>
      <link>https://mooncaker816.github.io/2018/04/21/linux-centos-%E5%91%BD%E4%BB%A4%E4%B9%8B-mkdirrmdirpwdcd/</link>
      <pubDate>Sat, 21 Apr 2018 12:50:00 +0000</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/04/21/linux-centos-%E5%91%BD%E4%BB%A4%E4%B9%8B-mkdirrmdirpwdcd/</guid>
      <description>&lt;h2 id=&#34;mkdir-make-directory-创建目录&#34;&gt;mkdir - make directory 创建目录&lt;/h2&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;usage&#34;&gt;Usage：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Usage: mkdir [OPTION]... DIRECTORY...
Create the DIRECTORY(ies), if they do not already exist.

Mandatory arguments to long options are mandatory for short options too.
  -m, --mode=MODE   set file mode (as in chmod), not a=rwx - umask
  -p, --parents     no error if existing, make parent directories as needed
  -v, --verbose     print a message for each created directory
  -Z                   set SELinux security context of each created directory
                         to the default type
      --context[=CTX]  like -Z, or if CTX is specified then set the SELinux
                         or SMACK security context to CTX
      --help     display this help and exit
      --version  output version information and exit
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;常用选项&#34;&gt;常用选项：&lt;/h3&gt;

&lt;p&gt;-m（mode）：按指定权限创建目录，若没有该选项则按 umask 的默认设置创建&lt;/p&gt;

&lt;p&gt;-p（parent）：递归创建所有目录&lt;/p&gt;

&lt;p&gt;-v（verbose）： 打印出每个创建的目录&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;递归创建目录&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@78063f0fe2e8 ~]# mkdir -pv /tmp/test1/test2/test3
mkdir: created directory ‘/tmp/test1’
mkdir: created directory ‘/tmp/test1/test2’
mkdir: created directory ‘/tmp/test1/test2/test3’
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;目录的权限由 umask 决定&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@78063f0fe2e8 ~]# umask
0022
[root@78063f0fe2e8 ~]# umask -S
u=rwx,g=rx,o=rx
[root@78063f0fe2e8 ~]# ls /tmp/test1 -l
total 4
drwxr-xr-x 3 root root 4096 Apr 21 05:01 test2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;022是指对应三个组别分别要减去的权限分数，777-022=755=（rwxr-xr-x）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;指定创建权限为711的目录&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@78063f0fe2e8 ~]# mkdir /tmp/mingle -m 711
[root@78063f0fe2e8 ~]# ls /tmp/mingle -ld
drwx--x--x 2 root root 4096 Apr 21 05:10 /tmp/mingle
&lt;/code&gt;&lt;/pre&gt;

&lt;asciinema-player src=&#34;https://mooncaker816.github.io/asciinema/177520&#34; cols=&#34;80&#34; rows=&#34;24&#34;&gt;&lt;/asciinema-player&gt;

&lt;h2 id=&#34;rmdir-remove-empty-directory-删除空目录&#34;&gt;rmdir - remove empty directory 删除空目录&lt;/h2&gt;

&lt;h3 id=&#34;usage-1&#34;&gt;Usage：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Usage: rmdir [OPTION]... DIRECTORY...
Remove the DIRECTORY(ies), if they are empty.

      --ignore-fail-on-non-empty
                  ignore each failure that is solely because a directory
                    is non-empty
  -p, --parents   remove DIRECTORY and its ancestors; e.g., &#39;rmdir -p a/b/c&#39; is
                    similar to &#39;rmdir a/b/c a/b a&#39;
  -v, --verbose   output a diagnostic for every directory processed
      --help     display this help and exit
      --version  output version information and exit
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;常用选项-1&#34;&gt;常用选项：&lt;/h3&gt;

&lt;p&gt;-p（parent）：递归删除空目录&lt;/p&gt;

&lt;p&gt;-v（verbose）：打印出每个删除的目录&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@78063f0fe2e8 ~]# mkdir -p /tmp/test1/test2/test3
[root@78063f0fe2e8 ~]# rmdir -pv /tmp/test1/test2/test3
rmdir: removing directory, ‘/tmp/test1/test2/test3’
rmdir: removing directory, ‘/tmp/test1/test2’
rmdir: removing directory, ‘/tmp/test1’
rmdir: removing directory, ‘/tmp’
rmdir: failed to remove directory ‘/tmp’: Directory not empty
&lt;/code&gt;&lt;/pre&gt;

&lt;asciinema-player src=&#34;https://mooncaker816.github.io/asciinema/177521&#34; cols=&#34;80&#34; rows=&#34;24&#34;&gt;&lt;/asciinema-player&gt;

&lt;h2 id=&#34;pwd-print-working-directory-打印当前路径&#34;&gt;pwd - print working directory 打印当前路径&lt;/h2&gt;

&lt;h3 id=&#34;usage-2&#34;&gt;Usage：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pwd [-LP]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;常用选项-2&#34;&gt;常用选项：&lt;/h3&gt;

&lt;p&gt;-L（link）：若为软链，则显示软链路径(默认)&lt;/p&gt;

&lt;p&gt;-P（）：若为软链，则显示为实际指向路径&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@78063f0fe2e8 mail]# ls -ld /var/mail
lrwxrwxrwx 1 root root 10 Apr  2 18:38 /var/mail -&amp;gt; spool/mail
[root@78063f0fe2e8 mail]# pwd
/var/mail
[root@78063f0fe2e8 mail]# pwd -P
/var/spool/mail
[root@78063f0fe2e8 mail]# pwd -L
/var/mail
&lt;/code&gt;&lt;/pre&gt;

&lt;asciinema-player src=&#34;https://mooncaker816.github.io/asciinema/177522&#34; cols=&#34;80&#34; rows=&#34;24&#34;&gt;&lt;/asciinema-player&gt;

&lt;h2 id=&#34;cd-change-directory-切换当前路径&#34;&gt;cd - change directory 切换当前路径&lt;/h2&gt;

&lt;h3 id=&#34;常用目录&#34;&gt;常用目录：&lt;/h3&gt;

&lt;p&gt;&amp;rdquo;.&amp;rdquo; ： 当前目录&lt;/p&gt;

&lt;p&gt;&amp;rdquo;..&amp;rdquo; ：上级目录&lt;/p&gt;

&lt;p&gt;&amp;rdquo;-&amp;rdquo; ：前一个工作目录&lt;/p&gt;

&lt;p&gt;&amp;ldquo;~&amp;ldquo;,&amp;rdquo; &amp;ldquo; ：当前用户所在的主目录
&amp;ldquo;~account&amp;rdquo; ：account 这个用户所在的主目录&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@78063f0fe2e8 mail]# cd
[root@78063f0fe2e8 ~]#
[root@78063f0fe2e8 ~]# cd /tmp
[root@78063f0fe2e8 tmp]# cd
[root@78063f0fe2e8 ~]# cd ~root
[root@78063f0fe2e8 ~]# cd -
/root
[root@78063f0fe2e8 ~]# cd ..
[root@78063f0fe2e8 /]# cd -
/root
[root@78063f0fe2e8 ~]# cd /var/mail
[root@78063f0fe2e8 mail]#
&lt;/code&gt;&lt;/pre&gt;

&lt;asciinema-player src=&#34;https://mooncaker816.github.io/asciinema/177524&#34; cols=&#34;80&#34; rows=&#34;24&#34;&gt;&lt;/asciinema-player&gt;</description>
    </item>
    
    <item>
      <title>Linux Centos 命令之 ls</title>
      <link>https://mooncaker816.github.io/2018/04/21/linux-centos-%E5%91%BD%E4%BB%A4%E4%B9%8B-ls/</link>
      <pubDate>Sat, 21 Apr 2018 11:50:00 +0000</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/04/21/linux-centos-%E5%91%BD%E4%BB%A4%E4%B9%8B-ls/</guid>
      <description>&lt;h2 id=&#34;ls-list-列出文件与目录&#34;&gt;ls - list 列出文件与目录&lt;/h2&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;usage&#34;&gt;Usage：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Usage: ls [OPTION]... [FILE]...
List information about the FILEs (the current directory by default).
Sort entries alphabetically if none of -cftuvSUX nor --sort is specified.

Mandatory arguments to long options are mandatory for short options too.
  -a, --all                  do not ignore entries starting with .
  -A, --almost-all           do not list implied . and ..
      --author               with -l, print the author of each file
  -b, --escape               print C-style escapes for nongraphic characters
      --block-size=SIZE      scale sizes by SIZE before printing them; e.g.,
                               &#39;--block-size=M&#39; prints sizes in units of
                               1,048,576 bytes; see SIZE format below
  -B, --ignore-backups       do not list implied entries ending with ~
  -c                         with -lt: sort by, and show, ctime (time of last
                               modification of file status information);
                               with -l: show ctime and sort by name;
                               otherwise: sort by ctime, newest first
  -C                         list entries by columns
      --color[=WHEN]         colorize the output; WHEN can be &#39;never&#39;, &#39;auto&#39;,
                               or &#39;always&#39; (the default); more info below
  -d, --directory            list directories themselves, not their contents
  -D, --dired                generate output designed for Emacs&#39; dired mode
  -f                         do not sort, enable -aU, disable -ls --color
  -F, --classify             append indicator (one of */=&amp;gt;@|) to entries
      --file-type            likewise, except do not append &#39;*&#39;
      --format=WORD          across -x, commas -m, horizontal -x, long -l,
                               single-column -1, verbose -l, vertical -C
      --full-time            like -l --time-style=full-iso
  -g                         like -l, but do not list owner
      --group-directories-first
                             group directories before files;
                               can be augmented with a --sort option, but any
                               use of --sort=none (-U) disables grouping
  -G, --no-group             in a long listing, don&#39;t print group names
  -h, --human-readable       with -l, print sizes in human readable format
                               (e.g., 1K 234M 2G)
      --si                   likewise, but use powers of 1000 not 1024
  -H, --dereference-command-line
                             follow symbolic links listed on the command line
      --dereference-command-line-symlink-to-dir
                             follow each command line symbolic link
                               that points to a directory
      --hide=PATTERN         do not list implied entries matching shell PATTERN
                               (overridden by -a or -A)
      --indicator-style=WORD  append indicator with style WORD to entry names:
                               none (default), slash (-p),
                               file-type (--file-type), classify (-F)
  -i, --inode                print the index number of each file
  -I, --ignore=PATTERN       do not list implied entries matching shell PATTERN
  -k, --kibibytes            default to 1024-byte blocks for disk usage
  -l                         use a long listing format
  -L, --dereference          when showing file information for a symbolic
                               link, show information for the file the link
                               references rather than for the link itself
  -m                         fill width with a comma separated list of entries
  -n, --numeric-uid-gid      like -l, but list numeric user and group IDs
  -N, --literal              print raw entry names (don&#39;t treat e.g. control
                               characters specially)
  -o                         like -l, but do not list group information
  -p, --indicator-style=slash
                             append / indicator to directories
  -q, --hide-control-chars   print ? instead of nongraphic characters
      --show-control-chars   show nongraphic characters as-is (the default,
                               unless program is &#39;ls&#39; and output is a terminal)
  -Q, --quote-name           enclose entry names in double quotes
      --quoting-style=WORD   use quoting style WORD for entry names:
                               literal, locale, shell, shell-always, c, escape
  -r, --reverse              reverse order while sorting
  -R, --recursive            list subdirectories recursively
  -s, --size                 print the allocated size of each file, in blocks
  -S                         sort by file size
      --sort=WORD            sort by WORD instead of name: none (-U), size (-S),
                               time (-t), version (-v), extension (-X)
      --time=WORD            with -l, show time as WORD instead of default
                               modification time: atime or access or use (-u)
                               ctime or status (-c); also use specified time
                               as sort key if --sort=time
      --time-style=STYLE     with -l, show times using style STYLE:
                               full-iso, long-iso, iso, locale, or +FORMAT;
                               FORMAT is interpreted like in &#39;date&#39;; if FORMAT
                               is FORMAT1&amp;lt;newline&amp;gt;FORMAT2, then FORMAT1 applies
                               to non-recent files and FORMAT2 to recent files;
                               if STYLE is prefixed with &#39;posix-&#39;, STYLE
                               takes effect only outside the POSIX locale
  -t                         sort by modification time, newest first
  -T, --tabsize=COLS         assume tab stops at each COLS instead of 8
  -u                         with -lt: sort by, and show, access time;
                               with -l: show access time and sort by name;
                               otherwise: sort by access time
  -U                         do not sort; list entries in directory order
  -v                         natural sort of (version) numbers within text
  -w, --width=COLS           assume screen width instead of current value
  -x                         list entries by lines instead of by columns
  -X                         sort alphabetically by entry extension
  -1                         list one file per line

SELinux options:

  --lcontext                 Display security context.   Enable -l. Lines
                             will probably be too wide for most displays.
  -Z, --context              Display security context so it fits on most
                             displays.  Displays only mode, user, group,
                             security context and file name.
  --scontext                 Display only security context and file name.
      --help     display this help and exit
      --version  output version information and exit

SIZE is an integer and optional unit (example: 10M is 10*1024*1024).  Units
are K, M, G, T, P, E, Z, Y (powers of 1024) or KB, MB, ... (powers of 1000).

Using color to distinguish file types is disabled both by default and
with --color=never.  With --color=auto, ls emits color codes only when
standard output is connected to a terminal.  The LS_COLORS environment
variable can change the settings.  Use the dircolors command to set it.

Exit status:
 0  if OK,
 1  if minor problems (e.g., cannot access subdirectory),
 2  if serious trouble (e.g., cannot access command-line argument).
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;常用选项&#34;&gt;常用选项：&lt;/h3&gt;

&lt;p&gt;-a：列出所有文件&lt;/p&gt;

&lt;p&gt;-d：列出目录本身，而不是其内容&lt;/p&gt;

&lt;p&gt;-h：以适合人类阅读的格式输出（size 大小转为 K，M，G 等）&lt;/p&gt;

&lt;p&gt;-i：打印出每个文件的 inode编号&lt;/p&gt;

&lt;p&gt;inode 参考：&lt;a href=&#34;http://www.ruanyifeng.com/blog/2011/12/inode.html&#34; target=&#34;_blank&#34;&gt;http://www.ruanyifeng.com/blog/2011/12/inode.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;-l：以长格式显示完整信息&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;drwxr-xr-x   2 root root  4096 Nov  5  2016 srv
dr-xr-xr-x  13 root root     0 Apr 21 03:02 sys
drwxrwxrwt   1 root root  4096 Apr 20 21:17 tmp
drwxr-xr-x   1 root root  4096 Apr  2 18:38 usr
drwxr-xr-x   1 root root  4096 Apr  2 18:38 var
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;drwxr-xr-x:&lt;/p&gt;

&lt;p&gt;常用文件类型：（-普通文件，d 目录，l 软链接文件）&lt;/p&gt;

&lt;p&gt;权限设置：rwxr-xr-x (拥有者权限 rwx，所属组权限r-x，其他权限r-x)&lt;/p&gt;

&lt;asciinema-player src=&#34;https://mooncaker816.github.io/asciinema/177514&#34; cols=&#34;80&#34; rows=&#34;24&#34;&gt;&lt;/asciinema-player&gt;</description>
    </item>
    
    <item>
      <title>Go 标准库学习</title>
      <link>https://mooncaker816.github.io/2018/01/14/go-%E6%A0%87%E5%87%86%E5%BA%93%E5%AD%A6%E4%B9%A0/</link>
      <pubDate>Sun, 14 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/01/14/go-%E6%A0%87%E5%87%86%E5%BA%93%E5%AD%A6%E4%B9%A0/</guid>
      <description>&lt;h3 id=&#34;bytes和strings函数比对&#34;&gt;bytes和strings函数比对&lt;/h3&gt;

&lt;p&gt;&lt;/p&gt;

&lt;table&gt;&lt;tr&gt;&lt;td&gt;bytes&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;strings&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;函数签名&lt;/td&gt;&lt;td&gt;功能&lt;/td&gt;&lt;td&gt;函数签名&lt;/td&gt;&lt;td&gt;功能&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func explode(s []byte, n int) [][]byte&lt;/td&gt;&lt;td&gt;以每个utf8字符为单位，将前n个字符对应的[]byte型组成新的slice返回&lt;/td&gt;&lt;td&gt;func explode(s string, n int) []string&lt;/td&gt;&lt;td&gt;以每个utf8字符为单位，将前n个字符对应的string型组成新的slice返回&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func countGeneric(s, sep []byte) int&lt;/td&gt;&lt;td&gt;返回s中有几个sep，若sep为空，则返回sutf8.RuneCount(s) + 1&lt;/td&gt;&lt;td&gt;func countGeneric(s, substr string) int&lt;/td&gt;&lt;td&gt;返回s中有几个substr，若substr为空，则返回sutf8.RuneCount(s) + 1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func Contains(b, subslice []byte) bool&lt;/td&gt;&lt;td&gt;b中是否含有subslice&lt;/td&gt;&lt;td&gt;func Contains(s, substr string) bool&lt;/td&gt;&lt;td&gt;s中是否含有substr&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func ContainsAny(b []byte, chars string) bool&lt;/td&gt;&lt;td&gt;b中是否含有字符串chars&lt;/td&gt;&lt;td&gt;func ContainsAny(s, chars string) bool&lt;/td&gt;&lt;td&gt;s中是否含有字符串chars中的任意一个unicode字符&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func ContainsRune(b []byte, r rune) bool&lt;/td&gt;&lt;td&gt;b中是否含有rune r&lt;/td&gt;&lt;td&gt;func ContainsRune(s string, r rune) bool&lt;/td&gt;&lt;td&gt;s中是否含有rune r&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func indexBytePortable(s []byte, c byte) int（并没有导出也没有用于内部）&lt;/td&gt;&lt;td&gt;返回s中c的位置，若不含有c，则返回-1&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func LastIndex(s, sep []byte) int&lt;/td&gt;&lt;td&gt;返回s中最后一个sep的位置，若sep为空，返回s的长度，若不含sep，则返回-1&lt;/td&gt;&lt;td&gt;func LastIndex(s, substr string) int&lt;/td&gt;&lt;td&gt;返回s中最后一个substr的位置，若substr为空，返回s的长度，若不含substr，则返回-1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func LastIndexByte(s []byte, c byte) int&lt;/td&gt;&lt;td&gt;返回最后一个c的位置，没有则返回-1&lt;/td&gt;&lt;td&gt;func LastIndexByte(s string, c byte) int&lt;/td&gt;&lt;td&gt;返回最后一个c的位置，没有则返回-1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func IndexRune(s []byte, r rune) int&lt;/td&gt;&lt;td&gt;返回第一个r的位置，如果r无法解码为utf8又不是\uFFFD，认为没找到返回-1&lt;/td&gt;&lt;td&gt;func IndexRune(s string, r rune) int&lt;/td&gt;&lt;td&gt;返回第一个r的位置，如果r无法解码为utf8又不是\uFFFD，认为没找到返回-1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func IndexAny(s []byte, chars string) int&lt;/td&gt;&lt;td&gt;返回chars中任意一个unicode字符在s中第一次出现的位置&lt;/td&gt;&lt;td&gt;func IndexAny(s, chars string) int&lt;/td&gt;&lt;td&gt;返回chars中任意一个unicode字符在s中第一次出现的位置&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func LastIndexAny(s []byte, chars string) int&lt;/td&gt;&lt;td&gt;返回chars中任意一个unicode字符在s中最后一次出现的位置&lt;/td&gt;&lt;td&gt;func LastIndexAny(s, chars string) int&lt;/td&gt;&lt;td&gt;返回chars中任意一个unicode字符在s中最后一次出现的位置&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func genSplit(s, sep []byte, sepSave, n int) [][]byte&lt;/td&gt;&lt;td&gt;按sep划分s，返回前n个组成的slice，每个slice中sep的保留位数有sepSave决定，n小于0时，返回所有划分组成的slice&lt;/td&gt;&lt;td&gt;func genSplit(s, sep string, sepSave, n int) []string&lt;/td&gt;&lt;td&gt;按sep划分s，返回前n个组成的slice，每个slice中sep的保留位数有sepSave决定，n小于0时，返回所有划分组成的slice&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func SplitN(s, sep []byte, n int) [][]byte&lt;/td&gt;&lt;td&gt;按sep划分s，返回前n个划分的slice组成的slice，每个划分的slice不包含sep，n小于0返回所有划分组成的slice&lt;/td&gt;&lt;td&gt;func SplitN(s, sep string, n int) []string&lt;/td&gt;&lt;td&gt;按sep划分s，返回前n个划分的string组成的slice，每个划分的string不包含sep，n小于0返回所有划分组成的slice&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func SplitAfterN(s, sep []byte, n int) [][]byte&lt;/td&gt;&lt;td&gt;按sep划分s，返回前n个划分的slice组成slice，每个划分包含sep&lt;/td&gt;&lt;td&gt;func SplitAfterN(s, sep string, n int) []string&lt;/td&gt;&lt;td&gt;按sep划分s，返回前n个划分的string组成slice，每个划分包含sep&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func Split(s, sep []byte) [][]byte&lt;/td&gt;&lt;td&gt;返回所有的由sep划分的slice组成的slice，每个划分不包含sep&lt;/td&gt;&lt;td&gt;func Split(s, sep string) []string&lt;/td&gt;&lt;td&gt;返回所有的由sep划分的string组成的slice，每个划分不包含sep&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func SplitAfter(s, sep []byte) [][]byte&lt;/td&gt;&lt;td&gt;返回所有的由sep划分的slice组成的slice，每个划分包含sep&lt;/td&gt;&lt;td&gt;func SplitAfter(s, sep string) []string&lt;/td&gt;&lt;td&gt;返回所有的由sep划分的string组成的slice，每个划分包含sep&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func Fields(s []byte) [][]byte&lt;/td&gt;&lt;td&gt;按unicode.IsSpace划分s（所有连续的whitespce当成一个sep），返回所有的划分组成的slice&lt;/td&gt;&lt;td&gt;func Fields(s string) []string&lt;/td&gt;&lt;td&gt;按unicode.IsSpace划分s（所有连续的whitespce当成一个sep），返回所有的划分组成的slice&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func FieldsFunc(s []byte, f func(rune) bool) [][]byte&lt;/td&gt;&lt;td&gt;如果s中对应的一个rune满足f，则这个rune就是s的一个分隔符，返回s中所有分隔符划分的子slice的slice&lt;/td&gt;&lt;td&gt;func FieldsFunc(s string, f func(rune) bool) []string&lt;/td&gt;&lt;td&gt;如果s中对应的一个rune满足f，则这个rune就是s的一个分隔符，返回s中所有分隔符划分的子string的slice&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func Join(s [][]byte, sep []byte) []byte&lt;/td&gt;&lt;td&gt;将s中的元素用sep拼接起来，返回一个新的slice&lt;/td&gt;&lt;td&gt;func Join(a []string, sep string) string &lt;/td&gt;&lt;td&gt;将s中的元素用sep拼接起来，返回一个新的string&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func HasPrefix(s, prefix []byte) bool&lt;/td&gt;&lt;td&gt;判断s是否以prefix开头&lt;/td&gt;&lt;td&gt;func HasPrefix(s, prefix string) bool&lt;/td&gt;&lt;td&gt;判断s是否以prefix开头&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func HasSuffix(s, suffix []byte) bool&lt;/td&gt;&lt;td&gt;判断s是否以suffix结尾&lt;/td&gt;&lt;td&gt;func HasSuffix(s, suffix string) bool&lt;/td&gt;&lt;td&gt;判断s是否以suffix结尾&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func Map(mapping func(r rune) rune, s []byte) []byte&lt;/td&gt;&lt;td&gt;将s中对应的每个rune字符作用映射f得到新的字符，再将这些字符转为utf8存储在一个新的slice中返回&lt;/td&gt;&lt;td&gt;func Map(mapping func(rune) rune, s string) string&lt;/td&gt;&lt;td&gt;将s中对应的每个rune字符作用映射f得到新的字符，再将这些字符存储在一个新的string中返回&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func Repeat(b []byte, count int) []byte&lt;/td&gt;&lt;td&gt;重复b count次，返回新的slice&lt;/td&gt;&lt;td&gt;func Repeat(s string, count int) string&lt;/td&gt;&lt;td&gt;重复s count次，返回新的string&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func ToUpper(s []byte) []byte&lt;/td&gt;&lt;td&gt;转为大写&lt;/td&gt;&lt;td&gt;func ToUpper(s string) string&lt;/td&gt;&lt;td&gt;转为大写&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func ToLower(s []byte) []byte &lt;/td&gt;&lt;td&gt;转为小写&lt;/td&gt;&lt;td&gt;func ToLower(s string) string&lt;/td&gt;&lt;td&gt;转为小写&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func ToTitle(s []byte) []byte&lt;/td&gt;&lt;td&gt;转为Title&lt;/td&gt;&lt;td&gt;func ToTitle(s string) string&lt;/td&gt;&lt;td&gt;转为Title&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func ToUpperSpecial(c unicode.SpecialCase, s []byte) []byte&lt;/td&gt;&lt;td&gt;只将SpecialCase范围里的字符转为大写&lt;/td&gt;&lt;td&gt;func ToUpperSpecial(c unicode.SpecialCase, s string) string&lt;/td&gt;&lt;td&gt;只将SpecialCase范围里的字符转为大写&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func ToLowerSpecial(c unicode.SpecialCase, s []byte) []byte&lt;/td&gt;&lt;td&gt;只将SpecialCase范围里的字符转为小写&lt;/td&gt;&lt;td&gt;func ToLowerSpecial(c unicode.SpecialCase, s string) string&lt;/td&gt;&lt;td&gt;只将SpecialCase范围里的字符转为小写&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func ToTitleSpecial(c unicode.SpecialCase, s []byte) []byte&lt;/td&gt;&lt;td&gt;只将SpecialCase范围里的字符转为Title&lt;/td&gt;&lt;td&gt;func ToTitleSpecial(c unicode.SpecialCase, s string) string&lt;/td&gt;&lt;td&gt;只将SpecialCase范围里的字符转为Title&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func isSeparator(r rune) bool&lt;/td&gt;&lt;td&gt;r是否可以作为一个词（unicode）的分隔符&lt;br&gt;ascii码，数字，字母，下划线不可以&lt;br&gt;非ascii码，unicode的数字，字母不可以，剩下其他认为是unicode的space可以&lt;/td&gt;&lt;td&gt;func isSeparator(r rune) bool&lt;/td&gt;&lt;td&gt;r是否可以作为一个词（unicode）的分隔符&lt;br&gt;ascii码，数字，字母，下划线不可以&lt;br&gt;非ascii码，unicode的数字，字母不可以，剩下其他认为是unicode的space可以&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func Title(s []byte) []byte &lt;/td&gt;&lt;td&gt;调用Map，s中非词分隔符的字符转换为Title&lt;/td&gt;&lt;td&gt;func Title(s string) string&lt;/td&gt;&lt;td&gt;调用Map，s中非词分隔符的字符转换为Title&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func TrimLeftFunc(s []byte, f func(r rune) bool) []byte&lt;/td&gt;&lt;td&gt;以左边起第一个不满足f的rune对应的utf8码开始到s末尾的子slice&lt;/td&gt;&lt;td&gt;func TrimLeftFunc(s string, f func(rune) bool) string&lt;/td&gt;&lt;td&gt;以左边起第一个不满足f的rune对应的utf8码开始到s末尾的子string&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func TrimRightFunc(s []byte, f func(r rune) bool) []byte&lt;/td&gt;&lt;td&gt;以s头开始到从右边起第一个不满足f的rune对应的utf8码为终点的子slice&lt;/td&gt;&lt;td&gt;func TrimRightFunc(s string, f func(rune) bool) string&lt;/td&gt;&lt;td&gt;以s头开始到从右边起第一个不满足f的rune对应的utf8码为终点的子string&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func TrimFunc(s []byte, f func(r rune) bool) []byte &lt;/td&gt;&lt;td&gt;去掉左边和去掉右边的结合体&lt;/td&gt;&lt;td&gt;func TrimFunc(s string, f func(rune) bool) string&lt;/td&gt;&lt;td&gt;去掉左边和去掉右边的结合体&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func TrimPrefix(s, prefix []byte) []byte&lt;/td&gt;&lt;td&gt;去掉prefix后的子slice&lt;/td&gt;&lt;td&gt;func TrimPrefix(s, prefix string) string&lt;/td&gt;&lt;td&gt;去掉prefix后的子string&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func TrimSuffix(s, suffix []byte) []byte&lt;/td&gt;&lt;td&gt;去掉suffix后的子slice&lt;/td&gt;&lt;td&gt;func TrimSuffix(s, suffix string) string&lt;/td&gt;&lt;td&gt;去掉suffix后的子string&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func IndexFunc(s []byte, f func(r rune) bool) int&lt;/td&gt;&lt;td&gt;返回s中第一个满足f的rune字符对应的utf8码的起始位置&lt;/td&gt;&lt;td&gt;func IndexFunc(s string, f func(rune) bool) int&lt;/td&gt;&lt;td&gt;返回s中第一个满足f的rune字符对应的utf8码的起始位置&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func LastIndexFunc(s []byte, f func(r rune) bool) int&lt;/td&gt;&lt;td&gt;返回s中最后一个满足f的rune字符对应的utf8码的起始位置&lt;/td&gt;&lt;td&gt;func LastIndexFunc(s string, f func(rune) bool) int&lt;/td&gt;&lt;td&gt;返回s中最后一个满足f的rune字符对应的utf8码的起始位置&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func indexFunc(s []byte, f func(r rune) bool, truth bool)&lt;/td&gt;&lt;td&gt;返回s中第一个在f作用下得到truth的rune字符对应的utf8码的起始位置&lt;/td&gt;&lt;td&gt;func indexFunc(s string, f func(rune) bool, truth bool) int&lt;/td&gt;&lt;td&gt;返回s中第一个在f作用下得到truth的rune字符对应的utf8码的起始位置&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func lastIndexFunc(s []byte, f func(r rune) bool, truth bool) int&lt;/td&gt;&lt;td&gt;返回s中最后一个在f作用下得到truth的rune字符对应的utf8码的起始位置&lt;/td&gt;&lt;td&gt;func lastIndexFunc(s string, f func(rune) bool, truth bool) int&lt;/td&gt;&lt;td&gt;返回s中最后一个在f作用下得到truth的rune字符对应的utf8码的起始位置&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func makeASCIISet(chars string) (as asciiSet, ok bool)&lt;/td&gt;&lt;td&gt;返回s中碰到非ascii码之前所有ascii码的集合，以及s中是否都是ascii码&lt;br&gt;可以把asciiSet看成是一个32字节长度的值，其中低16字节共计128位表达128个ascii码[0,127]，高16字节用来比对非ascii码&lt;br&gt;具体存储：&lt;br&gt;asciiSet是一个含有8个元素的数组，每个元素有32位，共计256位，&lt;br&gt;其中元素的位置保存了该字符（uint8）对应的高3位（c&gt;&gt;5）的信息，&lt;br&gt;元素的内容保存了每个字符低5位（1 &lt;&lt; uint(c&amp;31)）的信息，5位最大是31（11111），&lt;br&gt;刚好uint32的每一位可以代表在相同高3位的情况下，所有字符的低5位情况，&lt;br&gt;这样就可以用数组的前4个元素完整表达128个ascii了&lt;/td&gt;&lt;td&gt;func makeASCIISet(chars string) (as asciiSet, ok bool)&lt;/td&gt;&lt;td&gt;返回s中碰到非ascii码之前所有ascii码的集合，以及s中是否都是ascii码&lt;br&gt;可以把asciiSet看成是一个32字节长度的值，其中低16字节共计128位表达128个ascii码[0,127]，高16字节用来比对非ascii码&lt;br&gt;具体存储：&lt;br&gt;asciiSet是一个含有8个元素的数组，每个元素有32位，共计256位，&lt;br&gt;其中元素的位置保存了该字符（uint8）对应的高3位（c&gt;&gt;5）的信息，&lt;br&gt;元素的内容保存了每个字符低5位（1 &lt;&lt; uint(c&amp;31)）的信息，5位最大是31（11111），&lt;br&gt;刚好uint32的每一位可以代表在相同高3位的情况下，所有字符的低5位情况，&lt;br&gt;这样就可以用数组的前4个元素完整表达128个ascii了&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func (as *asciiSet) contains(c byte) bool&lt;/td&gt;&lt;td&gt;c是否在as中&lt;/td&gt;&lt;td&gt;func (as *asciiSet) contains(c byte) bool&lt;/td&gt;&lt;td&gt;c是否在as中&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func makeCutsetFunc(cutset string) func(r rune) bool&lt;/td&gt;&lt;td&gt;返回一个判断r是否在cutset字符串中的函数&lt;br&gt;若为单字节字符串，则返回一个直接比较r是否和cutset相同的函数&lt;br&gt;根据cutset创建一个ascii码的集合，&lt;br&gt;如果全是ascii，则返回一个用来判断r是否在上述集合中的函数&lt;br&gt;如果含有非ascii，则返回一个逐一循环cutset中rune字符，判断r是否其中之一的函数&lt;/td&gt;&lt;td&gt;func makeCutsetFunc(cutset string) func(rune) bool&lt;/td&gt;&lt;td&gt;返回一个判断r是否在cutset字符串中的函数&lt;br&gt;若为单字节字符串，则返回一个直接比较r是否和cutset相同的函数&lt;br&gt;根据cutset创建一个ascii码的集合，&lt;br&gt;如果全是ascii，则返回一个用来判断r是否在上述集合中的函数&lt;br&gt;如果含有非ascii，则返回一个逐一循环cutset中rune字符，判断r是否其中之一的函数&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func Trim(s []byte, cutset string) []byte&lt;/td&gt;&lt;td&gt;将s左右两端连续属于cutset的rune字符去除，保留中间的子slice&lt;/td&gt;&lt;td&gt;func Trim(s string, cutset string) string&lt;/td&gt;&lt;td&gt;将s左右两端连续属于cutset的rune字符去除，保留中间的子string&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func TrimLeft(s []byte, cutset string) []byte&lt;/td&gt;&lt;td&gt;将s左边连续属于cutset的rune字符去除，返回剩下的子slice&lt;/td&gt;&lt;td&gt;func TrimLeft(s string, cutset string) string&lt;/td&gt;&lt;td&gt;将s左边连续属于cutset的rune字符去除，返回剩下的子string&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func TrimRight(s []byte, cutset string) []byte&lt;/td&gt;&lt;td&gt;将s右边连续属于cutset的rune字符去除，返回剩下的子slice&lt;/td&gt;&lt;td&gt;func TrimRight(s string, cutset string) string&lt;/td&gt;&lt;td&gt;将s右边连续属于cutset的rune字符去除，返回剩下的子string&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func TrimSpace(s []byte) []byte&lt;/td&gt;&lt;td&gt;去除s左右两端的whitespce，保留剩下的子slice&lt;/td&gt;&lt;td&gt;func TrimSpace(s string) string&lt;/td&gt;&lt;td&gt;去除s左右两端的whitespce，保留剩下的子string&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func Runes(s []byte) []rune&lt;/td&gt;&lt;td&gt;返回s对应的rune类型的slice&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func Replace(s, old, new []byte, n int) []byte&lt;/td&gt;&lt;td&gt;将s中前n个old替换成new，返回一个新的slice，n为负数或者n&gt;old个数时，替换所有old&lt;/td&gt;&lt;td&gt;func Replace(s, old, new string, n int) string&lt;/td&gt;&lt;td&gt;将s中前n个old替换成new，返回一个新的string，n为负数或者n&gt;old个数时，替换所有old&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func EqualFold(s, t []byte) bool&lt;/td&gt;&lt;td&gt;判断s和t在不区分大小写（包括unicode case）的情况下是否相等&lt;/td&gt;&lt;td&gt;func EqualFold(s, t string) bool&lt;/td&gt;&lt;td&gt;判断s和t在不区分大小写（包括unicode case）的情况下是否相等&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func indexRabinKarp(s, sep []byte) int&lt;/td&gt;&lt;td&gt;返回第一个sep在s中的位置&lt;br&gt;Rabin-Karp字符串匹配算法和前面介绍的《朴素字符串匹配算法》类似，也是对应每一个字符进行比较，不同的是Rabin-Karp采用了把字符进行预处理，也就是对每个字符进行对应进制数并取模运算，类似于通过某种函数计算其函数值，比较的是每个字符的函数值。预处理时间O(m)，匹配时间是O((n-m+1)m)。&lt;br&gt;Rabin-Karp算法的思想：&lt;br&gt;假设待匹配字符串的长度为M，目标字符串的长度为N（N&gt;M）；&lt;br&gt;首先计算待匹配字符串的hash值，计算目标字符串前M个字符的hash值；&lt;br&gt;比较前面计算的两个hash值，比较次数N-M+1：&lt;br&gt;若hash值不相等，则继续计算目标字符串的下一个长度为M的字符子串的hash值&lt;br&gt;若hash值相同，则需要使用朴素算法再次判断是否为相同的字串；&lt;/td&gt;&lt;td&gt;func indexRabinKarp(s, substr string) int&lt;/td&gt;&lt;td&gt;返回第一个sep在s中的位置&lt;br&gt;Rabin-Karp字符串匹配算法和前面介绍的《朴素字符串匹配算法》类似，也是对应每一个字符进行比较，不同的是Rabin-Karp采用了把字符进行预处理，也就是对每个字符进行对应进制数并取模运算，类似于通过某种函数计算其函数值，比较的是每个字符的函数值。预处理时间O(m)，匹配时间是O((n-m+1)m)。&lt;br&gt;Rabin-Karp算法的思想：&lt;br&gt;假设待匹配字符串的长度为M，目标字符串的长度为N（N&gt;M）；&lt;br&gt;首先计算待匹配字符串的hash值，计算目标字符串前M个字符的hash值；&lt;br&gt;比较前面计算的两个hash值，比较次数N-M+1：&lt;br&gt;若hash值不相等，则继续计算目标字符串的下一个长度为M的字符子串的hash值&lt;br&gt;若hash值相同，则需要使用朴素算法再次判断是否为相同的字串；&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;func hashStr(sep []byte) (uint32, uint32)&lt;/td&gt;&lt;td&gt;计算sep的hash，用于Rabin-Karp算法&lt;/td&gt;&lt;td&gt;func hashStr(sep string) (uint32, uint32)&lt;/td&gt;&lt;td&gt;计算sep的hash，用于Rabin-Karp算法&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;func hashStrRev(sep string) (uint32, uint32)&lt;/td&gt;&lt;td&gt;计算reverse(sep)的hash，用于Rabin-Karp算法&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</description>
    </item>
    
    <item>
      <title>The Go Programming Language Ex（11）</title>
      <link>https://mooncaker816.github.io/2018/01/04/the-go-programming-language-ex11/</link>
      <pubDate>Thu, 04 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/01/04/the-go-programming-language-ex11/</guid>
      <description>&lt;h3 id=&#34;ex-9-1&#34;&gt;Ex 9.1&lt;/h3&gt;

&lt;p&gt;Add a function Withdraw(amount int) bool to the gopl.io/ch9/bank1 program. The result should indicate whether the transaction succeeded or failed due to insufﬁcient funds. The message sent to the monitor goroutine must contain both the amount to withdraw and a new channel over which the monitor goroutine can send the boolean result back to Withdraw.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Copyright © 2016 Alan A. A. Donovan &amp;amp; Brian W. Kernighan.
// License: https://creativecommons.org/licenses/by-nc-sa/4.0/

package bank_test

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;testing&amp;quot;

	&amp;quot;The_Go_Programming_Language_Exercises/CH9/ex9.1&amp;quot;
)

func TestBank(t *testing.T) {
	done := make(chan struct{})

	// Alice
	go func() {
		bank.Deposit(200)
		fmt.Println(&amp;quot;=&amp;quot;, bank.Balance())
		done &amp;lt;- struct{}{}
	}()

	// Bob
	go func() {
		bank.Deposit(100)
		done &amp;lt;- struct{}{}
	}()

	go func() {
		fmt.Println(bank.Withdraw(500))
		done &amp;lt;- struct{}{}
	}()

	// Wait for both transactions.
	&amp;lt;-done
	&amp;lt;-done
	&amp;lt;-done

	if got, want := bank.Balance(), 300; got != want {
		t.Errorf(&amp;quot;Balance = %d, want %d&amp;quot;, got, want)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ex-9-2&#34;&gt;Ex 9.2&lt;/h3&gt;

&lt;p&gt;Rewrite the PopCount example from Section 2.6.2 so that it initializes the l table using sync.Once the ﬁrst time it is needed. (Realistically, the cost of synchronization would be prohibitive for a small and highly optimized function like PopCount.)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Copyright © 2016 Alan A. A. Donovan &amp;amp; Brian W. Kernighan.
// License: https://creativecommons.org/licenses/by-nc-sa/4.0/

// See page 45.

// (Package doc comment intentionally malformed to demonstrate golint.)
//!+
package popcount

import &amp;quot;sync&amp;quot;

// pc[i] is the population count of i.
var pc [256]byte
var loadpcOnce sync.Once

//func init() {
//	for i := range pc {
//		pc[i] = pc[i/2] + byte(i&amp;amp;1)
//	}
//}

// PopCount returns the population count (number of set bits) of x.
func PopCount(x uint64) int {
	loadpcOnce.Do(loadpc)
	return int(pc[byte(x&amp;gt;&amp;gt;(0*8))] +
		pc[byte(x&amp;gt;&amp;gt;(1*8))] +
		pc[byte(x&amp;gt;&amp;gt;(2*8))] +
		pc[byte(x&amp;gt;&amp;gt;(3*8))] +
		pc[byte(x&amp;gt;&amp;gt;(4*8))] +
		pc[byte(x&amp;gt;&amp;gt;(5*8))] +
		pc[byte(x&amp;gt;&amp;gt;(6*8))] +
		pc[byte(x&amp;gt;&amp;gt;(7*8))])
}

func loadpc() {
	for i := range pc {
		pc[i] = pc[i/2] + byte(i&amp;amp;1)
	}
}

//!-

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ex-9-3&#34;&gt;Ex 9.3&lt;/h3&gt;

&lt;p&gt;Extend the Func type and the (*Memo).Get method so that callers may provide an optional done channel through which they can cancel the operation (§8.9). The results of a cancelled Func call should not be cached.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Copyright © 2016 Alan A. A. Donovan &amp;amp; Brian W. Kernighan.
// License: https://creativecommons.org/licenses/by-nc-sa/4.0/

// See page 278.

// Package memo provides a concurrency-safe non-blocking memoization
// of a function.  Requests for different keys proceed in parallel.
// Concurrent requests for the same key block until the first completes.
// This implementation uses a monitor goroutine.
package memo

import &amp;quot;errors&amp;quot;
import &amp;quot;time&amp;quot;

//!+Func

// Func is the type of the function to memoize.
type Func func(key string) (interface{}, error)

// A result is the result of calling a Func.
type result struct {
	value interface{}
	err   error
}

type entry struct {
	res   result
	ready chan struct{} // closed when res is ready
}

//!-Func

//!+get

// A request is a message requesting that the Func be applied to key.
type request struct {
	key      string
	response chan&amp;lt;- result // the client wants a single result
}

type Memo struct{ requests chan request }

// New returns a memoization of f.  Clients must subsequently call Close.
func New(f Func) *Memo {
	memo := &amp;amp;Memo{requests: make(chan request)}
	go memo.server(f)
	return memo
}

func (memo *Memo) Get(key string) (interface{}, error) {
	response := make(chan result)
	memo.requests &amp;lt;- request{key, response}
	res := &amp;lt;-response
	return res.value, res.err
}

func (memo *Memo) Close() { close(memo.requests) }

//!-get

//!+monitor

func (memo *Memo) server(f Func) {
	var done = make(chan struct{})
	// Cancel traversal when input is detected.
	go func() {
		//os.Stdin.Read(make([]byte, 1)) // read a single byte
		time.Sleep(300 * time.Millisecond)
		close(done)
	}()
	cancelled := func() bool {
		select {
		case &amp;lt;-done:
			return true
		default:
			return false
		}
	}
	cache := make(map[string]*entry)
	for req := range memo.requests {
		if cancelled() {
			//close(memo.requests)
			break
		}
		e := cache[req.key]
		if e == nil {
			// This is the first request for this key.
			e = &amp;amp;entry{ready: make(chan struct{})}
			cache[req.key] = e
			go e.call(f, req.key) // call f(key)
			if cancelled() {
				delete(cache, req.key)
			}
		}
		go e.deliver(req.response, done)
	}
}

func (e *entry) call(f Func, key string) {
	// Evaluate the function.
	e.res.value, e.res.err = f(key)
	// Broadcast the ready condition.
	close(e.ready)
}

func (e *entry) deliver(response chan&amp;lt;- result, done &amp;lt;-chan struct{}) {
	// Wait for the ready condition.
	select {
	case &amp;lt;-e.ready:
		response &amp;lt;- e.res
	case &amp;lt;-done:
		response &amp;lt;- result{nil, errors.New(&amp;quot;request cancelled&amp;quot;)}
	}
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>The Go Programming Language Ex（10）</title>
      <link>https://mooncaker816.github.io/2018/01/03/the-go-programming-language-ex10/</link>
      <pubDate>Wed, 03 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/01/03/the-go-programming-language-ex10/</guid>
      <description>&lt;h3 id=&#34;ex-8-6&#34;&gt;Ex 8.6&lt;/h3&gt;

&lt;p&gt;Add depth-limiting to the concurrent crawler. That is, if the user sets -depth=3, then only URLs reachable by at most three links will be fetched.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Copyright © 2016 Alan A. A. Donovan &amp;amp; Brian W. Kernighan.
// License: https://creativecommons.org/licenses/by-nc-sa/4.0/

// See page 241.

// Crawl2 crawls web links starting with the command-line arguments.
//
// This version uses a buffered channel as a counting semaphore
// to limit the number of concurrent calls to links.Extract.
package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;log&amp;quot;
	&amp;quot;os&amp;quot;

	&amp;quot;gopl.io/ch5/links&amp;quot;
)

//!+sema
// tokens is a counting semaphore used to
// enforce a limit of 20 concurrent requests.
var tokens = make(chan struct{}, 20)

func crawl(url string, deepth int, f *os.File) work {
	tokens &amp;lt;- struct{}{} // acquire a token
	list, err := links.Extract(url)
	fmt.Fprintln(f, deepth, &amp;quot; &amp;quot;, url, &amp;quot; &amp;quot;, len(list))
	&amp;lt;-tokens // release the token
	deepth++
	if err != nil {
		log.Print(err)
	}
	return work{list, deepth}
}

//!-sema
type work struct {
	worklist   []string
	workdeepth int
}

const DEEPTH = 2

//!+
func main() {
	wkpool := make(chan work)
	var n int // number of pending sends to worklist
	f, _ := os.Create(&amp;quot;stat&amp;quot;)
	defer f.Close()
	// Start with the command-line arguments.
	n++
	go func() { wkpool &amp;lt;- work{os.Args[1:], 0} }()

	// Crawl the web concurrently.
	seen := make(map[string]bool)
	for ; n &amp;gt; 0; n-- {
		wk := &amp;lt;-wkpool
		if wk.workdeepth &amp;gt; DEEPTH {
			continue
		}
		for _, link := range wk.worklist {
			if !seen[link] {
				seen[link] = true
				n++
				go func(link string, deepth int, f *os.File) {
					wkpool &amp;lt;- crawl(link, deepth, f)
				}(link, wk.workdeepth, f)
			}
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ex-8-8&#34;&gt;Ex 8.8&lt;/h3&gt;

&lt;p&gt;Using a select statement, add a timeout to the echo server from Section 8.3 so that it disconnects any client that shouts nothing within 10 seconds.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//client
package main

import (
	&amp;quot;io&amp;quot;
	&amp;quot;log&amp;quot;
	&amp;quot;net&amp;quot;
	&amp;quot;os&amp;quot;
)

func init() {
	log.SetFlags(log.Ldate | log.Lmicroseconds)
}

//!+
func main() {
	f, err := os.Open(&amp;quot;a&amp;quot;)
	defer f.Close()
	conn, err := net.Dial(&amp;quot;tcp&amp;quot;, &amp;quot;localhost:8000&amp;quot;)
	if err != nil {
		log.Fatal(err)
	}
	log.Println(&amp;quot;connected!&amp;quot;)
	done := make(chan struct{})
	go func() {
		io.Copy(os.Stdout, conn) // NOTE: ignoring errors
		log.Println(&amp;quot;done&amp;quot;)
		done &amp;lt;- struct{}{} // signal the main goroutine
	}()
	go func() {
		mustCopy(conn, os.Stdin)
		//conn.Close()
		err = conn.(*net.TCPConn).CloseWrite() //经实验：必须要关，否则无法通知服务端输入已结束（但不应该是服务端根据EOF来判断吗？）
		log.Println(&amp;quot;write finished in client: &amp;quot;, err)
	}()
	&amp;lt;-done // wait for background goroutine to finish
	log.Printf(&amp;quot;local in server: %#v\n&amp;quot;, conn.LocalAddr())
	log.Printf(&amp;quot;remote in server: %#v\n&amp;quot;, conn.RemoteAddr())
	log.Println(&amp;quot;finish print&amp;quot;)
	//err = conn.(*net.TCPConn).CloseRead()
	//log.Println(&amp;quot;read finished in client: &amp;quot;, err)
	err = conn.Close()
	log.Println(err)
}

//!-

func mustCopy(dst io.Writer, src io.Reader) {
	if _, err := io.Copy(dst, src); err != nil {
		log.Fatal(err)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//server
// Copyright © 2016 Alan A. A. Donovan &amp;amp; Brian W. Kernighan.
// License: https://creativecommons.org/licenses/by-nc-sa/4.0/

// See page 224.

// Reverb2 is a TCP server that simulates an echo.
package main

import (
	&amp;quot;bufio&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;log&amp;quot;
	&amp;quot;net&amp;quot;
	&amp;quot;strings&amp;quot;
	&amp;quot;sync&amp;quot;
	&amp;quot;time&amp;quot;
)

func init() {
	log.SetFlags(log.Ldate | log.Lmicroseconds)
}
func echo(c net.Conn, shout string, delay time.Duration, wg *sync.WaitGroup) {
	defer wg.Done()
	fmt.Fprintln(c, &amp;quot;\t&amp;quot;, strings.ToUpper(shout))
	time.Sleep(delay)
	fmt.Fprintln(c, &amp;quot;\t&amp;quot;, shout)
	time.Sleep(delay)
	fmt.Fprintln(c, &amp;quot;\t&amp;quot;, strings.ToLower(shout))
}

//!+
func handleConn(c net.Conn) {
	msg := make(chan string)
	go func(c net.Conn) {
		//for {
		input := bufio.NewScanner(c)
		for input.Scan() {
			fmt.Println(&amp;quot;getting: &amp;quot;, input.Text())
			msg &amp;lt;- input.Text()
		}
		msg &amp;lt;- &amp;quot;eof&amp;quot;
		//}
	}(c)
	ticker := time.NewTicker(5 * time.Second)
	var wg sync.WaitGroup
label1:
	for {
		select {
		case &amp;lt;-ticker.C:
			ticker.Stop()
			c.Close()
			fmt.Println(&amp;quot;connect closed!!&amp;quot;)
			return
		case s := &amp;lt;-msg:
			if s == &amp;quot;eof&amp;quot; {
				break label1
			}
			ticker.Stop()
			fmt.Println(s)
			wg.Add(1)
			go echo(c, s, 1*time.Second, &amp;amp;wg)
		}
	}
	// NOTE: ignoring potential errors from input.Err()
	//err := c.(*net.TCPConn).CloseRead()
	//log.Println(&amp;quot;read finished in server: &amp;quot;, err)
	log.Println(&amp;quot;finish scan&amp;quot;)
	log.Printf(&amp;quot;local in server: %#v\n&amp;quot;, c.LocalAddr())
	log.Printf(&amp;quot;remote in server: %#v\n&amp;quot;, c.RemoteAddr())
	wg.Wait()
	err := c.(*net.TCPConn).CloseWrite()
	//err := c.Close()
	log.Println(&amp;quot;finished in server: &amp;quot;, err)
}

//!-

func main() {
	l, err := net.Listen(&amp;quot;tcp&amp;quot;, &amp;quot;localhost:8000&amp;quot;)
	if err != nil {
		log.Fatal(err)
	}
	for {
		conn, err := l.Accept()
		if err != nil {
			log.Print(err) // e.g., connection aborted
			continue
		}
		go handleConn(conn)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;//client
$ ./ex8.3
2018/01/03 17:01:15.985187 connected!
2018/01/03 17:01:20.989292 done
2018/01/03 17:01:20.989515 local in server: &amp;amp;net.TCPAddr{IP:net.IP{0x7f, 0x0, 0x0, 0x1}, Port:49954, Zone:&amp;quot;&amp;quot;}
2018/01/03 17:01:20.989576 remote in server: &amp;amp;net.TCPAddr{IP:net.IP{0x7f, 0x0, 0x0, 0x1}, Port:8000, Zone:&amp;quot;&amp;quot;}
2018/01/03 17:01:20.989596 finish print
2018/01/03 17:01:20.989774 &amp;lt;nil&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;//server
./ex8.8
2018/01/03 17:01:20.989248 connect closed!! 127.0.0.1:8000 127.0.0.1:49954
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ex-8-9&#34;&gt;Ex 8.9&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Copyright © 2016 Alan A. A. Donovan &amp;amp; Brian W. Kernighan.
// License: https://creativecommons.org/licenses/by-nc-sa/4.0/

// See page 250.

// The du3 command computes the disk usage of the files in a directory.
package main

// The du3 variant traverses all directories in parallel.
// It uses a concurrency-limiting counting semaphore
// to avoid opening too many files at once.

import (
	&amp;quot;flag&amp;quot;
	&amp;quot;io/ioutil&amp;quot;
	&amp;quot;log&amp;quot;
	&amp;quot;os&amp;quot;
	&amp;quot;path/filepath&amp;quot;
	&amp;quot;sync&amp;quot;
	&amp;quot;time&amp;quot;
)

var vFlag = flag.Bool(&amp;quot;v&amp;quot;, false, &amp;quot;show verbose progress messages&amp;quot;)

func init() {
	log.SetFlags(log.Ldate | log.Lmicroseconds)
}

//!+
func main() {
	// ...determine roots...

	//!-
	flag.Parse()

	// Determine the initial directories.
	roots := flag.Args()
	if len(roots) == 0 {
		roots = []string{&amp;quot;.&amp;quot;}
	}

	//!+
	// Traverse each root of the file tree in parallel.
	//fileSizes := make(chan int64)
	var m sync.WaitGroup
	for _, root := range roots {
		var tick &amp;lt;-chan time.Time
		if *vFlag {
			tick = time.Tick(100 * time.Millisecond)
		}
		var fileSizes chan int64
		var n sync.WaitGroup
		fileSizes = make(chan int64)
		n.Add(1)
		go walkDir(root, &amp;amp;n, fileSizes)
		go func() {
			n.Wait()
			close(fileSizes)
		}()
		m.Add(1)
		go func(root string, tick &amp;lt;-chan time.Time) {
			defer m.Done()
			var nfiles, nbytes int64
		loop:
			for {
				select {
				case size, ok := &amp;lt;-fileSizes:
					if !ok {
						break loop // fileSizes was closed
					}
					nfiles++
					nbytes += size
				case &amp;lt;-tick:
					printDiskUsage(root, nfiles, nbytes)
				}
			}
			printDiskUsage(root, nfiles, nbytes) // final totals
		}(root, tick)
	}
	m.Wait()
}

//!-

func printDiskUsage(root string, nfiles, nbytes int64) {
	log.Printf(&amp;quot;%s: %d files  %.1f GB\n&amp;quot;, root, nfiles, float64(nbytes)/1e9)
}

// walkDir recursively walks the file tree rooted at dir
// and sends the size of each found file on fileSizes.
//!+walkDir
func walkDir(dir string, n *sync.WaitGroup, fileSizes chan&amp;lt;- int64) {
	defer n.Done()
	for _, entry := range dirents(dir) {
		if entry.IsDir() {
			n.Add(1)
			subdir := filepath.Join(dir, entry.Name())
			go walkDir(subdir, n, fileSizes)
		} else {
			fileSizes &amp;lt;- entry.Size()
		}
	}
}

//!-walkDir

//!+sema
// sema is a counting semaphore for limiting concurrency in dirents.
var sema = make(chan struct{}, 20)

// dirents returns the entries of directory dir.
func dirents(dir string) []os.FileInfo {
	sema &amp;lt;- struct{}{}        // acquire token
	defer func() { &amp;lt;-sema }() // release token
	// ...
	//!-sema

	entries, err := ioutil.ReadDir(dir)
	if err != nil {
		//fmt.Fprintf(os.Stderr, &amp;quot;du: %v\n&amp;quot;, err)
		return nil
	}
	return entries
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./ex8.9 -v /etc /usr /bin /var
2018/01/03 20:36:21.368337 /bin: 36 files  0.0 GB
2018/01/03 20:36:21.370797 /etc: 308 files  0.0 GB
2018/01/03 20:36:21.483464 /var: 2270 files  6.1 GB
2018/01/03 20:36:21.483846 /usr: 4322 files  1.9 GB
2018/01/03 20:36:21.571401 /var: 2449 files  6.3 GB
2018/01/03 20:36:21.599092 /usr: 9322 files  2.1 GB
2018/01/03 20:36:21.678850 /usr: 18130 files  2.6 GB
2018/01/03 20:36:21.782177 /usr: 47807 files  3.2 GB
2018/01/03 20:36:21.872339 /usr: 65859 files  3.7 GB
2018/01/03 20:36:21.920744 /usr: 89008 files  3.9 GB
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ex-8-12&#34;&gt;Ex 8.12&lt;/h3&gt;

&lt;p&gt;Make the broadcaster announce the current set of clients to each new arrival. This requires that the clients set and the entering and leaving channels record the client name too.&lt;/p&gt;

&lt;h3 id=&#34;ex-8-13&#34;&gt;Ex 8.13&lt;/h3&gt;

&lt;p&gt;Make the chat server disconnect idle clients, such as those that have sent no messages in the last ﬁve minutes. Hint: calling conn.Close() in another goroutine unblocks active Read calls such as the one done by input.Scan().&lt;/p&gt;

&lt;h3 id=&#34;ex-8-14&#34;&gt;Ex 8.14&lt;/h3&gt;

&lt;p&gt;Change the chat server’s network protocol so that each client provides its name on entering. Use that name instead of the network address when preﬁxing each message with its sender’s identity.&lt;/p&gt;

&lt;p&gt;只需要添加自定义协议，在压包解包的时候按协议进行就行，待做。。。&lt;/p&gt;

&lt;h3 id=&#34;ex-8-15&#34;&gt;Ex 8.15&lt;/h3&gt;

&lt;p&gt;Failure of any client program to read data in a timely manner ultimately causes all clients to get stuck. Modify the broadcaster to skip a message rather than wait if a client writer is not ready to accept it. Alternatively, add buffering to each client’s outgoing message channel so that most messages are not dropped; the broadcaster should use a non-blocking send to this channel.&lt;/p&gt;

&lt;p&gt;将broadcaster中向各个客户端发送消息的部分写入go routine，并将客户端发送通道定义为缓存通道&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Copyright © 2016 Alan A. A. Donovan &amp;amp; Brian W. Kernighan.
// License: https://creativecommons.org/licenses/by-nc-sa/4.0/

// See page 254.
//!+

// Chat is a server that lets clients chat with each other.
package main

import (
	&amp;quot;bufio&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;log&amp;quot;
	&amp;quot;net&amp;quot;
	&amp;quot;time&amp;quot;
)

//!+broadcaster
type client chan&amp;lt;- string // an outgoing message channel

var (
	entering = make(chan client)
	leaving  = make(chan client)
	messages = make(chan string) // all incoming client messages
)

func broadcaster() {
	clients := make(map[client]bool) // all connected clients
	for {
		select {
		case msg := &amp;lt;-messages:
			// Broadcast incoming message to all
			// clients&#39; outgoing message channels.
			for cli := range clients {
				cli &amp;lt;- msg
			}

		case cli := &amp;lt;-entering:
			clients[cli] = true

		case cli := &amp;lt;-leaving:
			delete(clients, cli)
			close(cli)
		}
	}
}

//!-broadcaster

//!+handleConn
func handleConn(conn net.Conn) {
	inittime := time.Now()
	itimestr := &amp;quot;[&amp;quot; + inittime.Format(&amp;quot;2006-01-02 15:04:05&amp;quot;) + &amp;quot;]&amp;quot;
	ch := make(chan string) // outgoing client messages
	go clientWriter(conn, ch)
	lastmsgtime := make(chan time.Time)
	who := conn.RemoteAddr().String()
	go func(t time.Time) {
		for {
			select {
			case t = &amp;lt;-lastmsgtime:
			default:
			}
			if time.Now().After(t.Add(20 * time.Second)) {
				ch &amp;lt;- fmt.Sprintf(&amp;quot;[%s] no msg in last 20 sec since %s, closing connect!&amp;quot;, time.Now().Format(&amp;quot;2006-01-02 15:04:05&amp;quot;), t.Format(&amp;quot;2006-01-02 15:04:05&amp;quot;))
				time.Sleep(1 * time.Second)
				conn.Close()
				//leaving &amp;lt;- ch
				//messages &amp;lt;- who + &amp;quot; has left&amp;quot;
				break
			}
		}
	}(inittime)
	ch &amp;lt;- itimestr + &amp;quot; &amp;quot; + &amp;quot;You are &amp;quot; + who
	messages &amp;lt;- itimestr + &amp;quot; &amp;quot; + who + &amp;quot; has arrived&amp;quot;
	entering &amp;lt;- ch

	input := bufio.NewScanner(conn)
	for input.Scan() {
		messages &amp;lt;- &amp;quot;[&amp;quot; + time.Now().Format(&amp;quot;2006-01-02 15:04:05&amp;quot;) + &amp;quot;]&amp;quot; + &amp;quot; &amp;quot; + who + &amp;quot;: &amp;quot; + input.Text()
		lastmsgtime &amp;lt;- time.Now()
	}
	// NOTE: ignoring potential errors from input.Err()

	leaving &amp;lt;- ch
	messages &amp;lt;- &amp;quot;[&amp;quot; + time.Now().Format(&amp;quot;2006-01-02 15:04:05&amp;quot;) + &amp;quot;]&amp;quot; + &amp;quot; &amp;quot; + who + &amp;quot; has left&amp;quot;
	conn.Close()
}

func clientWriter(conn net.Conn, ch &amp;lt;-chan string) {
	for msg := range ch {
		fmt.Fprintln(conn, msg) // NOTE: ignoring network errors
	}
}

//!-handleConn

//!+main
func main() {
	listener, err := net.Listen(&amp;quot;tcp&amp;quot;, &amp;quot;localhost:8000&amp;quot;)
	if err != nil {
		log.Fatal(err)
	}

	go broadcaster()
	for {
		conn, err := listener.Accept()
		if err != nil {
			log.Print(err)
			continue
		}
		go handleConn(conn)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./netcat1
[2018-01-04 01:09:14] You are 127.0.0.1:55627
[2018-01-04 01:09:18] 127.0.0.1:55630 has arrived
[2018-01-04 01:09:20] 127.0.0.1:55630: sdf
[2018-01-04 01:09:24] 127.0.0.1:55635 has arrived
[2018-01-04 01:09:28] 127.0.0.1:55635: ththth
[2018-01-04 01:09:34] no msg in last 20 sec since 2018-01-04 01:09:14, closing connect!
2018/01/04 01:09:35 done
$ ./netcat2
[2018-01-04 01:09:18] You are 127.0.0.1:55630
sdf
[2018-01-04 01:09:20] 127.0.0.1:55630: sdf
[2018-01-04 01:09:24] 127.0.0.1:55635 has arrived
[2018-01-04 01:09:28] 127.0.0.1:55635: ththth
[2018-01-04 01:09:35] 127.0.0.1:55627 has left
[2018-01-04 01:09:40] no msg in last 20 sec since 2018-01-04 01:09:20, closing connect!
2018/01/04 01:09:41 done
$ ./netcat3
[2018-01-04 01:09:24] You are 127.0.0.1:55635
ththth
[2018-01-04 01:09:28] 127.0.0.1:55635: ththth
[2018-01-04 01:09:35] 127.0.0.1:55627 has left
[2018-01-04 01:09:41] 127.0.0.1:55630 has left
[2018-01-04 01:09:48] no msg in last 20 sec since 2018-01-04 01:09:28, closing connect!
2018/01/04 01:09:49 done
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>The Go Programming Language Ex（9）</title>
      <link>https://mooncaker816.github.io/2018/01/01/the-go-programming-language-ex9/</link>
      <pubDate>Mon, 01 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/01/01/the-go-programming-language-ex9/</guid>
      <description>&lt;h3 id=&#34;ex-8-1&#34;&gt;Ex 8.1&lt;/h3&gt;

&lt;p&gt;Modify clock2 to accept a port number, and write a program, clockwall, that acts as a client of several clock servers at once, reading the times from each one and displaying the results in a table, akin to the wall of clocks seen in some business ofﬁces. If you have access to geographically distributed computers, run instances remotely ; otherwise run local instances on different ports with fake time zones.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;$ TZ=US/Eastern ./clock2 -port 8010 &amp;amp; $ TZ=Asia/Tokyo ./clock2 -port 8020 &amp;amp; $ TZ=Europe/London ./clock2 -port 8030 &amp;amp; $ clockwall NewYork=localhost:8010 London=localhost:8020 Tokyo=localhost:8030&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//clockwall
package main

import (
	&amp;quot;html/template&amp;quot;
	&amp;quot;log&amp;quot;
	&amp;quot;net&amp;quot;
	&amp;quot;net/http&amp;quot;
)

type City struct {
	Name string
	Addr string
	Time string
}

type cities []City

const templ = `
&amp;lt;h1&amp;gt;current times:&amp;lt;/h1&amp;gt;
&amp;lt;table&amp;gt;
&amp;lt;tr style=&#39;text-align: left&#39;&amp;gt;
  &amp;lt;th&amp;gt;City&amp;lt;/th&amp;gt;
  &amp;lt;th&amp;gt;Time&amp;lt;/th&amp;gt;
&amp;lt;/tr&amp;gt;
{{range . }}
&amp;lt;tr&amp;gt;
  &amp;lt;td&amp;gt;{{.Name}}&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;{{.Time}}&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;
{{end}}
&amp;lt;/table&amp;gt;
`

var report = template.Must(template.New(&amp;quot;result&amp;quot;).
	Parse(templ))
var cs = cities{
	{&amp;quot;NewYork&amp;quot;, &amp;quot;localhost:8010&amp;quot;, &amp;quot;&amp;quot;},
	{&amp;quot;Tokyo&amp;quot;, &amp;quot;localhost:8020&amp;quot;, &amp;quot;&amp;quot;},
	{&amp;quot;London&amp;quot;, &amp;quot;localhost:8030&amp;quot;, &amp;quot;&amp;quot;},
}

func main() {
	for i := range cs {
		go func(c *City) {
			conn, err := net.Dial(&amp;quot;tcp&amp;quot;, c.Addr)
			if err != nil {
				log.Fatal(err)
			}
			defer conn.Close()
			buf := make([]byte, 20)
			for {
				n, _ := conn.Read(buf)
				c.Time = string(buf[:n])
			}
		}(&amp;amp;cs[i])
	}
	http.HandleFunc(&amp;quot;/gettime&amp;quot;, cs.gettime)
	log.Fatal(http.ListenAndServe(&amp;quot;localhost:8000&amp;quot;, nil))
}

func (cs cities) gettime(w http.ResponseWriter, req *http.Request) {
	if err := report.Execute(w, cs); err != nil {
		log.Fatal(err)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//clock
package main

import (
	&amp;quot;flag&amp;quot;
	&amp;quot;io&amp;quot;
	&amp;quot;log&amp;quot;
	&amp;quot;net&amp;quot;
	&amp;quot;time&amp;quot;
)

func handleConn(c net.Conn) {
	defer c.Close()
	for {
		_, err := io.WriteString(c, time.Now().Format(&amp;quot;15:04:05\n&amp;quot;))
		if err != nil {
			return // e.g., client disconnected
		}
		time.Sleep(1 * time.Second)
	}
}

func main() {
	port := flag.String(&amp;quot;port&amp;quot;, &amp;quot;8000&amp;quot;, &amp;quot;port num&amp;quot;)
	flag.Parse()
	address := &amp;quot;localhost:&amp;quot; + *port
	listener, err := net.Listen(&amp;quot;tcp&amp;quot;, address)
	if err != nil {
		log.Fatal(err)
	}
	//!+
	for {
		conn, err := listener.Accept()
		if err != nil {
			log.Print(err) // e.g., connection aborted
			continue
		}
		go handleConn(conn) // handle connections concurrently
	}
	//!-
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;//启动服务器
TZ=US/Eastern    ./clock -port 8010 &amp;amp;
TZ=Asia/Tokyo    ./clock -port 8020 &amp;amp;
TZ=Europe/London ./clock -port 8030
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://oumnldfwl.bkt.clouddn.com/clockwall.png?imageView2/0/h/200&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;ex-8-3&#34;&gt;Ex 8.3&lt;/h3&gt;

&lt;p&gt;In netcat3, the interface value conn has the concrete type *net.TCPConn, which represents a TCP connection. A TCP connection consists of two halves that may be closed independently using its CloseRead and CloseWrite methods. Modify the main goroutine of netcat3 to close only the write half of the connection so that the program will continue to print the ﬁnal echoes from the reverb1 server even after the standard input has been closed. (Doing this for the reverb2 server is harder; see Exercise 8.4.)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;io&amp;quot;
	&amp;quot;log&amp;quot;
	&amp;quot;net&amp;quot;
	&amp;quot;os&amp;quot;
)

//!+
func main() {
	conn, err := net.Dial(&amp;quot;tcp&amp;quot;, &amp;quot;localhost:8000&amp;quot;)
	if err != nil {
		log.Fatal(err)
	}
	done := make(chan struct{})
	go func() {
		io.Copy(os.Stdout, conn) // NOTE: ignoring errors
		log.Println(&amp;quot;done&amp;quot;)
		done &amp;lt;- struct{}{} // signal the main goroutine
	}()
	mustCopy(conn, os.Stdin)
	//conn.Close()
	if conn, ok := conn.(*net.TCPConn); ok {
		conn.CloseWrite()
	}
	&amp;lt;-done // wait for background goroutine to finish
}

//!-

func mustCopy(dst io.Writer, src io.Reader) {
	if _, err := io.Copy(dst, src); err != nil {
		log.Fatal(err)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ex-8-4&#34;&gt;Ex 8.4&lt;/h3&gt;

&lt;p&gt;Modify the reverb2 server to use a sync.WaitGroup per connection to count the number of active echo goroutines. When it falls to zero, close the write half of the TCP connection as described in Exercise 8.3. Verify that your modiﬁed netcat3 client from that exercise waits for the ﬁnal echoes of multiple concurrent shouts, even after the standard input has been closed.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//client
package main

import (
	&amp;quot;io&amp;quot;
	&amp;quot;log&amp;quot;
	&amp;quot;net&amp;quot;
	&amp;quot;os&amp;quot;
)

func init() {
	log.SetFlags(log.Ldate | log.Lmicroseconds)
}

//!+
func main() {
	f, err := os.Open(&amp;quot;a&amp;quot;)
	defer f.Close()
	conn, err := net.Dial(&amp;quot;tcp&amp;quot;, &amp;quot;localhost:8000&amp;quot;)
	if err != nil {
		log.Fatal(err)
	}
	done := make(chan struct{})
	go func() {
		io.Copy(os.Stdout, conn) // NOTE: ignoring errors
		log.Println(&amp;quot;done&amp;quot;)
		done &amp;lt;- struct{}{} // signal the main goroutine
	}()
	mustCopy(conn, f)
	//conn.Close()
	log.Printf(&amp;quot;local in server: %#v\n&amp;quot;, conn.LocalAddr())
	log.Printf(&amp;quot;remote in server: %#v\n&amp;quot;, conn.RemoteAddr())
	err = conn.(*net.TCPConn).CloseWrite() //经实验：必须要关，否则无法通知服务端输入已结束（但不应该是服务端根据EOF来判断吗？）
	log.Println(&amp;quot;write finished in client: &amp;quot;, err)
	&amp;lt;-done // wait for background goroutine to finish
	log.Println(&amp;quot;finish print&amp;quot;)
	//err = conn.(*net.TCPConn).CloseRead()
	//log.Println(&amp;quot;read finished in client: &amp;quot;, err)
	err = conn.Close()
	log.Println(err)
}

//!-

func mustCopy(dst io.Writer, src io.Reader) {
	if _, err := io.Copy(dst, src); err != nil {
		log.Fatal(err)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//server
// Copyright © 2016 Alan A. A. Donovan &amp;amp; Brian W. Kernighan.
// License: https://creativecommons.org/licenses/by-nc-sa/4.0/

// See page 224.

// Reverb2 is a TCP server that simulates an echo.
package main

import (
	&amp;quot;bufio&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;log&amp;quot;
	&amp;quot;net&amp;quot;
	&amp;quot;strings&amp;quot;
	&amp;quot;sync&amp;quot;
	&amp;quot;time&amp;quot;
)

func init() {
	log.SetFlags(log.Ldate | log.Lmicroseconds)
}
func echo(c net.Conn, shout string, delay time.Duration, wg *sync.WaitGroup) {
	defer wg.Done()
	fmt.Fprintln(c, &amp;quot;\t&amp;quot;, strings.ToUpper(shout))
	time.Sleep(delay)
	fmt.Fprintln(c, &amp;quot;\t&amp;quot;, shout)
	time.Sleep(delay)
	fmt.Fprintln(c, &amp;quot;\t&amp;quot;, strings.ToLower(shout))
}

//!+
func handleConn(c net.Conn) {
	input := bufio.NewScanner(c)
	var wg sync.WaitGroup
	for input.Scan() {
		wg.Add(1)
		go echo(c, input.Text(), 1*time.Second, &amp;amp;wg)
		fmt.Println(input.Text())
	}
	// NOTE: ignoring potential errors from input.Err()
	//err := c.(*net.TCPConn).CloseRead()
	//log.Println(&amp;quot;read finished in server: &amp;quot;, err)
	log.Println(&amp;quot;finish scan&amp;quot;)
	log.Printf(&amp;quot;local in server: %#v\n&amp;quot;, c.LocalAddr())
	log.Printf(&amp;quot;remote in server: %#v\n&amp;quot;, c.RemoteAddr())
	wg.Wait()
	err := c.(*net.TCPConn).CloseWrite()
	//err := c.Close()
	log.Println(&amp;quot;finished in server: &amp;quot;, err)
}

//!-

func main() {
	l, err := net.Listen(&amp;quot;tcp&amp;quot;, &amp;quot;localhost:8000&amp;quot;)
	if err != nil {
		log.Fatal(err)
	}
	for {
		conn, err := l.Accept()
		if err != nil {
			log.Print(err) // e.g., connection aborted
			continue
		}
		go handleConn(conn)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;//client
$ ./ex8.3
2018/01/02 08:56:18.122881 local in server: &amp;amp;net.TCPAddr{IP:net.IP{0x7f, 0x0, 0x0, 0x1}, Port:59580, Zone:&amp;quot;&amp;quot;}
2018/01/02 08:56:18.123015 remote in server: &amp;amp;net.TCPAddr{IP:net.IP{0x7f, 0x0, 0x0, 0x1}, Port:8000, Zone:&amp;quot;&amp;quot;}
2018/01/02 08:56:18.123035 write finished in client:  &amp;lt;nil&amp;gt;
	 A
	 F
	 B
	 C
	 D
	 E
	 G
	 e
	 b
	 c
	 f
	 d
	 g
	 a
	 e
	 a
	 d
	 b
	 f
	 c
	 g
2018/01/02 08:56:20.125582 done
2018/01/02 08:56:20.125625 finish print
2018/01/02 08:56:20.125699 &amp;lt;nil&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;//server
$ ./ex8.4
a
b
c
d
e
f
g
2018/01/02 08:56:18.123125 finish scan
2018/01/02 08:56:18.123409 local in server: &amp;amp;net.TCPAddr{IP:net.IP{0x7f, 0x0, 0x0, 0x1}, Port:8000, Zone:&amp;quot;&amp;quot;}
2018/01/02 08:56:18.123427 remote in server: &amp;amp;net.TCPAddr{IP:net.IP{0x7f, 0x0, 0x0, 0x1}, Port:59580, Zone:&amp;quot;&amp;quot;}
2018/01/02 08:56:20.125383 finished in server:  &amp;lt;nil&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;conn是双向的（从各自local，remote属性相反可以看出），客户端本身对连接的关闭，只会影响客户端本身通过该连接的相关操作，不会影响服务器端连接；反之亦然！&lt;/li&gt;
&lt;li&gt;经过实验，客户端通过标准输入向conn写入消息时，即使写入EOF，服务器端也还会继续等待客户端输入的到来，只有当客户端CloseWrite()后，服务器端才会放弃等待输入，继续后面的逻辑；反之服务器端写，客户端读，也是这种情况。似乎与练习要达到的效果有些出入（手动ctrl-d，文件EOF都不行）~&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>The Go Programming Language Ex（8）</title>
      <link>https://mooncaker816.github.io/2017/12/31/the-go-programming-language-ex8/</link>
      <pubDate>Sun, 31 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://mooncaker816.github.io/2017/12/31/the-go-programming-language-ex8/</guid>
      <description>&lt;h3 id=&#34;ex-7-1&#34;&gt;Ex 7.1&lt;/h3&gt;

&lt;p&gt;Using the ideas from ByteCounter, implement counters for words and for lines. You will ﬁnd bufio.ScanWords useful.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;bufio&amp;quot;
	&amp;quot;bytes&amp;quot;
	&amp;quot;fmt&amp;quot;
)

func main() {
	var c ByteCounter
	c.Write([]byte(&amp;quot;hello&amp;quot;))
	fmt.Println(c) // &amp;quot;5&amp;quot;, = len(&amp;quot;hello&amp;quot;)
	c = 0          // reset the counter
	var name = &amp;quot;Dolly&amp;quot;
	fmt.Fprintf(&amp;amp;c, &amp;quot;hello, %s&amp;quot;, name)
	fmt.Println(c) // &amp;quot;12&amp;quot;, = len(&amp;quot;hello, Dolly&amp;quot;)

	var w WordCounter
	w.Write([]byte(&amp;quot;hello world, 世界&amp;quot;))
	fmt.Println(w)
	w = 0
	var str = &amp;quot;你 好&amp;quot;
	fmt.Fprintf(&amp;amp;w, &amp;quot;hello, %s&amp;quot;, str)
	fmt.Println(w)

	var l LineCounter
	l.Write([]byte(&amp;quot;hello world, 世界\nabc\nosjoij\nwefw&amp;quot;))
	fmt.Println(l)
}

type ByteCounter int

func (c *ByteCounter) Write(p []byte) (int, error) {
	*c += ByteCounter(len(p)) // convert int to ByteCounter
	return len(p), nil
}

type WordCounter int

func (w *WordCounter) Write(p []byte) (int, error) {
	scanner := bufio.NewScanner(bytes.NewReader(p))
	scanner.Split(bufio.ScanWords)
	var count int
	for scanner.Scan() {
		count++
	}
	*w += WordCounter(count)
	return count, nil
}

type LineCounter int

func (l *LineCounter) Write(p []byte) (int, error) {
	scanner := bufio.NewScanner(bytes.NewReader(p))
	scanner.Split(bufio.ScanLines)
	var count int
	for scanner.Scan() {
		count++
	}
	*l += LineCounter(count)
	return count, nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ go run counter.go
5
12
3
3
4
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ex-7-2&#34;&gt;Ex 7.2&lt;/h3&gt;

&lt;p&gt;Write a function CountingWriter with the signature below that, given an io.Writer, returns a new Writer that wraps the original, and a pointer to an int64 variable that at any moment contains the number of bytes written to the new Writer.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;func CountingWriter(w io.Writer) (io.Writer, *int64)&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;io&amp;quot;
	&amp;quot;os&amp;quot;
)

type byteCounter struct {
	n int64
	w io.Writer
}

func (c *byteCounter) Write(p []byte) (int, error) {
	c.n += int64(len(p))
	var err error
	if c.w != nil {
		_, err = c.w.Write(p)
	}
	return len(p), err
}

func CountingWriter(w io.Writer) (io.Writer, *int64) {
	var b byteCounter
	b.w = w
	return &amp;amp;b, &amp;amp;b.n
}

func main() {
	w, n := CountingWriter(os.Stdout)
	fmt.Fprintf(w, &amp;quot;hello, word!\n&amp;quot;)
	fmt.Printf(&amp;quot;writer count [%d]\n&amp;quot;, *n)
	fmt.Fprintf(w, &amp;quot;1234567890\n&amp;quot;)
	fmt.Printf(&amp;quot;writer count [%d]\n&amp;quot;, *n)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ go run counting.go
hello, word!
writer count [13]
1234567890
writer count [24]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ex-7-11&#34;&gt;Ex 7.11&lt;/h3&gt;

&lt;p&gt;Add additional handlers so that clients can create, read, update, and delete database entries. For example, a request of the form /update?item=socks&amp;amp;price=6 will update the price of an item in the inventory and report an error if the item does not exist or if the price is invalid. (Warning: this change introduces concurrent variable updates.)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;log&amp;quot;
	&amp;quot;net/http&amp;quot;
	&amp;quot;strconv&amp;quot;
	&amp;quot;sync&amp;quot;
)

var mu sync.Mutex

func main() {
	db := database{&amp;quot;shoes&amp;quot;: 50, &amp;quot;socks&amp;quot;: 5}
	http.HandleFunc(&amp;quot;/list&amp;quot;, db.list)
	http.HandleFunc(&amp;quot;/price&amp;quot;, db.price)
	http.HandleFunc(&amp;quot;/update&amp;quot;, db.update)
	http.HandleFunc(&amp;quot;/add&amp;quot;, db.add)
	http.HandleFunc(&amp;quot;/delete&amp;quot;, db.delete)
	log.Fatal(http.ListenAndServe(&amp;quot;localhost:8000&amp;quot;, nil))
}

type dollars float32

func (d dollars) String() string { return fmt.Sprintf(&amp;quot;$%.2f&amp;quot;, d) }

type database map[string]dollars

func (db database) list(w http.ResponseWriter, req *http.Request) {
	for item, price := range db {
		fmt.Fprintf(w, &amp;quot;%s: %s\n&amp;quot;, item, price)
	}
}

func (db database) price(w http.ResponseWriter, req *http.Request) {
	item := req.URL.Query().Get(&amp;quot;item&amp;quot;)
	if price, ok := db[item]; ok {
		fmt.Fprintf(w, &amp;quot;%s\n&amp;quot;, price)
	} else {
		w.WriteHeader(http.StatusNotFound) // 404
		fmt.Fprintf(w, &amp;quot;no such item: %q\n&amp;quot;, item)
	}
}

func (db database) update(w http.ResponseWriter, req *http.Request) {
	mu.Lock()
	defer mu.Unlock()
	item := req.URL.Query().Get(&amp;quot;item&amp;quot;)
	if _, ok := db[item]; ok {
		newpricestr := req.URL.Query().Get(&amp;quot;price&amp;quot;)
		newprice, err := strconv.ParseFloat(newpricestr, 32)
		if err != nil {
			w.Write([]byte(&amp;quot;price invalid!&amp;quot;))
		} else {
			db[item] = dollars(float32(newprice))
			w.Write([]byte(&amp;quot;new price updated!\n\n&amp;quot;))
			db.list(w, req)
		}
	} else {
		fmt.Fprintf(w, &amp;quot;no such item: %q\n&amp;quot;, item)
	}
}

func (db database) add(w http.ResponseWriter, req *http.Request) {
	mu.Lock()
	defer mu.Unlock()
	item := req.URL.Query().Get(&amp;quot;item&amp;quot;)
	if _, ok := db[item]; ok {
		fmt.Fprintf(w, &amp;quot;%s already exist!&amp;quot;, item)
	} else {
		newpricestr := req.URL.Query().Get(&amp;quot;price&amp;quot;)
		if len(newpricestr) &amp;lt;= 0 {
			newpricestr = &amp;quot;0&amp;quot;
		}
		newprice, err := strconv.ParseFloat(newpricestr, 32)
		if err != nil {
			w.Write([]byte(&amp;quot;price invalid!&amp;quot;))
		} else {
			db[item] = dollars(float32(newprice))
			fmt.Fprintf(w, &amp;quot;%s added!\n\n&amp;quot;, item)
			db.list(w, req)
		}
	}
}

func (db database) delete(w http.ResponseWriter, req *http.Request) {
	mu.Lock()
	defer mu.Unlock()
	item := req.URL.Query().Get(&amp;quot;item&amp;quot;)
	if _, ok := db[item]; ok {
		delete(db, item)
		fmt.Fprintf(w, &amp;quot;%s deleted!\n\n&amp;quot;, item)
		db.list(w, req)
	} else {
		fmt.Fprintf(w, &amp;quot;%s not exist!&amp;quot;, item)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://oumnldfwl.bkt.clouddn.com/list item.png?imageView2/0/h/200&#34; alt=&#34;list&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://oumnldfwl.bkt.clouddn.com/add item.png?imageView2/0/h/200&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://oumnldfwl.bkt.clouddn.com/update price.png?imageView2/0/h/200&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://oumnldfwl.bkt.clouddn.com/delete item.png?imageView2/0/h/200&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;ex-7-12&#34;&gt;Ex 7.12&lt;/h3&gt;

&lt;p&gt;Change the handler for /list to print its output as an HTML table, not text. You may ﬁnd the html/template package (§4.6) useful.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;html/template&amp;quot;
	&amp;quot;log&amp;quot;
	&amp;quot;net/http&amp;quot;
	&amp;quot;strconv&amp;quot;
	&amp;quot;sync&amp;quot;
)

var mu sync.Mutex

const templ = `
&amp;lt;h1&amp;gt;current prices:&amp;lt;/h1&amp;gt;
&amp;lt;table&amp;gt;
&amp;lt;tr style=&#39;text-align: left&#39;&amp;gt;
  &amp;lt;th&amp;gt;Item&amp;lt;/th&amp;gt;
  &amp;lt;th&amp;gt;Price&amp;lt;/th&amp;gt;
&amp;lt;/tr&amp;gt;
{{range $key, $value := . }}
&amp;lt;tr&amp;gt;
  &amp;lt;td&amp;gt;{{$key}}&amp;lt;/td&amp;gt;
  &amp;lt;td&amp;gt;{{$value}}&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;
{{end}}
&amp;lt;/table&amp;gt;
`

var report = template.Must(template.New(&amp;quot;result&amp;quot;).
	Parse(templ))

func main() {
	db := database{&amp;quot;shoes&amp;quot;: 50, &amp;quot;socks&amp;quot;: 5}
	http.HandleFunc(&amp;quot;/list&amp;quot;, db.list)
	http.HandleFunc(&amp;quot;/price&amp;quot;, db.price)
	http.HandleFunc(&amp;quot;/update&amp;quot;, db.update)
	http.HandleFunc(&amp;quot;/add&amp;quot;, db.add)
	http.HandleFunc(&amp;quot;/delete&amp;quot;, db.delete)
	log.Fatal(http.ListenAndServe(&amp;quot;localhost:8000&amp;quot;, nil))
}

type dollars float32

func (d dollars) String() string { return fmt.Sprintf(&amp;quot;$%.2f&amp;quot;, d) }

type database map[string]dollars

func (db database) list(w http.ResponseWriter, req *http.Request) {
	if err := report.Execute(w, db); err != nil {
		log.Fatal(err)
	}
}

func (db database) price(w http.ResponseWriter, req *http.Request) {
	item := req.URL.Query().Get(&amp;quot;item&amp;quot;)
	if price, ok := db[item]; ok {
		fmt.Fprintf(w, &amp;quot;%s\n&amp;quot;, price)
	} else {
		w.WriteHeader(http.StatusNotFound) // 404
		fmt.Fprintf(w, &amp;quot;no such item: %q\n&amp;quot;, item)
	}
}

func (db database) update(w http.ResponseWriter, req *http.Request) {
	mu.Lock()
	defer mu.Unlock()
	item := req.URL.Query().Get(&amp;quot;item&amp;quot;)
	if _, ok := db[item]; ok {
		newpricestr := req.URL.Query().Get(&amp;quot;price&amp;quot;)
		newprice, err := strconv.ParseFloat(newpricestr, 32)
		if err != nil {
			w.Write([]byte(&amp;quot;price invalid!&amp;quot;))
		} else {
			db[item] = dollars(float32(newprice))
			w.Write([]byte(&amp;quot;new price updated!\n\n&amp;quot;))
			db.list(w, req)
		}
	} else {
		fmt.Fprintf(w, &amp;quot;no such item: %q\n&amp;quot;, item)
	}
}

func (db database) add(w http.ResponseWriter, req *http.Request) {
	mu.Lock()
	defer mu.Unlock()
	item := req.URL.Query().Get(&amp;quot;item&amp;quot;)
	if _, ok := db[item]; ok {
		fmt.Fprintf(w, &amp;quot;%s already exist!&amp;quot;, item)
	} else {
		newpricestr := req.URL.Query().Get(&amp;quot;price&amp;quot;)
		if len(newpricestr) &amp;lt;= 0 {
			newpricestr = &amp;quot;0&amp;quot;
		}
		newprice, err := strconv.ParseFloat(newpricestr, 32)
		if err != nil {
			w.Write([]byte(&amp;quot;price invalid!&amp;quot;))
		} else {
			db[item] = dollars(float32(newprice))
			fmt.Fprintf(w, &amp;quot;%s added!\n\n&amp;quot;, item)
			db.list(w, req)
		}
	}
}

func (db database) delete(w http.ResponseWriter, req *http.Request) {
	mu.Lock()
	defer mu.Unlock()
	item := req.URL.Query().Get(&amp;quot;item&amp;quot;)
	if _, ok := db[item]; ok {
		delete(db, item)
		fmt.Fprintf(w, &amp;quot;%s deleted!\n\n&amp;quot;, item)
		db.list(w, req)
	} else {
		fmt.Fprintf(w, &amp;quot;%s not exist!&amp;quot;, item)
	}
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
  </channel>
</rss>
