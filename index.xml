<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Mooncaker816 on Mooncaker816</title>
    <link>https://mooncaker816.github.io/</link>
    <description>Recent content in Mooncaker816 on Mooncaker816</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <copyright>&amp;copy; 2018-Present</copyright>
    <lastBuildDate>Wed, 20 Apr 2016 00:00:00 +0800</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>天文算法17</title>
      <link>https://mooncaker816.github.io/2018/05/22/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9517/</link>
      <pubDate>Tue, 22 May 2018 10:15:11 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/05/22/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9517/</guid>
      <description>&lt;h1 id=&#34;第十九章-bodies-in-straight-line&#34;&gt;第十九章 Bodies in Straight Line&lt;/h1&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-定义&#34;&gt;1. 定义&lt;/h2&gt;

&lt;p&gt;　　当天体位于同一个天球大圆时，我们称之为天体处在同一&amp;rdquo;直线&amp;rdquo;上。&lt;br /&gt;
　　假设有三个天体,赤道系坐标分别为$(α_1,δ_1),(α_2,δ_2),(α_3,δ_3)$，当它们&amp;rdquo;共线&amp;rdquo;时，有：$$\tan δ_1\sin (α_2-α_3)+\tan δ_2\sin (α_3-α_1)+\tan δ_3\sin (α_1-α_2)=0$$
　　上述公式对黄道坐标系同样适用。&lt;/p&gt;

&lt;p&gt;　　利用该公式，我们就可以插值求得共线的时间点&lt;/p&gt;

&lt;h2 id=&#34;2-计算行星与两个恒星共线的时间点&#34;&gt;2. 计算行星与两个恒星共线的时间点&lt;/h2&gt;

&lt;p&gt;　　对于恒星，我们可以认为在一定观测时间范围内是静止的。所以在进行插值计算时，应该当做常数。如$(α_1,δ_1),(α_2,δ_2)$为恒星坐标，则插值时保持不变。&lt;br /&gt;
　　对于运动的行星，考虑一段时间范围内的坐标，进行插值并求零点。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Time computes the time at which a moving body is on a straight line (great
// circle) between two fixed points, such as stars.
//
// Coordinates may be right ascensions and declinations or longitudes and
// latitudes.  Fixed points are r1, d1, r2, d2.  Moving body is an ephemeris
// of 5 rows, r3, d3, starting at time t1 and ending at time t5.  Time scale
// is arbitrary.
//
// Result is time of alignment.
// 计算一个运动的天体和另外两个在观测时间内默认为不动的天体在一条直线上的时间点
func Time(r1, d1, r2, d2 unit.Angle, r3, d3 []unit.Angle, t1, t5 float64) (float64, error) {
	if len(r3) != 5 || len(d3) != 5 {
		return 0, errors.New(&amp;quot;r3, d3 must be length 5&amp;quot;)
	}
	gc := make([]float64, 5)
	for i, r3i := range r3 {
		// (19.1) p. 121
		gc[i] = d1.Tan()*(r2-r3i).Sin() +
			d2.Tan()*(r3i-r1).Sin() +
			d3[i].Tan()*(r1-r2).Sin()
	}
	l5, err := interp.NewLen5(t1, t5, gc)
	if err != nil {
		return 0, err
	}
	return l5.Zero(false)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;3-计算3点-近似共线-时的球面角和离共线大圆的角距离&#34;&gt;3. 计算3点&amp;rdquo;近似共线&amp;rdquo;时的球面角和离共线大圆的角距离&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://mooncaker816.github.io/img/line.png&#34; alt=&#34;&#34; /&gt;
　　如上图，$S_1,S_2,S_3$为三个天体，此时它们几乎&amp;rdquo;共线&amp;rdquo;,$C_1$为球面角$\angle PS_2S_1$，$C_2$为球面角$\angle PS_2S_3$，我们所求的就是球面角$\angle S_1S_2S_3$以及$S_2$与经过$S_1,S_3$的大圆之间的角距离（可以看作离共线还差多少度）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Meeus 计算三天体球面角$\angle S_1S_2S_3$&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;\begin{cases}
\tan C_1 &amp;amp;= \frac {\sin (α_2-α_1)}{\cos δ_2\tan δ_1-\sin δ_2\cos (α_2-α_1)}\\[2ex]
\tan C_2 &amp;amp;= \frac {\sin (α_3-α_2)}{\cos δ_2\tan δ_3-\sin δ_2\cos (α_3-α_2)}
\end{cases}
　　$C_1 + C_2$即为所求&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Angle returns the angle between great circles defined by three points.
//
// Coordinates may be right ascensions and declinations or longitudes and
// latitudes.  If r1, d1, r2, d2 defines one line and r2, d2, r3, d3 defines
// another, the result is the angle between the two lines.
//
// Algorithm by Meeus.
// 计算第一点第二点经过的大圆和第二点第三点经过的大圆之间的角度
func Angle(r1, d1, r2, d2, r3, d3 unit.Angle) unit.Angle {
	sd2, cd2 := d2.Sincos()
	sr21, cr21 := (r2 - r1).Sincos()
	sr32, cr32 := (r3 - r2).Sincos()
	C1 := math.Atan2(sr21, cd2*d1.Tan()-sd2*cr21)
	C2 := math.Atan2(sr32, cd2*d3.Tan()-sd2*cr32)
	return unit.Angle(C1 + C2)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Meeus 计算$S_2$与经过$S_1,S_3$的大圆之间的角距离&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　先计算：
\begin{cases}
X_1 &amp;amp;= \cos δ_1\cos α_1\\[2ex]
Y_1 &amp;amp;= \cos δ_1\sin α_1\\[2ex]
Z_1 &amp;amp;= \sin δ_1
\end{cases}
\begin{cases}
X_2 &amp;amp;= \cos δ_2\cos α_2\\[2ex]
Y_2 &amp;amp;= \cos δ_2\sin α_2\\[2ex]
Z_2 &amp;amp;= \sin δ_2
\end{cases}
\begin{cases}
A &amp;amp;= Y_1Z_2-Z_1Y_2\\[2ex]
B &amp;amp;= Z_1X_2-X_1Z_2\\[2ex]
C &amp;amp;= X_1Y_2-Y_1X_2
\end{cases}
$$m = \tan α_0, n = \frac {\tan δ_0}{\cos α_0}$$
　　则，$$\sin ω = \frac {A+Bm+Cn}{\sqrt {A^2+B^2+C^2}\sqrt{1+m^2+n^2}}$$
　　ω即为所求&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Error returns an error angle of three nearly co-linear points.
//
// For the line defined by r1, d1, r2, d2, the result is the anglular distance
// between that line and r0, d0.
//
// Algorithm by Meeus.
// 计算一点到由另外两点组成的大圆之间的角距离
func Error(r1, d1, r2, d2, r0, d0 unit.Angle) unit.Angle {
	sr1, cr1 := r1.Sincos()
	sd1, cd1 := d1.Sincos()
	sr2, cr2 := r2.Sincos()
	sd2, cd2 := d2.Sincos()
	X1 := cd1 * cr1
	X2 := cd2 * cr2
	Y1 := cd1 * sr1
	Y2 := cd2 * sr2
	Z1 := sd1
	Z2 := sd2
	A := Y1*Z2 - Z1*Y2
	B := Z1*X2 - X1*Z2
	C := X1*Y2 - Y1*X2
	m := r0.Tan()
	n := d0.Tan() / r0.Cos()
	return unit.Angle(math.Asin((A + B*m + C*n) /
		(math.Sqrt(A*A+B*B+C*C) * math.Sqrt(1+m*m+n*n))))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Pessens 同时计算上述两个量&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;\begin{cases}
a_1 &amp;amp;= \cos δ_1\cos α_1\\[2ex]
a_2 &amp;amp;= \cos δ_2\cos α_2\\[2ex]
a_3 &amp;amp;= \cos δ_3\cos α_3\\[2ex]
\end{cases}
\begin{cases}
b_1 &amp;amp;= \cos δ_1\sin α_1\\[2ex]
b_2 &amp;amp;= \cos δ_2\sin α_2\\[2ex]
b_3 &amp;amp;= \cos δ_3\sin α_3\\[2ex]
\end{cases}
\begin{cases}
c_1 &amp;amp;= \sin δ_1\\[2ex]
c_2 &amp;amp;= \sin δ_2\\[2ex]
c_3 &amp;amp;= \sin δ_3\\[2ex]
\end{cases}
\begin{cases}
l_1 &amp;amp;= b_1c_2-b_2c_1\\[2ex]
l_2 &amp;amp;= b_2c_3-b_3c_2\\[2ex]
l_3 &amp;amp;= b_1c_3-b_3c_1\\[2ex]
\end{cases}
\begin{cases}
m_1 &amp;amp;= c_1a_2-c_2a_1\\[2ex]
m_2 &amp;amp;= c_2a_3-c_3a_2\\[2ex]
m_3 &amp;amp;= c_1a_3-c_3a_1\\[2ex]
\end{cases}
\begin{cases}
n_1 &amp;amp;= a_1b_2-a_2b_1\\[2ex]
n_2 &amp;amp;= a_2b_3-a_3b_2\\[2ex]
n_3 &amp;amp;= a_1b_3-a_3b_1\\[2ex]
\end{cases}
　　则有：
\begin{cases}
\cos ψ &amp;amp;= \frac {l_1l_2+m_1m_2+n_1n_2}{\sqrt {l_1^2+m_1^2+n_1^2}\sqrt{l_2^2+m_2^2+n_2^2}}\\[2ex]
\sin ω &amp;amp;= \frac {a_2l_3+b_2m_3+c_2n_3}{\sqrt {a_2^2+b_2^2+c_2^2}\sqrt {l_3^2+m_3^2+n_3^2}}
\end{cases}
　　ψ，ω即为所求。ψ可能与 Meeus 方法求解的值互余180°。（平面的夹角有两个，互余180°）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// AngleError returns both an angle as in the function Angle, and an error
// as in the function Error.
//
// The algorithm is by B. Pessens.
// Angle和 Error 的合体版
// Angle 的值可能和之前 Angle 中计算的值互余180°（想象一下两个面的夹角）
func AngleError(r1, d1, r2, d2, r3, d3 unit.Angle) (ψ, ω unit.Angle) {
	sr1, cr1 := r1.Sincos()
	sd1, cd1 := d1.Sincos()
	sr2, cr2 := r2.Sincos()
	sd2, cd2 := d2.Sincos()
	sr3, cr3 := r3.Sincos()
	sd3, cd3 := d3.Sincos()
	a1 := cd1 * cr1
	a2 := cd2 * cr2
	a3 := cd3 * cr3
	b1 := cd1 * sr1
	b2 := cd2 * sr2
	b3 := cd3 * sr3
	c1 := sd1
	c2 := sd2
	c3 := sd3
	l1 := b1*c2 - b2*c1
	l2 := b2*c3 - b3*c2
	l3 := b1*c3 - b3*c1
	m1 := c1*a2 - c2*a1
	m2 := c2*a3 - c3*a2
	m3 := c1*a3 - c3*a1
	n1 := a1*b2 - a2*b1
	n2 := a2*b3 - a3*b2
	n3 := a1*b3 - a3*b1
	ψ = unit.Angle(math.Acos((l1*l2 + m1*m2 + n1*n2) /
		(math.Sqrt(l1*l1+m1*m1+n1*n1) * math.Sqrt(l2*l2+m2*m2+n2*n2))))
	ω = unit.Angle(math.Asin((a2*l3 + b2*m3 + c2*n3) /
		(math.Sqrt(a2*a2+b2*b2+c2*c2) * math.Sqrt(l3*l3+m3*m3+n3*n3))))
	return
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>天文算法16</title>
      <link>https://mooncaker816.github.io/2018/05/22/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9516/</link>
      <pubDate>Tue, 22 May 2018 09:37:47 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/05/22/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9516/</guid>
      <description>&lt;h1 id=&#34;第十八章-行星会合-planetary-conjunctions&#34;&gt;第十八章 行星会合 Planetary Conjunctions&lt;/h1&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-定义&#34;&gt;1. 定义&lt;/h2&gt;

&lt;p&gt;In astronomy, a conjunction occurs when two astronomical objects or spacecraft have either the same right ascension or the same ecliptic longitude, usually as observed from Earth.&lt;br /&gt;
当两个天体位于同一赤经（黄经）时，我们称之为会合。会合并不意味着最小角距离。&lt;/p&gt;

&lt;h2 id=&#34;2-计算会合的时间点以及纬度差&#34;&gt;2. 计算会合的时间点以及纬度差&lt;/h2&gt;

&lt;p&gt;由定义可知，当两天体的经度差为0时，我们称之为会合。&lt;br /&gt;
所以只要根据观测数据对经度差进行插值，再求零值对应的时间点即为会合时间。再根据这个时间点插值计算纬度差即可。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;两个都为移动的天体（行星）&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Planetary computes a conjunction between two moving objects, such as planets.
//
// Conjunction is found with interpolation against length 5 ephemerides.
//
// T1, t5 are times of first and last rows of ephemerides.  The scale is
// arbitrary.
//
// R1, d1 is the ephemeris of the first object.  The columns may be celestial
// coordinates in right ascension and declination or ecliptic coordinates in
// longitude and latitude.
//
// R2, d2 is the ephemeris of the second object, in the same frame as the first.
//
// Return value t is time of conjunction in the scale of t1, t5.
// Δd is the amount that object 2 was &amp;quot;above&amp;quot; object 1 at the time of
// conjunction.
// 计算两个移动的天体赤经（黄经）相同的时间点 t 和该时刻的赤纬（黄纬）差
func Planetary(t1, t5 float64, r1, d1, r2, d2 []unit.Angle) (t float64, Δd unit.Angle, err error) {
	if len(r1) != 5 || len(d1) != 5 || len(r2) != 5 || len(d2) != 5 {
		err = errors.New(&amp;quot;Five rows required in ephemerides&amp;quot;)
		return
	}
	dr := make([]float64, 5, 10)
	dd := dr[5:10]
	for i, r := range r1 {
		dr[i] = (r2[i] - r).Rad()
		dd[i] = (d2[i] - d1[i]).Rad()
	}
	return conj(t1, t5, dr, dd)
}

func conj(t1, t5 float64, dr, dd []float64) (t float64, Δd unit.Angle, err error) {
	var l5 *interp.Len5
	if l5, err = interp.NewLen5(t1, t5, dr); err != nil {
		return
	}
	if t, err = l5.Zero(true); err != nil { // 计算经度重合时的时间点 t
		return
	}
	if l5, err = interp.NewLen5(t1, t5, dd); err != nil {
		return
	}
	ΔdRad, err := l5.InterpolateXStrict(t) // 插值计算经度重合时的纬度差
	return t, unit.Angle(ΔdRad), err
}

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;一个为观测时间范围内默认不动的天体（恒星）&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Stellar computes a conjunction between a moving and non-moving object.
//
// Arguments and return values same as with Planetary, except the non-moving
// object is r1, d1.  The ephemeris of the moving object is r2, d2.
// 计算一个移动的天体和一个在观测时间范围内默认为不动的天体（如恒星）赤经（黄经）相同的时间点 t 和该时刻的赤纬（黄纬）差
func Stellar(t1, t5 float64, r1, d1 unit.Angle, r2, d2 []unit.Angle) (t float64, Δd unit.Angle, err error) {
	if len(r2) != 5 || len(d2) != 5 {
		err = errors.New(&amp;quot;Five rows required in ephemeris&amp;quot;)
		return
	}
	dr := make([]float64, 5, 10)
	dd := dr[5:10]
	for i, r := range r2 {
		dr[i] = (r - r1).Rad()
		dd[i] = (d2[i] - d1).Rad()
	}
	return conj(t1, t5, dr, dd)
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>天文算法15</title>
      <link>https://mooncaker816.github.io/2018/05/21/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9515/</link>
      <pubDate>Mon, 21 May 2018 18:46:37 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/05/21/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9515/</guid>
      <description>&lt;h1 id=&#34;第十七章-角距离-angular-separation&#34;&gt;第十七章 角距离 Angular Separation&lt;/h1&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-定义&#34;&gt;1. 定义&lt;/h2&gt;

&lt;p&gt;　　角距离，也称为角分离、视距离、或视分离，在数学(特别是几何学和三角学)和自然科学(包括天文学、地质学等等)，从不同于两个点物体的位置（即第三点）观察这两个物体，由观测者指向这两个物体的直线之间所夹角度的大小。角距离(或分离)与角度本身是同义的，但意义却是对两个天体(对恒星，是当从地球观测)之间线距离的建议(通常是很大或未知的)。&lt;/p&gt;

&lt;h2 id=&#34;2-计算&#34;&gt;2. 计算&lt;/h2&gt;

&lt;h3 id=&#34;2-1-余弦公式直接计算&#34;&gt;2.1 余弦公式直接计算&lt;/h3&gt;

&lt;p&gt;$$\cos d=\sin δ_1 \sin δ_2 + \cos δ_1 \cos δ_2 \cos (α_1 -α_2)$$
式中$α_1,δ_1,α_2,δ_2$分别对应两个天体的赤经和赤纬。&lt;br /&gt;
当$d$接近于0或180度时，$\left|\cos d\right|$接近于1，并且其值随$d$变化很小，所以得到的$d$不精确。此时需用以下公式计算：$$d = \sqrt {(Δα\cos δ)^2+(Δδ)^2}$$
式中$Δα$是两个赤经的差，$Δδ$是两个赤纬的差，$δ$是两个赤纬的平均值。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Sep returns the angular separation between two celestial bodies.
//
// The algorithm is numerically naïve, and while patched up a bit for
// small separations, remains unstable for separations near π.
// 计算两天体之间的角距，r为赤经，d为赤纬
func Sep(r1, d1, r2, d2 unit.Angle) unit.Angle {
	sd1, cd1 := d1.Sincos()
	sd2, cd2 := d2.Sincos()
	cd := sd1*sd2 + cd1*cd2*(r1-r2).Cos() // (17.1) p. 109
	if cd &amp;lt; base.CosSmallAngle {
		return unit.Angle(math.Acos(cd))
	}
	// (17.2) p. 109
	dm := (d1 + d2) / 2
	return unit.Angle(math.Hypot((r2-r1).Rad()*dm.Cos(), (d2 - d1).Rad()))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-2-根据观测数据插值计算最小角距离&#34;&gt;2.2 根据观测数据插值计算最小角距离&lt;/h3&gt;

&lt;p&gt;注意，不能先计算出各组数据点的角距离，再对角距离插值计算。因为当两个天体很近时，两天体间是线性的靠近再线性的离开。此时需要先对数据点插值，再把得出的数据套用2.1的方法进行计算。或者引入 u,v 坐标，先将原始数据转为 u,v 坐标，然后对 u,v 坐标点进行插值计算，得出最小值&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// MinSep returns the minimum separation between two moving objects.
//
// The motion is represented as an ephemeris of three rows, equally spaced
// in time.  Jd1, jd3 are julian day times of the first and last rows.
// R1, d1, r2, d2 are coordinates at the three times.  They must each be
// slices of length 3.
//
// Result is obtained by computing separation at each of the three times
// and interpolating a minimum.  This may be invalid for sufficiently close
// approaches.
//
// 计算两个天体之间的最小角距
// 此方法是将数据点计算成角距，然后直接对角距3点插值，求取最小值，
// 当两个天体十分接近时，这个结果是不准确的，要使用方法MinSepRect
func MinSep(jd1, jd3 float64, r1, d1, r2, d2 []unit.Angle) (unit.Angle, error) {
	if len(r1) != 3 || len(d1) != 3 || len(r2) != 3 || len(d2) != 3 {
		return 0, interp.ErrorNot3
	}
	y := make([]float64, 3)
	for x, r := range r1 {
		y[x] = Sep(r, d1[x], r2[x], d2[x]).Rad()
	}
	d3, err := interp.NewLen3(jd1, jd3, y)
	if err != nil {
		return 0, err
	}
	_, dMin, err := d3.Extremum()
	return unit.Angle(dMin), err
}

// MinSepRect returns the minimum separation between two moving objects.
//
// Like MinSep, but using a method of rectangular coordinates that gives
// accurate results even for close approaches.
// 计算两个天体之间的最小角距
// 此方法是引入直角坐标 u,v,先将数据点转换成u,v 表达，然后对u,v插值，求取最小值，
func MinSepRect(jd1, jd3 float64, r1, d1, r2, d2 []unit.Angle) (unit.Angle, error) {
	if len(r1) != 3 || len(d1) != 3 || len(r2) != 3 || len(d2) != 3 {
		return 0, interp.ErrorNot3
	}
	uv := func(r1, d1, r2, d2 unit.Angle) (u, v float64) {
		sd1, cd1 := d1.Sincos()
		Δr := r2 - r1
		tΔr := Δr.Tan()
		thΔr := (Δr / 2).Tan()
		K := 1 / (1 + sd1*sd1*tΔr*thΔr)
		sΔd := (d2 - d1).Sin()
		u = -K * (1 - (sd1/cd1)*sΔd) * cd1 * tΔr
		v = K * (sΔd + sd1*cd1*tΔr*thΔr)
		return
	}
	us := make([]float64, 3, 6)
	vs := us[3:6]
	for x, r := range r1 {
		us[x], vs[x] = uv(r, d1[x], r2[x], d2[x])
	}
	u3, err := interp.NewLen3(-1, 1, us)
	if err != nil {
		panic(err) // bug not caller&#39;s fault.
	}
	v3, err := interp.NewLen3(-1, 1, vs)
	if err != nil {
		panic(err) // bug not caller&#39;s fault.
	}
	up0 := (us[2] - us[0]) / 2
	vp0 := (vs[2] - vs[0]) / 2
	up1 := us[0] + us[2] - 2*us[1]
	vp1 := vs[0] + vs[2] - 2*vs[1]
	up := up0
	vp := vp0
	dn := -(us[1]*up + vs[1]*vp) / (up*up + vp*vp)
	n := dn
	var u, v float64
	for limit := 0; limit &amp;lt; 10; limit++ {
		u = u3.InterpolateN(n)
		v = v3.InterpolateN(n)
		if math.Abs(dn) &amp;lt; 1e-5 {
			return unit.Angle(math.Hypot(u, v)), nil // success
		}
		up := up0 + n*up1
		vp := vp0 + n*vp1
		dn = -(u*up + v*vp) / (up*up + vp*vp)
		n += dn
	}
	return 0, errors.New(&amp;quot;MinSepRect: failure to converge&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-3-利用半正矢的特点提高当角距很小时的精确程度&#34;&gt;2.3 利用半正矢的特点提高当角距很小时的精确程度&lt;/h3&gt;

&lt;p&gt;根据半正矢公式$hav(d) = hav(Δδ) + \cos δ_1 \cos δ_2 hav(Δα)$,式中 $Δα = α_1 - α_2，Δδ = δ_1 - δ_2$，
又由$hav(d)=\frac {1-\cos d}{2}=\sin^2(\frac d2)$,可以有效的在0，180°附近提高计算机的精度。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// SepHav returns the angular separation between two celestial bodies.
//
// The algorithm uses the haversine function and is superior to the naïve
// algorithm of the Sep function.
// 利用半正矢的特点提高当角距很小时的精确程度
func SepHav(r1, d1, r2, d2 unit.Angle) unit.Angle {
	// using (17.5) p. 115
	return unit.Angle(2 * math.Asin(math.Sqrt(base.Hav(d2-d1)+
		d1.Cos()*d2.Cos()*base.Hav(r2-r1))))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-4-pauwels公式&#34;&gt;2.4 Pauwels公式&lt;/h3&gt;

&lt;p&gt;令
\begin{cases}
x &amp;amp;= \cos δ_1\sin δ_2 - \sin δ_1\cos δ_2\cos (α_2-α_1)\\[2ex]
x &amp;amp;= \cos δ_2\sin (α_2-α_1)\\[2ex]
z &amp;amp;= \sin δ_1\sin δ_2 + \cos δ_1\cos δ_2\cos (α_2-α_1)\\[2ex]
\end{cases}
则有：$$d=\arctan (\frac {\sqrt {x^2+y^2}}{z})$$&lt;/p&gt;

&lt;p&gt;数学上来说，这与余弦定理完全等价，只不过是巧妙的将余弦转化为正切，而对于计算机来说，
反正切比反正弦能获得更高的精确度&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// SepPauwels returns the angular separation between two celestial bodies.
//
// The algorithm is a numerically stable form of that used in Sep.
// 当z小于0时，返回值应该在90-180度之间
// 该方法与直接余弦定理求角距在数学上是等价的，
// 但是对于计算机来说，arctan 比 arcsin能获得更高的精度
func SepPauwels(r1, d1, r2, d2 unit.Angle) unit.Angle {
	sd1, cd1 := d1.Sincos()
	sd2, cd2 := d2.Sincos()
	cdr := (r2 - r1).Cos()
	x := cd1*sd2 - sd1*cd2*cdr
	y := cd2 * (r2 - r1).Sin()
	z := sd1*sd2 + cd1*cd2*cdr
	return unit.Angle(math.Atan2(math.Hypot(x, y), z))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-5-relative-position-angle&#34;&gt;2.5 Relative Position Angle&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Position_angle&#34; target=&#34;_blank&#34;&gt;定义即相关信息&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// RelativePosition returns the position angle of one body with respect to
// another.
//
// The position angle result is measured counter-clockwise from North.
// 1相对2的角距，从2的正北到1的角度
// https://en.wikipedia.org/wiki/Position_angle
func RelativePosition(r1, d1, r2, d2 unit.Angle) unit.Angle {
	sΔr, cΔr := (r1 - r2).Sincos()
	sd2, cd2 := d2.Sincos()
	return unit.Angle(math.Atan2(sΔr, cd2*d1.Tan()-sd2*cΔr))
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>天文算法14</title>
      <link>https://mooncaker816.github.io/2018/05/21/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9514/</link>
      <pubDate>Mon, 21 May 2018 12:29:48 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/05/21/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9514/</guid>
      <description>&lt;h1 id=&#34;第十六章-大气折射-atmospheric-refraction&#34;&gt;第十六章 大气折射 Atmospheric Refraction&lt;/h1&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-大气折射&#34;&gt;1. 大气折射&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;大气折射（又称：蒙气差（蒙气即行星的大气）、折光差）即原本直线前进的光或其它电磁波在穿越大气层时，因为空气密度随着高度变化所产生的偏折。这种折射是光通过空气时因为密度的增加使速度降低（折射率增加）。大气折射在近地面时会产生海市蜃楼，让远方的物体出现或荡漾，和非幻觉的升高或降低，伸长或缩短。这个词也适用于声音的折射。无论是天体或地面上物体位置的测量都需要考虑大气折射。&lt;/p&gt;

&lt;p&gt;对天文或天体的折射，导致天体在天空中的位置看起来比实际为高。大地折射通常导致物体出现在比实际高的位置上，然而在靠近地面的空气被加热的下午，光线的曲折向上会使物体看似出现在比实际位置低的地方。&lt;/p&gt;

&lt;p&gt;折射不仅影响可见光，还包括所有的电磁波，然而在程度上不尽相同（见光的色散）。例如在可见光，蓝色受到的影响大于红色。这会对天体光谱在展开时的高解析图像造成影响。&lt;/p&gt;

&lt;p&gt;只要有可能，天文学家会安排在天体在天空中接近高度最高的顶点时才要观测。同样的，水手也不会观测一颗高度低于20°或更低恒星的位置。如果不能避免靠近地平线的观测，有可能使用具有修正系统，以弥补这种折射造成的影响。如果色散也是一个问题（如果是宽频的高解析观测），大气折射可以使用成对的旋转玻璃棱镜处理掉。但是当大气折射的总量是温度梯度、温度、压力和湿度（特别是在中红外波长时的水蒸气总量）的函数时，成功补偿这些修正量的工作可以让人为之望而却步。另一方面，测量师经常都会将他们的工作安排在下午折射程度最低的时候。&lt;/p&gt;

&lt;p&gt;在有很强的温度梯度、大气不均匀和空气动荡的时候，大气折射会变得很严重。这是造成恒星闪烁和日出与日落时太阳各种不同变形的原因。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/5/5d/Refracci%C3%B3n.png&#34; alt=&#34;太阳在日出和日落时位移的图&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;2-真纬度-视纬度&#34;&gt;2. 真纬度，视纬度&lt;/h2&gt;

&lt;p&gt;　　真纬度即为天体的真实地平纬度(仰角)$h$，视纬度即为经过大气折射后观测到的纬度$h_0$。&lt;br /&gt;
　　当已知真纬度$h$，&lt;strong&gt;可以由该$h$推算出一个矫正量R&lt;/strong&gt;，视纬度$h_0 = h + R$&lt;br /&gt;
　　当已知视纬度$h_0$，&lt;strong&gt;可以由该$h_0$推算出一个矫正量R&lt;/strong&gt;，真纬度$h = h_0 - R$&lt;/p&gt;

&lt;h2 id=&#34;3-矫正量r-单位角分&#34;&gt;3. 矫正量R&amp;ndash;单位角分&lt;/h2&gt;

&lt;h3 id=&#34;3-1-h-0-rightarrow-r-h&#34;&gt;3.1 $h_0 \Rightarrow R,h$&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;$h_0&amp;gt;15°$时：
$$R=58&amp;rdquo;.294\tan(90-h_0)-0&amp;rdquo;.0668\tan^3(90°-h_0)$$
$$h = h_0 - R$$&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Gt15True returns refraction for obtaining true altitude when altitude
// is greater than 15 degrees (about .26 radians.)
//
// h0 must be a measured apparent altitude of a celestial body.
//
// Result is refraction to be subtracted from h0 to obtain the true altitude
// of the body.
// 纬度大于15度时，由视纬度求真纬度的矫正量R
func Gt15True(h0 unit.Angle) unit.Angle {
    // (16.1) p. 105
    t := (math.Pi/2 - h0).Tan()
    return gt15true1.Mul(t) - gt15true2.Mul(t*t*t)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Bennett公式，当$h\in [0,90°]$时：
$$R = \frac {1}{\tan(h_0 +\frac {7.31}{h_0 +4.4})}$$
$$ΔR = -0.06sin(14.7R+13)$$
对于任意$h_0$，这个公式的精度是$0.07′=4.2&amp;rdquo;$，最大误差发生在$h_0 =12°$。&lt;br /&gt;
应当注意的是：当$h_0 =90°$时，$R=-0&amp;rdquo;.08$，理论上天顶应该不受折射影响，可以加上0.0013515′，从而为0。&lt;br /&gt;
若考虑修正量，即$R=R+ΔR$，最大误差为$0.015′=0.9&amp;rdquo;$。&lt;br /&gt;
当$h_0 =90°$时，计算的结果是$R=-0.89&amp;rdquo;$，不作第二项修正反而更好。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Bennett returns refraction for obtaining true altitude.
//
// h0 must be a measured apparent altitude of a celestial body in radians.
//
// Results are accurate to .07 arc min from horizon to zenith.
//
// Result is refraction to be subtracted from h0 to obtain the true altitude
// of the body.
// Bennett 公式，由视纬度求真纬度矫正量 R
func Bennett(h0 unit.Angle) unit.Angle {
    // (16.3) p. 106
    hd := h0.Deg()
    return unit.AngleFromMin(1 / math.Tan((hd+7.31/(hd+4.4))*math.Pi/180))
}

// Bennett2 returns refraction for obtaining true altitude.
//
// Similar to Bennett, but a correction is applied to give a more accurate
// result.
//
// Results are accurate to .015 arc min.  Result unit is radians.
// 带矫正量的Bennett公式
func Bennett2(h0 unit.Angle) unit.Angle {
    R := Bennett(h0).Min()
    return unit.AngleFromMin(R - .06*math.Sin((14.7*R+13)*math.Pi/180))
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;3-2-h-rightarrow-r-h-0&#34;&gt;3.2 $h \Rightarrow R,h_0$&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;$h&amp;gt;15°$时：
$$R=58&amp;rdquo;.276\tan(90°-h) -0&amp;rdquo;.0824\tan^3(90°-h)$$
$$h_0 = h + R$$&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Gt15Apparent returns refraction for obtaining apparent altitude when
// altitude is greater than 15 degrees (about .26 radians.)
//
// h must be a computed true &amp;quot;airless&amp;quot; altitude of a celestial body.
//
// Result is refraction to be added to h to obtain the apparent altitude
// of the body.
// 纬度大于15度时，由真纬度求视纬度的矫正量R
func Gt15Apparent(h unit.Angle) unit.Angle {
    // (16.2) p. 105
    t := (math.Pi/2 - h).Tan()
    return gt15app1.Mul(t) - gt15app2.Mul(t*t*t)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;类Bennett公式
$$R = \frac {1.02}{\tan(h+\frac{10.3}{h+5.11})}$$
同样，$h=90°$时，该式算得$R$不等于零,差值是 0.0019279。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Saemundsson returns refraction for obtaining apparent altitude.
//
// h must be a computed true &amp;quot;airless&amp;quot; altitude of a celestial body in radians.
//
// Result is refraction to be added to h to obtain the apparent altitude
// of the body.
//
// Results are consistent with Bennett to within 4 arc sec.
// 由真纬度求视纬度矫正量，与Bennett公式对应
func Saemundsson(h unit.Angle) unit.Angle {
    // (16.4) p. 106
    hd := h.Deg()
    return unit.AngleFromMin(1.02 / math.Tan((hd+10.3/(hd+5.11))*math.Pi/180))
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>天文算法13</title>
      <link>https://mooncaker816.github.io/2018/05/20/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9513/</link>
      <pubDate>Sun, 20 May 2018 20:50:07 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/05/20/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9513/</guid>
      <description>&lt;h1 id=&#34;第十五章-升-中天-降-rising-transit-setting&#34;&gt;第十五章 升，中天，降 Rising,Transit,Setting&lt;/h1&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-升-中天-降的概念&#34;&gt;1. 升，中天，降的概念&lt;/h2&gt;

&lt;p&gt;　　升就是天体位于观测点地平线上即将升起的位置，由于大气的折射，当我们看到天体位于地平线上时，天体的真实位置在地平线之下 0°34′。而对于太阳，视升降一般指太阳圆盘上边缘的升与降，因此需加上16′的太阳半径进行计算。&lt;br /&gt;
　　降与升类似，只是运动方向相反。&lt;br /&gt;
　　中天是指天体位于本地子午圈上时的位置，即离天顶最近的位置。&lt;/p&gt;

&lt;h2 id=&#34;2-计算升-中天-降的时刻&#34;&gt;2. 计算升，中天，降的时刻&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;根据第十三章中计算本地仰角的公式计算时角H$$\sin h = \sin φ\sin δ+\cos φ\cos δ\cos H$$
令$h_0=0$，则$$\cos H_0=-\tan φ\tan δ$$
但这只是理想状态，由于大气折射，我们要令$h_0=-0°34′$，对于太阳，令$h_0=-0°50′$，对于月亮，这个问题更复杂，因为$h_0$不是常数。考虑半径变化及地平视差，我们得到月亮的：$h_0 = 0.7275π - 0°34′$ 式中 $π$是月亮的地平视差（不是上章所说的视差角）。如果精度要球不高，$h_0$可以取均值$h_0 = 0°.125$，则$$\cos H_0 = \frac {\sin h_0 - \sin φ\sin δ}{\cos φ\cos δ}$$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;计算格林尼治D日0h（UT时）的视恒星时$θ_0$，并转为度单位,本地恒星时$θ=θ_0-L$,$L$为观测点经度，从格林尼治测量，向西为正，向东为负&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;天体的视赤经及视赤纬（单位是度）：
\begin{cases}
α_1 和 δ_1， 在力学时 D-1 日 0h\\[2ex]
α_2 和 δ_2， 在力学时 D 日 0h\\[2ex]
α_3 和 δ_3， 在力学时 D+1 日 0h\\[2ex]
\end{cases}
我们先使用下式估算时间： $$\cos H_0 = \frac {\sin h_0 - \sin φ\sin δ_2}{\cos φ\cos δ_2}$$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;估算中天，升起，降落时间点，单位为日（带小数）&lt;/p&gt;

&lt;p&gt;$H_0$单位是度，$H_0$应转换到 0 度到 180 度。那么我们有：
\begin{cases}
中天：m_0 = (α_2 + L - θ_0)/360 \\[2ex]
升起：m_1 = m_0 - H_0 /360 \\[2ex]
降落：m_2 = m_0 + H_0 /360\\[2ex]
\end{cases}
式中$m$是$D$日的时间（即$D$日$m$时），单位是日。因此 $m$ 的值在 0 到 1，如果$m$的值超过这个范围，那么应加 1 或减 1。例如：m = 0.3744，则不用变；m = -0.1709，则应加 1 变为+0.8291；m = +1.1853 则应减 1 变 为+0.1853。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;根据上一步求得的m,分别计算三个时刻点的格林威治恒星时$θ = θ_0 + 360.985647m$，式中$m$是$m_0、m_1、m_2$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;考虑ΔT，得到一个$m_0+ΔT/86400$的时刻点，对该时刻点在所给的视赤经，视赤纬数据中插值求解得到新的中天时刻对应的天体视赤经α，视赤纬δ（单单求解中天用不着视赤纬数据，但升降需要）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;计算中天时本地时角$H= θ - L - α$，新的中天即为$m_0 = m_0-\frac{H}{360}$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;同上，对升，降估计时间考虑$ΔT$并插值求解对应的视赤经$α$，视赤纬$δ$，再根据地平坐标转换公式，求得地平仰角$h$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;再求分别对应的本地时角$H$,则新的升,降即为$$m= m + \frac {h-h_0}{360\cos δ\cos φ\sin H}$$&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// ApproxTimes computes approximate UT rise, transit and set times for
// a celestial object on a day of interest.
//
// The function argurments do not actually include the day, but do include
// values computed from the day.
//
//	p is geographic coordinates of observer. p 为地平坐标（仰角，方位角）
//	h0 is &amp;quot;standard altitude&amp;quot; of the body. h0 为天体升，降时实际地平线纬度
//	Th0 is apparent sidereal time at 0h UT at Greenwich. Th0 为格林威治0h UT视恒星时
//	α, δ are right ascension and declination of the body. α, δ为天体0h DT视赤经，视赤纬
//
// Th0 must be the time on the day of interest.
// See sidereal.Apparent0UT.
//
// α, δ must be values at 0h dynamical time for the day of interest.
// 近似计算升，中天，降时间
func ApproxTimes(p globe.Coord, h0 unit.Angle, Th0 unit.Time, α unit.RA, δ unit.Angle) (tRise, tTransit, tSet unit.Time, err error) {
	// approximate local hour angle
	sLat, cLat := p.Lat.Sincos()
	sδ1, cδ1 := δ.Sincos()
	cH0 := (h0.Sin() - sLat*sδ1) / (cLat * cδ1) // (15.1) p. 102
	if cH0 &amp;lt; -1 || cH0 &amp;gt; 1 {
		err = ErrorCircumpolar
		return
	}
	H0 := unit.TimeFromRad(math.Acos(cH0))

	// approximate transit, rise, set times.
	// (15.2) p. 102.
	mt := unit.TimeFromRad(α.Rad()+p.Lon.Rad()) - Th0
	tTransit = mt.Mod1()
	tRise = (mt - H0).Mod1()
	tSet = (mt + H0).Mod1()
	return
}

// Times computes UT rise, transit and set times for a celestial object on
// a day of interest.
//
// The function argurments do not actually include the day, but do include
// a number of values computed from the day.
//
//	p is geographic coordinates of observer.
//	ΔT is delta T.
//	h0 is &amp;quot;standard altitude&amp;quot; of the body.
//	Th0 is apparent sidereal time at 0h UT at Greenwich.
//	α3, δ3 are slices of three right ascensions and declinations.
//
// h0 unit is radians.
//
// Th0 must be the time on the day of interest, in seconds.
// See sidereal.Apparent0UT.
//
// α3, δ3 must be values at 0h dynamical time for the day before, the day of,
// and the day after the day of interest.  Units are radians.
//
// Result units are seconds of day and are in the range [0,86400).
// 对近似计算结果迭代，得到精确升，中天，降时间
func Times(p globe.Coord, ΔT unit.Time, h0 unit.Angle, Th0 unit.Time, α3 []unit.RA, δ3 []unit.Angle) (tRise, tTransit, tSet unit.Time, err error) {
	tRise, tTransit, tSet, err = ApproxTimes(p, h0, Th0, α3[1], δ3[1])
	if err != nil {
		return
	}
	αf := make([]float64, 3)
	for i, α := range α3 {
		αf[i] = α.Rad()
	}
	δf := make([]float64, 3)
	for i, δ := range δ3 {
		δf[i] = δ.Rad()
	}
	var d3α, d3δ *interp.Len3
	d3α, err = interp.NewLen3(-86400, 86400, αf)
	if err != nil {
		return
	}
	d3δ, err = interp.NewLen3(-86400, 86400, δf)
	if err != nil {
		return
	}
	// adjust tTransit
	{
		th0 := (Th0 + tTransit.Mul(360.985647/360)).Mod1()
		α := d3α.InterpolateX((tTransit + ΔT).Sec())
		// local hour angle as Time
		H := th0 - unit.TimeFromRad(p.Lon.Rad()+α)
		tTransit -= H
	}
	// adjust tRise, tSet
	sLat, cLat := p.Lat.Sincos()
	adjustRS := func(m unit.Time) (unit.Time, error) {
		th0 := (Th0 + m.Mul(360.985647/360)).Mod1()
		ut := (m + ΔT).Sec()
		α := d3α.InterpolateX(ut)
		δ := d3δ.InterpolateX(ut)
		Hrad := th0.Rad() - p.Lon.Rad() - α
		sδ, cδ := math.Sincos(δ)
		sH, cH := math.Sincos(Hrad)
		h := math.Asin(sLat*sδ + cLat*cδ*cH)
		md := (unit.TimeFromRad(h) - h0.Time()).Div(cδ * cLat * sH)
		return m + md, nil
	}
	tRise, err = adjustRS(tRise)
	if err != nil {
		return
	}
	tSet, err = adjustRS(tSet)
	return
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>天文算法12</title>
      <link>https://mooncaker816.github.io/2018/05/20/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9512/</link>
      <pubDate>Sun, 20 May 2018 10:13:34 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/05/20/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9512/</guid>
      <description>&lt;h1 id=&#34;第十四章-the-parallactic-angle&#34;&gt;第十四章 The Parallactic Angle&lt;/h1&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-什么是parallactic-angle&#34;&gt;1. 什么是Parallactic Angle&lt;/h2&gt;

&lt;p&gt;　　&lt;strong&gt;&lt;em&gt;Parallactic is NOT Parallax&lt;/em&gt;&lt;/strong&gt;&lt;br /&gt;
　　这里所说的 Parallactic Angle 并不是 Parallax，Parallax是从两个不同的视点看同一物体时这两条视线之间的夹角(或半角)，主要用来测定物体的距离，如&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E7%A7%92%E5%B7%AE%E8%B7%9D&#34; target=&#34;_blank&#34;&gt;秒差距&lt;/a&gt;这一距离单位就是利用视差角来定义的。&lt;br /&gt;
　　In spherical astronomy, the parallactic angle is the angle between the great circle through a celestial object and the zenith(&lt;strong&gt;天体与天顶所在的大圆，即天球地平经线&lt;/strong&gt;), and the hour circle of the object（&lt;strong&gt;天体的时角，即天球赤道经线&lt;/strong&gt;）.It is usually denoted q. In the triangle zenith—object—celestial pole, the parallactic angle will be the position angle of the zenith at the celestial object. Despite its name, this angle is unrelated with parallax. The parallactic angle is zero when the object crosses the meridian.&lt;br /&gt;
　　换句话说，就是天体地平经线与天体赤道经线之间的角度。&lt;/p&gt;

&lt;h2 id=&#34;2-计算parallactic-angle&#34;&gt;2. 计算Parallactic Angle&lt;/h2&gt;

&lt;p&gt;$$\tan q=\frac {\sin H}{\tan φ\cos δ -\sin δ\cos H}$$
　　式中，$φ$是观测站地理纬度,$δ$是天体的赤纬，$H$是该时刻的时角。&lt;/p&gt;

&lt;p&gt;如何推导？&lt;br /&gt;
&lt;img src=&#34;https://mooncaker816.github.io/img/triangle.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如上图，P为天球极点，Z为天顶，X为观测目标，此时观测点为球心（地平坐标系），&lt;br /&gt;
由观测站地理纬度$φ$可知，弧长
$\newcommand{arc}[1]{\stackrel{\Large\frown}{#1}}\arc{PZ}= 90°-φ$,&lt;br /&gt;
由天体的赤纬$δ$可知，弧长
$\newcommand{arc}[1]{\stackrel{\Large\frown}{#1}}\arc{PX}= 90°-δ$,&lt;br /&gt;
由天体的时角$H$可知，球面角
$\angle ZPX = H$,&lt;br /&gt;
假设 X 的仰角为$a$,则弧长
$\newcommand{arc}[1]{\stackrel{\Large\frown}{#1}}\arc{ZX}= 90°-a$,&lt;br /&gt;
根据球面余弦公式，我们有
\begin{cases}
\cos (90°-a) &amp;amp;= \cos (90°-φ)\cos (90°-δ) + \sin (90°-φ)\sin (90°-δ)\cos H\\[2ex]
\cos (90°-φ) &amp;amp;= \cos (90°-a)\cos (90°-δ) + \sin (90°-a)\sin (90°-δ)\cos q
\end{cases}
即
\begin{cases}
\sin a &amp;amp;= \sin φ\sin δ + \cos φ\cos δ\cos H, &amp;amp;(1)\\[2ex]
\sin φ &amp;amp;= \sin a\sin δ + \cos a\cos δ\cos q, &amp;amp;(2)
\end{cases}
根据正弦公式，我们有$$\frac {\sin H}{\cos a} = \frac {\sin q}{\cos φ},\ \ \ (3)$$
由(2)(3)可得
\begin{align}
\tan q &amp;amp;= \frac {\sin q}{\cos q}\\[2ex]
&amp;amp; = \frac {\frac {\sin H\cos φ}{\cos a}}{\frac {\sin φ-\sin a\sin δ}{\cos a\cos δ}}\\[2ex]
&amp;amp; = \frac {\sin H\cos φ\cos δ}{\sin φ-\sin a\sin δ}
\end{align}
再将(1)代入上式中，
\begin{align}
\tan q &amp;amp; = \frac {\sin H\cos φ\cos δ}{\sin φ-\sin δ(\sin φ\sin δ + \cos φ\cos δ\cos H)}\\[2ex]
&amp;amp; = \frac {\sin H\cos φ\cos δ}{\sin φ\cos^2δ - \cos φ\cos δ\sin δ\cos H}\\[2ex]
&amp;amp; = \frac {\sin H}{\tan φ\cos δ - \sin δ\cos H}
\end{align}
得证&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.cnblogs.com/li-hua/p/5663915.html&#34; target=&#34;_blank&#34;&gt;另一种直接证明&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　当天体位于中天时恰好与天顶重合，则有$δ=φ$，此时$\tan q = \frac 00$，没有意义，也就是说角度由-90°跳到90°。&lt;br /&gt;
　　当天体位于地平线上时，即$a=0°$时，由(2)式直接可得$$\cos q = \frac {\sin φ}{\cos δ}$$
与时角$H$无关&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// ParallacticAngle returns parallactic angle of a celestial object.
//
//	φ is geographic latitude of observer.观测点地理纬度
//	δ is declination of observed object.天体赤纬
//	H is hour angle of observed object.天体赤经（时角）
//  计算天体的Parallactic Angle
func ParallacticAngle(φ, δ unit.Angle, H unit.HourAngle) unit.Angle {
	sδ, cδ := δ.Sincos()
	sH, cH := H.Sincos()
	// (14.1) p. 98
	return unit.Angle(math.Atan2(sH, φ.Tan()*cδ-sδ*cH))
}

// ParallacticAngleOnHorizon is a special case of ParallacticAngle.
//
// The hour angle is not needed as an input and the math inside simplifies.
// 当天体位于地平线上时，计算Parallactic Angle，与时角无关
func ParallacticAngleOnHorizon(φ, δ unit.Angle) unit.Angle {
	return unit.Angle(math.Acos(φ.Sin() / δ.Cos()))
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>天文算法11</title>
      <link>https://mooncaker816.github.io/2018/05/19/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9511/</link>
      <pubDate>Sat, 19 May 2018 15:04:04 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/05/19/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9511/</guid>
      <description>&lt;h1 id=&#34;第十三章-坐标的转换-transformation-of-coordinates&#34;&gt;第十三章 坐标的转换 Transformation of Coordinates&lt;/h1&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-天球坐标系统&#34;&gt;1. 天球坐标系统&lt;/h2&gt;

&lt;p&gt;　　天球坐标系统，是天文学上用来描绘天体在天球上位置的坐标系统。有许多不同的坐标系统都使用球面坐标投影在天球上，类似于使用在地球表面的地理坐标系统。这些坐标系统的不同处只在用来将天空分割成两个相等半球的大圆，也就是基面的不同。例如，地理坐标系统的基面是地球的赤道。每个坐标系统的命名都是依据其所选择的基面。&lt;/p&gt;

&lt;p&gt;\begin{array}{c|ccc}
坐标系统 &amp;amp; 基面 &amp;amp; 极 &amp;amp; 坐标 \\&lt;br /&gt;
\hline
地平 &amp;amp; 地平面 &amp;amp; 天顶/天底 &amp;amp; 高度（也称为仰角） - 方位 - 子午圈 \\&lt;br /&gt;
赤道 &amp;amp; 天球赤道 &amp;amp; 天极 &amp;amp; 赤纬 - 赤经或时角 \\&lt;br /&gt;
黄道 &amp;amp; 黄道 &amp;amp; 黄极 &amp;amp; 黄纬 - 黄经 \\&lt;br /&gt;
银河 &amp;amp; 银河平面 &amp;amp; 银极 &amp;amp; 银经 - 银纬 \\&lt;br /&gt;
超星系 &amp;amp; 超星系平面 &amp;amp;  &amp;amp;  \\&lt;br /&gt;
\end{array}&lt;/p&gt;

&lt;h2 id=&#34;2-地平坐标系&#34;&gt;2. 地平坐标系&lt;/h2&gt;

&lt;p&gt;　　地平坐标系，又作地平座标系，是天球坐标系统中的一种，以观测者所在地为中心点，所在地的地平线作为基础平面，将天球适当的分成能看见的上半球和看不见（被地球本身遮蔽）的下半球。上半球的顶点（最高点）称为天顶，下半球的顶点（最低点）称为地底。&lt;/p&gt;

&lt;p&gt;地平坐标系统是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;高度角（Altitude, Alt）或仰角又称地平纬度，是天体和观测者所在地的地平线的夹角，有时就称为高度或海拔标高（elevation, geometric height）。&lt;/li&gt;
&lt;li&gt;方位角（Azimuth, Az）又称地平经度，是沿着地平线测量的角度（由正北方为起点向东方测量）。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因此地平坐标系有时也被称为高度/方位（Alt/Az）坐标系统。
&lt;img src=&#34;https://kotobank.jp/image/dictionary/daijisen/media/103135.jpg&#34; alt=&#34;地平坐标系&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;注：方位角的测量可以从北点向东测量，也可从南点向西测量，两者相差180°。天文学家习惯从南点开始测量。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;3-赤道坐标系&#34;&gt;3. 赤道坐标系&lt;/h2&gt;

&lt;p&gt;　　赤道坐标系统，又作赤道座标系统，大概是使用得最广泛的天球坐标系统，他的元素是:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;赤纬Declination（ $\delta$ ）&lt;/li&gt;
&lt;li&gt;赤经Right ascension（ $\alpha$ ）－也记为RA&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　他与地理坐标系统非常相似，因为两者使用相同的基准平面和相同的极点。地球的赤道在天球上的投影就称为天球赤道，相同的，地理极点在天球上的投影就是天极。&lt;/p&gt;

&lt;p&gt;他有两种变化：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;时角系统像地理坐标系统一样，被固定在地球的表面上。&lt;/li&gt;
&lt;li&gt;赤经系统被固定于恒星上(实际上并非如此，请参考岁差和章动)。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因此，在经过一夜或数个夜晚，就能看出来星星在天空中的位置移动了，当然，这并非恒星在天球上的运动，只是地球运动造成的。因为岁差和章动的影响，在相当长的时间间隔下所做的观测，就必须注明所使用的特殊历元，为行星、恒星、星系等等的位置做记录。现在使用的历元是J2000.0分点，稍早期使用的是B1950.0分点。&lt;/p&gt;

&lt;p&gt;赤道坐标系统中与纬度相似的值是赤纬(缩写为Dec.)，是天体在天球赤道上方或下方的角度。与经度对应的是赤经(缩写为RA)，是与春分点的角度距离，不同于经度的是赤经以时、分、秒为单位，而非度、分、秒。因为地球的运动造成赤道坐标系统的视运动，就会造成恒星时和时角的相对变化。将天球运转一周的时间定为24小时，所以每小时天球会转动15度(360º / 24h = 15)。&lt;/p&gt;

&lt;p&gt;赤道坐标系统也是赤道仪上很普通的设备，也就是定位圈。定位圈与星图或星历表上的位置结合，可以让赤道仪很容易的指向已知天体在天球上的位置。
&lt;img src=&#34;https://kotobank.jp/image/dictionary/daijisen/media/103123.jpg&#34; alt=&#34;赤道坐标系&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;4-黄道坐标系&#34;&gt;4. 黄道坐标系&lt;/h2&gt;

&lt;p&gt;黄道是由地球上观察太阳一年中在天球上的视运动所通过的路径，若以地球“不动”作参照的话就是太阳绕地球公转的轨道平面（黄道面）在天球上的投影。&lt;/p&gt;

&lt;p&gt;黄道与天赤道相交于两点：春分点与秋分点（这两点称二分点）；而黄道对应的两个几何极是北黄极（在天龙座）、与南黄极 (在剑鱼座)。&lt;/p&gt;

&lt;p&gt;在黄道上与黄道平行的小圆称黄纬，符号β，以由黄道面向北黄极方向为正值（0°至90°），向南黄极方向则为负值。垂直黄道的经度称黄经，符号为λ，由春分点起由西向东量度（0°至360°）。像赤道坐标系中的赤经一样，以春分点做为黄经的起点。&lt;/p&gt;

&lt;p&gt;因为地轴有进动现象，此坐标系的两个黄极亦会因岁差影响而使坐标数值逐渐移动，计算时必须说明坐标系参照的历元。现常采用的是J2000.0历元（之前的出版物多以B1950.0历元），在天文年历这类精度较高的刊物中，则参考当天或当月之瞬时分点计算。&lt;/p&gt;

&lt;p&gt;此坐标系特别适合标示太阳系内天体的位置，大多数行星（水星和冥王星除外）与许多小行星轨道平面与黄道的倾角都很小，故其黄纬值（β）都不大。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kotobank.jp/image/dictionary/daijisen/media/103079.jpg&#34; alt=&#34;黄道坐标系&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;5-坐标系转换&#34;&gt;5. 坐标系转换&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;$λ$和$β$代表黄经和黄纬&lt;/li&gt;
&lt;li&gt;$α$和$δ$代表赤经和赤纬&lt;/li&gt;
&lt;li&gt;$φ,A,h$代表观察者纬度，方位角，和仰角，其中默认A从南点向西测量&lt;/li&gt;
&lt;li&gt;$ε$黄赤交角&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;注：如果给定的为视坐标，在转换为本地地平坐标时要先将视赤经（时角）转换为本地时角。&lt;br /&gt;
例如：如果θ是本地恒星时，$θ_0$ 是格林尼治恒星时，L 是观者站经度（从格林尼治向西为正，东为负），那么本地时角为$ θ - α 或 θ_0 - L – α$&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;5-1-赤道转黄道-α-δ-rightarrow-λ-β&#34;&gt;5.1 赤道转黄道($α,δ\  \Rightarrow\  λ,β$)&lt;/h3&gt;

&lt;p&gt;\begin{align}
\sin β &amp;amp;=\cos ε\sin δ-\sin α\cos δ\sin ε\\[2ex]
\cos λ\cos β &amp;amp;=\cos α\cos δ\\[2ex]
\sin λ\cos β &amp;amp;=\sin ε\sin δ+\sin α\cos δ\cos ε
\end{align}&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Obliquity represents the obliquity of the ecliptic.
// 黄赤交角对应的 sin,cos 值
type Obliquity struct {
	S, C float64 // sine and cosine of obliquity
}

// NewObliquity constructs a new Obliquity.
//
// Struct members are initialized from the given value ε of the obliquity of
// the ecliptic.
// 计算黄赤交角对应的 sin,cos 值
func NewObliquity(ε unit.Angle) *Obliquity {
	r := &amp;amp;Obliquity{}
	r.S, r.C = ε.Sincos()
	return r
}

// Ecliptic coordinates are referenced to the plane of the ecliptic.
// 黄道坐标结构
type Ecliptic struct {
	Lon unit.Angle // Longitude (λ)黄经
	Lat unit.Angle // Latitude (β)黄纬
}

// EqToEcl converts equatorial coordinates to ecliptic coordinates.
// 赤道转黄道
func (ecl *Ecliptic) EqToEcl(eq *Equatorial, ε *Obliquity) *Ecliptic {
	ecl.Lon, ecl.Lat = EqToEcl(eq.RA, eq.Dec, ε.S, ε.C)
	return ecl
}

// EqToEcl converts equatorial coordinates to ecliptic coordinates.
//
//	α: right ascension coordinate to transform
//	δ: declination coordinate to transform
//	sε: sine of obliquity of the ecliptic
//	cε: cosine of obliquity of the ecliptic
//
// Results:
//
//	λ: ecliptic longitude黄经
//	β: ecliptic latitude黄纬
//  赤道转黄道
func EqToEcl(α unit.RA, δ unit.Angle, sε, cε float64) (λ, β unit.Angle) {
	sα, cα := α.Sincos()
	sδ, cδ := δ.Sincos()
	λ = unit.Angle(math.Atan2(sα*cε+(sδ/cδ)*sε, cα)) // (13.1) p. 93
	β = unit.Angle(math.Asin(sδ*cε - cδ*sε*sα))      // (13.2) p. 93
	return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;5-2-黄道转赤道-λ-β-rightarrow-α-δ&#34;&gt;5.2 黄道转赤道($λ,β\  \Rightarrow\  α,δ$)&lt;/h3&gt;

&lt;p&gt;\begin{align}
\sin δ &amp;amp;=\sin ε\sin λ\cos β+\cos ε\sin β\\[2ex]
\cos α\cos δ &amp;amp;=\cos λ\cos β\\[2ex]
\sin α\cos δ &amp;amp;=\cos ε\sin λ\cos β-\sin ε\sin β
\end{align}&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Equatorial coordinates are referenced to the Earth&#39;s rotational axis.
// 赤道坐标结构
type Equatorial struct {
	RA  unit.RA    // Right ascension (α)赤经（时角）
	Dec unit.Angle // Declination (δ)赤纬
}

// EclToEq converts ecliptic coordinates to equatorial coordinates.
// 黄道转赤道
func (eq *Equatorial) EclToEq(ecl *Ecliptic, ε *Obliquity) *Equatorial {
	eq.RA, eq.Dec = EclToEq(ecl.Lon, ecl.Lat, ε.S, ε.C)
	return eq
}

// EclToEq converts ecliptic coordinates to equatorial coordinates.
//
//	λ: ecliptic longitude coordinate to transform
//	β: ecliptic latitude coordinate to transform
//	sε: sine of obliquity of the ecliptic
//	cε: cosine of obliquity of the ecliptic
//
// Results:
//	α: right ascension赤经（时角）
//	δ: declination赤纬
// 黄道转赤道
func EclToEq(λ, β unit.Angle, sε, cε float64) (α unit.RA, δ unit.Angle) {
	sλ, cλ := λ.Sincos()
	sβ, cβ := β.Sincos()
	α = unit.RAFromRad(math.Atan2(sλ*cε-(sβ/cβ)*sε, cλ)) // (13.3) p. 93
	δ = unit.Angle(math.Asin(sβ*cε + cβ*sε*sλ))          // (13.4) p. 93
	return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;5-3-地平转赤道-φ-a-h-rightarrow-α-δ&#34;&gt;5.3 地平转赤道($φ,A,h\  \Rightarrow\  α,δ$)&lt;/h3&gt;

&lt;p&gt;\begin{align}
\sin δ &amp;amp;=\sin φ\sin h-\cos φ\cos h\cos A\\[2ex]
\cos δ\cos α &amp;amp;=-\cos φ\sin h-\sin φ\cos h\cos A\\[2ex]
\cos δ\sin α &amp;amp;=-\sin A\cos h
\end{align}&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// HzToEq transforms horizontal coordinates to equatorial coordinates.
//
// Sidereal time st must be consistent with the equatorial coordinates
// in the sense that if coordinates are apparent, sidereal time must be
// apparent as well.
// 地平转赤道
func (eq *Equatorial) HzToEq(hz *Horizontal, g globe.Coord, st unit.Time) *Equatorial {
	eq.RA, eq.Dec = HzToEq(hz.Az, hz.Alt, g.Lat, g.Lon, st)
	return eq
}

// HzToEq transforms horizontal coordinates to equatorial coordinates.
//
//	A: azimuth方位角
//	h: elevation仰角
//	φ: latitude of observer on Earth观测纬度
//	ψ: longitude of observer on Earth观测经度
//	st: sidereal time at Greenwich at time of observation.恒星时
//
// Sidereal time must be consistent with the equatorial coordinates
// in the sense that tf coordinates are apparent, sidereal time must be
// apparent as well.
// 恒星时必须和所给条件保持一致
//
// Results:
//
//	α: right ascension赤经（时角）
//	δ: declination赤纬
// 地平转赤道
func HzToEq(A, h, φ, ψ unit.Angle, st unit.Time) (α unit.RA, δ unit.Angle) {
	sA, cA := A.Sincos()
	sh, ch := h.Sincos()
	sφ, cφ := φ.Sincos()
	H := math.Atan2(sA, cA*sφ+sh/ch*cφ)
	α = unit.RAFromRad(st.Rad() - ψ.Rad() - H)
	δ = unit.Angle(math.Asin(sφ*sh - cφ*ch*cA))
	return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;5-4-赤道转地平-φ-α-δ-rightarrow-a-h&#34;&gt;5.4 赤道转地平($φ,α,δ\  \Rightarrow\  A,h$)&lt;/h3&gt;

&lt;p&gt;\begin{align}
\sin h &amp;amp;= \sin φ\sin δ+\cos φ\cos δ\cos α\\[2ex]
\cos A\cos h &amp;amp;=-\cos φ\sin δ+\sin φ\cos δ\cos α\\[2ex]
\sin A\cos h &amp;amp;=\cos δ\sin α
\end{align}&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Horizontal coordinates are referenced to the local horizon of an observer
// on the surface of the Earth.
// 地平坐标结构
type Horizontal struct {
	Az  unit.Angle // Azimuth (A)方位角
	Alt unit.Angle // Altitude (h)仰角
}

// EqToHz computes Horizontal coordinates from equatorial coordinates.
//
// Argument g is the location of the observer on the Earth.  Argument st
// is the sidereal time at Greenwich.
//
// Sidereal time must be consistent with the equatorial coordinates.
// If coordinates are apparent, sidereal time must be apparent as well.
// 赤道转地平
func (hz *Horizontal) EqToHz(eq *Equatorial, g *globe.Coord, st unit.Time) *Horizontal {
	hz.Az, hz.Alt = EqToHz(eq.RA, eq.Dec, g.Lat, g.Lon, st)
	return hz
}

// EqToHz computes Horizontal coordinates from equatorial coordinates.
//
//	α: right ascension coordinate to transform
//	δ: declination coordinate to transform
//	φ: latitude of observer on Earth
//	ψ: longitude of observer on Earth
//	st: sidereal time at Greenwich at time of observation.
//
// Sidereal time must be consistent with the equatorial coordinates.
// If coordinates are apparent, sidereal time must be apparent as well.
//
// Results:
//
//	A: azimuth of observed point, measured westward from the South.
//	h: elevation, or height of observed point above horizon.
// 赤道转地平
func EqToHz(α unit.RA, δ, φ, ψ unit.Angle, st unit.Time) (A, h unit.Angle) {
	H := st.Rad() - ψ.Rad() - α.Rad()
	sH, cH := math.Sincos(H)
	sφ, cφ := φ.Sincos()
	sδ, cδ := δ.Sincos()
	A = unit.Angle(math.Atan2(sH, cH*sφ-(sδ/cδ)*cφ)) // (13.5) p. 93
	h = unit.Angle(math.Asin(sφ*sδ + cφ*cδ*cH))      // (13.6) p. 93
	return
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>天文算法10</title>
      <link>https://mooncaker816.github.io/2018/05/19/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9510/</link>
      <pubDate>Sat, 19 May 2018 09:20:12 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/05/19/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9510/</guid>
      <description>&lt;h1 id=&#34;第十二章-格林威治恒星时-sidereal-time-at-greenwich&#34;&gt;第十二章 格林威治恒星时 Sidereal Time at Greenwich&lt;/h1&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-恒星时&#34;&gt;1. 恒星时&lt;/h2&gt;

&lt;p&gt;　　&lt;strong&gt;恒星时是天文学和大地测量学标示的天球子午圈值&lt;/strong&gt;，由于借用了时间的计量单位，所以常被误解为是一种时间单位。恒星时是根据地球自转来计算的，它的基础是恒星日（比地球的自转周期短约8.4毫秒）。由于地球环绕太阳的公转运动，恒星日比平太阳日（也就是日常生活中所使用的日）短约1/365（相应约四分钟或一度）。&lt;/p&gt;

&lt;p&gt;　　恒星时的定义是一个地方的子午圈与天球的春分点之间的时角，因此地球上每个地方的恒星时都与它的经度有关。&lt;/p&gt;

&lt;p&gt;　　由于地球的章动春分点在天球上并不固定，而是以18.6年的周期围绕着平均春分点摆动。因此恒星时又分真恒星时和平恒星时。真恒星时是通过直接测量子午线与实际的春分点之间的时角获得的，平恒星时则忽略了地球的章动。真恒星时与平恒星时之间的差异最大可达约0.4秒。&lt;/p&gt;

&lt;p&gt;　　一个地方的当地恒星时与格林尼治天文台的恒星时之间的差就是这个地方的经度（参见天体导航）。因此通过观测恒星时可以确定当地的经度（假如格林尼治天文台的恒星时已知的话）或者可以确定时间（假如当地的经度已知的话）。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;一颗恒星的时角$\tau$ 、它的赤经$α$和当地的恒星时$θ$之间的关系为 $\tau=\theta -\alpha$&lt;/li&gt;
&lt;li&gt;当地的恒星时等于位于天顶的恒星的赤经&lt;/li&gt;
&lt;li&gt;当地的恒星时等于正位于中天恒星的赤经&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　通过确定恒星时可以简化天文学的计算，比如通过恒星时和当地的纬度可以很方便地计算出哪些星正好在地平线以上。&lt;/p&gt;

&lt;h2 id=&#34;2-恒星时的计算&#34;&gt;2. 恒星时的计算&lt;/h2&gt;

&lt;h3 id=&#34;2-1-格林威治0h平恒星时&#34;&gt;2.1 格林威治0h平恒星时&lt;/h3&gt;

&lt;p&gt;　　一个给定的世界时日期的&lt;strong&gt;&lt;em&gt;(0h UT)&lt;/em&gt;&lt;/strong&gt;，格林尼治子午圈的平恒星时可按如下计算。&lt;br /&gt;
　　1. 先计算当天（0h UT）对应的$JD$&lt;br /&gt;
　　2. 计算$T = \frac {JD - 2451545.0}{36525}$&lt;br /&gt;
　　3. 采用 &lt;strong&gt;IAU1982&lt;/strong&gt; 的格林尼治子午圈的平恒星时表达式： $$θ_0 = 6h41m50s.54841 + 8640184s.812866T + 0s.093104T^2 - 0s.0000062T^3$$
　　4. 若以度为单位，则上式为：$$θ_0 = 100.46061837 + 36000.770053608T + 0.000387933T^2 - T^3 / 38710000$$&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;注意，上述公式只适用于(0h UT）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// jdToCFrac returns values for use in computing sidereal time at Greenwich.
//
// Cen is centuries from J2000 of the JD at 0h UT of argument jd.  This is
// the value to use for evaluating the IAU sidereal time polynomial.
// DayFrac is the fraction of jd after 0h UT.  It is used to compute the
// final value of sidereal time.
// 计算 T = cen，dayFrac 为此 jd 对应的天的小数
func jdToCFrac(jd float64) (cen, dayFrac float64) {
	j0, f := math.Modf(jd + .5)
	return base.J2000Century(j0 - .5), f
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// J2000Century returns the number of Julian centuries since J2000.
//
// The quantity appears as T in a number of time series.
func J2000Century(jde float64) float64 {
	// The formula is given in a number of places in the book, for example
	// (12.1) p. 87.
	// (22.1) p. 143.
	// (25.1) p. 163.
	return (jde - J2000) / JulianCentury
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Mean0UT returns mean sidereal time at Greenwich at 0h UT on the given JD.
//
// The result is in the range [0,86400).
// 计算格林威治 0h UT 平恒星时，并化简为单位为秒一天之内的值[0,86400).
func Mean0UT(jd float64) unit.Time {
	s, _ := mean0UT(jd)
	return s.Mod1()
}

// 计算格林威治 0h UT 平恒星时，并返回此 jd 一天中相对于0h的秒数，用于瞬时平恒星时的计算
func mean0UT(jd float64) (sidereal, dayFrac unit.Time) {
	cen, f := jdToCFrac(jd)
	// (12.2) p. 87
	return unit.Time(base.Horner(cen, iau82...)), unit.TimeFromDay(f)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-2-格林威治任意-ut-平恒星时&#34;&gt;2.2 格林威治任意 UT 平恒星时&lt;/h3&gt;

&lt;p&gt;　　1. 计算0h 平恒星时&lt;br /&gt;
　　2. UT * 1.00273790935&lt;br /&gt;
　　3. 1 + 2 的结果即为格林威治瞬时平恒星时&lt;br /&gt;
　　4. 若以度为单位，则：$$θ_0 = 280.46061837 + 360.98564736629(JD-2451545.0) + 0.000387933T^2 - T^3 / 38710000$$&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Mean returns mean sidereal time at Greenwich for a given JD.
//
// Computation is by IAU 1982 coefficients.
// The result is in the range [0,86400).
// 计算格林威治 jd 时刻的瞬时平恒星时,化简结果至一天范围之内
func Mean(jd float64) unit.Time {
	return mean(jd).Mod1()
}

// 计算格林威治 jd 时刻的瞬时平恒星时
func mean(jd float64) unit.Time {
	s, f := mean0UT(jd)
	return s + f*1.00273790935
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-3-格林威治视恒星时&#34;&gt;2.3 格林威治视恒星时&lt;/h3&gt;

&lt;p&gt;　　要取得视恒星时，即真春分点起算的格林尼治时角，应加上修正值 $Δψ\cos ε$，式中 $Δψ$ 是黄经章动，$ε$ 是真黄赤交角。这个修正值也就作赤经章动（也称作分点方程）。因为 $Δψ$ 是个小量，所以 $ε$ 误差 10&amp;rdquo;也没关系。&lt;br /&gt;
　　如果 $Δψ$ 的单位是角秒（1 度是 3600 秒），则以时秒(1 小时是 3600 秒)为单位的修正值是：$\frac {Δψ\cos ε}{15}$&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Apparent returns apparent sidereal time at Greenwich for the given JD.
//
// Apparent is mean plus the nutation in right ascension.
//
// The result is in the range [0,86400).
// 计算格林威治瞬时视恒星时
func Apparent(jd float64) unit.Time {
	s := mean(jd)                  // Time
	n := nutation.NutationInRA(jd) // HourAngle
	return (s + n.Time()).Mod1()
}

// Apparent0UT returns apparent sidereal time at Greenwich at 0h UT
// on the given JD.
//
// The result is in the range [0,86400).
// 计算格林威治0h UT视恒星时
func Apparent0UT(jd float64) unit.Time {
	j0, f := math.Modf(jd + .5)
	cen := (j0 - .5 - base.J2000) / 36525
	s := unit.Time(base.Horner(cen, iau82...)) +
		unit.TimeFromDay(f*1.00273790935)
	n := nutation.NutationInRA(j0) // HourAngle
	return (s + n.Time()).Mod1()
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>天文算法9</title>
      <link>https://mooncaker816.github.io/2018/05/18/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%959/</link>
      <pubDate>Fri, 18 May 2018 15:55:20 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/05/18/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%959/</guid>
      <description>&lt;h1 id=&#34;第十一章-地球球体-the-earth-s-globe&#34;&gt;第十一章 地球球体 The Earth&amp;rsquo;s Globe&lt;/h1&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-椭球体&#34;&gt;1. 椭球体&lt;/h2&gt;

&lt;p&gt;　　天文学上，通常我们将地球看做一个近似的椭球体。如下图，&lt;img src=&#34;http://www.tleer.cn/uploads/allimg/170224/2-1F224111032348.jpg&#34; alt=&#34;&#34; /&gt;
所以子午圈截面为一个椭圆。如下图，&lt;img src=&#34;https://mooncaker816.github.io/img/tuoyuan.png&#34; alt=&#34;&#34; /&gt;
　　假设上图中$C$为地心，$N$为北极，$S$为南极，$CF$为赤道半径，$NC = b, CF = a$,$O$为观察点，$HK$为地平面，$OP\perp HK$,$OM//SN$，$OM$与$OH$的夹角是$φ$，$CF$与$CO$的夹角是$φ&amp;rsquo;$，$CO$的长度为$\rho$&lt;br /&gt;
　　则$φ$为$O$点的&lt;strong&gt;地理纬度&lt;/strong&gt;，$\angle OPF = φ$，$φ&amp;rsquo;$为$O$点的&lt;strong&gt;地心纬度&lt;/strong&gt;,$\rho$为$O$点的&lt;strong&gt;地心半径&lt;/strong&gt;,在极点和赤道上$φ=φ′$，在其它纬度上$|φ′|&amp;lt;|φ|$&lt;br /&gt;
　　地心纬度$φ&amp;rsquo;$与地理纬度$φ$的关系为：$\tan φ′=\frac {b^2}{a^2} \tan φ，$(&lt;a href=&#34;https://baike.baidu.com/item/地心纬度&#34; target=&#34;_blank&#34;&gt;推导&lt;/a&gt;)&lt;br /&gt;
　　由椭球体扁率$f=\frac {a-b}a$,可知$b=a(1-f)$,子午圈椭圆离心率
\begin{align}
e &amp;amp;= \frac ca\\[2ex]
&amp;amp; = \frac {\sqrt {a^2-b^2}}{a}\\[2ex]
&amp;amp; = \sqrt {2f-f^2}
\end{align}
　　地心纬度$φ&amp;rsquo;$对应的归化纬度$u$,有
\begin{cases}
\tan φ&amp;rsquo; = \frac ba \tan u\\[2ex]
\tan u = \frac ba \tan φ\\[2ex]
\end{cases}
且
\begin{cases}
\rho \cos φ&amp;rsquo; = a\cos u, \ (相当于子午圈椭圆上观察点O的x坐标)\\[2ex]
\rho \sin φ&amp;rsquo; = b\sin u, \ (相当于子午圈椭圆上观察点O的y坐标)
\end{cases}
　　如果观察点的海拔高度为$H$,且$\rho$以赤道半径$a$为单位，则有
\begin{cases}
\rho \cos φ&amp;rsquo; = cos u + \frac Ha\cos φ\\[2ex]
\rho \sin φ&amp;rsquo; = \frac ba\sin u + \frac Ha\sin φ
\end{cases}&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Ellipsoid represents an ellipsoid of revolution.
//
// Typical unit for Er is Km.
// 地球椭球体
type Ellipsoid struct {
	Er float64 // equatorial radius 赤道半径
	Fl float64 // flattening 地球扁率
}

// IAU 1976 values.  Radius in Km.
var Earth76 = Ellipsoid{Er: 6378.14, Fl: 1 / 298.257}

// A returns equatorial radius in units of e.Er.
//
// A is a common identifier for equatorial radius.
// 子午圈椭圆长半轴（赤道半径）
func (e Ellipsoid) A() float64 {
	return e.Er
}

// B returns polar radius in units of e.ER.
//
// B is a common identifier for polar radius.
//
// 子午圈椭圆短半轴（地心到极点的距离）
func (e Ellipsoid) B() float64 {
	return e.Er * (1 - e.Fl)
}

// Eccentricity of a meridian.
// 子午圈椭圆离心率
func (e Ellipsoid) Eccentricity() float64 {
	return math.Sqrt((2 - e.Fl) * e.Fl)
}

// ParallaxConstants computes parallax constants ρ sin φ′ and ρ cos φ′.
//
// Arguments are geographic latitude φ and height h above the ellipsoid.
// For e.Er in Km, h must be in meters.
// 海拔为h的观察点对应的ρ sin φ′，ρ cos φ′
func (e Ellipsoid) ParallaxConstants(φ unit.Angle, h float64) (s, c float64) {
	boa := 1 - e.Fl
	su, cu := math.Sincos(math.Atan(boa * φ.Tan()))
	s, c = φ.Sincos()
	hoa := h * 1e-3 / e.Er
	return su*boa + hoa*s, cu + hoa*c
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2-其他椭球公式&#34;&gt;2. 其他椭球公式&lt;/h2&gt;

&lt;p&gt;　　在椭球上给定的一点，地理纬度与地心纬度的差值为：$φ - φ′ = 692&amp;rdquo;.73sin(2φ) - 1&amp;rdquo;.16sin(4φ)$&lt;br /&gt;
　　当$u=45°$时，$φ-φ′$达到最大值。 如果$φ_0$和$φ_0′$是此时相应的地理纬度和地心纬度，我们有：$$tan(φ_0) = a/b，tan(φ_0′) = b/a， φ_0+φ_0′=90°$$
对于&lt;strong&gt;&lt;em&gt;IAU1976&lt;/em&gt;&lt;/strong&gt;($a = 6378.14km,b = 6356.755km,f=\frac {1}{298.257}$)
有
\begin{align}
φ_0 = 45°05′46&amp;rdquo;.36,\\[2ex]
φ_0′ = 44°54′13&amp;rdquo;.64,\\[2ex]
φ_0 - φ_0′ = 11′32&amp;rdquo;.73
\end{align}
　　海平面上，$$\rho =0.9983271+0.0016764\cos {2φ}-0.0000035\cos {4φ}$$
　　同纬度$φ$的圆的半径：$$R_p = \frac {a\cos φ}{\sqrt{(1-e^2\sin^2φ)}}$$
　　因此，在同一纬度$φ$上，经度变化1度，相应的长度变化为$(π/180)R_p$,线速度为$ωR_p$,其中$ω = 7.292114992*10^{-5}(弧度/秒)$&lt;br /&gt;
　　地球子午圈的曲率半径，在纬度$φ$：$$R_m=\frac {a(1-e^2)}{(1-e^2\sin ^2 φ)^{\frac 32}}$$
且纬度变化1度，相应的长度变化：$(π/180)R_m$,在赤道时，$R_m$达到最小值，值为$a(1-e^2)=6335.44km$， 在极点时达到最大值，值为$\frac {a}{\sqrt {1-e^2}}=6399.60km$&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Rho is distance from Earth center to a point on the ellipsoid at latitude φ.
//
// Result unit is fraction of the equatorial radius.
// 海平面上，ρ值计算
func Rho(φ unit.Angle) float64 {
	// Magic numbers...
	return .9983271 + .0016764*φ.Mul(2).Cos() - .0000035*φ.Mul(4).Cos()
}

// RadiusAtLatitude returns the radius of the circle that is the parallel of
// latitude φ.
//
// Result unit is same as e.Er (typically Km.)
// 同纬度圆半径
func (e Ellipsoid) RadiusAtLatitude(φ unit.Angle) float64 {
	s, c := φ.Sincos()
	return e.A() * c / math.Sqrt(1-(2-e.Fl)*e.Fl*s*s)
}

// OneDegreeOfLongitude returns the length of one degree of longitude.
//
// Argument rp is the radius of a circle that is a parallel of latitude
// (as returned by Ellipsoid.RadiusAtLatitude.)
//
// Result is distance along one degree of the circle, in same units as rp.
// 同纬度，计算经度变化1度时长度变化的值
func OneDegreeOfLongitude(rp float64) float64 {
	return rp * math.Pi / 180
}

// RotationRate1996_5 is the rotational angular velocity of the Earth
// with respect to the stars at the epoch 1996.5.
//
// Unit is radian/second.
const RotationRate1996_5 = 7.292114992e-5

// RadiusOfCurvature of meridian at latitude φ.
//
// Result in units of e.ER, typically Km.
// 纬度为φ，子午圈曲率半径
func (e Ellipsoid) RadiusOfCurvature(φ unit.Angle) float64 {
	s := φ.Sin()
	e2 := (2 - e.Fl) * e.Fl
	return e.A() * (1 - e2) / math.Pow(1-e2*s*s, 1.5)
}

// OneDegreeOfLatitude returns the length of one degree of latitude.
//
// Argument rm is the radius of curvature along a meridian.
// (as returned by Ellipsoid.RadiusOfCurvature.)
// Result is distance in units of rm along one degree of the meridian.
// 同经度，计算纬度变化1度时长度变化的值
func OneDegreeOfLatitude(rm float64) float64 {
	return rm * math.Pi / 180
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;3-地表两点间的距离&#34;&gt;3. 地表两点间的距离&lt;/h2&gt;

&lt;p&gt;　　假设经纬度是分别是$(L_1,φ_1),(L_2,φ_2)$，且这两点在海平面。
　　如果精度要求不高，可以把地球看作球形，平均半径为6371km。使用下式可得到两点间的角距离：$$\cos d=\sin φ_1\sin φ_2 +\cos φ_1\cos φ_2\cos(L_1-L_2)$$
那么$$s = \frac {6371πd}{180}$$
　　高精度计算可使用以下方法：
$$F=\frac {φ_1+φ_2}{2},G=\frac {φ_1-φ_2}{2},\lambda = \frac {L_1-L_2}{2}$$
$$S = \sin^2G\cos^2\lambda+\cos^2F\sin^2\lambda$$
$$C = \cos^2G\cos^2\lambda+\sin^2F\sin^2\lambda$$
$$\tan ω = \sqrt{\frac SC}$$
$$R=\frac{\sqrt{SC}}{ω}$$
$$D=2ωa,H_1=\frac{3R-1}{2C},H_2=\frac{3R+1}{2S}$$
$$s=D(1+fH_1\sin^2F\cos^2G-fH_2\cos^2F\sin^2G)$$&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Distance is distance between two points measured along the surface
// of an ellipsoid.
//
// Accuracy is much better than that of ApproxAngularDistance or
// ApproxLinearDistance.
//
// Result unit is units of e.Er, typically Km.
// 地表两点距离
func (e Ellipsoid) Distance(c1, c2 Coord) float64 {
	// From AA, ch 11, p 84.
	s2f, c2f := sincos2((c1.Lat + c2.Lat) / 2)
	s2g, c2g := sincos2((c1.Lat - c2.Lat) / 2)
	s2λ, c2λ := sincos2((c1.Lon - c2.Lon) / 2)
	s := s2g*c2λ + c2f*s2λ
	c := c2g*c2λ + s2f*s2λ
	ω := math.Atan(math.Sqrt(s / c))
	r := math.Sqrt(s*c) / ω
	d := 2 * ω * e.Er
	h1 := (3*r - 1) / (2 * c)
	h2 := (3*r + 1) / (2 * s)
	return d * (1 + e.Fl*(h1*s2f*c2g-h2*c2f*s2g))
}

func sincos2(x unit.Angle) (s2, c2 float64) {
	s, c := x.Sincos()
	return s * s, c * c
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>天文算法8</title>
      <link>https://mooncaker816.github.io/2018/05/17/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%958/</link>
      <pubDate>Thu, 17 May 2018 09:56:34 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/05/17/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%958/</guid>
      <description>&lt;h1 id=&#34;第十章-力学时和世界时-dynamical-time-universal-time&#34;&gt;第十章 力学时和世界时 Dynamical Time &amp;amp; Universal Time&lt;/h1&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-力学时&#34;&gt;1. 力学时&lt;/h2&gt;

&lt;p&gt;　　力学时（Dynamical Time，简称DT）是一种从历书时(ET)到地球时(TT)过渡的时间尺度。分为地球力学时（Temps Dynamique Terrestrique，简称TDT）和质心力学时（Temps Dynamique Barycentrique，简称TDB）两种。&lt;/p&gt;

&lt;p&gt;　　1958年国际天文学联合会（IAU）决定从1960年开始使用以地球公转运动为基准的历书时（ET）代替以地球自转为基准的世界时（UT），目的是解决由于地球自转速度不均匀导致的世界时的时间尺度不均匀的问题。但是由于历书时所用的基准地球运动的理论框架是牛顿力学，根据广义相对论可知，在以太阳为中心的坐标系和以地球为中心的坐标系中时间将会不同。为解决这一问题，1976年国际天文学联合会分别定义了地球力学时（TDT）和质心力学时（TDB）。这两个时间尺度可以看作是历书时在两个坐标系中的实现。1991年，地球力学时被重新精确定义后改名为地球时（TT）。&lt;/p&gt;

&lt;p&gt;　　太阳系质心力学时（TDB）和地心力学时（TDT） 的区分。这两个系统最多相差 0.0017 秒，此种差异与地球以椭圆轨道绕日运动有关(相对论效应)。因这一差异小到可以被大多数实际应用忽略，&lt;strong&gt;&lt;em&gt;故此处我们对质心力学时和地球力学时不加区分，统称为力学时(TD)。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;/p&gt;

&lt;h2 id=&#34;2-世界时&#34;&gt;2. 世界时&lt;/h2&gt;

&lt;p&gt;　　世界时（Universal Time，简称UT）是一种以格林尼治子夜起算的平太阳时。世界时是以地球自转为基准得到的时间尺度，其精度受到地球自转不均匀变化和极移的影响，为了解决这种影响，1955年国际天文联合会定义了UT0、UT1和UT2三个系统：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;UT0系统是由一个天文台的天文观测直接测定的世界时，没有考虑极移造成的天文台地理坐标变化。该系统曾长期被认为是稳定均匀的时间计量系统，得到过广泛应用。&lt;/li&gt;
&lt;li&gt;UT1系统是在UT0的基础上加入了极移改正 Δλ，修正地轴摆动的影响。&lt;strong&gt;UT1是目前使用的世界时标准。被作为目前世界民用时间标准UTC在增减闰秒时的参照标准。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;UT2系统是UT1的平滑处理版本，在UT1基础上加入了地球自转速率的季节性改正 ΔT。&lt;/li&gt;
&lt;li&gt;它们之间的关系可以表示为：
\begin{align}
UT1 = UT0 + Δλ\\[2ex]
UT2 = UT1 + ΔT
\end{align}&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　&lt;/p&gt;

&lt;h2 id=&#34;3-协调世界时&#34;&gt;3. 协调世界时&lt;/h2&gt;

&lt;p&gt;　　协调世界时（英语：Coordinated Universal Time，法语：Temps Universel Coordonné，简称UTC）是最主要的世界时间标准，其以原子时秒长为基础，在时刻上尽量接近于格林尼治标准时间。&lt;/p&gt;

&lt;p&gt;　　协调世界时是世界上调节时钟和时间的主要时间标准，它与0度经线的平太阳时相差不超过1秒，并不遵守夏令时。协调世界时是最接近格林威治标准时间（GMT）的几个替代时间系统之一。对于大多数用途来说，UTC时间被认为能与GMT时间互换，但GMT时间已不再被科学界所确定。&lt;/p&gt;

&lt;p&gt;　　UTC基于国际原子时，并通过不规则的加入闰秒来抵消地球自转变慢的影响。闰秒在必要的时候会被插入到UTC中，以保证协调世界时（UTC）与世界时（UT1）相差不超过0.9秒。&lt;/p&gt;

&lt;p&gt;　　为了保证协调世界时很接近世界时UT1，UTC从基于TAI的线性方程转变成另一方程时，偶尔会出现不连续点。这些不连续点以闰秒的形式体现出来，这些不连续点就是造成了UTC天的长度不规则的闰秒。IERS规定不连续点仅出现在6月或12月底，但也有规定将3月或者9月作为备选。国际地球自转服务组织(IERS)跟踪并公布UTC时间和世界时的差别，即$DUT1 = UT1 - UTC$，另外，IERS也负责引入不连续的闰秒来保证它们的时间差DUT1在±0.9秒之间。&lt;/p&gt;

&lt;p&gt;　　&lt;/p&gt;

&lt;h2 id=&#34;4-计算力学时和世界时之间的差值&#34;&gt;4. 计算力学时和世界时之间的差值&lt;/h2&gt;

&lt;p&gt;　　由于地球自转一直在变缓，而且变缓规律难以预测，力学时和世界时之间的精确差值 $ΔT = TD - UT$ 只能由天文观测值推算。&lt;br /&gt;
　　书中给出了1620年至1998年的ΔT数据，所以在此之间的时间可以通过插值法来计算，其余时期的数据可以用以下方式推算：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;令 $t=\frac {year-2000}{100}$&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// c2000 returns centuries from calendar year 2000.0.
//
// Arg should be a calendar year.
// 计算年份y距离2000年的世纪数
func c2000(y float64) float64 {
    return (y - 2000) * .01
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;$ΔT = 2177 + 497t + 44.1t^2, year &amp;lt; +948 $&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// PolyBefore948 returns a polynomial approximation of ΔT valid for calendar
// years before 948.
// +948年之前的ΔT推算公式
func PolyBefore948(year float64) (ΔT unit.Time) {
    // (10.1) p. 78
    return unit.Time(base.Horner(c2000(year), 2177, 497, 44.1))
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;$ΔT = 102 + 102t + 25.3t^2, +948 \leq year \leq +1600 || year \geq +2000 $&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Poly948to1600 returns a polynomial approximation of ΔT valid for calendar
// years 948 to 1600.
// +984年至1600年的ΔT推算公式
func Poly948to1600(year float64) (ΔT unit.Time) {
    // (10.2) p. 78
    return unit.Time(base.Horner(c2000(year), 102, 102, 25.3))
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;若 $+2000 \leq year \leq +2100$, 还要在第3步的基础上加上一个修正量$+0.37(year-2100)$&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// PolyAfter2000 returns a polynomial approximation of ΔT valid for calendar
// years after 2000.
// 2000年以后的ΔT推算公式
func PolyAfter2000(year float64) (ΔT unit.Time) {
    ΔT = Poly948to1600(year)
    if year &amp;lt; 2100 {
        ΔT += unit.Time(.37 * (year - 2100))
    }
    return
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;经验公式：&lt;/p&gt;

&lt;p&gt;5.0 $\  儒略日世纪数\theta=\frac {JDE-J1900.0}{36525},J1900.0=2415020.0(1899-12-31)$&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// jc1900 returns julian centuries from the epoch J1900.0
//
// Arg should be a julian day, technically JDE.
// 计算儒略日jde距离J1900.0的世纪数
func jc1900(jde float64) float64 {
    return (jde - base.J1900) / base.JulianCentury
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5.1 $\  1800 - 1997$：(最大误差2.3秒)
    \begin{align}
    ΔT = &amp;amp;-1.02 + 91.02\theta + 265.90\theta^2 - 839.16\theta^3 - 1545.20\theta^4 \\[2ex]
    &amp;amp;+ 3603.62\theta^5 + 4385.98\theta^6 - 6993.23\theta^7 - 6090.04\theta^8 \\[2ex]
    &amp;amp;+ 6298.12\theta^9 + 4102.86\theta^{10} - 2137.64\theta^{11} - 1081.51\theta^{12}
    \end{align}&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Poly1800to1997 returns a polynomial approximation of ΔT valid for years
// 1800 to 1997.
//
// The accuracy is within 2.3 seconds.
// 1800至1997ΔT经验公式，最大误差2.3秒
func Poly1800to1997(jde float64) (ΔT unit.Time) {
    return unit.Time(base.Horner(jc1900(jde),
        -1.02, 91.02, 265.90, -839.16, -1545.20,
        3603.62, 4385.98, -6993.23, -6090.04,
        6298.12, 4102.86, -2137.64, -1081.51))
}    
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5.2 $\  1800 - 1899$：(最大误差0.9秒)
    \begin{align}
    ΔT = &amp;amp;-2.50 + 228.95\theta + 5218.61\theta^2 + 56282.84\theta^3 + 324011.78\theta^4 \\[2ex]
    &amp;amp;+ 1061660.75\theta^5 + 2087298.89\theta^6 + 2513807.78\theta^7 + 1818961.41\theta^8 \\[2ex]
    &amp;amp;+ 727058.63\theta^9 + 123563.95\theta^{10}
    \end{align}&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Poly1800to1899 returns a polynomial approximation of ΔT valid for years
// 1800 to 1899.
//
// The accuracy is within 0.9 seconds.
// 1800至1899ΔT经验公式，最大误差0.9秒
func Poly1800to1899(jde float64) (ΔT unit.Time) {
    return unit.Time(base.Horner(jc1900(jde),
        -2.50, 228.95, 5218.61, 56282.84, 324011.78,
        1061660.75, 2087298.89, 2513807.78,
        1818961.41, 727058.63, 123563.95))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5.3 $\  1900 - 1997$：(最大误差0.9秒)
    \begin{align}
    ΔT = &amp;amp;-2.44 + 87.24\theta + 815.20\theta^2 - 2637.80\theta^3 - 18756.33\theta^4 \\[2ex]
    &amp;amp;+ 124906.15\theta^5 - 303191.19\theta^6 + 372919.88\theta^7 - 232424.66\theta^8 \\[2ex]
    &amp;amp;+ 58353.42\theta^9
    \end{align}&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Poly1900to1997 returns a polynomial approximation of ΔT valid for years
// 1900 to 1997.
//
// The accuracy is within 0.9 seconds.
// 1900至1997ΔT经验公式，最大误差0.9秒
func Poly1900to1997(jde float64) (ΔT unit.Time) {
    return unit.Time(base.Horner(jc1900(jde),
        -2.44, 87.24, 815.20, -2637.80, -18756.33,
        124906.15, -303191.19, 372919.88,
        -232424.66, 58353.42))
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>天文算法7</title>
      <link>https://mooncaker816.github.io/2018/05/17/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%957/</link>
      <pubDate>Thu, 17 May 2018 08:56:34 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/05/17/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%957/</guid>
      <description>&lt;h1 id=&#34;第九章-犹太历和穆斯林历&#34;&gt;第九章 犹太历和穆斯林历&lt;/h1&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;略&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>天文算法6</title>
      <link>https://mooncaker816.github.io/2018/05/17/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%956/</link>
      <pubDate>Thu, 17 May 2018 07:40:44 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/05/17/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%956/</guid>
      <description>&lt;h1 id=&#34;第八章-复活节日-date-of-easter&#34;&gt;第八章 复活节日 Date of Easter&lt;/h1&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;　　对西方的节日没有多少了解，这里就直接给出书中的算法吧~&lt;/p&gt;

&lt;h2 id=&#34;1-格里历复活节算法&#34;&gt;1. 格里历复活节算法&lt;/h2&gt;

&lt;p&gt;\begin{array}{l|ccc}
被除数 &amp;amp; 除数 &amp;amp; 商 &amp;amp; 余数 \\&lt;br /&gt;
\hline
年份y &amp;amp; 19 &amp;amp; - &amp;amp; a \\&lt;br /&gt;
年份y &amp;amp; 100 &amp;amp; b &amp;amp; c \\&lt;br /&gt;
b &amp;amp; 4 &amp;amp; d &amp;amp; e \\&lt;br /&gt;
b+8 &amp;amp; 25 &amp;amp; f &amp;amp; - \\&lt;br /&gt;
b-f+1 &amp;amp; 3 &amp;amp; g &amp;amp; - \\&lt;br /&gt;
19a+b-d-g+15 &amp;amp; 30 &amp;amp; - &amp;amp; h \\&lt;br /&gt;
c &amp;amp; 4 &amp;amp; i &amp;amp; k \\&lt;br /&gt;
32+2e+2i-h-k &amp;amp; 7 &amp;amp; - &amp;amp; l \\&lt;br /&gt;
a+11h+22l &amp;amp; 451 &amp;amp; m &amp;amp; - \\&lt;br /&gt;
h+l-7m+114 &amp;amp; 31 &amp;amp; n &amp;amp; p \\&lt;br /&gt;
\end{array}&lt;/p&gt;

&lt;p&gt;得 $$n = 月份, \ p+1 = 日期$$&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Gregorian returns month and day of Easter in the Gregorian calendar.
// 格里历复活节日算法
func Gregorian(y int) (m, d int) {
	a := y % 19
	b, c := y/100, y%100
	d, e := b/4, b%4
	f := (b + 8) / 25
	g := (b - f + 1) / 3
	h := (19*a + b - d - g + 15) % 30
	i, k := c/4, c%4
	l := (32 + 2*e + 2*i - h - k) % 7
	m = (a + 11*h + 22*l) / 451
	n := h + l - 7*m + 114
	n, p := n/31, n%31
	return n, p + 1
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2-儒略历复活节算法&#34;&gt;2. 儒略历复活节算法&lt;/h2&gt;

&lt;p&gt;\begin{array}{l|ccc}
被除数 &amp;amp; 除数 &amp;amp; 商 &amp;amp; 余数 \\&lt;br /&gt;
\hline
年份y &amp;amp; 4 &amp;amp; - &amp;amp; a \\&lt;br /&gt;
年份y &amp;amp; 7 &amp;amp; - &amp;amp; b \\&lt;br /&gt;
年份y &amp;amp; 19 &amp;amp; - &amp;amp; c \\&lt;br /&gt;
19c+15 &amp;amp; 30 &amp;amp; - &amp;amp; d \\&lt;br /&gt;
2a+4b-d+34 &amp;amp; 7 &amp;amp; - &amp;amp; e \\&lt;br /&gt;
d+e+114 &amp;amp; 31 &amp;amp; f &amp;amp; g \\&lt;br /&gt;
\end{array}&lt;/p&gt;

&lt;p&gt;得 $$f = 月份, \ g+1 = 日期$$&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Julian returns month and day of Easter in the Julian calendar.
// 儒略历复活节日算法
func Julian(y int) (m, d int) {
	a := y % 4
	b := y % 7
	c := y % 19
	d = (19*c + 15) % 30
	e := (2*a + 4*b - d + 34) % 7
	f := d + e + 114
	f, g := f/31, f%31
	return f, g + 1
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>天文算法5</title>
      <link>https://mooncaker816.github.io/2018/05/16/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%955/</link>
      <pubDate>Wed, 16 May 2018 09:27:51 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/05/16/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%955/</guid>
      <description>&lt;h1 id=&#34;第七章-儒略日-julian-day&#34;&gt;第七章 儒略日 Julian Day&lt;/h1&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-儒略历和格里高利历&#34;&gt;1. 儒略历和格里高利历&lt;/h2&gt;

&lt;h3 id=&#34;1-1-定义&#34;&gt;1.1 定义&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;儒略历，是格里历的前身，由罗马共和国独裁官儒略·凯撒采纳埃及亚历山大的希腊数学家兼天文学家索西琴尼计算的历法，在公元前45年1月1日起执行，取代旧罗马历历法的历法。一年设12个月，大小月交替，四年一闰，平年365日，闰年于二月底增加一闰日，年平均长度为365.25日。由于累积误差随着时间越来越大，1582年后由教皇格里高利十三世改良，变为格里历，即沿用至今的公历。但大英帝国、北美十三州等直到1752年才从儒略历改用格里历。现今儒略历只有苏格兰昔德兰群岛之富拉岛、阿索斯神权共和国和一些北非的柏柏尔人使用。&lt;/p&gt;

&lt;p&gt;格里历（拉丁语：Calendarium Gregorianum，又译、国瑞历、额我略历、格列高利历、格里高利历、葛瑞格里历、格列高历，也称基督历[1]），是由意大利医生兼哲学家阿洛伊修斯·里利乌斯改革儒略历制定的历法，由罗马大公教会教宗格列高利十三世在1582年颁行。公历是阳历的一种，于1912年在中国引进采用，因农历等中国传统历法是阴阳历，故公历在中文中又称阳历、西历、新历、公历。格里历与儒略历一样，格里历也是每四年在2月底置一闰日，但格里历特别规定，除非能被400整除，所有的世纪年（能被100整除）都不设闰日；如此，每四百年，格里历仅有97个闰年，比儒略历减少3个闰年 [注 1]。 格里历的历年平均长度为365.2425日，接近平均回归年的365.242199074日，即约每3300年误差一日，也更接近春分点回归年的365.24237日，即约每8000年误差一日；而儒略历的历年为365.25日，约每128年就误差一日[注 1]。到1582年时，儒略历的春分日（3月21日）与地球公转到春分点的实际时间已相差10天。因此，格里历开始实行时，将儒略历1582年10月4日星期四的次日，为格里历1582年10月15日星期五，即有10天被删除，但原星期的周期保持不变。格里历的纪年沿用儒略历，自传统的耶稣诞生年开始，称为“公元”，亦称“西元”。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;1-2-区别&#34;&gt;1.2 区别&lt;/h3&gt;

&lt;p&gt;　　由定义可见，儒略历和格里高利历都属于阳历，后者是以太阳回归年为基础，对前者置润误差进行调整后的历法。所以两者之间最大的不同就是置润规则。&lt;/p&gt;

&lt;h4 id=&#34;1-2-1-置润规则&#34;&gt;1.2.1 置润规则&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;儒略历&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;能被4整除的年份为闰年（产生多润的原因，从而使儒略历在日期上落后于格里历）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;格里历&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;能被4整除但不能被100整除的非世纪年 + 能被400整除的世纪年，即要在儒略历闰年中扣除那些不能被400整除的世纪年（如1600，1700等）&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// LeapYearJulian returns true if year y in the Julian calendar is a leap year.
// 儒略历闰年判断
func LeapYearJulian(y int) bool {
	return y%4 == 0
}

// LeapYearGregorian returns true if year y in the Gregorian calendar is a leap year.
// 格里历闰年判断
func LeapYearGregorian(y int) bool {
	return (y%4 == 0 &amp;amp;&amp;amp; y%100 != 0) || y%400 == 0
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;1-2-2-转换&#34;&gt;1.2.2 转换&lt;/h4&gt;

&lt;p&gt;　　知道了这个不同，我们就能推导出两种历法之间实际的相差天数，如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;1582年：&lt;br /&gt;
格里历10月15日，合儒略历10月5日，或之后的日期：格里历日期减10日等于儒略历日期。&lt;/li&gt;
&lt;li&gt;1583年——1699年：&lt;br /&gt;
格里历日期减10日等于儒略历日期。&lt;/li&gt;
&lt;li&gt;1700年（格里历没有闰日，但儒略历有）：&lt;br /&gt;
格里历2月28日，合儒略历2月18日，或之前的日期：格里历日期减10日等于儒略历日期。&lt;br /&gt;
格里历3月1日，合儒略历2月19日，或之后的日期：格里历日期减11日等于儒略历日期。&lt;/li&gt;
&lt;li&gt;1701年——1799年：&lt;br /&gt;
格里历日期减11日等于儒略历日期。&lt;/li&gt;
&lt;li&gt;1800年（格里历没有闰日，但儒略历有）：&lt;br /&gt;
格里历2月28日，合儒略历2月17日，或之前的日期：格里历日期减11日等于儒略历日期。&lt;br /&gt;
格里历3月1日，合儒略历2月18日，或之后的日期：格里历日期减12日等于儒略历日期。&lt;/li&gt;
&lt;li&gt;1801年——1899年：&lt;br /&gt;
格里历日期减12日等于儒略历日期。&lt;/li&gt;
&lt;li&gt;1900年（格里历没有闰日，但儒略历有）：&lt;br /&gt;
格里历2月28日，合儒略历2月16日，或之前的日期：格里历日期减12日等于儒略历日期。&lt;br /&gt;
格里历3月1日，合儒略历2月17日，或之后的日期：格里历日期减13日等于儒略历日期。&lt;/li&gt;
&lt;li&gt;1901年——2099年：&lt;br /&gt;
格里历日期减13日等于儒略历日期。&lt;/li&gt;
&lt;li&gt;2100年（格里历没有闰日，但儒略历有）：&lt;br /&gt;
格里历2月28日，合儒略历2月15日，或之前的日期：格里历日期减13日等于儒略历日期。&lt;br /&gt;
格里历3月1日，合儒略历2月16日，或之后的日期：格里历日期减14日等于儒略历日期。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2-儒略日-julian-day&#34;&gt;2. 儒略日 Julian Day&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;儒略日（Julian Day）&lt;/strong&gt;&lt;br /&gt;
儒略日是在儒略周期内以连续的日数计算时间的计时法，主要是天文学家在使用。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;儒略日数（Julian Day Number，JDN）&lt;/strong&gt;&lt;br /&gt;
儒略日数的计算是从格林威治标准时间的中午开始，包含一个整天的时间，起点的时间（0日）回溯至儒略历的公元前4713年1月1日中午12点（在格里历是公元前4714年11月24日），这个日期是三种多年周期的共同起点，且是历史上最接近现代的一个起点。例如，2000年1月1日的UT12:00是儒略日2,451,545。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;儒略日期（Julian date，JD）&lt;/strong&gt;&lt;br /&gt;
儒略日期是以格林威治标准时中午12:00的儒略日加上那一天的瞬时时间的分数。儒略日期是儒略日添加小数部分所表示的儒略日数。例如，2013年1月1日00:30:00（UT）是儒略日期2,456,293.520833。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;儒略周期（Julian Period）&lt;/strong&gt;&lt;br /&gt;
儒略周期是开始于公元前4713年，长达7980年的纪年法，被用于历史上各种不同历法的日期转换。公元2018年是儒略周期的6731年，下一个儒略周期将开始于公元3268年。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;儒略日起点&lt;/strong&gt;&lt;br /&gt;
儒略日的起点订在西元前4713年（天文学上记为 -4712年）1月1日格林威治时间平午（世界时12:00），即JD 0指定为UT时间B.C.4713年1月1日12:00到UC时间B.C.4713年1月2日12:00的24小时。每一天赋予了一个唯一的数字，顺数而下，如：1996年1月1日12:00:00的儒略日是2450084。这个日期是考虑了太阳、月亮的轨道运行周期，以及当时收税的间隔而订出来的。Joseph Scaliger定义儒略周期为7980年，是因28、19、15的最小公倍数为28×19×15=7980。其中：&lt;/p&gt;

&lt;p&gt;28年为一太阳周期（solar cycle），经过一太阳周期，则星期的日序与月的日序会重复。&lt;/p&gt;

&lt;p&gt;19年为一太阴周期，或称默冬章（Metonic cycle），因235朔望月=19回归年，经过一太阴周期则阴历月年的日序重复。&lt;/p&gt;

&lt;p&gt;15年为一小纪（indiction cycle），此为罗马皇帝君士坦丁一世所颁，每15年评定财产价值以供课税，成为古罗马用的一个纪元单位，&lt;/p&gt;

&lt;p&gt;故以7980年为一儒略周期，而所选的起点公元前4713年，则是这三个循环周期同时开始的最近年份。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;简化儒略日（MJD）&lt;/strong&gt;&lt;br /&gt;
由于儒略日数字位数太多，国际天文学联合会于1973年采用简化儒略日（MJD），其定义为MJD = JD - 2400000.5。MJD相应的起点是1858年11月17日世界时0时。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　　算法中主要用的是 &lt;strong&gt;儒略日期（Julian date，JD）&lt;/strong&gt;，后续简称为&lt;strong&gt;儒略日&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;3-儒略日和阳历日期-格里历-儒略历日期-的转换&#34;&gt;3. 儒略日和阳历日期（格里历、儒略历日期）的转换&lt;/h2&gt;

&lt;h3 id=&#34;3-1-阳历日期-y-m-d-rightarrow-儒略日-jd&#34;&gt;3.1 阳历日期$(Y,M,D)$ $\Rightarrow$ 儒略日$(JD)$&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;设$Y$为给定年份，$M$为月份，$D$为该月日期（可以带小数）。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;若 $M &amp;gt; 2$，$Y$和$M$不变，&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;若 $M =1或2$，以$Y–1$代$Y$，以$M+12$代$M$，换句话说，如果日期在1月或2月，则被看作是在前一年的13月或14月。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对格里历有 ：$A = \lfloor \frac {Y}{100}\rfloor$ $B = 2 - A + \lfloor \frac{A}{4}\rfloor$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对儒略历，取 $B = 0$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;要求的儒略日即为：$$JD = \lfloor 365.25(Y+4716)\rfloor+\lfloor30.6001(M+1)\rfloor+D+B-1524.5$$&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;此处作对30.6001取值的解释是为了确保小数在运算时的准确性，如30.6 * 5 应该等于153，但是很多计算机得出的结果是152.999 9998。&lt;/p&gt;

&lt;p&gt;另一种方式就是用306代替，最后再除以10取整&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// FloorDiv returns the integer floor of the fractional value (x / y).
//
// It uses integer math only, so is more efficient than using floating point
// intermediate values.  This function can be used in many places where INT()
// appears in AA.  As with built in integer division, it panics with y == 0.
func FloorDiv(x, y int) (q int) {
	q = x / y
	if (x &amp;lt; 0) != (y &amp;lt; 0) &amp;amp;&amp;amp; x%y != 0 {
		q--
	}
	return
}

// FloorDiv64 returns the integer floor of the fractional value (x / y).
//
// It uses integer math only, so is more efficient than using floating point
// intermediate values.  This function can be used in many places where INT()
// appears in AA.  As with built in integer division, it panics with y == 0.
func FloorDiv64(x, y int64) (q int64) {
	q = x / y
	if (x &amp;lt; 0) != (y &amp;lt; 0) &amp;amp;&amp;amp; x%y != 0 {
		q--
	}
	return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// CalendarGregorianToJD converts a Gregorian year, month, and day of month
// to Julian day.
//
// Negative years are valid, back to JD 0.  The result is not valid for
// dates before JD 0.
// 格里历日期转儒略日
func CalendarGregorianToJD(y, m int, d float64) float64 {
	switch m {
	case 1, 2:
		y--
		m += 12
	}
	a := base.FloorDiv(y, 100)
	b := 2 - a + base.FloorDiv(a, 4)
	// (7.1) p. 61
	return float64(base.FloorDiv64(36525*(int64(y+4716)), 100)) +
		float64(base.FloorDiv(306*(m+1), 10)+b) + d - 1524.5
}

// CalendarJulianToJD converts a Julian year, month, and day of month to Julian day.
//
// Negative years are valid, back to JD 0.  The result is not valid for
// dates before JD 0.
// 儒略历日期转儒略日
func CalendarJulianToJD(y, m int, d float64) float64 {
	switch m {
	case 1, 2:
		y--
		m += 12
	}
	return float64(base.FloorDiv64(36525*(int64(y+4716)), 100)) +
		float64(base.FloorDiv(306*(m+1), 10)) + d - 1524.5
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3-2-儒略日-jd-rightarrow-阳历日期-y-m-d&#34;&gt;3.2 儒略日$(JD)$ $\Rightarrow$ 阳历日期$(y,m,d)$&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;将 $JD$ 加上 0.5，令$Z$为其整数部分，$F$ 为尾数（小数）部分。&lt;/li&gt;
&lt;li&gt;若 $Z$ &amp;lt; 2299161，取 $A$ = $Z$;&lt;br /&gt;
若 $Z$ 大于等于 2299161，计算
\begin{align}
α &amp;amp;=\lfloor \frac {Z-1867216.25}{36524.25}\rfloor\\[2ex]
A &amp;amp;=Z+1+α-\lfloor \frac α4\rfloor
\end{align}&lt;/li&gt;
&lt;li&gt;然后计算
\begin{align}
B &amp;amp;= A+1524\\[2ex]
C &amp;amp;= \lfloor \frac {B-122.1}{365.25}\rfloor\\[2ex]
D &amp;amp;= \lfloor 365.25C\rfloor\\[2ex]
E &amp;amp;= \lfloor \frac {B-D}{30.6001}\rfloor\\[2ex]
\end{align}&lt;/li&gt;
&lt;li&gt;该月日期（带小数部分）则为：$$d = B - D - \lfloor 30.6001E\rfloor + F$$&lt;/li&gt;
&lt;li&gt;月份 m 为：
\begin{cases}
m = E – 1 ;&amp;amp;  \text {if $E$ &amp;lt; 14}\\[2ex]
m = E – 13 ;&amp;amp;  \text {if $E$ $\geq$ 14}
\end{cases}&lt;/li&gt;
&lt;li&gt;年份为 y：
\begin{cases}
y = C – 4716 ;&amp;amp;  \text {if $m$ &amp;gt; 2}\\[2ex]
y = C – 4715 ;&amp;amp;  \text {if $m$ $\leq$ 2}
\end{cases}&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// JDToCalendar returns the calendar date for the given jd.
//
// Note that this function returns a date in either the Julian or Gregorian
// Calendar, as appropriate.
// 儒略日转公历日期
// 如果儒略日对应的格里历时间点在1582-10-15 12点之前，则转为儒略历日期
// 如果儒略日对应的格里历时间点在1582-10-15 12点之后，则转为格里历日期
func JDToCalendar(jd float64) (year, month int, day float64) {
	zf, f := math.Modf(jd + .5)
	z := int64(zf)
	a := z
	// if z &amp;gt;= 2299151 { // typo 应该是2299161对应于现实格里历起始日1582-10-15中午12点
	if z &amp;gt;= 2299161 { // typo 应该是2299161对应于现实格里历起始日1582-10-15中午12点
		α := base.FloorDiv64(z*100-186721625, 3652425)
		a = z + 1 + α - base.FloorDiv64(α, 4)
	}
	b := a + 1524
	c := base.FloorDiv64(b*100-12210, 36525)
	d := base.FloorDiv64(36525*c, 100)
	e := int(base.FloorDiv64((b-d)*1e4, 306001))
	// compute return values
	day = float64(int(b-d)-base.FloorDiv(306001*e, 1e4)) + f
	switch e {
	default:
		month = e - 1
	case 14, 15:
		month = e - 13
	}
	switch month {
	default:
		year = int(c) - 4716
	case 1, 2:
		year = int(c) - 4715
	}
	return
}

// jdToCalendarGregorian returns the Gregorian calendar date for the given jd.
//
// Note that it returns a Gregorian date even for dates before the start of
// the Gregorian calendar.  The function is useful when working with Go
// time.Time values because they are always based on the Gregorian calendar.
// 始终转为格里历，忽略儒略历转格里历被扣除的那10天，即把1582-10-15 12点之前的日期也当成格里历算
func jdToCalendarGregorian(jd float64) (year, month int, day float64) {
	zf, f := math.Modf(jd + .5)
	z := int64(zf)
	α := base.FloorDiv64(z*100-186721625, 3652425)
	a := z + 1 + α - base.FloorDiv64(α, 4)
	b := a + 1524
	c := base.FloorDiv64(b*100-12210, 36525)
	d := base.FloorDiv64(36525*c, 100)
	e := int(base.FloorDiv64((b-d)*1e4, 306001))
	// compute return values
	day = float64(int(b-d)-base.FloorDiv(306001*e, 1e4)) + f
	switch e {
	default:
		month = e - 1
	case 14, 15:
		month = e - 13
	}
	switch month {
	default:
		year = int(c) - 4716
	case 1, 2:
		year = int(c) - 4715
	}
	return
}

// JDToTime takes a JD and returns a Go time.Time value.
// 儒略历转为格里历日期对应的 Go Time 类型
func JDToTime(jd float64) time.Time {
	// time.Time is always Gregorian
	y, m, d := jdToCalendarGregorian(jd)
	t := time.Date(y, time.Month(m), 0, 0, 0, 0, 0, time.UTC)
	return t.Add(time.Duration(d * 24 * float64(time.Hour)))
}

// TimeToJD takes a Go time.Time and returns a JD as float64.
//
// Any time zone offset in the time.Time is ignored and the time is
// treated as UTC.
// Go Time 类型转为儒略日（默认日期为格里历）
func TimeToJD(t time.Time) float64 {
	ut := t.UTC()
	y, m, _ := ut.Date()
	d := ut.Sub(time.Date(y, m, 0, 0, 0, 0, 0, time.UTC))
	// time.Time is always Gregorian
	return CalendarGregorianToJD(y, int(m), float64(d)/float64(24*time.Hour))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3-3-儒略日-jd-rightarrow-星期几&#34;&gt;3.3 儒略日$(JD)$ $\Rightarrow$ 星期几&lt;/h3&gt;

&lt;p&gt;　　因为儒略日0.0(-4712-1-1 12:00) 是星期一，往后7天一循环就能得出星期几了&lt;br /&gt;
　　计算该日0时的儒略日，加上1.5，再除以7，所得余数将指示出星期几：&lt;br /&gt;
若余数为0，则为星期日，1为星期一，2为星期二，3为星期三，4为星期四，5为星期五，6为星期六。&lt;br /&gt;
　　儒略历到格里高利历的换算并不影响星期。 因而，在1582年10月4日星期四接下来的一天便是10月15日星期五。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// DayOfWeek determines the day of the week for a given JD.
//
// The value returned is an integer in the range 0 to 6, where 0 represents
// Sunday.  This is the same convention followed in the time package of the
// Go standard library.
// 儒略日0.0为-4712-1-1 12:00 星期一，往后7天一循环就能得出星期几了
func DayOfWeek(jd float64) int {
	return int(jd+1.5) % 7
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3-4-日阳历日期-y-m-d-rightarrow-年内序数日-n&#34;&gt;3.4 日阳历日期$(Y,M,D)$ $\Rightarrow$ 年内序数日$(N)$&lt;/h3&gt;

&lt;p&gt;　　年内的序数日$N$可由以下公式得出：$$N = \lfloor \frac {275M}{9}\rfloor - K\lfloor \frac {M+9}{12}\rfloor + D - 30 $$
　　此处$M$为月份，$D$为该月日期，闰年$K = 1$，平年$K = 2$&lt;br /&gt;
　　$N$ 取整数，自1月1日开始取值1，直至12月31日取值365（或闰年取值366）。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;如何推导出这个公式？&lt;/strong&gt;&lt;br /&gt;
　　乍一看挺没头绪的，我们先来看一个数列$$ a_m = \lfloor \frac {5(m+1)}{9}\rfloor, (m=0,1,2,\dots,12)$$&lt;/p&gt;

&lt;p&gt;\begin{array}{c|ccl}
m &amp;amp; a_m &amp;amp; a_m - a_{m-1} &amp;amp; 当月天数 \\&lt;br /&gt;
\hline
0 &amp;amp; 0 &amp;amp; - &amp;amp; - \\&lt;br /&gt;
1 &amp;amp; 1 &amp;amp; 1 &amp;amp; 31 \\&lt;br /&gt;
2 &amp;amp; 1 &amp;amp; 0 &amp;amp; 30(看做30) \\&lt;br /&gt;
3 &amp;amp; 2 &amp;amp; 1 &amp;amp; 31 \\&lt;br /&gt;
4 &amp;amp; 2 &amp;amp; 0 &amp;amp; 30 \\&lt;br /&gt;
5 &amp;amp; 3 &amp;amp; 1 &amp;amp; 31 \\&lt;br /&gt;
6 &amp;amp; 3 &amp;amp; 0 &amp;amp; 30 \\&lt;br /&gt;
7 &amp;amp; 4 &amp;amp; 1 &amp;amp; 31 \\&lt;br /&gt;
8 &amp;amp; 5 &amp;amp; 1 &amp;amp; 31 \\&lt;br /&gt;
9 &amp;amp; 5 &amp;amp; 0 &amp;amp; 30 \\&lt;br /&gt;
10 &amp;amp; 6 &amp;amp; 1 &amp;amp; 31 \\&lt;br /&gt;
11 &amp;amp; 6 &amp;amp; 0 &amp;amp; 30 \\&lt;br /&gt;
12 &amp;amp; 7 &amp;amp; 1 &amp;amp; 31
\end{array}&lt;/p&gt;

&lt;p&gt;　　如果把$m$看成是月份，并且暂时把二月看成是30天，那么第二列恰好是$当月天数-30$，所以我们就可以用以下公式来表示每个月的天数。
$$D_m = 30 + a_m - a_{m-1}$$&lt;/p&gt;

&lt;p&gt;　　所以从1月到m月的总天数：
\begin{align}
S_m = &amp;amp; D_1+D_2+,\dots,+D_m\\[2ex]
= &amp;amp; 30 + a_m - a_{m-1} + \\[2ex]
&amp;amp; 30 + a_{m-1} - a_{m-2} + \\[2ex]
&amp;amp; \cdots \\[2ex]
&amp;amp; 30 + a_2 - a_1 + \\[2ex]
&amp;amp; 30 + a_1 - a_0 \\[2ex]
= &amp;amp; 30m + a_m - a_0\\[2ex]
= &amp;amp; 30m + \lfloor \frac {5(m+1)}{9}\rfloor
\end{align}&lt;/p&gt;

&lt;p&gt;　　由于上述表达式只有在2月等于30天的情况下才成立，所以当$m\geq 2$时还要根据平年、闰年分别减去相应的天数2，1，得到1月到$m$月的总天数和为：
\begin{align}
S_m=30m + \lfloor \frac {5(m+1)}{9}\rfloor - \lfloor \frac {m+10}{12}\rfloor k,\ 其中
\end{align}
\begin{cases}
k = 1 , \ 闰年\\[2ex]
k = 2 , \ 平年
\end{cases}&lt;/p&gt;

&lt;p&gt;　　所以$M$月$D$日的年内序数$N$为：
\begin{align}
N &amp;amp;= S_{M-1} + D\\[2ex]
&amp;amp;= 30(M-1) + \lfloor \frac {5M}{9}\rfloor - \lfloor \frac {M+9}{12}\rfloor k + D\\[2ex]
&amp;amp;= \lfloor \frac {275M}{9}\rfloor - \lfloor \frac {M+9}{12}\rfloor k -30 + D\\[2ex]
\end{align}&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// DayOfYearGregorian computes the day number within the year of the Gregorian
// calendar.
// 格里历年内序数
func DayOfYearGregorian(y, m, d int) int {
	return DayOfYear(y, m, d, LeapYearGregorian(y))
}

// DayOfYearJulian computes the day number within the year of the Julian
// calendar.
// 儒略历年内序数
func DayOfYearJulian(y, m, d int) int {
	return DayOfYear(y, m, d, LeapYearJulian(y))
}

// DayOfYear computes the day number within the year.
//
// This form of the function is not specific to the Julian or Gregorian
// calendar, but you must tell it whether the year is a leap year.
// 输入闰年标识，计算年内序数
func DayOfYear(y, m, d int, leap bool) int {
	k := 2
	if leap {
		k--
	}
	return wholeMonths(m, k) + d
}

// m月之前的所有月份天数之和
func wholeMonths(m, k int) int {
	return 275*m/9 - k*((m+9)/12) - 30
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3-5-年内序数日-n-rightarrow-阳历日期-m-d&#34;&gt;3.5 年内序数日$(N)$  $\Rightarrow$ 阳历日期$(M,D)$&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// DayOfYearToCalendar returns the calendar month and day for a given
// day of year and leap year status.
// 年内序数求对应的日期
func DayOfYearToCalendar(n int, leap bool) (m, d int) {
	k := 2
	if leap {
		k--
	}
	if n &amp;lt; 32 {
		m = 1
	} else {
		m = (900*(k+n) + 98*275) / 27500
	}
	return m, n - wholeMonths(m, k)
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>天文算法4</title>
      <link>https://mooncaker816.github.io/2018/05/15/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%954/</link>
      <pubDate>Tue, 15 May 2018 17:34:49 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/05/15/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%954/</guid>
      <description>&lt;h1 id=&#34;第六章-排序-sort&#34;&gt;第六章 排序 Sort&lt;/h1&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;Go 标准库已经够了，所以就略了&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>天文算法3</title>
      <link>https://mooncaker816.github.io/2018/05/15/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%953/</link>
      <pubDate>Tue, 15 May 2018 13:48:36 +0800</pubDate>
      
      <guid>https://mooncaker816.github.io/2018/05/15/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%953/</guid>
      <description>&lt;h1 id=&#34;第五章-迭代-iteration&#34;&gt;第五章 迭代 Iteration&lt;/h1&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-什么是迭代算法&#34;&gt;1. 什么是迭代算法&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;　　迭代法（英语：Iterative Method），在计算数学中，迭代是通过从一个初始估计出发寻找一系列近似解来解决问题（一般是解方程或者方程组）的数学过程，为实现这一过程所使用的方法统称。&lt;/p&gt;

&lt;p&gt;　　跟迭代法相对应的是直接法（或者称为一次解法），即一次性解决问题，例如通过开方解决方程 $ x^{2}=4$。一般如果可能，直接解法总是优先考虑的。但当遇到复杂问题时，特别是在未知量很多，方程为非线性时，我们无法找到直接解法（例如五次以及更高次的代数方程没有解析解，参见阿贝尔定理），这时候或许可以通过迭代法寻求方程（组）的近似解。&lt;/p&gt;

&lt;p&gt;　　最常见的迭代法是牛顿法。其他还包括最速下降法、共轭迭代法、变尺度迭代法、最小二乘法、线性规划、非线性规划、单纯型法、惩罚函数法、斜率投影法、遗传算法、模拟退火等等。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　以上是 wiki 上对迭代算法的描述，可以看出，迭代法的主要用途就是求解近似根，这一点我们再第三章插值函数逆推插值点的介绍中已经得到了运用。下面我们主要介绍牛顿迭代法和二分迭代法。&lt;/p&gt;

&lt;h2 id=&#34;2-牛顿迭代法&#34;&gt;2. 牛顿迭代法&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;　　首先，选择一个接近函数$f(x)$零点的 $x_0$，计算相应的 $f(x_0)$和切线斜率 $f&amp;rsquo;(x_0)$。然后我们计算穿过点 $(x_0,f(x_0))$并且斜率为 $f&amp;rsquo;(x_0)$的直线和 $x$轴的交点的 $x$坐标，也就是求如下方程的解：
$$0=(x-x_0)f&amp;rsquo;(x_0)+f(x_0)$$
　　我们将新求得的点的$x$坐标命名为$x_1$，通常$x_1$会比$x_0$更接近方程$f(x)=0$的解。因此我们现在可以利用$x_1$开始下一轮迭代。迭代公式可化简为如下所示：
$$x_{n+1}=x_n - \frac {f(x_n)}{f&amp;rsquo;(x_n)}$$
　　已经证明，如果$f&amp;rsquo;$是连续的，并且待求的零点$x$是孤立的，那么在零点$x$周围存在一个区域，只要初始值$x_0$位于这个邻近区域内，那么牛顿法必定收敛。&lt;/p&gt;

&lt;p&gt;　　并且，如果$f&amp;rsquo;(x)\neq 0$，那么牛顿法将具有平方收敛的性能。粗略的说，这意味着每迭代一次，牛顿法结果的有效数字将增加一倍。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/thumb/e/e0/NewtonIteration_Ani.gif/600px-NewtonIteration_Ani.gif&#34; width=400 height=300 /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// BetterFunc is a convience type definition.
type BetterFunc func(float64) float64
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// DecimalPlaces iterates to a fixed number of decimal places.
//
// Inputs are an improvement function, a starting value, the number of
// decimal places desired in the result, and an iteration limit.
// better 为迭代公式，start 为起始点，places 为视作迭代结束的最大精度值的小数点位数,
// maxIterations 为迭代最大次数
func DecimalPlaces(better BetterFunc, start float64, places, maxIterations int) (float64, error) {
	d := math.Pow(10, float64(-places))
	for i := 0; i &amp;lt; maxIterations; i++ {
		n := better(start)
		if math.Abs(n-start) &amp;lt; d {
			return n, nil
		}
		start = n
	}
	return 0, errors.New(&amp;quot;Maximum iterations reached&amp;quot;)
}

// FullPrecison iterates to (nearly) the full precision of a float64.
//
// To allow for a little bit of floating point jitter, FullPrecision iterates
// to 15 significant figures, which is the maximum number of full significant
// figures representable in a float64, but still a couple of bits shy of the
// full representable precision.
// 和 DecimalPlaces 功能类似，只不过默认迭代结束的标志为小于float64的最大精度15
func FullPrecision(better BetterFunc, start float64, maxIterations int) (float64, error) {
	for i := 0; i &amp;lt; maxIterations; i++ {
		n := better(start)
		if math.Abs((n-start)/n) &amp;lt; 1e-15 {
			return n, nil
		}
		start = n
	}
	return 0, errors.New(&amp;quot;Maximum iterations reached&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;3-二分迭代法&#34;&gt;3. 二分迭代法&lt;/h2&gt;

&lt;p&gt;　　二分迭代法，顾名思义，就是计算中点的函数值，并与当前低值和高值比较，&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;若与低值同号，则把该值作为新的低值，继续迭代&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;若与高值同号，则把该值作为新的高值，继续迭代&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// RootFunc is a convience type definition.
type RootFunc func(float64) float64
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// BinaryRoot finds a root between given bounds by binary search.
//
// Inputs are a function on x and the bounds on x.  A root must exist between
// the given bounds, otherwise the result is not meaningful.
// 因为float64 的小数bit位最多为52位(10进制为15位有效数字)，
// 即每次迭代理论上能提升一位精度，所以最多52次就应该跳出迭代
func BinaryRoot(f RootFunc, lower, upper float64) float64 {
	yLower := f(lower)
	var mid float64
	for j := 0; j &amp;lt; 52; j++ {
		mid = (lower + upper) / 2
		yMid := f(mid)
		if yMid == 0 {
			break
		}
		if math.Signbit(yLower) == math.Signbit(yMid) { // 与低值同号，替代低值
			lower = mid
			yLower = yMid
		} else {
			upper = mid //与高值同号，替换高值
		}
	}
	return mid
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
  </channel>
</rss>
